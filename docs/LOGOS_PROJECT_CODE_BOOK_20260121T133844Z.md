# LOGOS Project Code Book

- Generated: `20260121T133844Z`
- Map source: `/root/logos_project_map_20260121T113413Z`
- Repo: `/root/logos_lrb`

## Contents

- [01_blockchain_core](#01-blockchain-core)
- [02_node_api](#02-node-api)
- [03_resonance_modules](#03-resonance-modules)
- [04_web_wallet_explorer_repo](#04-web-wallet-explorer-repo)
- [05_tools_generators](#05-tools-generators)
- [06_scripts_configs_docs](#06-scripts-configs-docs)
- [07_wallet_prod](#07-wallet-prod)
- [08_wallet_proxy_api](#08-wallet-proxy-api)
- [09_runtime_system](#09-runtime-system)

## 01_blockchain_core



**Roots:**
- `/root/logos_lrb/lrb_core`

- Files total: **17** (Rust: 16 | Py: 0 | JS/TS: 0 | cfg/sh/sql: 1)
- dirs.txt: `/root/logos_project_map_20260121T113413Z/01_blockchain_core/dirs.txt`
- files.txt: `/root/logos_project_map_20260121T113413Z/01_blockchain_core/files.txt`


### Modules (files)

- `/root/logos_lrb/lrb_core/Cargo.toml`
- `/root/logos_lrb/lrb_core/src/anti_replay.rs`
- `/root/logos_lrb/lrb_core/src/beacon.rs`
- `/root/logos_lrb/lrb_core/src/crypto.rs`
- `/root/logos_lrb/lrb_core/src/dynamic_balance.rs`
- `/root/logos_lrb/lrb_core/src/heartbeat.rs`
- `/root/logos_lrb/lrb_core/src/ledger.rs`
- `/root/logos_lrb/lrb_core/src/lib.rs`
- `/root/logos_lrb/lrb_core/src/phase_consensus.rs`
- `/root/logos_lrb/lrb_core/src/phase_filters.rs`
- `/root/logos_lrb/lrb_core/src/phase_integrity.rs`
- `/root/logos_lrb/lrb_core/src/quorum.rs`
- `/root/logos_lrb/lrb_core/src/rcp_engine.rs`
- `/root/logos_lrb/lrb_core/src/resonance.rs`
- `/root/logos_lrb/lrb_core/src/sigpool.rs`
- `/root/logos_lrb/lrb_core/src/spam_guard.rs`
- `/root/logos_lrb/lrb_core/src/types.rs`

### Module contents

---

## 02_node_api



**Roots:**
- `/root/logos_lrb/node`

- Files total: **34** (Rust: 30 | Py: 0 | JS/TS: 0 | cfg/sh/sql: 4)
- dirs.txt: `/root/logos_project_map_20260121T113413Z/02_node_api/dirs.txt`
- files.txt: `/root/logos_project_map_20260121T113413Z/02_node_api/files.txt`


### Modules (files)

- `/root/logos_lrb/node/build.rs`
- `/root/logos_lrb/node/Cargo.toml`
- `/root/logos_lrb/node/openapi/openapi.json`
- `/root/logos_lrb/node/src/admin.rs`
- `/root/logos_lrb/node/src/api/archive.rs`
- `/root/logos_lrb/node/src/api/base.rs`
- `/root/logos_lrb/node/src/api/mod.rs`
- `/root/logos_lrb/node/src/api/staking.rs`
- `/root/logos_lrb/node/src/api/tx.rs`
- `/root/logos_lrb/node/src/archive/mod.rs`
- `/root/logos_lrb/node/src/archive/pg.rs`
- `/root/logos_lrb/node/src/archive/sqlite.rs`
- `/root/logos_lrb/node/src/auth.rs`
- `/root/logos_lrb/node/src/bridge_journal.rs`
- `/root/logos_lrb/node/src/bridge.rs`
- `/root/logos_lrb/node/src/fork.rs`
- `/root/logos_lrb/node/src/gossip.rs`
- `/root/logos_lrb/node/src/guard.rs`
- `/root/logos_lrb/node/src/health.rs`
- `/root/logos_lrb/node/src/lib.rs`
- `/root/logos_lrb/node/src/main.rs`
- `/root/logos_lrb/node/src/metrics.rs`
- `/root/logos_lrb/node/src/openapi.json`
- `/root/logos_lrb/node/src/openapi/openapi.json`
- `/root/logos_lrb/node/src/openapi.rs`
- `/root/logos_lrb/node/src/payout_adapter.rs`
- `/root/logos_lrb/node/src/peers.rs`
- `/root/logos_lrb/node/src/producer.rs`
- `/root/logos_lrb/node/src/stake_claim.rs`
- `/root/logos_lrb/node/src/stake.rs`
- `/root/logos_lrb/node/src/state.rs`
- `/root/logos_lrb/node/src/storage.rs`
- `/root/logos_lrb/node/src/version.rs`
- `/root/logos_lrb/node/src/wallet.rs`

### Module contents

---

## 03_resonance_modules



**Roots:**
- `/root/logos_lrb/modules`

- Files total: **19** (Rust: 10 | Py: 3 | JS/TS: 1 | cfg/sh/sql: 5)
- dirs.txt: `/root/logos_project_map_20260121T113413Z/03_resonance_modules/dirs.txt`
- files.txt: `/root/logos_project_map_20260121T113413Z/03_resonance_modules/files.txt`


### Modules (files)

- `/root/logos_lrb/modules/beacon_emitter.rs`
- `/root/logos_lrb/modules/env_impact_tracker.py`
- `/root/logos_lrb/modules/external_phase_broadcaster.rs`
- `/root/logos_lrb/modules/external_phase_link.rs`
- `/root/logos_lrb/modules/genesis_fragment_seeds.rs`
- `/root/logos_lrb/modules/go_to_market.yaml`
- `/root/logos_lrb/modules/heartbeat_monitor.rs`
- `/root/logos_lrb/modules/legacy_migrator.rs`
- `/root/logos_lrb/modules/maintenance_strategy.yaml`
- `/root/logos_lrb/modules/resonance_analytics_frontend.tsx`
- `/root/logos_lrb/modules/resonance_emergency_plan.yaml`
- `/root/logos_lrb/modules/resonance_meshmap.yaml`
- `/root/logos_lrb/modules/resonance_tutor.py`
- `/root/logos_lrb/modules/ritual_engine.rs`
- `/root/logos_lrb/modules/symbolic_parser.py`
- `/root/logos_lrb/modules/uplink_controller.rs`
- `/root/logos_lrb/modules/uplink_router.rs`
- `/root/logos_lrb/modules/x_guard/Cargo.toml`
- `/root/logos_lrb/modules/x_guard/src/main.rs`

### Module contents

---

## 04_web_wallet_explorer_repo



**Roots:**
- `/root/logos_lrb/www`

- Files total: **9** (Rust: 0 | Py: 0 | JS/TS: 9 | cfg/sh/sql: 0)
- dirs.txt: `/root/logos_project_map_20260121T113413Z/04_web_wallet_explorer_repo/dirs.txt`
- files.txt: `/root/logos_project_map_20260121T113413Z/04_web_wallet_explorer_repo/files.txt`


### Modules (files)

- `/root/logos_lrb/www/explorer/explorer.js`
- `/root/logos_lrb/www/shared/i18n.js`
- `/root/logos_lrb/www/shared/tweetnacl.min.js`
- `/root/logos_lrb/www/wallet/api_base.js`
- `/root/logos_lrb/www/wallet/app.js`
- `/root/logos_lrb/www/wallet/auth.js`
- `/root/logos_lrb/www/wallet/common.js`
- `/root/logos_lrb/www/wallet/compat.js`
- `/root/logos_lrb/www/wallet/ui.js`

### Module contents

---

## 05_tools_generators



**Roots:**
- `/root/logos_lrb/tools`

- Files total: **55** (Rust: 1 | Py: 10 | JS/TS: 5 | cfg/sh/sql: 39)
- dirs.txt: `/root/logos_project_map_20260121T113413Z/05_tools_generators/dirs.txt`
- files.txt: `/root/logos_project_map_20260121T113413Z/05_tools_generators/files.txt`


### Modules (files)

- `/root/logos_lrb/tools/admin_cli.sh`
- `/root/logos_lrb/tools/admin_fund.sh`
- `/root/logos_lrb/tools/batch.json`
- `/root/logos_lrb/tools/bench/submit_tx_auto.js`
- `/root/logos_lrb/tools/book_make.sh`
- `/root/logos_lrb/tools/book_restore.sh`
- `/root/logos_lrb/tools/build_book_from_list.sh`
- `/root/logos_lrb/tools/build_books_ascii.sh`
- `/root/logos_lrb/tools/build_books.sh`
- `/root/logos_lrb/tools/find_sk_var_for_rid.py`
- `/root/logos_lrb/tools/gen_full_codemap.py`
- `/root/logos_lrb/tools/gen_main_rs.sh`
- `/root/logos_lrb/tools/gen_rid/Cargo.toml`
- `/root/logos_lrb/tools/gen_rid/src/main.rs`
- `/root/logos_lrb/tools/gen_stress_key.py`
- `/root/logos_lrb/tools/k6_smoke.js`
- `/root/logos_lrb/tools/k6_submit_tx_auto.js`
- `/root/logos_lrb/tools/load_healthz.sh`
- `/root/logos_lrb/tools/lrb_audit.sh`
- `/root/logos_lrb/tools/make_admin_jwt.py`
- `/root/logos_lrb/tools/make_airdrop_bots_book.sh`
- `/root/logos_lrb/tools/make_airdrop_verifiers_snapshot.sh`
- `/root/logos_lrb/tools/make_block_producer_snapshot.sh`
- `/root/logos_lrb/tools/make_book_and_push.sh`
- `/root/logos_lrb/tools/make_bots_stack_snapshot.sh`
- `/root/logos_lrb/tools/make_codebook.sh`
- `/root/logos_lrb/tools/make_deploy_infra_snapshot.sh`
- `/root/logos_lrb/tools/make_explorer_snapshot.sh`
- `/root/logos_lrb/tools/make_front_stack_snapshot.sh`
- `/root/logos_lrb/tools/make_full_book.sh`
- `/root/logos_lrb/tools/make_full_snapshot_live.sh`
- `/root/logos_lrb/tools/make_global_code_snapshot.sh`
- `/root/logos_lrb/tools/make_LOGOS_FULL_BOOK.sh`
- `/root/logos_lrb/tools/make_LOGOS_FULL_SYSTEM_BOOK_V3_1.sh`
- `/root/logos_lrb/tools/make_LOGOS_FULL_SYSTEM_BOOK_V3.sh`
- `/root/logos_lrb/tools/make_mono_book.sh`
- `/root/logos_lrb/tools/make_resonance_core_snapshot.sh`
- `/root/logos_lrb/tools/make_stress_env.py`
- `/root/logos_lrb/tools/make_wallet_explorer_snapshot.sh`
- `/root/logos_lrb/tools/make_wallet_snapshot.sh`
- `/root/logos_lrb/tools/make_web_stack_snapshot.sh`
- `/root/logos_lrb/tools/prepare_payer.sh`
- `/root/logos_lrb/tools/probe_canon.py`
- `/root/logos_lrb/tools/repo_audit.sh`
- `/root/logos_lrb/tools/sdk/ts/index.mjs`
- `/root/logos_lrb/tools/sdk/ts/sdk_test.mjs`
- `/root/logos_lrb/tools/stress_read_wallets.py`
- `/root/logos_lrb/tools/stress_submit_tx.py`
- `/root/logos_lrb/tools/stress_write_batch.py`
- `/root/logos_lrb/tools/stress_write_tx.py`
- `/root/logos_lrb/tools/test_tx.sh`
- `/root/logos_lrb/tools/tx_load.sh`
- `/root/logos_lrb/tools/tx_one.sh`
- `/root/logos_lrb/tools/vegeta_submit_live.sh`
- `/root/logos_lrb/tools/vegeta_submit.sh`

### Module contents

---

## 06_scripts_configs_docs



**Roots:**
- `/root/logos_lrb/configs`
- `/root/logos_lrb/docs`
- `/root/logos_lrb/scripts`

- Files total: **5** (Rust: 0 | Py: 0 | JS/TS: 0 | cfg/sh/sql: 5)
- dirs.txt: `/root/logos_project_map_20260121T113413Z/06_scripts_configs_docs/dirs.txt`
- files.txt: `/root/logos_project_map_20260121T113413Z/06_scripts_configs_docs/files.txt`


### Modules (files)

- `/root/logos_lrb/configs/genesis.yaml`
- `/root/logos_lrb/configs/logos_config.yaml`
- `/root/logos_lrb/scripts/bootstrap_node.sh`
- `/root/logos_lrb/scripts/collect_and_push.sh`
- `/root/logos_lrb/scripts/logos_healthcheck.sh`

### Module contents

---

## 07_wallet_prod



**Roots:**
- `/opt/logos/www/wallet_dev`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z.tar.gz`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z.tar.gz`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z.tar.gz`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z.tar.gz`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z.tar.gz`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z`
- `/opt/logos/www/wallet_prod`
- `/opt/logos/www/wallet_prod__1111`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z.tar.gz`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z.tar.gz.sha256`

- Files total: **138** (Rust: 0 | Py: 0 | JS/TS: 138 | cfg/sh/sql: 0)
- dirs.txt: `/root/logos_project_map_20260121T113413Z/07_wallet_prod/dirs.txt`
- files.txt: `/root/logos_project_map_20260121T113413Z/07_wallet_prod/files.txt`


### Modules (files)

- `/opt/logos/www/wallet_dev__111_20260111T150406Z/api_base.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/app.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/assets.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/auth.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/_bak_bridge_20260107T102635Z/app.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/_bak_bridge_20260107T102822Z/app.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/_bak_premiumtabs_20260109T063827Z/app.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/_bak_ui_20260107T101342Z/app.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/compat.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/connect.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/modules/settings.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/tabs.js`
- `/opt/logos/www/wallet_dev__111_20260111T150406Z/ui.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/api_base.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/assets.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/auth.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/_bak_bridge_20260107T102635Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/_bak_bridge_20260107T102822Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/_bak_premiumtabs_20260109T063827Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/_bak_ui_20260107T101342Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/compat.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/connect.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/modules/send.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/modules/settings.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/tabs.js`
- `/opt/logos/www/wallet_dev__222_20260111T151455Z/ui.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/api_base.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/assets.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/auth.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/_bak_bridge_20260107T102635Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/_bak_bridge_20260107T102822Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/_bak_premiumtabs_20260109T063827Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/_bak_ui_20260107T101342Z/app.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/compat.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/connect.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/modules/send.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/modules/settings.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/tabs.js`
- `/opt/logos/www/wallet_dev__222_20260111T151520Z/ui.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/api_base.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/app.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/assets.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/auth.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/_bak_bridge_20260107T102635Z/app.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/_bak_bridge_20260107T102822Z/app.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/_bak_premiumtabs_20260109T063827Z/app.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/_bak_ui_20260107T101342Z/app.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/compat.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/connect.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/tabs.js`
- `/opt/logos/www/wallet_dev__777_20260111T114200Z/ui.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/api_base.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/app.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/assets.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/auth.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/_bak_bridge_20260107T102635Z/app.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/_bak_bridge_20260107T102822Z/app.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/_bak_premiumtabs_20260109T063827Z/app.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/_bak_ui_20260107T101342Z/app.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/compat.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/connect.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/tabs.js`
- `/opt/logos/www/wallet_dev__999_20260111T143334Z/ui.js`
- `/opt/logos/www/wallet_dev/api_base.js`
- `/opt/logos/www/wallet_dev/app.js`
- `/opt/logos/www/wallet_dev/assets.js`
- `/opt/logos/www/wallet_dev/auth.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/api_base.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/app.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/assets.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/auth.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/_bak_bridge_20260107T102635Z/app.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/_bak_bridge_20260107T102822Z/app.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/_bak_premiumtabs_20260109T063827Z/app.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/_bak_ui_20260107T101342Z/app.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/compat.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/connect.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/modules/send.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/modules/settings.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/modules/tx_redirect.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/tabs.js`
- `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/ui.js`
- `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.js`
- `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.js`
- `/opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/app.js`
- `/opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.js`
- `/opt/logos/www/wallet_dev/compat.js`
- `/opt/logos/www/wallet_dev/connect.js`
- `/opt/logos/www/wallet_dev/modules/send.js`
- `/opt/logos/www/wallet_dev/modules/settings.js`
- `/opt/logos/www/wallet_dev/modules/tx_redirect.js`
- `/opt/logos/www/wallet_dev/tabs.js`
- `/opt/logos/www/wallet_dev/ui.js`
- `/opt/logos/www/wallet_prod__1111/api_base.js`
- `/opt/logos/www/wallet_prod__1111/app.js`
- `/opt/logos/www/wallet_prod__1111/assets.js`
- `/opt/logos/www/wallet_prod__1111/auth.js`
- `/opt/logos/www/wallet_prod__1111/compat.js`
- `/opt/logos/www/wallet_prod__1111/connect.js`
- `/opt/logos/www/wallet_prod__1111/modules/send.js`
- `/opt/logos/www/wallet_prod__1111/modules/settings.js`
- `/opt/logos/www/wallet_prod__1111/modules/tx_redirect.js`
- `/opt/logos/www/wallet_prod__1111/tabs.js`
- `/opt/logos/www/wallet_prod__1111/ui.js`
- `/opt/logos/www/wallet_prod/api_base.js`
- `/opt/logos/www/wallet_prod/app.js`
- `/opt/logos/www/wallet_prod/assets.js`
- `/opt/logos/www/wallet_prod/auth.js`
- `/opt/logos/www/wallet_prod/compat.js`
- `/opt/logos/www/wallet_prod/connect.js`
- `/opt/logos/www/wallet_prod/modules/bridge_withdraw.js`
- `/opt/logos/www/wallet_prod/modules/lgn_send.js`
- `/opt/logos/www/wallet_prod/modules/logout_fix.js`
- `/opt/logos/www/wallet_prod/modules/send.js`
- `/opt/logos/www/wallet_prod/modules/settings.js`
- `/opt/logos/www/wallet_prod/modules/tx_redirect.js`
- `/opt/logos/www/wallet_prod/tabs.js`
- `/opt/logos/www/wallet_prod/ui.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/api_base.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/app.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/assets.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/auth.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/compat.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/connect.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/modules/lgn_send.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/modules/send.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/modules/settings.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/modules/tx_redirect.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/tabs.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/ui.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/vendor/bip39_lite.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/vendor/nacl-fast.min.js`
- `/opt/logos/www/wallet_prod__v555_20260114T103906Z/vendor/wordlist_en.js`
- `/opt/logos/www/wallet_prod/vendor/bip39_lite.js`
- `/opt/logos/www/wallet_prod/vendor/nacl-fast.min.js`
- `/opt/logos/www/wallet_prod/vendor/wordlist_en.js`

### Module contents

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/api_base.js`

- Size: 179 bytes
- Lines: 5

```javascript
(() => {
  // same-origin only
  window.API_BASE   = "/api";        // node backend (nginx -> 127.0.0.1:8080)
  window.WALLET_API = "/wallet-api"; // wallet proxy (FastAPI)
})();
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/app.js`

- Size: 23117 bytes
- Lines: 627

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/auth.js`

- Size: 9193 bytes
- Lines: 288

```javascript
'use strict';

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30,0x2e,0x02,0x01,0x00,
  0x30,0x05,0x06,0x03,0x2b,0x65,0x70,
  0x04,0x22,0x04,0x20
]);

const $ = (id) => document.getElementById(id);

function setStatus(t){
  const el = $('status');
  if (el) el.textContent = 'Статус: ' + t;
}

function ensureEnv(){
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto?.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error('tweetnacl не загружен (нет window.nacl)');
}

const B58_ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function base58encode(bytes){
  const b = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
  if (b.length === 0) return "";
  let digits = [0];
  for (let i=0;i<b.length;i++){
    let carry = b[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j]*256 + carry;
      digits[j] = x % 58;
      carry = (x/58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry/58) | 0;
    }
  }
  let out = "";
  for (let k=0;k<b.length && b[k]===0;k++) out += "1";
  for (let q=digits.length-1;q>=0;q--) out += B58_ALPH[digits[q]];
  return out;
}

async function sha256(u8){
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

function pkcs8FromSeed(seed32){
  const seed = (seed32 instanceof Uint8Array) ? seed32 : new Uint8Array(seed32||[]);
  if (seed.length !== 32) throw new Error('seed must be 32 bytes');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed, ED25519_PKCS8_PREFIX.length);
  return out;
}

async function deriveKey(pass, saltU8, usage=['encrypt','decrypt']){
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltU8, iterations:120000, hash:'SHA-256' },
    keyMat,
    { name:'AES-GCM', length:256 },
    false,
    usage
  );
}

async function aesEncrypt(aesKey, plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plainU8);
  return { iv, ct: new Uint8Array(ct) };
}

async function aesDecrypt(aesKey, ivU8, ctU8){
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

let DBP = null;
function openDb(){
  if (DBP) return DBP;
  DBP = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbPut(key, val){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = ()=>resolve(true);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbListRids(){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const out = [];
    const req = st.openCursor();
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve(out);
      const k = String(cur.key||'');
      if (k.startsWith('acct:')) out.push(k.slice(5));
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

function setSession(rid, pass){
  // mirror to localStorage for app.js compatibility
  try {
    localStorage.setItem("logos_rid", String(rid||""));
    localStorage.setItem("RID", String(rid||""));
    if (pass != null) localStorage.setItem("logos_pass", String(pass||""));
  } catch(e) {}

  sessionStorage.setItem('logos_rid', rid);
  sessionStorage.setItem('logos_pass', pass);
  localStorage.setItem('logos_rid', rid);
  localStorage.setItem('logos_pass', pass);
}

function validatePass(p){
  const s = String(p||'').trim();
  if (s.length < 10) throw new Error('Пароль слишком короткий (мин 10)');
  return s;
}

function normalizePhrase(ph){
  return String(ph||'').trim().replace(/\s+/g,' ').toLowerCase();
}

const WORDS = [
  "alpha","bravo","canyon","delta","eagle","frost","galaxy","harbor","ivory","jungle","karma","legend",
  "matrix","nebula","orbit","pioneer","quantum","raven","signal","temple","union","vector","wander","xenon",
  "yellow","zenith","acoustic","breeze","crystal","drift","ember","forest","glimmer","horizon","island","jewel",
  "kernel","lunar","mirror","nova","oasis","prism","quiet","river","stone","thunder","ultra","vivid","whisper","zero"
];

function genPhrase16(){
  const rnd = crypto.getRandomValues(new Uint8Array(16));
  const w = [];
  for (let i=0;i<16;i++) w.push(WORDS[rnd[i] % WORDS.length]);
  return w.join(' ');
}

async function seedFromPhrase(phrase){
  const p = normalizePhrase(phrase);
  if (!p) throw new Error('Фраза пустая');
  const h = await sha256(enc.encode(p));
  return h.slice(0,32);
}

function ridFromSeed(seed32){
  const kp = nacl.sign.keyPair.fromSeed(seed32);
  const pub = new Uint8Array(kp.publicKey);
  return base58encode(pub);
}

async function storeAccount(rid, pass, seed32){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt, ['encrypt','decrypt']);
  const pkcs8 = pkcs8FromSeed(seed32);
  const {iv, ct} = await aesEncrypt(aes, pkcs8);

  const meta = { salt: Array.from(salt), iv: Array.from(iv), priv: Array.from(ct), ts: Date.now() };
  await idbPut('acct:' + rid, meta);
}

async function loadAndVerify(rid, pass){
  const meta = await idbGet('acct:' + rid);
  if (!meta) throw new Error('RID не найден на этом устройстве (нет локальной записи)');
  const salt = new Uint8Array(meta.salt || []);
  const iv   = new Uint8Array(meta.iv || []);
  const ct   = new Uint8Array(meta.priv || []);
  const aes  = await deriveKey(pass, salt, ['decrypt']);
  const pkcs8 = await aesDecrypt(aes, iv, ct);
  const seed = pkcs8.slice(ED25519_PKCS8_PREFIX.length);
  const checkRid = ridFromSeed(seed);
  if (checkRid !== rid) throw new Error('Неверный пароль');
  return true;
}

async function doShow(){
  try{
    ensureEnv();
    const list = await idbListRids();
    const box = $('savedList');
    if (box){
      box.style.display = '';
      box.textContent = list.length ? list.map(x=>'• '+x).join('\n') : '— пусто —';
    }
    setStatus('saved RID: ' + list.length);
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doLogin(){
  try{
    ensureEnv();
    const rid = String($('ridIn')?.value||'').trim();
    const pass = validatePass($('passIn')?.value||'');
    if (!rid) throw new Error('RID пустой');
    setStatus('checking…');
    await loadAndVerify(rid, pass);
    setSession(rid, pass);
    setStatus('ok → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doCreate(){
  try{
    ensureEnv();
    const pass = validatePass($('newPass')?.value||'');
    const phrase = genPhrase16();
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    const out = $('newPhraseOut');
    if (out) out.value = phrase;
    setSession(rid, pass);
    setStatus('created: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doRestore(){
  try{
    ensureEnv();
    const phrase = normalizePhrase($('phraseIn')?.value||'');
    const pass = validatePass($('restorePass')?.value||'');
    if (!phrase) throw new Error('Фраза пустая');
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    setSession(rid, pass);
    setStatus('restored: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  $('btnShow')?.addEventListener('click', doShow);
  $('btnLogin')?.addEventListener('click', doLogin);
  $('btnCreate')?.addEventListener('click', doCreate);
  $('btnRestore')?.addEventListener('click', doRestore);
  setStatus('ready');
});
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/_bak_bridge_20260107T102635Z/app.js`

- Size: 16445 bytes
- Lines: 519

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/_bak_bridge_20260107T102822Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/_bak_premiumtabs_20260109T063827Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/_bak_ui_20260107T101342Z/app.js`

- Size: 11592 bytes
- Lines: 359

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/compat.js`

- Size: 5512 bytes
- Lines: 180

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/modules/settings.js`

- Size: 9308 bytes
- Lines: 241

```javascript
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_dev__111_20260111T150406Z/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/api_base.js`

- Size: 179 bytes
- Lines: 5

```javascript
(() => {
  // same-origin only
  window.API_BASE   = "/api";        // node backend (nginx -> 127.0.0.1:8080)
  window.WALLET_API = "/wallet-api"; // wallet proxy (FastAPI)
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/app.js`

- Size: 23117 bytes
- Lines: 627

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/auth.js`

- Size: 9193 bytes
- Lines: 288

```javascript
'use strict';

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30,0x2e,0x02,0x01,0x00,
  0x30,0x05,0x06,0x03,0x2b,0x65,0x70,
  0x04,0x22,0x04,0x20
]);

const $ = (id) => document.getElementById(id);

function setStatus(t){
  const el = $('status');
  if (el) el.textContent = 'Статус: ' + t;
}

function ensureEnv(){
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto?.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error('tweetnacl не загружен (нет window.nacl)');
}

const B58_ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function base58encode(bytes){
  const b = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
  if (b.length === 0) return "";
  let digits = [0];
  for (let i=0;i<b.length;i++){
    let carry = b[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j]*256 + carry;
      digits[j] = x % 58;
      carry = (x/58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry/58) | 0;
    }
  }
  let out = "";
  for (let k=0;k<b.length && b[k]===0;k++) out += "1";
  for (let q=digits.length-1;q>=0;q--) out += B58_ALPH[digits[q]];
  return out;
}

async function sha256(u8){
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

function pkcs8FromSeed(seed32){
  const seed = (seed32 instanceof Uint8Array) ? seed32 : new Uint8Array(seed32||[]);
  if (seed.length !== 32) throw new Error('seed must be 32 bytes');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed, ED25519_PKCS8_PREFIX.length);
  return out;
}

async function deriveKey(pass, saltU8, usage=['encrypt','decrypt']){
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltU8, iterations:120000, hash:'SHA-256' },
    keyMat,
    { name:'AES-GCM', length:256 },
    false,
    usage
  );
}

async function aesEncrypt(aesKey, plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plainU8);
  return { iv, ct: new Uint8Array(ct) };
}

async function aesDecrypt(aesKey, ivU8, ctU8){
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

let DBP = null;
function openDb(){
  if (DBP) return DBP;
  DBP = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbPut(key, val){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = ()=>resolve(true);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbListRids(){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const out = [];
    const req = st.openCursor();
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve(out);
      const k = String(cur.key||'');
      if (k.startsWith('acct:')) out.push(k.slice(5));
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

function setSession(rid, pass){
  // mirror to localStorage for app.js compatibility
  try {
    localStorage.setItem("logos_rid", String(rid||""));
    localStorage.setItem("RID", String(rid||""));
    if (pass != null) localStorage.setItem("logos_pass", String(pass||""));
  } catch(e) {}

  sessionStorage.setItem('logos_rid', rid);
  sessionStorage.setItem('logos_pass', pass);
  localStorage.setItem('logos_rid', rid);
  localStorage.setItem('logos_pass', pass);
}

function validatePass(p){
  const s = String(p||'').trim();
  if (s.length < 10) throw new Error('Пароль слишком короткий (мин 10)');
  return s;
}

function normalizePhrase(ph){
  return String(ph||'').trim().replace(/\s+/g,' ').toLowerCase();
}

const WORDS = [
  "alpha","bravo","canyon","delta","eagle","frost","galaxy","harbor","ivory","jungle","karma","legend",
  "matrix","nebula","orbit","pioneer","quantum","raven","signal","temple","union","vector","wander","xenon",
  "yellow","zenith","acoustic","breeze","crystal","drift","ember","forest","glimmer","horizon","island","jewel",
  "kernel","lunar","mirror","nova","oasis","prism","quiet","river","stone","thunder","ultra","vivid","whisper","zero"
];

function genPhrase16(){
  const rnd = crypto.getRandomValues(new Uint8Array(16));
  const w = [];
  for (let i=0;i<16;i++) w.push(WORDS[rnd[i] % WORDS.length]);
  return w.join(' ');
}

async function seedFromPhrase(phrase){
  const p = normalizePhrase(phrase);
  if (!p) throw new Error('Фраза пустая');
  const h = await sha256(enc.encode(p));
  return h.slice(0,32);
}

function ridFromSeed(seed32){
  const kp = nacl.sign.keyPair.fromSeed(seed32);
  const pub = new Uint8Array(kp.publicKey);
  return base58encode(pub);
}

async function storeAccount(rid, pass, seed32){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt, ['encrypt','decrypt']);
  const pkcs8 = pkcs8FromSeed(seed32);
  const {iv, ct} = await aesEncrypt(aes, pkcs8);

  const meta = { salt: Array.from(salt), iv: Array.from(iv), priv: Array.from(ct), ts: Date.now() };
  await idbPut('acct:' + rid, meta);
}

async function loadAndVerify(rid, pass){
  const meta = await idbGet('acct:' + rid);
  if (!meta) throw new Error('RID не найден на этом устройстве (нет локальной записи)');
  const salt = new Uint8Array(meta.salt || []);
  const iv   = new Uint8Array(meta.iv || []);
  const ct   = new Uint8Array(meta.priv || []);
  const aes  = await deriveKey(pass, salt, ['decrypt']);
  const pkcs8 = await aesDecrypt(aes, iv, ct);
  const seed = pkcs8.slice(ED25519_PKCS8_PREFIX.length);
  const checkRid = ridFromSeed(seed);
  if (checkRid !== rid) throw new Error('Неверный пароль');
  return true;
}

async function doShow(){
  try{
    ensureEnv();
    const list = await idbListRids();
    const box = $('savedList');
    if (box){
      box.style.display = '';
      box.textContent = list.length ? list.map(x=>'• '+x).join('\n') : '— пусто —';
    }
    setStatus('saved RID: ' + list.length);
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doLogin(){
  try{
    ensureEnv();
    const rid = String($('ridIn')?.value||'').trim();
    const pass = validatePass($('passIn')?.value||'');
    if (!rid) throw new Error('RID пустой');
    setStatus('checking…');
    await loadAndVerify(rid, pass);
    setSession(rid, pass);
    setStatus('ok → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doCreate(){
  try{
    ensureEnv();
    const pass = validatePass($('newPass')?.value||'');
    const phrase = genPhrase16();
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    const out = $('newPhraseOut');
    if (out) out.value = phrase;
    setSession(rid, pass);
    setStatus('created: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doRestore(){
  try{
    ensureEnv();
    const phrase = normalizePhrase($('phraseIn')?.value||'');
    const pass = validatePass($('restorePass')?.value||'');
    if (!phrase) throw new Error('Фраза пустая');
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    setSession(rid, pass);
    setStatus('restored: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  $('btnShow')?.addEventListener('click', doShow);
  $('btnLogin')?.addEventListener('click', doLogin);
  $('btnCreate')?.addEventListener('click', doCreate);
  $('btnRestore')?.addEventListener('click', doRestore);
  setStatus('ready');
});
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/_bak_bridge_20260107T102635Z/app.js`

- Size: 16445 bytes
- Lines: 519

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/_bak_bridge_20260107T102822Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/_bak_premiumtabs_20260109T063827Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/_bak_ui_20260107T101342Z/app.js`

- Size: 11592 bytes
- Lines: 359

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/compat.js`

- Size: 5512 bytes
- Lines: 180

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/modules/send.js`

- Size: 6204 bytes
- Lines: 178

```javascript
/* ===== LOGOS Wallet: Send module (v1) ===== */
(() => {
  const $  = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function nodeApi(){
    // node backend (nginx /api -> node)
    return (window.LOGOS_NODE_API || window.API_BASE || "/api");
  }

  function setMsg(panel, text, ok=true){
    const el = $(".sendMsg", panel);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try{ j = JSON.parse(t); }catch(e){}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? (j.detail || j.error) : t;
      throw new Error(msg || ("HTTP " + r.status));
    }
    return j ?? t;
  }

  function render(){
    const panel = document.getElementById("panel-send");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Отправка</div>
        <div class="muted">LGN отправляется в сети LOGOS. Внешний вывод появится после включения HOT wallet на сервере.</div>

        <div style="height:12px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Send LGN</div>
          <div class="muted">Перевод LGN на RID внутри сети.</div>

          <div style="height:10px"></div>

          <div class="grid2">
            <div>
              <div class="k">To RID</div>
              <input id="sendToRid" class="mono" placeholder="RID получателя">
            </div>
            <div>
              <div class="k">Amount (LGN)</div>
              <input id="sendAmount" class="mono" placeholder="например 10" inputmode="decimal">
            </div>
          </div>

          <div style="height:10px"></div>

          <div>
            <div class="k">Memo (optional)</div>
            <input id="sendMemo" class="mono" placeholder="комментарий (необязательно)">
          </div>

          <div style="height:12px"></div>

          <div class="btnRow">
            <button class="btn" id="btnSendLGN">Send LGN</button>
            <button class="btn" id="btnFillSelf">Вставить мой RID</button>
          </div>

          <div class="muted sendMsg" style="margin-top:10px;opacity:0"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card" style="padding:14px">
          <div class="h">External (soon)</div>
          <div class="muted">BTC / ETH / TRON / USDT — вывод будет активен, когда включим hot wallet.</div>

          <div style="height:10px"></div>

          <div class="grid2">
            <div>
              <div class="k">Network</div>
              <select id="extNet">
                <option>BTC</option>
                <option>ETH</option>
                <option>TRON</option>
                <option>USDT (ERC20)</option>
                <option>USDT (TRC20)</option>
              </select>
            </div>
            <div>
              <div class="k">Amount</div>
              <input id="extAmount" class="mono" placeholder="0" inputmode="decimal" disabled>
            </div>
          </div>

          <div style="height:10px"></div>

          <div>
            <div class="k">To address</div>
            <input id="extAddr" class="mono" placeholder="0x... / bc1... / T..." disabled>
          </div>

          <div style="height:12px"></div>

          <button class="btn" id="btnExtSoon" disabled>Withdraw (soon)</button>
          <div class="muted" style="margin-top:10px">Сейчас выключено, чтобы не было фейковых кнопок и ошибок.</div>
        </div>
      </div>
    `;

    const btnSend = $("#btnSendLGN", panel);
    const btnSelf = $("#btnFillSelf", panel);

    btnSelf.addEventListener("click", () => {
      const rid = ridGet();
      if (!rid) return setMsg(panel, "RID не найден. Сначала войди в кошелёк.", false);
      $("#sendToRid", panel).value = rid;
      setMsg(panel, "Ок: вставил твой RID.", true);
    });

    btnSend.addEventListener("click", async () => {
      try{
        const from = ridGet();
        const to = ($("#sendToRid", panel).value || "").trim();
        const amountStr = ($("#sendAmount", panel).value || "").trim().replace(",", ".");
        const memo = ($("#sendMemo", panel).value || "").trim();

        if (!from) return setMsg(panel, "RID не найден. Перезайди в кошелёк.", false);
        if (!to || to.length < 12) return setMsg(panel, "Введи правильный RID получателя.", false);

        const amount = Number(amountStr);
        if (!Number.isFinite(amount) || amount <= 0) return setMsg(panel, "Введи сумму больше 0.", false);

        setMsg(panel, "Отправляю…", true);

        // IMPORTANT:
        // Тут нужен реальный endpoint на node для tx.
        // Мы вызываем /transfer если он есть (если нет — вернёт понятную ошибку).
        const res = await postJSON(nodeApi() + "/transfer", {
          from_rid: from,
          to_rid: to,
          amount_lgn: amount,
          memo: memo || undefined
        });

        setMsg(panel, "✅ Отправлено. " + (res?.txid ? ("txid: " + res.txid) : ""), true);
      }catch(e){
        setMsg(panel, "ERR: " + (e?.message || e), false);
      }
    });
  }

  // init
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", render);
  } else {
    render();
  }
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/modules/settings.js`

- Size: 9308 bytes
- Lines: 241

```javascript
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151455Z/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/api_base.js`

- Size: 179 bytes
- Lines: 5

```javascript
(() => {
  // same-origin only
  window.API_BASE   = "/api";        // node backend (nginx -> 127.0.0.1:8080)
  window.WALLET_API = "/wallet-api"; // wallet proxy (FastAPI)
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/app.js`

- Size: 23117 bytes
- Lines: 627

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/auth.js`

- Size: 9193 bytes
- Lines: 288

```javascript
'use strict';

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30,0x2e,0x02,0x01,0x00,
  0x30,0x05,0x06,0x03,0x2b,0x65,0x70,
  0x04,0x22,0x04,0x20
]);

const $ = (id) => document.getElementById(id);

function setStatus(t){
  const el = $('status');
  if (el) el.textContent = 'Статус: ' + t;
}

function ensureEnv(){
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto?.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error('tweetnacl не загружен (нет window.nacl)');
}

const B58_ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function base58encode(bytes){
  const b = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
  if (b.length === 0) return "";
  let digits = [0];
  for (let i=0;i<b.length;i++){
    let carry = b[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j]*256 + carry;
      digits[j] = x % 58;
      carry = (x/58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry/58) | 0;
    }
  }
  let out = "";
  for (let k=0;k<b.length && b[k]===0;k++) out += "1";
  for (let q=digits.length-1;q>=0;q--) out += B58_ALPH[digits[q]];
  return out;
}

async function sha256(u8){
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

function pkcs8FromSeed(seed32){
  const seed = (seed32 instanceof Uint8Array) ? seed32 : new Uint8Array(seed32||[]);
  if (seed.length !== 32) throw new Error('seed must be 32 bytes');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed, ED25519_PKCS8_PREFIX.length);
  return out;
}

async function deriveKey(pass, saltU8, usage=['encrypt','decrypt']){
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltU8, iterations:120000, hash:'SHA-256' },
    keyMat,
    { name:'AES-GCM', length:256 },
    false,
    usage
  );
}

async function aesEncrypt(aesKey, plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plainU8);
  return { iv, ct: new Uint8Array(ct) };
}

async function aesDecrypt(aesKey, ivU8, ctU8){
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

let DBP = null;
function openDb(){
  if (DBP) return DBP;
  DBP = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbPut(key, val){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = ()=>resolve(true);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbListRids(){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const out = [];
    const req = st.openCursor();
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve(out);
      const k = String(cur.key||'');
      if (k.startsWith('acct:')) out.push(k.slice(5));
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

function setSession(rid, pass){
  // mirror to localStorage for app.js compatibility
  try {
    localStorage.setItem("logos_rid", String(rid||""));
    localStorage.setItem("RID", String(rid||""));
    if (pass != null) localStorage.setItem("logos_pass", String(pass||""));
  } catch(e) {}

  sessionStorage.setItem('logos_rid', rid);
  sessionStorage.setItem('logos_pass', pass);
  localStorage.setItem('logos_rid', rid);
  localStorage.setItem('logos_pass', pass);
}

function validatePass(p){
  const s = String(p||'').trim();
  if (s.length < 10) throw new Error('Пароль слишком короткий (мин 10)');
  return s;
}

function normalizePhrase(ph){
  return String(ph||'').trim().replace(/\s+/g,' ').toLowerCase();
}

const WORDS = [
  "alpha","bravo","canyon","delta","eagle","frost","galaxy","harbor","ivory","jungle","karma","legend",
  "matrix","nebula","orbit","pioneer","quantum","raven","signal","temple","union","vector","wander","xenon",
  "yellow","zenith","acoustic","breeze","crystal","drift","ember","forest","glimmer","horizon","island","jewel",
  "kernel","lunar","mirror","nova","oasis","prism","quiet","river","stone","thunder","ultra","vivid","whisper","zero"
];

function genPhrase16(){
  const rnd = crypto.getRandomValues(new Uint8Array(16));
  const w = [];
  for (let i=0;i<16;i++) w.push(WORDS[rnd[i] % WORDS.length]);
  return w.join(' ');
}

async function seedFromPhrase(phrase){
  const p = normalizePhrase(phrase);
  if (!p) throw new Error('Фраза пустая');
  const h = await sha256(enc.encode(p));
  return h.slice(0,32);
}

function ridFromSeed(seed32){
  const kp = nacl.sign.keyPair.fromSeed(seed32);
  const pub = new Uint8Array(kp.publicKey);
  return base58encode(pub);
}

async function storeAccount(rid, pass, seed32){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt, ['encrypt','decrypt']);
  const pkcs8 = pkcs8FromSeed(seed32);
  const {iv, ct} = await aesEncrypt(aes, pkcs8);

  const meta = { salt: Array.from(salt), iv: Array.from(iv), priv: Array.from(ct), ts: Date.now() };
  await idbPut('acct:' + rid, meta);
}

async function loadAndVerify(rid, pass){
  const meta = await idbGet('acct:' + rid);
  if (!meta) throw new Error('RID не найден на этом устройстве (нет локальной записи)');
  const salt = new Uint8Array(meta.salt || []);
  const iv   = new Uint8Array(meta.iv || []);
  const ct   = new Uint8Array(meta.priv || []);
  const aes  = await deriveKey(pass, salt, ['decrypt']);
  const pkcs8 = await aesDecrypt(aes, iv, ct);
  const seed = pkcs8.slice(ED25519_PKCS8_PREFIX.length);
  const checkRid = ridFromSeed(seed);
  if (checkRid !== rid) throw new Error('Неверный пароль');
  return true;
}

async function doShow(){
  try{
    ensureEnv();
    const list = await idbListRids();
    const box = $('savedList');
    if (box){
      box.style.display = '';
      box.textContent = list.length ? list.map(x=>'• '+x).join('\n') : '— пусто —';
    }
    setStatus('saved RID: ' + list.length);
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doLogin(){
  try{
    ensureEnv();
    const rid = String($('ridIn')?.value||'').trim();
    const pass = validatePass($('passIn')?.value||'');
    if (!rid) throw new Error('RID пустой');
    setStatus('checking…');
    await loadAndVerify(rid, pass);
    setSession(rid, pass);
    setStatus('ok → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doCreate(){
  try{
    ensureEnv();
    const pass = validatePass($('newPass')?.value||'');
    const phrase = genPhrase16();
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    const out = $('newPhraseOut');
    if (out) out.value = phrase;
    setSession(rid, pass);
    setStatus('created: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doRestore(){
  try{
    ensureEnv();
    const phrase = normalizePhrase($('phraseIn')?.value||'');
    const pass = validatePass($('restorePass')?.value||'');
    if (!phrase) throw new Error('Фраза пустая');
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    setSession(rid, pass);
    setStatus('restored: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  $('btnShow')?.addEventListener('click', doShow);
  $('btnLogin')?.addEventListener('click', doLogin);
  $('btnCreate')?.addEventListener('click', doCreate);
  $('btnRestore')?.addEventListener('click', doRestore);
  setStatus('ready');
});
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/_bak_bridge_20260107T102635Z/app.js`

- Size: 16445 bytes
- Lines: 519

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/_bak_bridge_20260107T102822Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/_bak_premiumtabs_20260109T063827Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/_bak_ui_20260107T101342Z/app.js`

- Size: 11592 bytes
- Lines: 359

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/compat.js`

- Size: 5512 bytes
- Lines: 180

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/modules/send.js`

- Size: 6204 bytes
- Lines: 178

```javascript
/* ===== LOGOS Wallet: Send module (v1) ===== */
(() => {
  const $  = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function nodeApi(){
    // node backend (nginx /api -> node)
    return (window.LOGOS_NODE_API || window.API_BASE || "/api");
  }

  function setMsg(panel, text, ok=true){
    const el = $(".sendMsg", panel);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try{ j = JSON.parse(t); }catch(e){}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? (j.detail || j.error) : t;
      throw new Error(msg || ("HTTP " + r.status));
    }
    return j ?? t;
  }

  function render(){
    const panel = document.getElementById("panel-send");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Отправка</div>
        <div class="muted">LGN отправляется в сети LOGOS. Внешний вывод появится после включения HOT wallet на сервере.</div>

        <div style="height:12px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Send LGN</div>
          <div class="muted">Перевод LGN на RID внутри сети.</div>

          <div style="height:10px"></div>

          <div class="grid2">
            <div>
              <div class="k">To RID</div>
              <input id="sendToRid" class="mono" placeholder="RID получателя">
            </div>
            <div>
              <div class="k">Amount (LGN)</div>
              <input id="sendAmount" class="mono" placeholder="например 10" inputmode="decimal">
            </div>
          </div>

          <div style="height:10px"></div>

          <div>
            <div class="k">Memo (optional)</div>
            <input id="sendMemo" class="mono" placeholder="комментарий (необязательно)">
          </div>

          <div style="height:12px"></div>

          <div class="btnRow">
            <button class="btn" id="btnSendLGN">Send LGN</button>
            <button class="btn" id="btnFillSelf">Вставить мой RID</button>
          </div>

          <div class="muted sendMsg" style="margin-top:10px;opacity:0"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card" style="padding:14px">
          <div class="h">External (soon)</div>
          <div class="muted">BTC / ETH / TRON / USDT — вывод будет активен, когда включим hot wallet.</div>

          <div style="height:10px"></div>

          <div class="grid2">
            <div>
              <div class="k">Network</div>
              <select id="extNet">
                <option>BTC</option>
                <option>ETH</option>
                <option>TRON</option>
                <option>USDT (ERC20)</option>
                <option>USDT (TRC20)</option>
              </select>
            </div>
            <div>
              <div class="k">Amount</div>
              <input id="extAmount" class="mono" placeholder="0" inputmode="decimal" disabled>
            </div>
          </div>

          <div style="height:10px"></div>

          <div>
            <div class="k">To address</div>
            <input id="extAddr" class="mono" placeholder="0x... / bc1... / T..." disabled>
          </div>

          <div style="height:12px"></div>

          <button class="btn" id="btnExtSoon" disabled>Withdraw (soon)</button>
          <div class="muted" style="margin-top:10px">Сейчас выключено, чтобы не было фейковых кнопок и ошибок.</div>
        </div>
      </div>
    `;

    const btnSend = $("#btnSendLGN", panel);
    const btnSelf = $("#btnFillSelf", panel);

    btnSelf.addEventListener("click", () => {
      const rid = ridGet();
      if (!rid) return setMsg(panel, "RID не найден. Сначала войди в кошелёк.", false);
      $("#sendToRid", panel).value = rid;
      setMsg(panel, "Ок: вставил твой RID.", true);
    });

    btnSend.addEventListener("click", async () => {
      try{
        const from = ridGet();
        const to = ($("#sendToRid", panel).value || "").trim();
        const amountStr = ($("#sendAmount", panel).value || "").trim().replace(",", ".");
        const memo = ($("#sendMemo", panel).value || "").trim();

        if (!from) return setMsg(panel, "RID не найден. Перезайди в кошелёк.", false);
        if (!to || to.length < 12) return setMsg(panel, "Введи правильный RID получателя.", false);

        const amount = Number(amountStr);
        if (!Number.isFinite(amount) || amount <= 0) return setMsg(panel, "Введи сумму больше 0.", false);

        setMsg(panel, "Отправляю…", true);

        // IMPORTANT:
        // Тут нужен реальный endpoint на node для tx.
        // Мы вызываем /transfer если он есть (если нет — вернёт понятную ошибку).
        const res = await postJSON(nodeApi() + "/transfer", {
          from_rid: from,
          to_rid: to,
          amount_lgn: amount,
          memo: memo || undefined
        });

        setMsg(panel, "✅ Отправлено. " + (res?.txid ? ("txid: " + res.txid) : ""), true);
      }catch(e){
        setMsg(panel, "ERR: " + (e?.message || e), false);
      }
    });
  }

  // init
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", render);
  } else {
    render();
  }
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/modules/settings.js`

- Size: 9308 bytes
- Lines: 241

```javascript
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_dev__222_20260111T151520Z/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/api_base.js`

- Size: 179 bytes
- Lines: 5

```javascript
(() => {
  // same-origin only
  window.API_BASE   = "/api";        // node backend (nginx -> 127.0.0.1:8080)
  window.WALLET_API = "/wallet-api"; // wallet proxy (FastAPI)
})();
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/app.js`

- Size: 13062 bytes
- Lines: 366

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/auth.js`

- Size: 9193 bytes
- Lines: 288

```javascript
'use strict';

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30,0x2e,0x02,0x01,0x00,
  0x30,0x05,0x06,0x03,0x2b,0x65,0x70,
  0x04,0x22,0x04,0x20
]);

const $ = (id) => document.getElementById(id);

function setStatus(t){
  const el = $('status');
  if (el) el.textContent = 'Статус: ' + t;
}

function ensureEnv(){
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto?.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error('tweetnacl не загружен (нет window.nacl)');
}

const B58_ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function base58encode(bytes){
  const b = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
  if (b.length === 0) return "";
  let digits = [0];
  for (let i=0;i<b.length;i++){
    let carry = b[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j]*256 + carry;
      digits[j] = x % 58;
      carry = (x/58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry/58) | 0;
    }
  }
  let out = "";
  for (let k=0;k<b.length && b[k]===0;k++) out += "1";
  for (let q=digits.length-1;q>=0;q--) out += B58_ALPH[digits[q]];
  return out;
}

async function sha256(u8){
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

function pkcs8FromSeed(seed32){
  const seed = (seed32 instanceof Uint8Array) ? seed32 : new Uint8Array(seed32||[]);
  if (seed.length !== 32) throw new Error('seed must be 32 bytes');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed, ED25519_PKCS8_PREFIX.length);
  return out;
}

async function deriveKey(pass, saltU8, usage=['encrypt','decrypt']){
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltU8, iterations:120000, hash:'SHA-256' },
    keyMat,
    { name:'AES-GCM', length:256 },
    false,
    usage
  );
}

async function aesEncrypt(aesKey, plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plainU8);
  return { iv, ct: new Uint8Array(ct) };
}

async function aesDecrypt(aesKey, ivU8, ctU8){
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

let DBP = null;
function openDb(){
  if (DBP) return DBP;
  DBP = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbPut(key, val){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = ()=>resolve(true);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbListRids(){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const out = [];
    const req = st.openCursor();
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve(out);
      const k = String(cur.key||'');
      if (k.startsWith('acct:')) out.push(k.slice(5));
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

function setSession(rid, pass){
  // mirror to localStorage for app.js compatibility
  try {
    localStorage.setItem("logos_rid", String(rid||""));
    localStorage.setItem("RID", String(rid||""));
    if (pass != null) localStorage.setItem("logos_pass", String(pass||""));
  } catch(e) {}

  sessionStorage.setItem('logos_rid', rid);
  sessionStorage.setItem('logos_pass', pass);
  localStorage.setItem('logos_rid', rid);
  localStorage.setItem('logos_pass', pass);
}

function validatePass(p){
  const s = String(p||'').trim();
  if (s.length < 10) throw new Error('Пароль слишком короткий (мин 10)');
  return s;
}

function normalizePhrase(ph){
  return String(ph||'').trim().replace(/\s+/g,' ').toLowerCase();
}

const WORDS = [
  "alpha","bravo","canyon","delta","eagle","frost","galaxy","harbor","ivory","jungle","karma","legend",
  "matrix","nebula","orbit","pioneer","quantum","raven","signal","temple","union","vector","wander","xenon",
  "yellow","zenith","acoustic","breeze","crystal","drift","ember","forest","glimmer","horizon","island","jewel",
  "kernel","lunar","mirror","nova","oasis","prism","quiet","river","stone","thunder","ultra","vivid","whisper","zero"
];

function genPhrase16(){
  const rnd = crypto.getRandomValues(new Uint8Array(16));
  const w = [];
  for (let i=0;i<16;i++) w.push(WORDS[rnd[i] % WORDS.length]);
  return w.join(' ');
}

async function seedFromPhrase(phrase){
  const p = normalizePhrase(phrase);
  if (!p) throw new Error('Фраза пустая');
  const h = await sha256(enc.encode(p));
  return h.slice(0,32);
}

function ridFromSeed(seed32){
  const kp = nacl.sign.keyPair.fromSeed(seed32);
  const pub = new Uint8Array(kp.publicKey);
  return base58encode(pub);
}

async function storeAccount(rid, pass, seed32){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt, ['encrypt','decrypt']);
  const pkcs8 = pkcs8FromSeed(seed32);
  const {iv, ct} = await aesEncrypt(aes, pkcs8);

  const meta = { salt: Array.from(salt), iv: Array.from(iv), priv: Array.from(ct), ts: Date.now() };
  await idbPut('acct:' + rid, meta);
}

async function loadAndVerify(rid, pass){
  const meta = await idbGet('acct:' + rid);
  if (!meta) throw new Error('RID не найден на этом устройстве (нет локальной записи)');
  const salt = new Uint8Array(meta.salt || []);
  const iv   = new Uint8Array(meta.iv || []);
  const ct   = new Uint8Array(meta.priv || []);
  const aes  = await deriveKey(pass, salt, ['decrypt']);
  const pkcs8 = await aesDecrypt(aes, iv, ct);
  const seed = pkcs8.slice(ED25519_PKCS8_PREFIX.length);
  const checkRid = ridFromSeed(seed);
  if (checkRid !== rid) throw new Error('Неверный пароль');
  return true;
}

async function doShow(){
  try{
    ensureEnv();
    const list = await idbListRids();
    const box = $('savedList');
    if (box){
      box.style.display = '';
      box.textContent = list.length ? list.map(x=>'• '+x).join('\n') : '— пусто —';
    }
    setStatus('saved RID: ' + list.length);
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doLogin(){
  try{
    ensureEnv();
    const rid = String($('ridIn')?.value||'').trim();
    const pass = validatePass($('passIn')?.value||'');
    if (!rid) throw new Error('RID пустой');
    setStatus('checking…');
    await loadAndVerify(rid, pass);
    setSession(rid, pass);
    setStatus('ok → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doCreate(){
  try{
    ensureEnv();
    const pass = validatePass($('newPass')?.value||'');
    const phrase = genPhrase16();
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    const out = $('newPhraseOut');
    if (out) out.value = phrase;
    setSession(rid, pass);
    setStatus('created: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doRestore(){
  try{
    ensureEnv();
    const phrase = normalizePhrase($('phraseIn')?.value||'');
    const pass = validatePass($('restorePass')?.value||'');
    if (!phrase) throw new Error('Фраза пустая');
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    setSession(rid, pass);
    setStatus('restored: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  $('btnShow')?.addEventListener('click', doShow);
  $('btnLogin')?.addEventListener('click', doLogin);
  $('btnCreate')?.addEventListener('click', doCreate);
  $('btnRestore')?.addEventListener('click', doRestore);
  setStatus('ready');
});
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/_bak_bridge_20260107T102635Z/app.js`

- Size: 16445 bytes
- Lines: 519

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/_bak_bridge_20260107T102822Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/_bak_premiumtabs_20260109T063827Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/_bak_ui_20260107T101342Z/app.js`

- Size: 11592 bytes
- Lines: 359

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/compat.js`

- Size: 5512 bytes
- Lines: 180

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_dev__777_20260111T114200Z/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/api_base.js`

- Size: 179 bytes
- Lines: 5

```javascript
(() => {
  // same-origin only
  window.API_BASE   = "/api";        // node backend (nginx -> 127.0.0.1:8080)
  window.WALLET_API = "/wallet-api"; // wallet proxy (FastAPI)
})();
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/app.js`

- Size: 23117 bytes
- Lines: 627

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/auth.js`

- Size: 9193 bytes
- Lines: 288

```javascript
'use strict';

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30,0x2e,0x02,0x01,0x00,
  0x30,0x05,0x06,0x03,0x2b,0x65,0x70,
  0x04,0x22,0x04,0x20
]);

const $ = (id) => document.getElementById(id);

function setStatus(t){
  const el = $('status');
  if (el) el.textContent = 'Статус: ' + t;
}

function ensureEnv(){
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto?.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error('tweetnacl не загружен (нет window.nacl)');
}

const B58_ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function base58encode(bytes){
  const b = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
  if (b.length === 0) return "";
  let digits = [0];
  for (let i=0;i<b.length;i++){
    let carry = b[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j]*256 + carry;
      digits[j] = x % 58;
      carry = (x/58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry/58) | 0;
    }
  }
  let out = "";
  for (let k=0;k<b.length && b[k]===0;k++) out += "1";
  for (let q=digits.length-1;q>=0;q--) out += B58_ALPH[digits[q]];
  return out;
}

async function sha256(u8){
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

function pkcs8FromSeed(seed32){
  const seed = (seed32 instanceof Uint8Array) ? seed32 : new Uint8Array(seed32||[]);
  if (seed.length !== 32) throw new Error('seed must be 32 bytes');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed, ED25519_PKCS8_PREFIX.length);
  return out;
}

async function deriveKey(pass, saltU8, usage=['encrypt','decrypt']){
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltU8, iterations:120000, hash:'SHA-256' },
    keyMat,
    { name:'AES-GCM', length:256 },
    false,
    usage
  );
}

async function aesEncrypt(aesKey, plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plainU8);
  return { iv, ct: new Uint8Array(ct) };
}

async function aesDecrypt(aesKey, ivU8, ctU8){
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

let DBP = null;
function openDb(){
  if (DBP) return DBP;
  DBP = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbPut(key, val){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = ()=>resolve(true);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbListRids(){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const out = [];
    const req = st.openCursor();
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve(out);
      const k = String(cur.key||'');
      if (k.startsWith('acct:')) out.push(k.slice(5));
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

function setSession(rid, pass){
  // mirror to localStorage for app.js compatibility
  try {
    localStorage.setItem("logos_rid", String(rid||""));
    localStorage.setItem("RID", String(rid||""));
    if (pass != null) localStorage.setItem("logos_pass", String(pass||""));
  } catch(e) {}

  sessionStorage.setItem('logos_rid', rid);
  sessionStorage.setItem('logos_pass', pass);
  localStorage.setItem('logos_rid', rid);
  localStorage.setItem('logos_pass', pass);
}

function validatePass(p){
  const s = String(p||'').trim();
  if (s.length < 10) throw new Error('Пароль слишком короткий (мин 10)');
  return s;
}

function normalizePhrase(ph){
  return String(ph||'').trim().replace(/\s+/g,' ').toLowerCase();
}

const WORDS = [
  "alpha","bravo","canyon","delta","eagle","frost","galaxy","harbor","ivory","jungle","karma","legend",
  "matrix","nebula","orbit","pioneer","quantum","raven","signal","temple","union","vector","wander","xenon",
  "yellow","zenith","acoustic","breeze","crystal","drift","ember","forest","glimmer","horizon","island","jewel",
  "kernel","lunar","mirror","nova","oasis","prism","quiet","river","stone","thunder","ultra","vivid","whisper","zero"
];

function genPhrase16(){
  const rnd = crypto.getRandomValues(new Uint8Array(16));
  const w = [];
  for (let i=0;i<16;i++) w.push(WORDS[rnd[i] % WORDS.length]);
  return w.join(' ');
}

async function seedFromPhrase(phrase){
  const p = normalizePhrase(phrase);
  if (!p) throw new Error('Фраза пустая');
  const h = await sha256(enc.encode(p));
  return h.slice(0,32);
}

function ridFromSeed(seed32){
  const kp = nacl.sign.keyPair.fromSeed(seed32);
  const pub = new Uint8Array(kp.publicKey);
  return base58encode(pub);
}

async function storeAccount(rid, pass, seed32){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt, ['encrypt','decrypt']);
  const pkcs8 = pkcs8FromSeed(seed32);
  const {iv, ct} = await aesEncrypt(aes, pkcs8);

  const meta = { salt: Array.from(salt), iv: Array.from(iv), priv: Array.from(ct), ts: Date.now() };
  await idbPut('acct:' + rid, meta);
}

async function loadAndVerify(rid, pass){
  const meta = await idbGet('acct:' + rid);
  if (!meta) throw new Error('RID не найден на этом устройстве (нет локальной записи)');
  const salt = new Uint8Array(meta.salt || []);
  const iv   = new Uint8Array(meta.iv || []);
  const ct   = new Uint8Array(meta.priv || []);
  const aes  = await deriveKey(pass, salt, ['decrypt']);
  const pkcs8 = await aesDecrypt(aes, iv, ct);
  const seed = pkcs8.slice(ED25519_PKCS8_PREFIX.length);
  const checkRid = ridFromSeed(seed);
  if (checkRid !== rid) throw new Error('Неверный пароль');
  return true;
}

async function doShow(){
  try{
    ensureEnv();
    const list = await idbListRids();
    const box = $('savedList');
    if (box){
      box.style.display = '';
      box.textContent = list.length ? list.map(x=>'• '+x).join('\n') : '— пусто —';
    }
    setStatus('saved RID: ' + list.length);
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doLogin(){
  try{
    ensureEnv();
    const rid = String($('ridIn')?.value||'').trim();
    const pass = validatePass($('passIn')?.value||'');
    if (!rid) throw new Error('RID пустой');
    setStatus('checking…');
    await loadAndVerify(rid, pass);
    setSession(rid, pass);
    setStatus('ok → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doCreate(){
  try{
    ensureEnv();
    const pass = validatePass($('newPass')?.value||'');
    const phrase = genPhrase16();
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    const out = $('newPhraseOut');
    if (out) out.value = phrase;
    setSession(rid, pass);
    setStatus('created: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doRestore(){
  try{
    ensureEnv();
    const phrase = normalizePhrase($('phraseIn')?.value||'');
    const pass = validatePass($('restorePass')?.value||'');
    if (!phrase) throw new Error('Фраза пустая');
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    setSession(rid, pass);
    setStatus('restored: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  $('btnShow')?.addEventListener('click', doShow);
  $('btnLogin')?.addEventListener('click', doLogin);
  $('btnCreate')?.addEventListener('click', doCreate);
  $('btnRestore')?.addEventListener('click', doRestore);
  setStatus('ready');
});
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/_bak_bridge_20260107T102635Z/app.js`

- Size: 16445 bytes
- Lines: 519

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/_bak_bridge_20260107T102822Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/_bak_premiumtabs_20260109T063827Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/_bak_ui_20260107T101342Z/app.js`

- Size: 11592 bytes
- Lines: 359

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/compat.js`

- Size: 5512 bytes
- Lines: 180

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_dev__999_20260111T143334Z/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_dev/api_base.js`

- Size: 179 bytes
- Lines: 5

```javascript
(() => {
  // same-origin only
  window.API_BASE   = "/api";        // node backend (nginx -> 127.0.0.1:8080)
  window.WALLET_API = "/wallet-api"; // wallet proxy (FastAPI)
})();
```

### `/opt/logos/www/wallet_dev/app.js`

- Size: 30839 bytes
- Lines: 874

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();



/* ========= SEND LGN MODULE (v2, sig_hex) ========= */
(() => {
  const NODE_API = (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");

  function q(sel, root=document){ return root.querySelector(sel); }
  function qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function utf8(s){ return new TextEncoder().encode(String(s)); }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++){
      out += u8[i].toString(16).padStart(2,"0");
    }
    return out;
  }

  function hexToU8(h){
    h = (h||"").trim().replace(/^0x/,"");
    if (!h || (h.length % 2)) return null;
    const u = new Uint8Array(h.length/2);
    for (let i=0;i<u.length;i++) u[i] = parseInt(h.substr(i*2,2),16);
    return u;
  }

  function getRID(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || "";
  }

  // пытаемся найти private Ed25519 JWK в localStorage (если ключи хранятся так)
  function findEd25519PrivJwk(){
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      const v = localStorage.getItem(k);
      if (!v || v.length < 20) continue;
      try{
        const j = JSON.parse(v);
        if (j && j.crv === "Ed25519" && j.kty && j.d && j.x) return j;
      }catch(e){}
    }
    return null;
  }

  async function importPrivKeyFromJwk(jwk){
    return crypto.subtle.importKey("jwk", jwk, {name:"Ed25519"}, false, ["sign"]);
  }

  async function signEd25519(privKey, msgU8){
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msgU8);
    return new Uint8Array(sig);
  }

  async function getNonce(rid){
    const r = await fetch(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    if(!r.ok) throw new Error(`balance http ${r.status}`);
    const j = await r.json();
    return j.nonce;
  }

  async function getCanonBytes(draft){
    // пробуем debug_canon (если включен на сервере)
    try{
      const r = await fetch(`${NODE_API}/debug_canon`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(draft)
      });
      if (r.ok){
        const t = await r.text();
        // варианты: JSON или просто строка
        try{
          const j = JSON.parse(t);
          const ch = j.canon_hex || j.canon || j.msg_hex || j.message_hex || j.bytes_hex || "";
          const u = hexToU8(ch);
          if (u) return u;
          const s = (j.canon_str || j.message || j.msg || "");
          if (s) return utf8(s);
        }catch(e){
          // если просто строка
          const u = hexToU8(t);
          if (u) return u;
          if (t && t.length) return utf8(t);
        }
      }
    }catch(e){}

    // fallback: стабильная строка (если debug_canon нет)
    const memo = (draft.memo === null || draft.memo === undefined) ? "" : String(draft.memo);
    const s = `LOGOS_TX|from=${draft.from}|to=${draft.to}|amount=${draft.amount}|nonce=${draft.nonce}|memo=${memo}`;
    return utf8(s);
  }

  function setStatus(panel, text, ok=true){
    let el = q(".sendStatus", panel);
    if(!el){
      el = document.createElement("div");
      el.className = "sendStatus";
      el.style.marginTop = "10px";
      el.style.fontSize = "13px";
      el.style.opacity = "0.95";
      panel.appendChild(el);
    }
    el.textContent = text || "";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function findSendPanel(){
    return document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('.panel[data-panel="send"]')
      || null;
  }

  function findSendControls(panel){
    const btnSend = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("send lgn"));
    const inputs = qa("input", panel);
    const toRid   = inputs[0] || null;
    const amount  = inputs[1] || null;
    const memo    = inputs[2] || null;
    const btnFillMe = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("мой rid"));
    return {btnSend, btnFillMe, toRid, amount, memo};
  }

  async function handleSend(panel, ui){
    const fromRid = getRID();
    const toRid = (ui.toRid?.value || "").trim();
    const memoStr = (ui.memo?.value || "").trim();
    const amtStr = (ui.amount?.value || "").trim();

    if(!fromRid){ setStatus(panel, "ERR: нет RID (ключи не найдены).", false); return; }
    if(!toRid || toRid.length < 10){ setStatus(panel, "ERR: введи RID получателя.", false); return; }

    const amt = Number(amtStr.replace(",", "."));
    if(!isFinite(amt) || amt <= 0){ setStatus(panel, "ERR: введи сумму > 0.", false); return; }

    const amount_mic = Math.round(amt * 1e6);

    setStatus(panel, "Отправляю…", true);

    let nonce;
    try{
      nonce = await getNonce(fromRid);
    }catch(e){
      setStatus(panel, "ERR: не смог получить nonce (balance).", false);
      return;
    }

    // draft по схеме TxIn (без подписи)
    const draft = {
      from: fromRid,
      to: toRid,
      amount: amount_mic,
      nonce: nonce,
      memo: memoStr ? memoStr : None
    };

    // JS не знает None, поэтому:
    if (!memoStr) draft.memo = null;

    // bytes for signing
    const canonBytes = await getCanonBytes(draft);

    // signer
    const jwk = findEd25519PrivJwk();
    if(!jwk){
      setStatus(panel, "ERR: приватный ключ не найден (localStorage). Если ключи в IndexedDB — скажи, сделаем доступ через существующий signer.", false);
      return;
    }

    let privKey;
    try{
      privKey = await importPrivKeyFromJwk(jwk);
    }catch(e){
      setStatus(panel, "ERR: не смог импортировать Ed25519 ключ.", false);
      return;
    }

    let sigU8;
    try{
      sigU8 = await signEd25519(privKey, canonBytes);
    }catch(e){
      setStatus(panel, "ERR: не смог подписать транзакцию.", false);
      return;
    }

    const txIn = {
      from: draft.from,
      to: draft.to,
      amount: draft.amount,
      nonce: draft.nonce,
      memo: draft.memo,
      sig_hex: hex(sigU8)
    };

    try{
      const r = await fetch(`${NODE_API}/submit_tx`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(txIn)
      });
      const text = await r.text();
      if(!r.ok){
        setStatus(panel, `ERR submit_tx: ${r.status} ${text}`.slice(0,500), false);
        return;
      }
      try{
        const j = JSON.parse(text);
        if (j && j.ok){
          setStatus(panel, `✅ Отправлено. txid: ${(j.txid||"")}`.trim(), true);
        } else {
          setStatus(panel, `⚠️ Ответ: ${text}`.slice(0,500), false);
        }
      }catch(e){
        setStatus(panel, `✅ Отправлено. Ответ: ${text}`.slice(0,200), true);
      }
    }catch(e){
      setStatus(panel, "ERR: сеть/submit_tx не доступен.", false);
    }
  }

  function initSend(){
    const panel = findSendPanel();
    if(!panel) return;
    const ui = findSendControls(panel);

    if(ui.btnFillMe){
      ui.btnFillMe.addEventListener("click", () => {
        const rid = getRID();
        if(ui.toRid) ui.toRid.value = rid || "";
      });
    }
    if(ui.btnSend){
      ui.btnSend.addEventListener("click", () => handleSend(panel, ui));
    }
  }

  try{ initSend(); }catch(e){}
})();

```

### `/opt/logos/www/wallet_dev/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_dev/auth.js`

- Size: 9193 bytes
- Lines: 288

```javascript
'use strict';

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30,0x2e,0x02,0x01,0x00,
  0x30,0x05,0x06,0x03,0x2b,0x65,0x70,
  0x04,0x22,0x04,0x20
]);

const $ = (id) => document.getElementById(id);

function setStatus(t){
  const el = $('status');
  if (el) el.textContent = 'Статус: ' + t;
}

function ensureEnv(){
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto?.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error('tweetnacl не загружен (нет window.nacl)');
}

const B58_ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function base58encode(bytes){
  const b = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
  if (b.length === 0) return "";
  let digits = [0];
  for (let i=0;i<b.length;i++){
    let carry = b[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j]*256 + carry;
      digits[j] = x % 58;
      carry = (x/58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry/58) | 0;
    }
  }
  let out = "";
  for (let k=0;k<b.length && b[k]===0;k++) out += "1";
  for (let q=digits.length-1;q>=0;q--) out += B58_ALPH[digits[q]];
  return out;
}

async function sha256(u8){
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

function pkcs8FromSeed(seed32){
  const seed = (seed32 instanceof Uint8Array) ? seed32 : new Uint8Array(seed32||[]);
  if (seed.length !== 32) throw new Error('seed must be 32 bytes');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed, ED25519_PKCS8_PREFIX.length);
  return out;
}

async function deriveKey(pass, saltU8, usage=['encrypt','decrypt']){
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltU8, iterations:120000, hash:'SHA-256' },
    keyMat,
    { name:'AES-GCM', length:256 },
    false,
    usage
  );
}

async function aesEncrypt(aesKey, plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plainU8);
  return { iv, ct: new Uint8Array(ct) };
}

async function aesDecrypt(aesKey, ivU8, ctU8){
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

let DBP = null;
function openDb(){
  if (DBP) return DBP;
  DBP = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbPut(key, val){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = ()=>resolve(true);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbListRids(){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const out = [];
    const req = st.openCursor();
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve(out);
      const k = String(cur.key||'');
      if (k.startsWith('acct:')) out.push(k.slice(5));
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

function setSession(rid, pass){
  // mirror to localStorage for app.js compatibility
  try {
    localStorage.setItem("logos_rid", String(rid||""));
    localStorage.setItem("RID", String(rid||""));
    if (pass != null) localStorage.setItem("logos_pass", String(pass||""));
  } catch(e) {}

  sessionStorage.setItem('logos_rid', rid);
  sessionStorage.setItem('logos_pass', pass);
  localStorage.setItem('logos_rid', rid);
  localStorage.setItem('logos_pass', pass);
}

function validatePass(p){
  const s = String(p||'').trim();
  if (s.length < 10) throw new Error('Пароль слишком короткий (мин 10)');
  return s;
}

function normalizePhrase(ph){
  return String(ph||'').trim().replace(/\s+/g,' ').toLowerCase();
}

const WORDS = [
  "alpha","bravo","canyon","delta","eagle","frost","galaxy","harbor","ivory","jungle","karma","legend",
  "matrix","nebula","orbit","pioneer","quantum","raven","signal","temple","union","vector","wander","xenon",
  "yellow","zenith","acoustic","breeze","crystal","drift","ember","forest","glimmer","horizon","island","jewel",
  "kernel","lunar","mirror","nova","oasis","prism","quiet","river","stone","thunder","ultra","vivid","whisper","zero"
];

function genPhrase16(){
  const rnd = crypto.getRandomValues(new Uint8Array(16));
  const w = [];
  for (let i=0;i<16;i++) w.push(WORDS[rnd[i] % WORDS.length]);
  return w.join(' ');
}

async function seedFromPhrase(phrase){
  const p = normalizePhrase(phrase);
  if (!p) throw new Error('Фраза пустая');
  const h = await sha256(enc.encode(p));
  return h.slice(0,32);
}

function ridFromSeed(seed32){
  const kp = nacl.sign.keyPair.fromSeed(seed32);
  const pub = new Uint8Array(kp.publicKey);
  return base58encode(pub);
}

async function storeAccount(rid, pass, seed32){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt, ['encrypt','decrypt']);
  const pkcs8 = pkcs8FromSeed(seed32);
  const {iv, ct} = await aesEncrypt(aes, pkcs8);

  const meta = { salt: Array.from(salt), iv: Array.from(iv), priv: Array.from(ct), ts: Date.now() };
  await idbPut('acct:' + rid, meta);
}

async function loadAndVerify(rid, pass){
  const meta = await idbGet('acct:' + rid);
  if (!meta) throw new Error('RID не найден на этом устройстве (нет локальной записи)');
  const salt = new Uint8Array(meta.salt || []);
  const iv   = new Uint8Array(meta.iv || []);
  const ct   = new Uint8Array(meta.priv || []);
  const aes  = await deriveKey(pass, salt, ['decrypt']);
  const pkcs8 = await aesDecrypt(aes, iv, ct);
  const seed = pkcs8.slice(ED25519_PKCS8_PREFIX.length);
  const checkRid = ridFromSeed(seed);
  if (checkRid !== rid) throw new Error('Неверный пароль');
  return true;
}

async function doShow(){
  try{
    ensureEnv();
    const list = await idbListRids();
    const box = $('savedList');
    if (box){
      box.style.display = '';
      box.textContent = list.length ? list.map(x=>'• '+x).join('\n') : '— пусто —';
    }
    setStatus('saved RID: ' + list.length);
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doLogin(){
  try{
    ensureEnv();
    const rid = String($('ridIn')?.value||'').trim();
    const pass = validatePass($('passIn')?.value||'');
    if (!rid) throw new Error('RID пустой');
    setStatus('checking…');
    await loadAndVerify(rid, pass);
    setSession(rid, pass);
    setStatus('ok → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doCreate(){
  try{
    ensureEnv();
    const pass = validatePass($('newPass')?.value||'');
    const phrase = genPhrase16();
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    const out = $('newPhraseOut');
    if (out) out.value = phrase;
    setSession(rid, pass);
    setStatus('created: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doRestore(){
  try{
    ensureEnv();
    const phrase = normalizePhrase($('phraseIn')?.value||'');
    const pass = validatePass($('restorePass')?.value||'');
    if (!phrase) throw new Error('Фраза пустая');
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    setSession(rid, pass);
    setStatus('restored: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  $('btnShow')?.addEventListener('click', doShow);
  $('btnLogin')?.addEventListener('click', doLogin);
  $('btnCreate')?.addEventListener('click', doCreate);
  $('btnRestore')?.addEventListener('click', doRestore);
  setStatus('ready');
});
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/api_base.js`

- Size: 179 bytes
- Lines: 5

```javascript
(() => {
  // same-origin only
  window.API_BASE   = "/api";        // node backend (nginx -> 127.0.0.1:8080)
  window.WALLET_API = "/wallet-api"; // wallet proxy (FastAPI)
})();
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/app.js`

- Size: 30839 bytes
- Lines: 874

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();



/* ========= SEND LGN MODULE (v2, sig_hex) ========= */
(() => {
  const NODE_API = (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");

  function q(sel, root=document){ return root.querySelector(sel); }
  function qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function utf8(s){ return new TextEncoder().encode(String(s)); }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++){
      out += u8[i].toString(16).padStart(2,"0");
    }
    return out;
  }

  function hexToU8(h){
    h = (h||"").trim().replace(/^0x/,"");
    if (!h || (h.length % 2)) return null;
    const u = new Uint8Array(h.length/2);
    for (let i=0;i<u.length;i++) u[i] = parseInt(h.substr(i*2,2),16);
    return u;
  }

  function getRID(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || "";
  }

  // пытаемся найти private Ed25519 JWK в localStorage (если ключи хранятся так)
  function findEd25519PrivJwk(){
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      const v = localStorage.getItem(k);
      if (!v || v.length < 20) continue;
      try{
        const j = JSON.parse(v);
        if (j && j.crv === "Ed25519" && j.kty && j.d && j.x) return j;
      }catch(e){}
    }
    return null;
  }

  async function importPrivKeyFromJwk(jwk){
    return crypto.subtle.importKey("jwk", jwk, {name:"Ed25519"}, false, ["sign"]);
  }

  async function signEd25519(privKey, msgU8){
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msgU8);
    return new Uint8Array(sig);
  }

  async function getNonce(rid){
    const r = await fetch(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    if(!r.ok) throw new Error(`balance http ${r.status}`);
    const j = await r.json();
    return j.nonce;
  }

  async function getCanonBytes(draft){
    // пробуем debug_canon (если включен на сервере)
    try{
      const r = await fetch(`${NODE_API}/debug_canon`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(draft)
      });
      if (r.ok){
        const t = await r.text();
        // варианты: JSON или просто строка
        try{
          const j = JSON.parse(t);
          const ch = j.canon_hex || j.canon || j.msg_hex || j.message_hex || j.bytes_hex || "";
          const u = hexToU8(ch);
          if (u) return u;
          const s = (j.canon_str || j.message || j.msg || "");
          if (s) return utf8(s);
        }catch(e){
          // если просто строка
          const u = hexToU8(t);
          if (u) return u;
          if (t && t.length) return utf8(t);
        }
      }
    }catch(e){}

    // fallback: стабильная строка (если debug_canon нет)
    const memo = (draft.memo === null || draft.memo === undefined) ? "" : String(draft.memo);
    const s = `LOGOS_TX|from=${draft.from}|to=${draft.to}|amount=${draft.amount}|nonce=${draft.nonce}|memo=${memo}`;
    return utf8(s);
  }

  function setStatus(panel, text, ok=true){
    let el = q(".sendStatus", panel);
    if(!el){
      el = document.createElement("div");
      el.className = "sendStatus";
      el.style.marginTop = "10px";
      el.style.fontSize = "13px";
      el.style.opacity = "0.95";
      panel.appendChild(el);
    }
    el.textContent = text || "";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function findSendPanel(){
    return document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('.panel[data-panel="send"]')
      || null;
  }

  function findSendControls(panel){
    const btnSend = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("send lgn"));
    const inputs = qa("input", panel);
    const toRid   = inputs[0] || null;
    const amount  = inputs[1] || null;
    const memo    = inputs[2] || null;
    const btnFillMe = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("мой rid"));
    return {btnSend, btnFillMe, toRid, amount, memo};
  }

  async function handleSend(panel, ui){
    const fromRid = getRID();
    const toRid = (ui.toRid?.value || "").trim();
    const memoStr = (ui.memo?.value || "").trim();
    const amtStr = (ui.amount?.value || "").trim();

    if(!fromRid){ setStatus(panel, "ERR: нет RID (ключи не найдены).", false); return; }
    if(!toRid || toRid.length < 10){ setStatus(panel, "ERR: введи RID получателя.", false); return; }

    const amt = Number(amtStr.replace(",", "."));
    if(!isFinite(amt) || amt <= 0){ setStatus(panel, "ERR: введи сумму > 0.", false); return; }

    const amount_mic = Math.round(amt * 1e6);

    setStatus(panel, "Отправляю…", true);

    let nonce;
    try{
      nonce = await getNonce(fromRid);
    }catch(e){
      setStatus(panel, "ERR: не смог получить nonce (balance).", false);
      return;
    }

    // draft по схеме TxIn (без подписи)
    const draft = {
      from: fromRid,
      to: toRid,
      amount: amount_mic,
      nonce: nonce,
      memo: memoStr ? memoStr : None
    };

    // JS не знает None, поэтому:
    if (!memoStr) draft.memo = null;

    // bytes for signing
    const canonBytes = await getCanonBytes(draft);

    // signer
    const jwk = findEd25519PrivJwk();
    if(!jwk){
      setStatus(panel, "ERR: приватный ключ не найден (localStorage). Если ключи в IndexedDB — скажи, сделаем доступ через существующий signer.", false);
      return;
    }

    let privKey;
    try{
      privKey = await importPrivKeyFromJwk(jwk);
    }catch(e){
      setStatus(panel, "ERR: не смог импортировать Ed25519 ключ.", false);
      return;
    }

    let sigU8;
    try{
      sigU8 = await signEd25519(privKey, canonBytes);
    }catch(e){
      setStatus(panel, "ERR: не смог подписать транзакцию.", false);
      return;
    }

    const txIn = {
      from: draft.from,
      to: draft.to,
      amount: draft.amount,
      nonce: draft.nonce,
      memo: draft.memo,
      sig_hex: hex(sigU8)
    };

    try{
      const r = await fetch(`${NODE_API}/submit_tx`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(txIn)
      });
      const text = await r.text();
      if(!r.ok){
        setStatus(panel, `ERR submit_tx: ${r.status} ${text}`.slice(0,500), false);
        return;
      }
      try{
        const j = JSON.parse(text);
        if (j && j.ok){
          setStatus(panel, `✅ Отправлено. txid: ${(j.txid||"")}`.trim(), true);
        } else {
          setStatus(panel, `⚠️ Ответ: ${text}`.slice(0,500), false);
        }
      }catch(e){
        setStatus(panel, `✅ Отправлено. Ответ: ${text}`.slice(0,200), true);
      }
    }catch(e){
      setStatus(panel, "ERR: сеть/submit_tx не доступен.", false);
    }
  }

  function initSend(){
    const panel = findSendPanel();
    if(!panel) return;
    const ui = findSendControls(panel);

    if(ui.btnFillMe){
      ui.btnFillMe.addEventListener("click", () => {
        const rid = getRID();
        if(ui.toRid) ui.toRid.value = rid || "";
      });
    }
    if(ui.btnSend){
      ui.btnSend.addEventListener("click", () => handleSend(panel, ui));
    }
  }

  try{ initSend(); }catch(e){}
})();

```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/auth.js`

- Size: 9193 bytes
- Lines: 288

```javascript
'use strict';

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30,0x2e,0x02,0x01,0x00,
  0x30,0x05,0x06,0x03,0x2b,0x65,0x70,
  0x04,0x22,0x04,0x20
]);

const $ = (id) => document.getElementById(id);

function setStatus(t){
  const el = $('status');
  if (el) el.textContent = 'Статус: ' + t;
}

function ensureEnv(){
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto?.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error('tweetnacl не загружен (нет window.nacl)');
}

const B58_ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function base58encode(bytes){
  const b = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
  if (b.length === 0) return "";
  let digits = [0];
  for (let i=0;i<b.length;i++){
    let carry = b[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j]*256 + carry;
      digits[j] = x % 58;
      carry = (x/58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry/58) | 0;
    }
  }
  let out = "";
  for (let k=0;k<b.length && b[k]===0;k++) out += "1";
  for (let q=digits.length-1;q>=0;q--) out += B58_ALPH[digits[q]];
  return out;
}

async function sha256(u8){
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

function pkcs8FromSeed(seed32){
  const seed = (seed32 instanceof Uint8Array) ? seed32 : new Uint8Array(seed32||[]);
  if (seed.length !== 32) throw new Error('seed must be 32 bytes');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed, ED25519_PKCS8_PREFIX.length);
  return out;
}

async function deriveKey(pass, saltU8, usage=['encrypt','decrypt']){
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltU8, iterations:120000, hash:'SHA-256' },
    keyMat,
    { name:'AES-GCM', length:256 },
    false,
    usage
  );
}

async function aesEncrypt(aesKey, plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plainU8);
  return { iv, ct: new Uint8Array(ct) };
}

async function aesDecrypt(aesKey, ivU8, ctU8){
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

let DBP = null;
function openDb(){
  if (DBP) return DBP;
  DBP = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbPut(key, val){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = ()=>resolve(true);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbListRids(){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const out = [];
    const req = st.openCursor();
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve(out);
      const k = String(cur.key||'');
      if (k.startsWith('acct:')) out.push(k.slice(5));
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

function setSession(rid, pass){
  // mirror to localStorage for app.js compatibility
  try {
    localStorage.setItem("logos_rid", String(rid||""));
    localStorage.setItem("RID", String(rid||""));
    if (pass != null) localStorage.setItem("logos_pass", String(pass||""));
  } catch(e) {}

  sessionStorage.setItem('logos_rid', rid);
  sessionStorage.setItem('logos_pass', pass);
  localStorage.setItem('logos_rid', rid);
  localStorage.setItem('logos_pass', pass);
}

function validatePass(p){
  const s = String(p||'').trim();
  if (s.length < 10) throw new Error('Пароль слишком короткий (мин 10)');
  return s;
}

function normalizePhrase(ph){
  return String(ph||'').trim().replace(/\s+/g,' ').toLowerCase();
}

const WORDS = [
  "alpha","bravo","canyon","delta","eagle","frost","galaxy","harbor","ivory","jungle","karma","legend",
  "matrix","nebula","orbit","pioneer","quantum","raven","signal","temple","union","vector","wander","xenon",
  "yellow","zenith","acoustic","breeze","crystal","drift","ember","forest","glimmer","horizon","island","jewel",
  "kernel","lunar","mirror","nova","oasis","prism","quiet","river","stone","thunder","ultra","vivid","whisper","zero"
];

function genPhrase16(){
  const rnd = crypto.getRandomValues(new Uint8Array(16));
  const w = [];
  for (let i=0;i<16;i++) w.push(WORDS[rnd[i] % WORDS.length]);
  return w.join(' ');
}

async function seedFromPhrase(phrase){
  const p = normalizePhrase(phrase);
  if (!p) throw new Error('Фраза пустая');
  const h = await sha256(enc.encode(p));
  return h.slice(0,32);
}

function ridFromSeed(seed32){
  const kp = nacl.sign.keyPair.fromSeed(seed32);
  const pub = new Uint8Array(kp.publicKey);
  return base58encode(pub);
}

async function storeAccount(rid, pass, seed32){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt, ['encrypt','decrypt']);
  const pkcs8 = pkcs8FromSeed(seed32);
  const {iv, ct} = await aesEncrypt(aes, pkcs8);

  const meta = { salt: Array.from(salt), iv: Array.from(iv), priv: Array.from(ct), ts: Date.now() };
  await idbPut('acct:' + rid, meta);
}

async function loadAndVerify(rid, pass){
  const meta = await idbGet('acct:' + rid);
  if (!meta) throw new Error('RID не найден на этом устройстве (нет локальной записи)');
  const salt = new Uint8Array(meta.salt || []);
  const iv   = new Uint8Array(meta.iv || []);
  const ct   = new Uint8Array(meta.priv || []);
  const aes  = await deriveKey(pass, salt, ['decrypt']);
  const pkcs8 = await aesDecrypt(aes, iv, ct);
  const seed = pkcs8.slice(ED25519_PKCS8_PREFIX.length);
  const checkRid = ridFromSeed(seed);
  if (checkRid !== rid) throw new Error('Неверный пароль');
  return true;
}

async function doShow(){
  try{
    ensureEnv();
    const list = await idbListRids();
    const box = $('savedList');
    if (box){
      box.style.display = '';
      box.textContent = list.length ? list.map(x=>'• '+x).join('\n') : '— пусто —';
    }
    setStatus('saved RID: ' + list.length);
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doLogin(){
  try{
    ensureEnv();
    const rid = String($('ridIn')?.value||'').trim();
    const pass = validatePass($('passIn')?.value||'');
    if (!rid) throw new Error('RID пустой');
    setStatus('checking…');
    await loadAndVerify(rid, pass);
    setSession(rid, pass);
    setStatus('ok → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doCreate(){
  try{
    ensureEnv();
    const pass = validatePass($('newPass')?.value||'');
    const phrase = genPhrase16();
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    const out = $('newPhraseOut');
    if (out) out.value = phrase;
    setSession(rid, pass);
    setStatus('created: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doRestore(){
  try{
    ensureEnv();
    const phrase = normalizePhrase($('phraseIn')?.value||'');
    const pass = validatePass($('restorePass')?.value||'');
    if (!phrase) throw new Error('Фраза пустая');
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    setSession(rid, pass);
    setStatus('restored: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  $('btnShow')?.addEventListener('click', doShow);
  $('btnLogin')?.addEventListener('click', doLogin);
  $('btnCreate')?.addEventListener('click', doCreate);
  $('btnRestore')?.addEventListener('click', doRestore);
  setStatus('ready');
});
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/_bak_bridge_20260107T102635Z/app.js`

- Size: 16445 bytes
- Lines: 519

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/_bak_bridge_20260107T102822Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/_bak_premiumtabs_20260109T063827Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/_bak_ui_20260107T101342Z/app.js`

- Size: 11592 bytes
- Lines: 359

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/compat.js`

- Size: 5512 bytes
- Lines: 180

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/modules/send.js`

- Size: 7566 bytes
- Lines: 205

```javascript
/* modules/send.js — REAL SEND LGN (TxIn -> /api/submit_tx) */
(() => {
  function $(sel, root=document){ return root.querySelector(sel); }

  function ridGet(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || sessionStorage.getItem("logos_rid")
      || "";
  }

  function nodeApi(){
    return (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");
  }

  function setMsg(panel, text, ok=true){
    const el = $("#sendMsg", panel) || $(".sendMsg", panel);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function b64ToU8(b64){
    b64 = (b64||"").replace(/-/g,'+').replace(/_/g,'/');
    while (b64.length % 4) b64 += "=";
    const s = atob(b64);
    const u = new Uint8Array(s.length);
    for (let i=0;i<s.length;i++) u[i] = s.charCodeAt(i);
    return u;
  }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++) out += u8[i].toString(16).padStart(2,"0");
    return out;
  }

  // точное преобразование LGN -> micro-LGN (6 decimals)
  function lgnToMicro(s){
    s = String(s||"").trim().replace(",",".");
    if (!s) return null;
    const m = s.match(/^(\d+)(?:\.(\d{0,6})\d*)?$/);
    if (!m) return null;
    const a = m[1];
    const frac = (m[2]||"").padEnd(6,"0");
    const microStr = a + frac;
    // без BigInt не рискуем переполнением? у нас u64 — используем BigInt
    return BigInt(microStr);
  }

  async function getJSON(url){
    const r = await fetch(url, {method:"GET"});
    const t = await r.text();
    let j=null; try{ j=JSON.parse(t);}catch(_){}
    if (!r.ok){
      const msg = j?.detail || j?.error || j?.message || t;
      throw new Error("HTTP " + r.status + ": " + msg);
    }
    return j ?? t;
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method:"POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j=null; try{ j=JSON.parse(t);}catch(_){}
    if (!r.ok){
      const msg = j?.detail || j?.error || j?.message || t;
      throw new Error("HTTP " + r.status + ": " + msg);
    }
    return j ?? t;
  }

  // Пытаемся найти приватный ключ в localStorage (PKCS8 base64/base64url) — без знания имени.
  async function findEd25519PrivKeyForRid(rid){
    const keys = [];
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      const v = localStorage.getItem(k);
      if (!v) continue;
      if (v.length < 40) continue;
      keys.push([k,v]);
    }

    for (const [k,v] of keys){
      // пропускаем явно не ключи
      if (k.toLowerCase().includes("theme")) continue;
      if (k.toLowerCase().includes("lang")) continue;

      // пробуем как pkcs8 base64/base64url
      let u8 = null;
      try { u8 = b64ToU8(v); } catch(_){}
      if (!u8 || u8.length < 40) continue;

      try{
        const priv = await crypto.subtle.importKey(
          "pkcs8",
          u8,
          { name:"Ed25519" },
          false,
          ["sign"]
        );

        // проверяем: подпись должна валидироваться на pubkey, который соответствует RID
        // (RID у тебя base58(pubkey) — но мы не будем вычислять pubkey: просто вернём ключ и надеемся что он правильный;
        // если неправильный — сервер вернёт bad_signature)
        return priv;
      }catch(_){
        // not a pkcs8 ed25519
      }
    }
    return null;
  }

  function canonBytes(tx){
    // ВАЖНО: это канонизация “по-человечески”.
    // Если на ноде другой формат — сразу увидим "bad_signature", и тогда сделаем canon-endpoint.
    const memo = tx.memo ? String(tx.memo) : "";
    const s = `${tx.from}|${tx.to}|${tx.amount}|${tx.nonce}|${memo}`;
    return new TextEncoder().encode(s);
  }

  async function signTx(privKey, tx){
    const msg = canonBytes(tx);
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msg);
    return hex(new Uint8Array(sig));
  }

  function render(){
    const panel =
      document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('[data-panel="send"]')
      || document.querySelector('#panel-send');

    if (!panel) return;

    const btnSend = $("#btnSendLGN", panel) || $("#sendBtn", panel) || panel.querySelector("button");
    if (!btnSend) return;

    btnSend.addEventListener("click", async () => {
      try{
        const from = ridGet();
        const to = ($("#sendToRid", panel)?.value || "").trim();
        const amountStr = ($("#sendAmount", panel)?.value || "").trim();
        const memo = ($("#sendMemo", panel)?.value || "").trim();

        if (!from) return setMsg(panel, "RID не найден. Перезайди в кошелёк.", false);
        if (!to || to.length < 12) return setMsg(panel, "Введи правильный RID получателя.", false);

        const micro = lgnToMicro(amountStr);
        if (micro === null) return setMsg(panel, "Введи сумму (например 1 или 0.5).", false);
        if (micro <= 0n) return setMsg(panel, "Сумма должна быть больше 0.", false);

        setMsg(panel, "Получаю nonce…", true);
        const bal = await getJSON(nodeApi() + "/balance/" + encodeURIComponent(from));
        const nonceNow = (bal && (bal.nonce ?? bal.nonce_u64 ?? bal.account_nonce)) ;
        if (nonceNow === undefined || nonceNow === null) {
          return setMsg(panel, "Не смог прочитать nonce из /balance. Нужно уточнить формат ответа.", false);
        }
        const nonce = BigInt(nonceNow) + 1n;

        setMsg(panel, "Ищу ключ…", true);
        const priv = await findEd25519PrivKeyForRid(from);
        if (!priv){
          return setMsg(panel, "Нет приватного ключа в браузере. Нужен импорт/создание ключа (добавим в Настройки).", false);
        }

        const tx = {
          from,
          to,
          amount: micro.toString(),
          nonce: nonce.toString(),
          memo: memo || null
        };

        setMsg(panel, "Подписываю…", true);
        const sig_hex = await signTx(priv, tx);

        setMsg(panel, "Отправляю в сеть…", true);
        const res = await postJSON(nodeApi() + "/submit_tx", {
          from: tx.from,
          to: tx.to,
          amount: Number(tx.amount), // u64 — у тебя тут маленькие суммы; если будут огромные — переведём на строку на сервере
          nonce: Number(tx.nonce),
          memo: tx.memo,
          sig_hex
        });

        setMsg(panel, "✅ Отправлено. " + (res?.txid ? ("txid: " + res.txid) : (res?.info ? res.info : "")), true);
      }catch(e){
        setMsg(panel, "ERR: " + (e?.message || e), false);
      }
    });
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", render);
  else render();
})();
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/modules/settings.js`

- Size: 9308 bytes
- Lines: 241

```javascript
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/modules/tx_redirect.js`

- Size: 2810 bytes
- Lines: 90

```javascript
/* tx_redirect.js — redirect old /transfer -> /submit_tx and normalize body to TxIn */
(() => {
  const _fetch = window.fetch.bind(window);

  function isHex(s){
    s = String(s||"").replace(/^0x/,"").trim();
    return s.length > 0 && s.length % 2 === 0 && /^[0-9a-fA-F]+$/.test(s);
  }

  function b64urlToBytes(b64url){
    try{
      let s = String(b64url||"").replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u[i] = bin.charCodeAt(i);
      return u;
    }catch(e){ return null; }
  }

  function bytesToHex(u){
    let out = "";
    for (let i=0;i<u.length;i++) out += u[i].toString(16).padStart(2,"0");
    return out;
  }

  function normalizeTx(body){
    const j = body && typeof body === "object" ? body : {};
    const from = j.from || j.rid_from || j.sender || j.rid || "";
    const to   = j.to   || j.rid_to   || j.receiver || "";
    let amount = j.amount_mic ?? j.amount_micro ?? j.amount ?? 0;
    const nonce = j.nonce ?? j.n ?? j.account_nonce;

    // если вдруг прислали amount_lgn — переводим в micro-LGN
    if (j.amount_lgn !== undefined && j.amount_lgn !== null){
      const a = Number(j.amount_lgn);
      if (isFinite(a)) amount = Math.round(a * 1e6);
    }

    // подпись: sig_hex обязательно
    let sig_hex = j.sig_hex || j.sigHex || "";
    if (!sig_hex){
      const s = j.sig || j.signature || j.sig_b64 || j.sigB64 || "";
      if (s){
        if (isHex(s)) sig_hex = String(s).replace(/^0x/,"");
        else {
          const u = b64urlToBytes(s);
          if (u) sig_hex = bytesToHex(u);
        }
      }
    }

    const memo = (j.memo === undefined ? null : j.memo);

    return { from, to, amount, nonce, memo, sig_hex };
  }

  window.fetch = async (input, init={}) => {
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url.includes("/transfer")){
        const newUrl = url.replace("/transfer", "/submit_tx");

        let bodyObj = {};
        try{ bodyObj = JSON.parse(init.body || "{}"); }catch(e){ bodyObj = {}; }

        const tx = normalizeTx(bodyObj);

        const newInit = {
          ...init,
          method: "POST",
          headers: { ...(init.headers||{}), "Content-Type":"application/json" },
          body: JSON.stringify({
            from: tx.from,
            to: tx.to,
            amount: tx.amount,
            nonce: tx.nonce,
            memo: tx.memo,
            sig_hex: tx.sig_hex
          })
        };

        return _fetch(newUrl, newInit);
      }
    }catch(e){}
    return _fetch(input, init);
  };

  console.log("[tx_redirect] installed: /transfer -> /submit_tx");
})();
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_dev__bak_before_restore_20260112T090309Z/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.js`

- Size: 16445 bytes
- Lines: 519

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */
```

### `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/app.js`

- Size: 21990 bytes
- Lines: 681

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```

### `/opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.js`

- Size: 11592 bytes
- Lines: 359

```javascript
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);
```

### `/opt/logos/www/wallet_dev/compat.js`

- Size: 5512 bytes
- Lines: 180

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_dev/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_dev/modules/send.js`

- Size: 7566 bytes
- Lines: 205

```javascript
/* modules/send.js — REAL SEND LGN (TxIn -> /api/submit_tx) */
(() => {
  function $(sel, root=document){ return root.querySelector(sel); }

  function ridGet(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || sessionStorage.getItem("logos_rid")
      || "";
  }

  function nodeApi(){
    return (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");
  }

  function setMsg(panel, text, ok=true){
    const el = $("#sendMsg", panel) || $(".sendMsg", panel);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function b64ToU8(b64){
    b64 = (b64||"").replace(/-/g,'+').replace(/_/g,'/');
    while (b64.length % 4) b64 += "=";
    const s = atob(b64);
    const u = new Uint8Array(s.length);
    for (let i=0;i<s.length;i++) u[i] = s.charCodeAt(i);
    return u;
  }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++) out += u8[i].toString(16).padStart(2,"0");
    return out;
  }

  // точное преобразование LGN -> micro-LGN (6 decimals)
  function lgnToMicro(s){
    s = String(s||"").trim().replace(",",".");
    if (!s) return null;
    const m = s.match(/^(\d+)(?:\.(\d{0,6})\d*)?$/);
    if (!m) return null;
    const a = m[1];
    const frac = (m[2]||"").padEnd(6,"0");
    const microStr = a + frac;
    // без BigInt не рискуем переполнением? у нас u64 — используем BigInt
    return BigInt(microStr);
  }

  async function getJSON(url){
    const r = await fetch(url, {method:"GET"});
    const t = await r.text();
    let j=null; try{ j=JSON.parse(t);}catch(_){}
    if (!r.ok){
      const msg = j?.detail || j?.error || j?.message || t;
      throw new Error("HTTP " + r.status + ": " + msg);
    }
    return j ?? t;
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method:"POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j=null; try{ j=JSON.parse(t);}catch(_){}
    if (!r.ok){
      const msg = j?.detail || j?.error || j?.message || t;
      throw new Error("HTTP " + r.status + ": " + msg);
    }
    return j ?? t;
  }

  // Пытаемся найти приватный ключ в localStorage (PKCS8 base64/base64url) — без знания имени.
  async function findEd25519PrivKeyForRid(rid){
    const keys = [];
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      const v = localStorage.getItem(k);
      if (!v) continue;
      if (v.length < 40) continue;
      keys.push([k,v]);
    }

    for (const [k,v] of keys){
      // пропускаем явно не ключи
      if (k.toLowerCase().includes("theme")) continue;
      if (k.toLowerCase().includes("lang")) continue;

      // пробуем как pkcs8 base64/base64url
      let u8 = null;
      try { u8 = b64ToU8(v); } catch(_){}
      if (!u8 || u8.length < 40) continue;

      try{
        const priv = await crypto.subtle.importKey(
          "pkcs8",
          u8,
          { name:"Ed25519" },
          false,
          ["sign"]
        );

        // проверяем: подпись должна валидироваться на pubkey, который соответствует RID
        // (RID у тебя base58(pubkey) — но мы не будем вычислять pubkey: просто вернём ключ и надеемся что он правильный;
        // если неправильный — сервер вернёт bad_signature)
        return priv;
      }catch(_){
        // not a pkcs8 ed25519
      }
    }
    return null;
  }

  function canonBytes(tx){
    // ВАЖНО: это канонизация “по-человечески”.
    // Если на ноде другой формат — сразу увидим "bad_signature", и тогда сделаем canon-endpoint.
    const memo = tx.memo ? String(tx.memo) : "";
    const s = `${tx.from}|${tx.to}|${tx.amount}|${tx.nonce}|${memo}`;
    return new TextEncoder().encode(s);
  }

  async function signTx(privKey, tx){
    const msg = canonBytes(tx);
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msg);
    return hex(new Uint8Array(sig));
  }

  function render(){
    const panel =
      document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('[data-panel="send"]')
      || document.querySelector('#panel-send');

    if (!panel) return;

    const btnSend = $("#btnSendLGN", panel) || $("#sendBtn", panel) || panel.querySelector("button");
    if (!btnSend) return;

    btnSend.addEventListener("click", async () => {
      try{
        const from = ridGet();
        const to = ($("#sendToRid", panel)?.value || "").trim();
        const amountStr = ($("#sendAmount", panel)?.value || "").trim();
        const memo = ($("#sendMemo", panel)?.value || "").trim();

        if (!from) return setMsg(panel, "RID не найден. Перезайди в кошелёк.", false);
        if (!to || to.length < 12) return setMsg(panel, "Введи правильный RID получателя.", false);

        const micro = lgnToMicro(amountStr);
        if (micro === null) return setMsg(panel, "Введи сумму (например 1 или 0.5).", false);
        if (micro <= 0n) return setMsg(panel, "Сумма должна быть больше 0.", false);

        setMsg(panel, "Получаю nonce…", true);
        const bal = await getJSON(nodeApi() + "/balance/" + encodeURIComponent(from));
        const nonceNow = (bal && (bal.nonce ?? bal.nonce_u64 ?? bal.account_nonce)) ;
        if (nonceNow === undefined || nonceNow === null) {
          return setMsg(panel, "Не смог прочитать nonce из /balance. Нужно уточнить формат ответа.", false);
        }
        const nonce = BigInt(nonceNow) + 1n;

        setMsg(panel, "Ищу ключ…", true);
        const priv = await findEd25519PrivKeyForRid(from);
        if (!priv){
          return setMsg(panel, "Нет приватного ключа в браузере. Нужен импорт/создание ключа (добавим в Настройки).", false);
        }

        const tx = {
          from,
          to,
          amount: micro.toString(),
          nonce: nonce.toString(),
          memo: memo || null
        };

        setMsg(panel, "Подписываю…", true);
        const sig_hex = await signTx(priv, tx);

        setMsg(panel, "Отправляю в сеть…", true);
        const res = await postJSON(nodeApi() + "/submit_tx", {
          from: tx.from,
          to: tx.to,
          amount: Number(tx.amount), // u64 — у тебя тут маленькие суммы; если будут огромные — переведём на строку на сервере
          nonce: Number(tx.nonce),
          memo: tx.memo,
          sig_hex
        });

        setMsg(panel, "✅ Отправлено. " + (res?.txid ? ("txid: " + res.txid) : (res?.info ? res.info : "")), true);
      }catch(e){
        setMsg(panel, "ERR: " + (e?.message || e), false);
      }
    });
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", render);
  else render();
})();
```

### `/opt/logos/www/wallet_dev/modules/settings.js`

- Size: 9308 bytes
- Lines: 241

```javascript
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();
```

### `/opt/logos/www/wallet_dev/modules/tx_redirect.js`

- Size: 2810 bytes
- Lines: 90

```javascript
/* tx_redirect.js — redirect old /transfer -> /submit_tx and normalize body to TxIn */
(() => {
  const _fetch = window.fetch.bind(window);

  function isHex(s){
    s = String(s||"").replace(/^0x/,"").trim();
    return s.length > 0 && s.length % 2 === 0 && /^[0-9a-fA-F]+$/.test(s);
  }

  function b64urlToBytes(b64url){
    try{
      let s = String(b64url||"").replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u[i] = bin.charCodeAt(i);
      return u;
    }catch(e){ return null; }
  }

  function bytesToHex(u){
    let out = "";
    for (let i=0;i<u.length;i++) out += u[i].toString(16).padStart(2,"0");
    return out;
  }

  function normalizeTx(body){
    const j = body && typeof body === "object" ? body : {};
    const from = j.from || j.rid_from || j.sender || j.rid || "";
    const to   = j.to   || j.rid_to   || j.receiver || "";
    let amount = j.amount_mic ?? j.amount_micro ?? j.amount ?? 0;
    const nonce = j.nonce ?? j.n ?? j.account_nonce;

    // если вдруг прислали amount_lgn — переводим в micro-LGN
    if (j.amount_lgn !== undefined && j.amount_lgn !== null){
      const a = Number(j.amount_lgn);
      if (isFinite(a)) amount = Math.round(a * 1e6);
    }

    // подпись: sig_hex обязательно
    let sig_hex = j.sig_hex || j.sigHex || "";
    if (!sig_hex){
      const s = j.sig || j.signature || j.sig_b64 || j.sigB64 || "";
      if (s){
        if (isHex(s)) sig_hex = String(s).replace(/^0x/,"");
        else {
          const u = b64urlToBytes(s);
          if (u) sig_hex = bytesToHex(u);
        }
      }
    }

    const memo = (j.memo === undefined ? null : j.memo);

    return { from, to, amount, nonce, memo, sig_hex };
  }

  window.fetch = async (input, init={}) => {
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url.includes("/transfer")){
        const newUrl = url.replace("/transfer", "/submit_tx");

        let bodyObj = {};
        try{ bodyObj = JSON.parse(init.body || "{}"); }catch(e){ bodyObj = {}; }

        const tx = normalizeTx(bodyObj);

        const newInit = {
          ...init,
          method: "POST",
          headers: { ...(init.headers||{}), "Content-Type":"application/json" },
          body: JSON.stringify({
            from: tx.from,
            to: tx.to,
            amount: tx.amount,
            nonce: tx.nonce,
            memo: tx.memo,
            sig_hex: tx.sig_hex
          })
        };

        return _fetch(newUrl, newInit);
      }
    }catch(e){}
    return _fetch(input, init);
  };

  console.log("[tx_redirect] installed: /transfer -> /submit_tx");
})();
```

### `/opt/logos/www/wallet_dev/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_dev/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_prod__1111/api_base.js`

- Size: 180 bytes
- Lines: 7

```javascript
/* LOGOS Wallet routes (same-origin). No inline scripts. */
(function(){
  // node backend
  window.API_BASE = "/api";
  // wallet proxy
  window.WALLET_API = "/wallet-api";
})();
```

### `/opt/logos/www/wallet_prod__1111/app.js`

- Size: 30988 bytes
- Lines: 881

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }

  function clearSessionPass(){
    try{
      sessionStorage.removeItem("PASS");
      sessionStorage.removeItem("logos_pass");
    }catch(e){}
  }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();



/* ========= SEND LGN MODULE (v2, sig_hex) ========= */
(() => {
  const NODE_API = (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");

  function q(sel, root=document){ return root.querySelector(sel); }
  function qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function utf8(s){ return new TextEncoder().encode(String(s)); }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++){
      out += u8[i].toString(16).padStart(2,"0");
    }
    return out;
  }

  function hexToU8(h){
    h = (h||"").trim().replace(/^0x/,"");
    if (!h || (h.length % 2)) return null;
    const u = new Uint8Array(h.length/2);
    for (let i=0;i<u.length;i++) u[i] = parseInt(h.substr(i*2,2),16);
    return u;
  }

  function getRID(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || "";
  }

  // пытаемся найти private Ed25519 JWK в localStorage (если ключи хранятся так)
  function findEd25519PrivJwk(){
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      const v = localStorage.getItem(k);
      if (!v || v.length < 20) continue;
      try{
        const j = JSON.parse(v);
        if (j && j.crv === "Ed25519" && j.kty && j.d && j.x) return j;
      }catch(e){}
    }
    return null;
  }

  async function importPrivKeyFromJwk(jwk){
    return crypto.subtle.importKey("jwk", jwk, {name:"Ed25519"}, false, ["sign"]);
  }

  async function signEd25519(privKey, msgU8){
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msgU8);
    return new Uint8Array(sig);
  }

  async function getNonce(rid){
    const r = await fetch(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    if(!r.ok) throw new Error(`balance http ${r.status}`);
    const j = await r.json();
    return j.nonce;
  }

  async function getCanonBytes(draft){
    // пробуем debug_canon (если включен на сервере)
    try{
      const r = await fetch(`${NODE_API}/debug_canon`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(draft)
      });
      if (r.ok){
        const t = await r.text();
        // варианты: JSON или просто строка
        try{
          const j = JSON.parse(t);
          const ch = j.canon_hex || j.canon || j.msg_hex || j.message_hex || j.bytes_hex || "";
          const u = hexToU8(ch);
          if (u) return u;
          const s = (j.canon_str || j.message || j.msg || "");
          if (s) return utf8(s);
        }catch(e){
          // если просто строка
          const u = hexToU8(t);
          if (u) return u;
          if (t && t.length) return utf8(t);
        }
      }
    }catch(e){}

    // fallback: стабильная строка (если debug_canon нет)
    const memo = (draft.memo === null || draft.memo === undefined) ? "" : String(draft.memo);
    const s = `LOGOS_TX|from=${draft.from}|to=${draft.to}|amount=${draft.amount}|nonce=${draft.nonce}|memo=${memo}`;
    return utf8(s);
  }

  function setStatus(panel, text, ok=true){
    let el = q(".sendStatus", panel);
    if(!el){
      el = document.createElement("div");
      el.className = "sendStatus";
      el.style.marginTop = "10px";
      el.style.fontSize = "13px";
      el.style.opacity = "0.95";
      panel.appendChild(el);
    }
    el.textContent = text || "";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function findSendPanel(){
    return document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('.panel[data-panel="send"]')
      || null;
  }

  function findSendControls(panel){
    const btnSend = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("send lgn"));
    const inputs = qa("input", panel);
    const toRid   = inputs[0] || null;
    const amount  = inputs[1] || null;
    const memo    = inputs[2] || null;
    const btnFillMe = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("мой rid"));
    return {btnSend, btnFillMe, toRid, amount, memo};
  }

  async function handleSend(panel, ui){
    const fromRid = getRID();
    const toRid = (ui.toRid?.value || "").trim();
    const memoStr = (ui.memo?.value || "").trim();
    const amtStr = (ui.amount?.value || "").trim();

    if(!fromRid){ setStatus(panel, "ERR: нет RID (ключи не найдены).", false); return; }
    if(!toRid || toRid.length < 10){ setStatus(panel, "ERR: введи RID получателя.", false); return; }

    const amt = Number(amtStr.replace(",", "."));
    if(!isFinite(amt) || amt <= 0){ setStatus(panel, "ERR: введи сумму > 0.", false); return; }

    const amount_mic = Math.round(amt * 1e6);

    setStatus(panel, "Отправляю…", true);

    let nonce;
    try{
      nonce = await getNonce(fromRid);
    }catch(e){
      setStatus(panel, "ERR: не смог получить nonce (balance).", false);
      return;
    }

    // draft по схеме TxIn (без подписи)
    const draft = {
      from: fromRid,
      to: toRid,
      amount: amount_mic,
      nonce: nonce,
      memo: memoStr ? memoStr : None
    };

    // JS не знает None, поэтому:
    if (!memoStr) draft.memo = null;

    // bytes for signing
    const canonBytes = await getCanonBytes(draft);

    // signer
    const jwk = findEd25519PrivJwk();
    if(!jwk){
      setStatus(panel, "ERR: приватный ключ не найден (localStorage). Если ключи в IndexedDB — скажи, сделаем доступ через существующий signer.", false);
      return;
    }

    let privKey;
    try{
      privKey = await importPrivKeyFromJwk(jwk);
    }catch(e){
      setStatus(panel, "ERR: не смог импортировать Ed25519 ключ.", false);
      return;
    }

    let sigU8;
    try{
      sigU8 = await signEd25519(privKey, canonBytes);
    }catch(e){
      setStatus(panel, "ERR: не смог подписать транзакцию.", false);
      return;
    }

    const txIn = {
      from: draft.from,
      to: draft.to,
      amount: draft.amount,
      nonce: draft.nonce,
      memo: draft.memo,
      sig_hex: hex(sigU8)
    };

    try{
      const r = await fetch(`${NODE_API}/submit_tx`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(txIn)
      });
      const text = await r.text();
      if(!r.ok){
        setStatus(panel, `ERR submit_tx: ${r.status} ${text}`.slice(0,500), false);
        return;
      }
      try{
        const j = JSON.parse(text);
        if (j && j.ok){
          setStatus(panel, `✅ Отправлено. txid: ${(j.txid||"")}`.trim(), true);
        } else {
          setStatus(panel, `⚠️ Ответ: ${text}`.slice(0,500), false);
        }
      }catch(e){
        setStatus(panel, `✅ Отправлено. Ответ: ${text}`.slice(0,200), true);
      }
    }catch(e){
      setStatus(panel, "ERR: сеть/submit_tx не доступен.", false);
    }
  }

  function initSend(){
    const panel = findSendPanel();
    if(!panel) return;
    const ui = findSendControls(panel);

    if(ui.btnFillMe){
      ui.btnFillMe.addEventListener("click", () => {
        const rid = getRID();
        if(ui.toRid) ui.toRid.value = rid || "";
      });
    }
    if(ui.btnSend){
      ui.btnSend.addEventListener("click", () => handleSend(panel, ui));
    }
  }

  try{ initSend(); }catch(e){}
})();

```

### `/opt/logos/www/wallet_prod__1111/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_prod__1111/auth.js`

- Size: 2177 bytes
- Lines: 75

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){
    const el = $("status");
    if (el) el.textContent = t || "";
  }

  function loadSavedRid(){
    try{
      const rid = (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
      if (rid && $("rid")) $("rid").value = rid;
      return rid;
    }catch(e){ return ""; }
  }

  function saveRid(rid){
    try{
      localStorage.setItem("RID", rid);
      localStorage.setItem("logos_rid", rid);
    }catch(e){}
  }

  function savePassToSession(pass){
    // PROD: пароль НЕ пишем в localStorage. Только sessionStorage (сгорит при закрытии вкладки/браузера).
    try{
      sessionStorage.setItem("PASS", pass);
      sessionStorage.setItem("logos_pass", pass);
    }catch(e){}
  }

  function clearSessionPass(){
    try{
      sessionStorage.removeItem("PASS");
      sessionStorage.removeItem("logos_pass");
    }catch(e){}
  }

  function onLogin(){
    const rid = String(($("rid") && $("rid").value) || "").trim();
    const pass = String(($("pass") && $("pass").value) || "").trim();

    if (!rid || rid.length < 20) return setStatus("ERR: введи корректный RID.");
    if (!pass) return setStatus("ERR: введи пароль.");

    saveRid(rid);
    clearSessionPass();
    savePassToSession(pass);

    setStatus("OK: RID сохранён локально, пароль — только в сессии. Переход…");
    location.href = "./app.html?v=1";
  }

  function onSaved(){
    const rid = loadSavedRid();
    setStatus(rid ? "RID подставлен из браузера." : "Сохранённого RID нет.");
  }

  document.addEventListener("DOMContentLoaded", () => {
    loadSavedRid();

    const btnLogin = $("btnLogin");
    const btnSaved = $("btnSaved");
    const pass = $("pass");

    if (btnLogin) btnLogin.addEventListener("click", onLogin);
    if (btnSaved) btnSaved.addEventListener("click", onSaved);

    if (pass){
      pass.addEventListener("keydown", (e) => {
        if (e.key === "Enter") onLogin();
      });
    }
  });
})();
```

### `/opt/logos/www/wallet_prod__1111/compat.js`

- Size: 5512 bytes
- Lines: 180

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_prod__1111/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_prod__1111/modules/send.js`

- Size: 4208 bytes
- Lines: 136

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function esc(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function setStatus(msg){
    const el = $("wdStatus");
    if (el) el.textContent = msg || "";
  }

  function setRaw(obj){
    const pre = $("wdRaw");
    if (!pre) return;
    try{ pre.textContent = JSON.stringify(obj, null, 2); }
    catch(e){ pre.textContent = String(obj); }
  }

  function fillNetworkOptionsFromBalances(balJson){
    const sel = $("wdNetwork");
    if (!sel) return;

    const b = (balJson && balJson.balances) ? balJson.balances : {};
    const opts = [];

    // Withdraw у нас "USDT". Реальные сети вывода: ERC20 (ETH) и TRC20 (TRON)
    if (b.ETH)  opts.push({v:"ETH",  t:"ETH (ERC20)"});
    if (b.TRON) opts.push({v:"TRON", t:"TRON (TRC20)"});

    // fallback если вдруг API не дал balances
    if (opts.length === 0) opts.push({v:"ETH", t:"ETH (ERC20)"});

    const cur = sel.value;
    sel.innerHTML = "";
    for (const o of opts){
      const opt = document.createElement("option");
      opt.value = o.v;
      opt.textContent = o.t;
      sel.appendChild(opt);
    }
    if (cur && [...sel.options].some(x => x.value === cur)) sel.value = cur;
  }

  async function refreshNetworks(){
    try{
      const rid = readRID();
      if (!rid) return;

      const base = window.WALLET_API || "/wallet-api";
      const r = await fetch(base + "/v1/balances/" + encodeURIComponent(rid), { cache: "no-store" });
      if (!r.ok) return;
      const j = await r.json();
      fillNetworkOptionsFromBalances(j);
    }catch(e){}
  }

  function clearForm(){
    if ($("wdAmount")) $("wdAmount").value = "";
    if ($("wdTo")) $("wdTo").value = "";
    setStatus("");
    setRaw("");
  }

  async function doWithdraw(){
    const rid = readRID();
    if (!rid) return setStatus("ERR: RID не найден. Зайди через /wallet/auth.html");

    const base = window.WALLET_API || "/wallet-api";

    const net = ($("wdNetwork") && $("wdNetwork").value) ? $("wdNetwork").value : "ETH";
    const amountStr = String(($("wdAmount") && $("wdAmount").value) || "").trim();
    const to = String(($("wdTo") && $("wdTo").value) || "").trim();

    if (!amountStr) return setStatus("ERR: введи Amount (целое число).");
    if (!/^\d+$/.test(amountStr)) return setStatus("ERR: Amount должен быть целым числом (integer).");
    const amount = Number(amountStr);
    if (!Number.isFinite(amount) || amount <= 0) return setStatus("ERR: Amount должен быть > 0.");

    if (!to || to.length < 8) return setStatus("ERR: введи адрес получателя.");

    setStatus("request…");
    setRaw("");

    try{
      const body = { rid, network: net, amount, to };

      const r = await fetch(base + "/v1/withdraw", {
        method: "POST",
        headers: { "content-type":"application/json" },
        body: JSON.stringify(body),
        cache: "no-store"
      });

      const j = await r.json().catch(()=>({}));
      setRaw(j);

      if (!r.ok){
        return setStatus("ERR: HTTP " + r.status + " — " + (j && (j.error || j.message) ? (j.error || j.message) : "withdraw failed"));
      }

      setStatus("OK: отправлено (" + esc(net) + ").");
    }catch(e){
      setStatus("ERR: " + (e && e.message ? e.message : String(e)));
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    refreshNetworks();

    const btnSend = $("btnWithdraw");
    const btnClear = $("btnWithdrawClear");

    if (btnSend) btnSend.addEventListener("click", doWithdraw);
    if (btnClear) btnClear.addEventListener("click", clearForm);

    // enter = send (в поле адреса)
    const to = $("wdTo");
    if (to){
      to.addEventListener("keydown", (e) => {
        if (e.key === "Enter") doWithdraw();
      });
    }
  });
})();
```

### `/opt/logos/www/wallet_prod__1111/modules/settings.js`

- Size: 9436 bytes
- Lines: 245

```javascript
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();


// PROD hard clear session password
try{sessionStorage.removeItem("PASS");sessionStorage.removeItem("logos_pass");}catch(e){}
```

### `/opt/logos/www/wallet_prod__1111/modules/tx_redirect.js`

- Size: 2810 bytes
- Lines: 90

```javascript
/* tx_redirect.js — redirect old /transfer -> /submit_tx and normalize body to TxIn */
(() => {
  const _fetch = window.fetch.bind(window);

  function isHex(s){
    s = String(s||"").replace(/^0x/,"").trim();
    return s.length > 0 && s.length % 2 === 0 && /^[0-9a-fA-F]+$/.test(s);
  }

  function b64urlToBytes(b64url){
    try{
      let s = String(b64url||"").replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u[i] = bin.charCodeAt(i);
      return u;
    }catch(e){ return null; }
  }

  function bytesToHex(u){
    let out = "";
    for (let i=0;i<u.length;i++) out += u[i].toString(16).padStart(2,"0");
    return out;
  }

  function normalizeTx(body){
    const j = body && typeof body === "object" ? body : {};
    const from = j.from || j.rid_from || j.sender || j.rid || "";
    const to   = j.to   || j.rid_to   || j.receiver || "";
    let amount = j.amount_mic ?? j.amount_micro ?? j.amount ?? 0;
    const nonce = j.nonce ?? j.n ?? j.account_nonce;

    // если вдруг прислали amount_lgn — переводим в micro-LGN
    if (j.amount_lgn !== undefined && j.amount_lgn !== null){
      const a = Number(j.amount_lgn);
      if (isFinite(a)) amount = Math.round(a * 1e6);
    }

    // подпись: sig_hex обязательно
    let sig_hex = j.sig_hex || j.sigHex || "";
    if (!sig_hex){
      const s = j.sig || j.signature || j.sig_b64 || j.sigB64 || "";
      if (s){
        if (isHex(s)) sig_hex = String(s).replace(/^0x/,"");
        else {
          const u = b64urlToBytes(s);
          if (u) sig_hex = bytesToHex(u);
        }
      }
    }

    const memo = (j.memo === undefined ? null : j.memo);

    return { from, to, amount, nonce, memo, sig_hex };
  }

  window.fetch = async (input, init={}) => {
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url.includes("/transfer")){
        const newUrl = url.replace("/transfer", "/submit_tx");

        let bodyObj = {};
        try{ bodyObj = JSON.parse(init.body || "{}"); }catch(e){ bodyObj = {}; }

        const tx = normalizeTx(bodyObj);

        const newInit = {
          ...init,
          method: "POST",
          headers: { ...(init.headers||{}), "Content-Type":"application/json" },
          body: JSON.stringify({
            from: tx.from,
            to: tx.to,
            amount: tx.amount,
            nonce: tx.nonce,
            memo: tx.memo,
            sig_hex: tx.sig_hex
          })
        };

        return _fetch(newUrl, newInit);
      }
    }catch(e){}
    return _fetch(input, init);
  };

  console.log("[tx_redirect] installed: /transfer -> /submit_tx");
})();
```

### `/opt/logos/www/wallet_prod__1111/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_prod__1111/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_prod/api_base.js`

- Size: 180 bytes
- Lines: 7

```javascript
/* LOGOS Wallet routes (same-origin). No inline scripts. */
(function(){
  // node backend
  window.API_BASE = "/api";
  // wallet proxy
  window.WALLET_API = "/wallet-api";
})();
```

### `/opt/logos/www/wallet_prod/app.js`

- Size: 31286 bytes
- Lines: 885

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }

  function clearSessionPass(){
    try{
      sessionStorage.removeItem("PASS");
      sessionStorage.removeItem("logos_pass");
    }catch(e){}
  }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();



/* ========= SEND LGN MODULE (v2, sig_hex) ========= */
(() => {
  const NODE_API = (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");

  function q(sel, root=document){ return root.querySelector(sel); }
  function qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function utf8(s){ return new TextEncoder().encode(String(s)); }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++){
      out += u8[i].toString(16).padStart(2,"0");
    }
    return out;
  }

  function hexToU8(h){
    h = (h||"").trim().replace(/^0x/,"");
    if (!h || (h.length % 2)) return null;
    const u = new Uint8Array(h.length/2);
    for (let i=0;i<u.length;i++) u[i] = parseInt(h.substr(i*2,2),16);
    return u;
  }

  function getRID(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || "";
  }

  // пытаемся найти private Ed25519 JWK в localStorage (если ключи хранятся так)
  function findEd25519PrivJwk(){
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      const v = localStorage.getItem(k);
      if (!v || v.length < 20) continue;
      try{
        const j = JSON.parse(v);
        if (j && j.crv === "Ed25519" && j.kty && j.d && j.x) return j;
      }catch(e){}
    }
    return null;
  }

  async function importPrivKeyFromJwk(jwk){
    return crypto.subtle.importKey("jwk", jwk, {name:"Ed25519"}, false, ["sign"]);
  }

  async function signEd25519(privKey, msgU8){
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msgU8);
    return new Uint8Array(sig);
  }

  async function getNonce(rid){
    const r = await fetch(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    if(!r.ok) throw new Error(`balance http ${r.status}`);
    const j = await r.json();
    return j.nonce;
  }

  async function getCanonBytes(draft){
    // пробуем debug_canon (если включен на сервере)
    try{
      const r = await fetch(`${NODE_API}/debug_canon`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(draft)
      });
      if (r.ok){
        const t = await r.text();
        // варианты: JSON или просто строка
        try{
          const j = JSON.parse(t);
          const ch = j.canon_hex || j.canon || j.msg_hex || j.message_hex || j.bytes_hex || "";
          const u = hexToU8(ch);
          if (u) return u;
          const s = (j.canon_str || j.message || j.msg || "");
          if (s) return utf8(s);
        }catch(e){
          // если просто строка
          const u = hexToU8(t);
          if (u) return u;
          if (t && t.length) return utf8(t);
        }
      }
    }catch(e){}

    // fallback: стабильная строка (если debug_canon нет)
    const memo = (draft.memo === null || draft.memo === undefined) ? "" : String(draft.memo);
    const s = `LOGOS_TX|from=${draft.from}|to=${draft.to}|amount=${draft.amount}|nonce=${draft.nonce}|memo=${memo}`;
    return utf8(s);
  }

  function setStatus(panel, text, ok=true){
    let el = q(".sendStatus", panel);
    if(!el){
      el = document.createElement("div");
      el.className = "sendStatus";
      el.style.marginTop = "10px";
      el.style.fontSize = "13px";
      el.style.opacity = "0.95";
      panel.appendChild(el);
    }
    el.textContent = text || "";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function findSendPanel(){
    return document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('.panel[data-panel="send"]')
      || null;
  }

  function findSendControls(panel){
      const btnSend = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("send lgn"));
      const btnFillMe = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("мой rid"));

      // ВАЖНО: не по индексу, а по id (иначе withdraw inputs ломают логику)
      const toRid  = document.getElementById("lgnTo") || document.getElementById("lgmTo") || null;
      const amount = document.getElementById("lgnAmount") || document.getElementById("lgmAmount") || null;

      // memo optional
      const memo = document.getElementById("lgnMemo") || document.getElementById("lgmMemo") || null;

      return {btnSend, btnFillMe, toRid, amount, memo};
    }

  async function handleSend(panel, ui){
    const fromRid = getRID();
    const toRid = (ui.toRid?.value || "").trim();
    const memoStr = (ui.memo?.value || "").trim();
    const amtStr = (ui.amount?.value || "").trim();

    if(!fromRid){ setStatus(panel, "ERR: нет RID (ключи не найдены).", false); return; }
    if(!toRid || toRid.length < 10){ setStatus(panel, "ERR: введи RID получателя.", false); return; }

    const amt = Number(amtStr.replace(",", "."));
    if(!isFinite(amt) || amt <= 0){ setStatus(panel, "ERR: введи сумму > 0.", false); return; }

    const amount_mic = Math.round(amt * 1e6);

    setStatus(panel, "Отправляю…", true);

    let nonce;
    try{
      nonce = await getNonce(fromRid);
    }catch(e){
      setStatus(panel, "ERR: не смог получить nonce (balance).", false);
      return;
    }

    // draft по схеме TxIn (без подписи)
    const draft = {
      from: fromRid,
      to: toRid,
      amount: amount_mic,
      nonce: nonce,
      memo: memoStr ? memoStr : null
    };

    // JS не знает null, поэтому:
    if (!memoStr) draft.memo = null;

    // bytes for signing
    const canonBytes = await getCanonBytes(draft);

    // signer
    const jwk = findEd25519PrivJwk();
    if(!jwk){
      setStatus(panel, "ERR: приватный ключ не найден (localStorage). Если ключи в IndexedDB — скажи, сделаем доступ через существующий signer.", false);
      return;
    }

    let privKey;
    try{
      privKey = await importPrivKeyFromJwk(jwk);
    }catch(e){
      setStatus(panel, "ERR: не смог импортировать Ed25519 ключ.", false);
      return;
    }

    let sigU8;
    try{
      sigU8 = await signEd25519(privKey, canonBytes);
    }catch(e){
      setStatus(panel, "ERR: не смог подписать транзакцию.", false);
      return;
    }

    const txIn = {
      from: draft.from,
      to: draft.to,
      amount: draft.amount,
      nonce: draft.nonce,
      memo: draft.memo,
      sig_hex: hex(sigU8)
    };

    try{
      const r = await fetch(`${NODE_API}/submit_tx`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(txIn)
      });
      const text = await r.text();
      if(!r.ok){
        setStatus(panel, `ERR submit_tx: ${r.status} ${text}`.slice(0,500), false);
        return;
      }
      try{
        const j = JSON.parse(text);
        if (j && j.ok){
          setStatus(panel, `✅ Отправлено. txid: ${(j.txid||"")}`.trim(), true);
        } else {
          setStatus(panel, `⚠️ Ответ: ${text}`.slice(0,500), false);
        }
      }catch(e){
        setStatus(panel, `✅ Отправлено. Ответ: ${text}`.slice(0,200), true);
      }
    }catch(e){
      setStatus(panel, "ERR: сеть/submit_tx не доступен.", false);
    }
  }

  function initSend(){
    const panel = findSendPanel();
    if(!panel) return;
    const ui = findSendControls(panel);

    if(ui.btnFillMe){
      ui.btnFillMe.addEventListener("click", () => {
        const rid = getRID();
        if(ui.toRid) ui.toRid.value = rid || "";
      });
    }
    if(ui.btnSend){
      ui.btnSend.addEventListener("click", () => handleSend(panel, ui));
    }
  }

  try{ initSend(); }catch(e){}
})();

```

### `/opt/logos/www/wallet_prod/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_prod/auth.js`

- Size: 15011 bytes
- Lines: 444

```javascript
(() => {
  const LS_VAULT = "logos_vault_v1";
  const SS_SEED  = "logos_sk_seed_b64";     // sessionStorage (seed32)
  const LS_LAST  = "logos_last_rid";
  const LS_RID1  = "RID";
  const LS_RID2  = "logos_rid";

  const $ = (id) => document.getElementById(id);

function __bindClick(id, fn){
  try{
    const el = $(id);
    if (el) el.onclick = fn;
  }catch(e){}
}


/* ===== PATCH: SAVE SEED32_B64 AFTER UNLOCK ===== */
  function __u8ToB64(u8){
    try{
      let s="";
      for(let i=0;i<u8.length;i++) s+=String.fromCharCode(u8[i]);
      return btoa(s);
    }catch(e){ return ""; }
  }
  function __saveSeed32B64(seed32, src){
    try{
      if (!seed32 || seed32.length !== 32) return;
      const b64 = __u8ToB64(seed32);
      if (!b64 || b64.length < 20) return;
      try{ localStorage.setItem("seed32_b64", b64); }catch(e){}
      try{ sessionStorage.setItem("seed32_b64", b64); }catch(e){}
      console.log("[auth] saved seed32_b64 from", src);
    }catch(e){}
  }


/* ===== PATCH: KEY CAPTURE ED25519 (SAFE) =====
   Captures any Ed25519 private CryptoKey imported/generated on auth page
   and saves JWK to localStorage for LGN send in wallet page.
*/
(function(){
  const LS="ed25519_priv_jwk";
  if (!crypto || !crypto.subtle) return;

  function isEdAlg(alg){
    try{
      if (alg == "Ed25519") return true;
      if (alg && typeof alg === "object" && (alg.name === "Ed25519")) return true;
    }catch(e){}
    return false;
  }

  async function savePrivKey(key, src){
    try{
      if (!key || key.type !== "private") return;
      const jwk = await crypto.subtle.exportKey("jwk", key);
      if (jwk && jwk.kty==="OKP" && jwk.crv==="Ed25519" && jwk.d && jwk.x) {
        try{ localStorage.setItem(LS, JSON.stringify(jwk)); }catch(e){}
        try{
          window.KEYS = window.KEYS || {};
          window.KEYS.privateKey = key;
          window.KEYS.privKeyJwk = jwk;
        }catch(e){}
        console.log("[auth:keycapture] saved ed25519_priv_jwk from", src);
      }
    }catch(e){}
  }

  const origImport = crypto.subtle.importKey.bind(crypto.subtle);
  crypto.subtle.importKey = async function(format, keyData, algorithm, extractable, keyUsages){
/* ===== PATCH: SAVE ED25519 JWK FROM keyData ===== */
    try{
      const isEd = (algorithm === "Ed25519") || (algorithm && typeof algorithm === "object" && algorithm.name === "Ed25519");
      if (isEd && format === "jwk") {
        let jwk = keyData;
        try { if (typeof jwk === "string") jwk = JSON.parse(jwk); } catch(e){}
        if (jwk && jwk.kty==="OKP" && jwk.crv==="Ed25519" && jwk.d && jwk.x) {
          try { localStorage.setItem("ed25519_priv_jwk", JSON.stringify(jwk)); } catch(e){}
          try {
            window.KEYS = window.KEYS || {};
            window.KEYS.privKeyJwk = jwk;
          } catch(e){}
          console.log("[auth] saved ed25519_priv_jwk from importKey(keyData)");
        }
      }
    }catch(e){}


    const k = await origImport(format, keyData, algorithm, extractable, keyUsages);
    try{
      if (isEdAlg(algorithm) && k && k.type==="private" && (keyUsages||[]).includes("sign")) {
        savePrivKey(k, "importKey");
      }
    }catch(e){}
    return k;
  };

  const origGen = crypto.subtle.generateKey.bind(crypto.subtle);
  crypto.subtle.generateKey = async function(algorithm, extractable, keyUsages){
    const res = await origGen(algorithm, extractable, keyUsages);
    try{
      if (isEdAlg(algorithm) && res && res.privateKey && (keyUsages||[]).includes("sign")) {
        savePrivKey(res.privateKey, "generateKey");
      }
    }catch(e){}
    return res;
  };
})();
 /* ===== END PATCH ===== */

  // After unlock, key exists in memory as CryptoKey.
  // We auto-export it to localStorage so wallet page can sign LGN without DevTools.
  (function(){
    const LS="ed25519_priv_jwk";
    let tries=0;
    const t=setInterval(async ()=>{
      tries++;
      try{
        // key may be stored either in window.KEYS or in global KEYS
        const k = (window.KEYS && window.KEYS.privateKey) ||
                  ((typeof KEYS!=="undefined") && KEYS && KEYS.privateKey);
        if (!k || !crypto || !crypto.subtle || !crypto.subtle.exportKey) {
          if (tries>120) clearInterval(t);
          return;
        }

        // already saved
        const cur = localStorage.getItem(LS);
        if (cur && cur.length>20) { clearInterval(t); return; }

        const jwk = await crypto.subtle.exportKey("jwk", k);
        if (jwk && jwk.kty==="OKP" && jwk.crv==="Ed25519" && jwk.d && jwk.x) {
          try{ localStorage.setItem(LS, JSON.stringify(jwk)); }catch(e){}
          try{
            window.KEYS = window.KEYS || {};
            window.KEYS.privateKey = k;
            window.KEYS.privKeyJwk = jwk;
          }catch(e){}
          console.log("[auth] saved ed25519_priv_jwk to localStorage");
          clearInterval(t);
        }
      }catch(e){}
      if (tries>120) clearInterval(t);
    }, 250);
  })();

/* ===== PATCH: AUTH PAGE GUARD ===== */
  // If auth UI is not present on this page — do nothing (prevents onclick null errors)
  try{
    const hasAuthUI =
      document.getElementById("mnemonicSection") ||
      document.getElementById("restoreSection")  ||
      document.getElementById("unlockSection")   ||
      document.getElementById("confirmSection")  ||
      document.getElementById("setPassSection")  ||
      document.getElementById("status");
    if (!hasAuthUI) return;
  }catch(e){ return; }



  

  // --- BIP39 (local, offline): use window.bip39lite ---
  function BIP39(){
    const b = window.bip39lite;
    if(!b) throw new Error("BIP39 not loaded: check vendor/wordlist_en.js + vendor/bip39_lite.js in auth.html");
    return b;
  }
  const show = (id) => $(id).style.display = "";
  const hide = (id) => $(id).style.display = "none";
  const go = (id) => {
    ["step0","mnemonicSection","confirmSection","setPassSection","restoreSection","unlockSection"].forEach(hide);
    show(id);
  };

  function status(el, ok, msg){
    el.textContent = msg || "";
    el.className = ok ? "status ok" : "status err";
  }

  function norm(s){ return (s||"").toLowerCase().trim().replace(/\s+/g," "); }

  function u8ToB64(u8){
    let s=""; u8.forEach(b=>s+=String.fromCharCode(b));
    return btoa(s);
  }
  function b64ToU8(b64){
    const s = atob(b64);
    const u8 = new Uint8Array(s.length);
    for(let i=0;i<s.length;i++) u8[i]=s.charCodeAt(i);
    return u8;
  }

  async function sha256(u8){
    const h = await crypto.subtle.digest("SHA-256", u8);
    return new Uint8Array(h);
  }

  async function pbkdf2Key(password, saltU8){
    const base = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]);
    return crypto.subtle.deriveKey(
      {name:"PBKDF2", salt:saltU8, iterations:210000, hash:"SHA-256"},
      base,
      {name:"AES-GCM", length:256},
      false,
      ["encrypt","decrypt"]
    );
  }

  async function encryptSeed32(seed32, password){
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv   = crypto.getRandomValues(new Uint8Array(12));
    const key  = await pbkdf2Key(password, salt);
    const ctBuf = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, seed32);
    return { salt:u8ToB64(salt), iv:u8ToB64(iv), ct:u8ToB64(new Uint8Array(ctBuf)) };
  }

  async function decryptSeed32(vault, password){
    const salt = b64ToU8(vault.salt);
    const iv   = b64ToU8(vault.iv);
    const ct   = b64ToU8(vault.ct);
    const key  = await pbkdf2Key(password, salt);
    const ptBuf = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct);
    return new Uint8Array(ptBuf);
  }

  // Base58 (fallback RID derivation)
  function base58(u8){
    const A = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let x = 0n;
    for (const b of u8) x = (x<<8n) + BigInt(b);
    let out = "";
    while (x > 0n) {
      const mod = x % 58n;
      out = A[Number(mod)] + out;
      x = x / 58n;
    }
    return out || "1";
  }

  function makeRIDFromPub(pubU8){
    // если где-то есть ваш канон — используем его
    if (typeof window.ridFromPub === "function") return window.ridFromPub(pubU8);
    if (typeof window.makeRID === "function") return window.makeRID(pubU8);
    // fallback формат похожий на текущие Atx...
    return "Atx" + base58(pubU8).slice(0, 44);
  }

  function setRidSession(rid){
    rid = (rid||"").trim();
    if (!rid) return;
    localStorage.setItem(LS_RID1, rid);
    localStorage.setItem(LS_RID2, rid);
    localStorage.setItem(LS_LAST, rid);
    $("rid").value = rid;
  }

  function goWallet(){
    location.href = "./app.html#assets";
  }

  // ---------- Create flow ----------
  let mnemonic = "";
  let words = [];
  let checkIdx = [];
  let pos = 0;

  async function startCreate(){
    mnemonic = norm(await BIP39().generateMnemonic(256)); // 24 words
    words = mnemonic.split(" ");
    $("mnemonicShow").textContent = mnemonic;

    checkIdx = [3, 11, 17].map(i => Math.min(i, words.length-1));
    pos = 0;
    $("cIdx").textContent = String(checkIdx[pos] + 1);
    $("confirmWord").value = "";
    $("cStatus").textContent = "";

    go("mnemonicSection");
  }

  function startConfirm(){
    $("confirmWord").value = "";
    $("cStatus").textContent = "";
    $("cIdx").textContent = String(checkIdx[pos] + 1);
    go("confirmSection");
  }

  function doConfirmNext(){
    const w = norm($("confirmWord").value);
    const idx = checkIdx[pos];
    if (w !== words[idx]) {
      status($("cStatus"), false, "Неверно. Проверь слово.");
      return;
    }
    pos++;
    if (pos >= checkIdx.length) {
      go("setPassSection");
      return;
    }
    status($("cStatus"), true, "OK");
    $("confirmWord").value = "";
    $("cIdx").textContent = String(checkIdx[pos] + 1);
  }

  async function finishCreate(){
    const p1 = $("p1").value || "";
    const p2 = $("p2").value || "";
    if (p1.length < 6) return status($("pStatus"), false, "Пароль минимум 6 символов");
    if (p1 !== p2) return status($("pStatus"), false, "Пароли не совпадают");

    status($("pStatus"), true, "Создаю…");

    const seedBuf = await BIP39().mnemonicToSeed32(mnemonic, "");
    const seedU8  = new Uint8Array(seedBuf);

    const seed32 = await sha256(seedU8);                 
      __saveSeed32B64(seed32, 'create');
// 32 bytes
    const kp = nacl.sign.keyPair.fromSeed(seed32);
    const rid = makeRIDFromPub(kp.publicKey);

    const enc = await encryptSeed32(seed32, p1);

    const vault = {
      ver: 1,
      rid,
      pub: u8ToB64(kp.publicKey),
      ...enc,
      created_at: new Date().toISOString()
    };
    localStorage.setItem(LS_VAULT, JSON.stringify(vault));

    sessionStorage.setItem(SS_SEED, u8ToB64(seed32));
    setRidSession(rid);

    goWallet();
  }

  // ---------- Restore flow ----------
  async function doRestore(){
    const m = norm($("restoreMnemonic").value);
    const pass = $("restorePass").value || "";
    if (!await BIP39().validateMnemonic(m)) return status($("rStatus"), false, "Фраза некорректная (проверь слова/пробелы)");
    if (pass.length < 6) return status($("rStatus"), false, "Пароль минимум 6 символов");

    status($("rStatus"), true, "Восстанавливаю…");

    const seedBuf = await BIP39().mnemonicToSeed32(m, "");
    const seedU8  = new Uint8Array(seedBuf);
    const seed32  = await sha256(seedU8);

      __saveSeed32B64(seed32, 'restore');

    const kp = nacl.sign.keyPair.fromSeed(seed32);
    const rid = makeRIDFromPub(kp.publicKey);

    const enc = await encryptSeed32(seed32, pass);
    const vault = {
      ver: 1,
      rid,
      pub: u8ToB64(kp.publicKey),
      ...enc,
      created_at: new Date().toISOString()
    };
    localStorage.setItem(LS_VAULT, JSON.stringify(vault));

    sessionStorage.setItem(SS_SEED, u8ToB64(seed32));
    setRidSession(rid);

    goWallet();
  }

  // ---------- Unlock flow ----------
  async function doUnlock(){
    let v = null;
    try { v = JSON.parse(localStorage.getItem(LS_VAULT) || "null"); } catch(_){}
    if (!v || !v.ct) return status($("uStatus"), false, "Vault не найден");
    const pass = $("unlockPass").value || "";
    if (pass.length < 6) return status($("uStatus"), false, "Пароль минимум 6 символов");

    status($("uStatus"), true, "Unlock…");
    try{
      const seed32 = await decryptSeed32(v, pass);
      __saveSeed32B64(seed32, 'unlock');
      sessionStorage.setItem(SS_SEED, u8ToB64(seed32));
      setRidSession(v.rid || "");
      goWallet();
    } catch(e){
      status($("uStatus"), false, "Неверный пароль или vault повреждён");
    }
  }

  // ---------- Legacy RID login ----------
  function legacyLogin(){
    const rid = ($("rid").value || "").trim();
    if (!rid) return status($("status"), false, "Введите RID");
    setRidSession(rid);
    status($("status"), true, "OK");
    goWallet();
  }

  function showSavedRid(){
    const rid = (localStorage.getItem(LS_RID2) || localStorage.getItem(LS_RID1) || localStorage.getItem(LS_LAST) || "").trim();
    if (!rid) return status($("status"), false, "RID не найден в браузере");
    $("rid").value = rid;
    status($("status"), true, "RID подставлен из браузера");
  }

  // init
  document.addEventListener("DOMContentLoaded", () => {
    // если vault есть — показываем Unlock кнопку
    try{
      const v = JSON.parse(localStorage.getItem(LS_VAULT) || "null");
      if (v && v.ct) $("btnUnlock").style.display = "";
    }catch(_){}

    __bindClick("btnCreate", startCreate);
    __bindClick("btnRestore", () => go("restoreSection"));
    __bindClick("btnUnlock", () => go("unlockSection"));

    __bindClick("btnRecorded", startConfirm);
    __bindClick("btnConfirmNext", doConfirmNext);
    __bindClick("btnFinishCreate", () => finishCreate().catch(e => status($("pStatus"), false, "ERR: " + (e.message||String(e)))));

    __bindClick("btnDoRestore", () => doRestore().catch(e => status($("rStatus"), false, "ERR: " + (e.message||String(e)))));
    __bindClick("btnDoUnlock", () => doUnlock().catch(e => status($("uStatus"), false, "ERR: " + (e.message||String(e)))));

    __bindClick("btnBack0", () => go("step0"));
    __bindClick("btnBack1", () => go("mnemonicSection"));
    __bindClick("btnBack2", () => go("confirmSection"));
    __bindClick("btnBackR", () => go("step0"));
    __bindClick("btnBackU", () => go("step0"));

    __bindClick("btnLogin", legacyLogin);
    __bindClick("btnShowRid", showSavedRid);

    // автоподстановка RID
    const rid = (localStorage.getItem(LS_RID2) || localStorage.getItem(LS_RID1) || localStorage.getItem(LS_LAST) || "").trim();
    if (rid) $("rid").value = rid;
  });
})();
```

### `/opt/logos/www/wallet_prod/compat.js`

- Size: 6115 bytes
- Lines: 200

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

    /* ===== PATCH: KEYS/RID from window ===== */
    function getRID(){
      try { if (window.RID) return window.RID; } catch(e){}
      try { if (typeof RID !== "undefined") return RID; } catch(e){}
      return "";
    }
    function getKEYS(){
      try { if (window.KEYS) return window.KEYS; } catch(e){}
      try { if (typeof KEYS !== "undefined") return KEYS; } catch(e){}
      return null;
    }
    /* ===== END PATCH ===== */


  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      const K = getKEYS();
        if (!K || !K.privateKey) throw new Error("кошелёк заблокирован (нет ключа)");
        return await signCanon(K.privateKey, canonHex);
    }

    const K = getKEYS();

      if (!K || !K.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", K.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        const RIDV = getRID();
          if (!RIDV) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        const KK = getKEYS();
          if (!KK || !KK.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RIDV);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RIDV, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RIDV,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_prod/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_prod/modules/bridge_withdraw.js`

- Size: 2813 bytes
- Lines: 91

```javascript
(() => {
  const $ = (id) => document.getElementById(id);

  function ridGet(){
    try{
      return (
        localStorage.getItem("RID") ||
        localStorage.getItem("logos_rid") ||
        sessionStorage.getItem("RID") ||
        sessionStorage.getItem("logos_rid") ||
        ""
      ).trim();
    }catch(e){ return ""; }
  }

  function uuid(){
    const b = new Uint8Array(16);
    crypto.getRandomValues(b);
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  function setText(id, msg){
    const el = $(id);
    if (el) el.textContent = msg || "";
  }
  function setRaw(obj){
    const pre = $("wdRaw");
    if (!pre) return;
    try{ pre.textContent = JSON.stringify(obj, null, 2); }
    catch(e){ pre.textContent = String(obj); }
  }

  async function doWithdraw(){
    const rid = ridGet();
    if (!rid) return setText("wdStatus", "ERR: RID не найден (сделай Unlock на стартовой).");

    const base = (window.WALLET_API || "/wallet-api").replace(/\/+$/,"");
    const net = ($("wdNetwork") && $("wdNetwork").value) ? String($("wdNetwork").value) : "ETH";
    const amountStr = String(($("wdAmount") && $("wdAmount").value) || "").trim();
    const to = String(($("wdTo") && $("wdTo").value) || "").trim();

    if (!/^\d+$/.test(amountStr)) return setText("wdStatus", "ERR: Amount должен быть integer (например 100).");
    if (to.length < 8) return setText("wdStatus", "ERR: Введи to address.");

    setText("wdStatus", "sending…");
    setRaw("");

    const body = {
      rid,
      token: "USDT",
      network: net,
      amount: amountStr,
      to_address: to,
      request_id: uuid()
    };

    try{
      const r = await fetch(base + "/v1/withdraw", {
        method: "POST",
        headers: {"content-type":"application/json"},
        body: JSON.stringify(body),
        cache: "no-store"
      });
      const j = await r.json().catch(()=>({}));
      setRaw(j);

      if (!r.ok){
        return setText("wdStatus", "ERR: HTTP " + r.status + " " + (j.detail || j.error || j.message || "withdraw failed"));
      }
      setText("wdStatus", "OK: txid=" + (j.txid || ""));
    }catch(e){
      setText("wdStatus", "ERR: " + (e && e.message ? e.message : String(e)));
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    const btn = $("btnWithdraw");
    if (!btn) return;

    // capture=true — убиваем старые хендлеры
    btn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      doWithdraw();
    }, true);
  });
})();
```

### `/opt/logos/www/wallet_prod/modules/lgn_send.js`

- Size: 5884 bytes
- Lines: 176

```javascript
/* LOGOS Wallet - LGN send (RID -> PUB without base58 coding)
   Build: FIX_B58LESS_20260121
*/
(() => {
  window.__LGN_SEND_BUILD = "FIX_B58LESS_20260121";
  console.log("[lgn_send] build", window.__LGN_SEND_BUILD);

  function byId(id){ return document.getElementById(id); }
  function setText(el, txt){ if (el) el.textContent = txt || ""; }

  function setStatus(ok, msg){
    const el = byId("lgnStatus") || byId("statusLGN") || byId("status");
    if (!el) return;
    el.classList.toggle("ok", !!ok);
    el.classList.toggle("err", !ok);
    setText(el, msg);
  }

  function setRaw(obj){
    const pre = byId("lgnRaw") || byId("rawLGN") || byId("raw");
    if (!pre) return;
    try{ pre.textContent = (typeof obj === "string") ? obj : JSON.stringify(obj, null, 2); }
    catch(e){ pre.textContent = String(obj); }
  }

  // always absolute /node-api
  const NODE_API = (location.origin + "/node-api").replace(/\/+$/,"");
  console.log("[lgn_send] NODE_API", NODE_API);

  async function getJSON(url){
    const r = await fetch(url, { credentials: "omit" });
    if (!r.ok) throw new Error(`HTTP ${r.status} for ${url}`);
    return await r.json();
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: { "content-type":"application/json" },
      body: JSON.stringify(body),
      credentials: "omit"
    });
    const txt = await r.text();
    let js = null;
    try{ js = txt ? JSON.parse(txt) : null; }catch(_){}
    if (!r.ok) throw new Error(js?.info || txt || `HTTP ${r.status}`);
    return js;
  }

  function u64be(x){
    let v = (typeof x === "bigint") ? x : BigInt(x);
    if (v < 0n) throw new Error("u64be negative");
    const out = new Uint8Array(8);
    for (let i=7;i>=0;i--){ out[i] = Number(v & 255n); v >>= 8n; }
    return out;
  }

  async function canonicalMsgHash(from, to, amount_u64, nonce_u64){
    const enc = new TextEncoder();
    const parts = [
      enc.encode(from), enc.encode("|"),
      enc.encode(to),   enc.encode("|"),
      u64be(amount_u64), enc.encode("|"),
      u64be(nonce_u64),
    ];
    let n=0; for (const p of parts) n += p.length;
    const buf = new Uint8Array(n);
    let off=0;
    for (const p of parts){ buf.set(p, off); off += p.length; }
    const dig = await crypto.subtle.digest("SHA-256", buf);
    return new Uint8Array(dig);
  }

  function b64ToU8(b64){
    const bin = atob(b64);
    const u8 = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
    return u8;
  }

  function getSeed32(){
    const v1 = sessionStorage.getItem("logos_sk_seed_b64");
    if (v1) {
      const u = b64ToU8(v1);
      if (u.length === 32) return u;
    }
    const v2 = sessionStorage.getItem("seed32_b64") || localStorage.getItem("seed32_b64");
    if (v2) {
      const u = b64ToU8(v2);
      if (u.length === 32) return u;
    }
    return null;
  }

  function ridToPub(rid){
    rid = String(rid || "").trim();
    if (!rid.startsWith("Atx") || rid.length <= 3) throw new Error("bad RID (expected Atx...)");
    return rid.slice(3);
  }

  function wipeOldListeners(button){
    const clone = button.cloneNode(true);
    button.parentNode.replaceChild(clone, button);
    return clone;
  }

  async function sendLGN(){
    try{
      setStatus(true, "");
      setRaw("");

      const toRID = (byId("lgnTo")?.value || "").trim();
      const amountStr = (byId("lgnAmount")?.value || "").trim().replace(",", ".");
      if (!toRID) throw new Error("Введите To RID");
      if (!amountStr) throw new Error("Введите Amount");

      const amountNum = Number(amountStr);
      if (!Number.isFinite(amountNum) || amountNum <= 0) throw new Error("Amount некорректный");

      const seed = getSeed32();
      if (!seed) throw new Error("Seed не найден в сессии. Сделай Restore/Unlock.");
      if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error("nacl не загружен");

      const uiRID = (byId("rid")?.value || byId("topRid")?.textContent || "").trim();
      if (!uiRID) throw new Error("RID не найден в UI (открой вкладку Identity/Активы и обнови).");

      const fromRID = uiRID;
      const fromPUB = ridToPub(fromRID);
      const toPUB   = ridToPub(toRID);

      // nonce by RID (ledger key)
      const bal = await getJSON(`${NODE_API}/balance/${encodeURIComponent(fromRID)}`);
      const nonce = Number(bal?.nonce || 0) + 1;

      const kp = nacl.sign.keyPair.fromSeed(seed);

      const amt = BigInt(Math.floor(amountNum));
      const msg = await canonicalMsgHash(fromPUB, toPUB, amt, BigInt(nonce));
      const sig = nacl.sign.detached(msg, kp.secretKey);
      const sig_hex = Array.from(sig).map(b=>b.toString(16).padStart(2,"0")).join("");

      const body = { from: fromPUB, to: toPUB, amount: Number(amt), nonce, memo: null, sig_hex };

      setRaw({
        build: window.__LGN_SEND_BUILD,
        NODE_API,
        uiRID,
        fromRID,
        fromPUB,
        toRID,
        toPUB,
        nonce,
        body
      });

      const res = await postJSON(`${NODE_API}/submit_tx`, body);
      setStatus(true, `OK: accepted txid=${res?.txid || "-"}`);
      setRaw({ ...JSON.parse((byId("lgnRaw")?.textContent || "{}") || "{}"), result: res });

    }catch(e){
      setStatus(false, `ERR: ${e.message || e}`);
      console.error(e);
    }
  }

  function bind(){
    const btn0 = byId("btnLgnSend") || [...document.querySelectorAll("button")].find(b => /send\s*lgn/i.test(b.textContent||""));
    if (!btn0) return console.warn("[lgn_send] button not found");
    const btn = wipeOldListeners(btn0);
    btn.addEventListener("click", sendLGN);
    console.log("[lgn_send] bound");
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", bind);
  else bind();
})();
```

### `/opt/logos/www/wallet_prod/modules/logout_fix.js`

- Size: 895 bytes
- Lines: 40

```javascript
(() => {
  "use strict";
  const KEYS = [
    "logos_sk_seed_b64",
    "seed32_b64",
    "seed32_hex",
    "seed32",
    "mnemonic",
    "mnemonic_enc",
    "wallet_seed",
    "wallet_mnemonic",
    "rid",
    "logos_rid",
    "wallet_rid",
    "wallet_pass",
    "pass_hash"
  ];

  function clearAll(){
    for (const k of KEYS){
      try { sessionStorage.removeItem(k); } catch(e){}
      try { localStorage.removeItem(k); } catch(e){}
    }
  }

  function bind(){
    const btn = document.getElementById("btnLogout");
    if (!btn) return;
    btn.addEventListener("click", () => {
      clearAll();
      console.log("[logout_fix] storage cleared");
    }, true); // capture: срабатывает раньше старых обработчиков
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", bind);
  } else {
    bind();
  }
})();
```

### `/opt/logos/www/wallet_prod/modules/send.js`

- Size: 4208 bytes
- Lines: 136

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function esc(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function setStatus(msg){
    const el = $("wdStatus");
    if (el) el.textContent = msg || "";
  }

  function setRaw(obj){
    const pre = $("wdRaw");
    if (!pre) return;
    try{ pre.textContent = JSON.stringify(obj, null, 2); }
    catch(e){ pre.textContent = String(obj); }
  }

  function fillNetworkOptionsFromBalances(balJson){
    const sel = $("wdNetwork");
    if (!sel) return;

    const b = (balJson && balJson.balances) ? balJson.balances : {};
    const opts = [];

    // Withdraw у нас "USDT". Реальные сети вывода: ERC20 (ETH) и TRC20 (TRON)
    if (b.ETH)  opts.push({v:"ETH",  t:"ETH (ERC20)"});
    if (b.TRON) opts.push({v:"TRON", t:"TRON (TRC20)"});

    // fallback если вдруг API не дал balances
    if (opts.length === 0) opts.push({v:"ETH", t:"ETH (ERC20)"});

    const cur = sel.value;
    sel.innerHTML = "";
    for (const o of opts){
      const opt = document.createElement("option");
      opt.value = o.v;
      opt.textContent = o.t;
      sel.appendChild(opt);
    }
    if (cur && [...sel.options].some(x => x.value === cur)) sel.value = cur;
  }

  async function refreshNetworks(){
    try{
      const rid = readRID();
      if (!rid) return;

      const base = window.WALLET_API || "/wallet-api";
      const r = await fetch(base + "/v1/balances/" + encodeURIComponent(rid), { cache: "no-store" });
      if (!r.ok) return;
      const j = await r.json();
      fillNetworkOptionsFromBalances(j);
    }catch(e){}
  }

  function clearForm(){
    if ($("wdAmount")) $("wdAmount").value = "";
    if ($("wdTo")) $("wdTo").value = "";
    setStatus("");
    setRaw("");
  }

  async function doWithdraw(){
    const rid = readRID();
    if (!rid) return setStatus("ERR: RID не найден. Зайди через /wallet/auth.html");

    const base = window.WALLET_API || "/wallet-api";

    const net = ($("wdNetwork") && $("wdNetwork").value) ? $("wdNetwork").value : "ETH";
    const amountStr = String(($("wdAmount") && $("wdAmount").value) || "").trim();
    const to = String(($("wdTo") && $("wdTo").value) || "").trim();

    if (!amountStr) return setStatus("ERR: введи Amount (целое число).");
    if (!/^\d+$/.test(amountStr)) return setStatus("ERR: Amount должен быть целым числом (integer).");
    const amount = Number(amountStr);
    if (!Number.isFinite(amount) || amount <= 0) return setStatus("ERR: Amount должен быть > 0.");

    if (!to || to.length < 8) return setStatus("ERR: введи адрес получателя.");

    setStatus("request…");
    setRaw("");

    try{
      const body = { rid, network: net, amount, to };

      const r = await fetch(base + "/v1/withdraw", {
        method: "POST",
        headers: { "content-type":"application/json" },
        body: JSON.stringify(body),
        cache: "no-store"
      });

      const j = await r.json().catch(()=>({}));
      setRaw(j);

      if (!r.ok){
        return setStatus("ERR: HTTP " + r.status + " — " + (j && (j.error || j.message) ? (j.error || j.message) : "withdraw failed"));
      }

      setStatus("OK: отправлено (" + esc(net) + ").");
    }catch(e){
      setStatus("ERR: " + (e && e.message ? e.message : String(e)));
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    refreshNetworks();

    const btnSend = $("btnWithdraw");
    const btnClear = $("btnWithdrawClear");

    if (btnSend) btnSend.addEventListener("click", doWithdraw);
    if (btnClear) btnClear.addEventListener("click", clearForm);

    // enter = send (в поле адреса)
    const to = $("wdTo");
    if (to){
      to.addEventListener("keydown", (e) => {
        if (e.key === "Enter") doWithdraw();
      });
    }
  });
})();
```

### `/opt/logos/www/wallet_prod/modules/settings.js`

- Size: 9436 bytes
- Lines: 245

```javascript
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();


// PROD hard clear session password
try{sessionStorage.removeItem("PASS");sessionStorage.removeItem("logos_pass");}catch(e){}
```

### `/opt/logos/www/wallet_prod/modules/tx_redirect.js`

- Size: 2810 bytes
- Lines: 90

```javascript
/* tx_redirect.js — redirect old /transfer -> /submit_tx and normalize body to TxIn */
(() => {
  const _fetch = window.fetch.bind(window);

  function isHex(s){
    s = String(s||"").replace(/^0x/,"").trim();
    return s.length > 0 && s.length % 2 === 0 && /^[0-9a-fA-F]+$/.test(s);
  }

  function b64urlToBytes(b64url){
    try{
      let s = String(b64url||"").replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u[i] = bin.charCodeAt(i);
      return u;
    }catch(e){ return null; }
  }

  function bytesToHex(u){
    let out = "";
    for (let i=0;i<u.length;i++) out += u[i].toString(16).padStart(2,"0");
    return out;
  }

  function normalizeTx(body){
    const j = body && typeof body === "object" ? body : {};
    const from = j.from || j.rid_from || j.sender || j.rid || "";
    const to   = j.to   || j.rid_to   || j.receiver || "";
    let amount = j.amount_mic ?? j.amount_micro ?? j.amount ?? 0;
    const nonce = j.nonce ?? j.n ?? j.account_nonce;

    // если вдруг прислали amount_lgn — переводим в micro-LGN
    if (j.amount_lgn !== undefined && j.amount_lgn !== null){
      const a = Number(j.amount_lgn);
      if (isFinite(a)) amount = Math.round(a * 1e6);
    }

    // подпись: sig_hex обязательно
    let sig_hex = j.sig_hex || j.sigHex || "";
    if (!sig_hex){
      const s = j.sig || j.signature || j.sig_b64 || j.sigB64 || "";
      if (s){
        if (isHex(s)) sig_hex = String(s).replace(/^0x/,"");
        else {
          const u = b64urlToBytes(s);
          if (u) sig_hex = bytesToHex(u);
        }
      }
    }

    const memo = (j.memo === undefined ? null : j.memo);

    return { from, to, amount, nonce, memo, sig_hex };
  }

  window.fetch = async (input, init={}) => {
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url.includes("/transfer")){
        const newUrl = url.replace("/transfer", "/submit_tx");

        let bodyObj = {};
        try{ bodyObj = JSON.parse(init.body || "{}"); }catch(e){ bodyObj = {}; }

        const tx = normalizeTx(bodyObj);

        const newInit = {
          ...init,
          method: "POST",
          headers: { ...(init.headers||{}), "Content-Type":"application/json" },
          body: JSON.stringify({
            from: tx.from,
            to: tx.to,
            amount: tx.amount,
            nonce: tx.nonce,
            memo: tx.memo,
            sig_hex: tx.sig_hex
          })
        };

        return _fetch(newUrl, newInit);
      }
    }catch(e){}
    return _fetch(input, init);
  };

  console.log("[tx_redirect] installed: /transfer -> /submit_tx");
})();
```

### `/opt/logos/www/wallet_prod/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_prod/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/api_base.js`

- Size: 180 bytes
- Lines: 7

```javascript
/* LOGOS Wallet routes (same-origin). No inline scripts. */
(function(){
  // node backend
  window.API_BASE = "/api";
  // wallet proxy
  window.WALLET_API = "/wallet-api";
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/app.js`

- Size: 31286 bytes
- Lines: 885

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }

  function clearSessionPass(){
    try{
      sessionStorage.removeItem("PASS");
      sessionStorage.removeItem("logos_pass");
    }catch(e){}
  }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();



/* ========= SEND LGN MODULE (v2, sig_hex) ========= */
(() => {
  const NODE_API = (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");

  function q(sel, root=document){ return root.querySelector(sel); }
  function qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function utf8(s){ return new TextEncoder().encode(String(s)); }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++){
      out += u8[i].toString(16).padStart(2,"0");
    }
    return out;
  }

  function hexToU8(h){
    h = (h||"").trim().replace(/^0x/,"");
    if (!h || (h.length % 2)) return null;
    const u = new Uint8Array(h.length/2);
    for (let i=0;i<u.length;i++) u[i] = parseInt(h.substr(i*2,2),16);
    return u;
  }

  function getRID(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || "";
  }

  // пытаемся найти private Ed25519 JWK в localStorage (если ключи хранятся так)
  function findEd25519PrivJwk(){
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      const v = localStorage.getItem(k);
      if (!v || v.length < 20) continue;
      try{
        const j = JSON.parse(v);
        if (j && j.crv === "Ed25519" && j.kty && j.d && j.x) return j;
      }catch(e){}
    }
    return null;
  }

  async function importPrivKeyFromJwk(jwk){
    return crypto.subtle.importKey("jwk", jwk, {name:"Ed25519"}, false, ["sign"]);
  }

  async function signEd25519(privKey, msgU8){
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msgU8);
    return new Uint8Array(sig);
  }

  async function getNonce(rid){
    const r = await fetch(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    if(!r.ok) throw new Error(`balance http ${r.status}`);
    const j = await r.json();
    return j.nonce;
  }

  async function getCanonBytes(draft){
    // пробуем debug_canon (если включен на сервере)
    try{
      const r = await fetch(`${NODE_API}/debug_canon`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(draft)
      });
      if (r.ok){
        const t = await r.text();
        // варианты: JSON или просто строка
        try{
          const j = JSON.parse(t);
          const ch = j.canon_hex || j.canon || j.msg_hex || j.message_hex || j.bytes_hex || "";
          const u = hexToU8(ch);
          if (u) return u;
          const s = (j.canon_str || j.message || j.msg || "");
          if (s) return utf8(s);
        }catch(e){
          // если просто строка
          const u = hexToU8(t);
          if (u) return u;
          if (t && t.length) return utf8(t);
        }
      }
    }catch(e){}

    // fallback: стабильная строка (если debug_canon нет)
    const memo = (draft.memo === null || draft.memo === undefined) ? "" : String(draft.memo);
    const s = `LOGOS_TX|from=${draft.from}|to=${draft.to}|amount=${draft.amount}|nonce=${draft.nonce}|memo=${memo}`;
    return utf8(s);
  }

  function setStatus(panel, text, ok=true){
    let el = q(".sendStatus", panel);
    if(!el){
      el = document.createElement("div");
      el.className = "sendStatus";
      el.style.marginTop = "10px";
      el.style.fontSize = "13px";
      el.style.opacity = "0.95";
      panel.appendChild(el);
    }
    el.textContent = text || "";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function findSendPanel(){
    return document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('.panel[data-panel="send"]')
      || null;
  }

  function findSendControls(panel){
      const btnSend = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("send lgn"));
      const btnFillMe = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("мой rid"));

      // ВАЖНО: не по индексу, а по id (иначе withdraw inputs ломают логику)
      const toRid  = document.getElementById("lgnTo") || document.getElementById("lgmTo") || null;
      const amount = document.getElementById("lgnAmount") || document.getElementById("lgmAmount") || null;

      // memo optional
      const memo = document.getElementById("lgnMemo") || document.getElementById("lgmMemo") || null;

      return {btnSend, btnFillMe, toRid, amount, memo};
    }

  async function handleSend(panel, ui){
    const fromRid = getRID();
    const toRid = (ui.toRid?.value || "").trim();
    const memoStr = (ui.memo?.value || "").trim();
    const amtStr = (ui.amount?.value || "").trim();

    if(!fromRid){ setStatus(panel, "ERR: нет RID (ключи не найдены).", false); return; }
    if(!toRid || toRid.length < 10){ setStatus(panel, "ERR: введи RID получателя.", false); return; }

    const amt = Number(amtStr.replace(",", "."));
    if(!isFinite(amt) || amt <= 0){ setStatus(panel, "ERR: введи сумму > 0.", false); return; }

    const amount_mic = Math.round(amt * 1e6);

    setStatus(panel, "Отправляю…", true);

    let nonce;
    try{
      nonce = await getNonce(fromRid);
    }catch(e){
      setStatus(panel, "ERR: не смог получить nonce (balance).", false);
      return;
    }

    // draft по схеме TxIn (без подписи)
    const draft = {
      from: fromRid,
      to: toRid,
      amount: amount_mic,
      nonce: nonce,
      memo: memoStr ? memoStr : None
    };

    // JS не знает None, поэтому:
    if (!memoStr) draft.memo = null;

    // bytes for signing
    const canonBytes = await getCanonBytes(draft);

    // signer
    const jwk = findEd25519PrivJwk();
    if(!jwk){
      setStatus(panel, "ERR: приватный ключ не найден (localStorage). Если ключи в IndexedDB — скажи, сделаем доступ через существующий signer.", false);
      return;
    }

    let privKey;
    try{
      privKey = await importPrivKeyFromJwk(jwk);
    }catch(e){
      setStatus(panel, "ERR: не смог импортировать Ed25519 ключ.", false);
      return;
    }

    let sigU8;
    try{
      sigU8 = await signEd25519(privKey, canonBytes);
    }catch(e){
      setStatus(panel, "ERR: не смог подписать транзакцию.", false);
      return;
    }

    const txIn = {
      from: draft.from,
      to: draft.to,
      amount: draft.amount,
      nonce: draft.nonce,
      memo: draft.memo,
      sig_hex: hex(sigU8)
    };

    try{
      const r = await fetch(`${NODE_API}/submit_tx`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(txIn)
      });
      const text = await r.text();
      if(!r.ok){
        setStatus(panel, `ERR submit_tx: ${r.status} ${text}`.slice(0,500), false);
        return;
      }
      try{
        const j = JSON.parse(text);
        if (j && j.ok){
          setStatus(panel, `✅ Отправлено. txid: ${(j.txid||"")}`.trim(), true);
        } else {
          setStatus(panel, `⚠️ Ответ: ${text}`.slice(0,500), false);
        }
      }catch(e){
        setStatus(panel, `✅ Отправлено. Ответ: ${text}`.slice(0,200), true);
      }
    }catch(e){
      setStatus(panel, "ERR: сеть/submit_tx не доступен.", false);
    }
  }

  function initSend(){
    const panel = findSendPanel();
    if(!panel) return;
    const ui = findSendControls(panel);

    if(ui.btnFillMe){
      ui.btnFillMe.addEventListener("click", () => {
        const rid = getRID();
        if(ui.toRid) ui.toRid.value = rid || "";
      });
    }
    if(ui.btnSend){
      ui.btnSend.addEventListener("click", () => handleSend(panel, ui));
    }
  }

  try{ initSend(); }catch(e){}
})();

```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/assets.js`

- Size: 7861 bytes
- Lines: 247

```javascript
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/auth.js`

- Size: 11107 bytes
- Lines: 332

```javascript
(() => {
  const LS_VAULT = "logos_vault_v1";
  const SS_SEED  = "logos_sk_seed_b64";     // sessionStorage (seed32)
  const LS_LAST  = "logos_last_rid";
  const LS_RID1  = "RID";
  const LS_RID2  = "logos_rid";

  const $ = (id) => document.getElementById(id);

  

  // --- BIP39 (local, offline): use window.bip39lite ---
  function BIP39(){
    const b = window.bip39lite;
    if(!b) throw new Error("BIP39 not loaded: check vendor/wordlist_en.js + vendor/bip39_lite.js in auth.html");
    return b;
  }
  const show = (id) => $(id).style.display = "";
  const hide = (id) => $(id).style.display = "none";
  const go = (id) => {
    ["step0","mnemonicSection","confirmSection","setPassSection","restoreSection","unlockSection"].forEach(hide);
    show(id);
  };

  function status(el, ok, msg){
    el.textContent = msg || "";
    el.className = ok ? "status ok" : "status err";
  }

  function norm(s){ return (s||"").toLowerCase().trim().replace(/\s+/g," "); }

  function u8ToB64(u8){
    let s=""; u8.forEach(b=>s+=String.fromCharCode(b));
    return btoa(s);
  }
  function b64ToU8(b64){
    const s = atob(b64);
    const u8 = new Uint8Array(s.length);
    for(let i=0;i<s.length;i++) u8[i]=s.charCodeAt(i);
    return u8;
  }

  async function sha256(u8){
    const h = await crypto.subtle.digest("SHA-256", u8);
    return new Uint8Array(h);
  }

  async function pbkdf2Key(password, saltU8){
    const base = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]);
    return crypto.subtle.deriveKey(
      {name:"PBKDF2", salt:saltU8, iterations:210000, hash:"SHA-256"},
      base,
      {name:"AES-GCM", length:256},
      false,
      ["encrypt","decrypt"]
    );
  }

  async function encryptSeed32(seed32, password){
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv   = crypto.getRandomValues(new Uint8Array(12));
    const key  = await pbkdf2Key(password, salt);
    const ctBuf = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, seed32);
    return { salt:u8ToB64(salt), iv:u8ToB64(iv), ct:u8ToB64(new Uint8Array(ctBuf)) };
  }

  async function decryptSeed32(vault, password){
    const salt = b64ToU8(vault.salt);
    const iv   = b64ToU8(vault.iv);
    const ct   = b64ToU8(vault.ct);
    const key  = await pbkdf2Key(password, salt);
    const ptBuf = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct);
    return new Uint8Array(ptBuf);
  }

  // Base58 (fallback RID derivation)
  function base58(u8){
    const A = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let x = 0n;
    for (const b of u8) x = (x<<8n) + BigInt(b);
    let out = "";
    while (x > 0n) {
      const mod = x % 58n;
      out = A[Number(mod)] + out;
      x = x / 58n;
    }
    return out || "1";
  }

  function makeRIDFromPub(pubU8){
    // если где-то есть ваш канон — используем его
    if (typeof window.ridFromPub === "function") return window.ridFromPub(pubU8);
    if (typeof window.makeRID === "function") return window.makeRID(pubU8);
    // fallback формат похожий на текущие Atx...
    return "Atx" + base58(pubU8).slice(0, 44);
  }

  function setRidSession(rid){
    rid = (rid||"").trim();
    if (!rid) return;
    localStorage.setItem(LS_RID1, rid);
    localStorage.setItem(LS_RID2, rid);
    localStorage.setItem(LS_LAST, rid);
    $("rid").value = rid;
  }

  function goWallet(){
    location.href = "./app.html#assets";
  }

  // ---------- Create flow ----------
  let mnemonic = "";

  // --- Premium seed renderer (chips + copy/hide) ---
  function renderSeed(wordsArr){
    const el = $("mnemonicShow");
    if(!el) return;
    el.innerHTML = wordsArr.map((w,i)=>(
      `<div class="seedWord"><div class="seedNum">${i+1}</div><div class="seedText">${w}</div></div>`
    )).join("");
    // default visible
    el.classList.remove("isHidden");
    const b = $("btnSeedHide");
    if (b) b.textContent = "Скрыть";
  }

  function bindSeedActions(){
    const btnCopy = $("btnSeedCopy");
    if (btnCopy && !btnCopy.__bound){
      btnCopy.__bound = true;
      btnCopy.addEventListener("click", async ()=>{
        try{
          if(!mnemonic) return;
          await navigator.clipboard.writeText(mnemonic);
          btnCopy.textContent = "Скопировано";
          setTimeout(()=>btnCopy.textContent="Copy", 900);
        }catch(e){
          console.warn("copy failed", e);
          btnCopy.textContent = "Не удалось";
          setTimeout(()=>btnCopy.textContent="Copy", 900);
        }
      });
    }

    const btnHide = $("btnSeedHide");
    if (btnHide && !btnHide.__bound){
      btnHide.__bound = true;
      btnHide.addEventListener("click", ()=>{
        const el = $("mnemonicShow");
        if(!el) return;
        const on = !el.classList.contains("isHidden");
        el.classList.toggle("isHidden", on);
        btnHide.textContent = on ? "Показать" : "Скрыть";
      });
    }
  }


  let words = [];
  let checkIdx = [];
  let pos = 0;

  async function startCreate(){
    mnemonic = norm(await BIP39().generateMnemonic(256)); // 24 words
    words = mnemonic.split(" ");
    renderSeed(words);
      bindSeedActions();
checkIdx = [3, 11, 17].map(i => Math.min(i, words.length-1));
    pos = 0;
    $("cIdx").textContent = String(checkIdx[pos] + 1);
    $("confirmWord").value = "";
    $("cStatus").textContent = "";

    go("mnemonicSection");
  }

  function startConfirm(){
    $("confirmWord").value = "";
    $("cStatus").textContent = "";
    $("cIdx").textContent = String(checkIdx[pos] + 1);
    go("confirmSection");
  }

  function doConfirmNext(){
    const w = norm($("confirmWord").value);
    const idx = checkIdx[pos];
    if (w !== words[idx]) {
      status($("cStatus"), false, "Неверно. Проверь слово.");
      return;
    }
    pos++;
    if (pos >= checkIdx.length) {
      go("setPassSection");
      return;
    }
    status($("cStatus"), true, "OK");
    $("confirmWord").value = "";
    $("cIdx").textContent = String(checkIdx[pos] + 1);
  }

  async function finishCreate(){
    const p1 = $("p1").value || "";
    const p2 = $("p2").value || "";
    if (p1.length < 6) return status($("pStatus"), false, "Пароль минимум 6 символов");
    if (p1 !== p2) return status($("pStatus"), false, "Пароли не совпадают");

    status($("pStatus"), true, "Создаю…");

    const seedBuf = await BIP39().mnemonicToSeed32(mnemonic, "");
    const seedU8  = new Uint8Array(seedBuf);

    const seed32 = await sha256(seedU8);                 // 32 bytes
    const kp = nacl.sign.keyPair.fromSeed(seed32);
    const rid = makeRIDFromPub(kp.publicKey);

    const enc = await encryptSeed32(seed32, p1);

    const vault = {
      ver: 1,
      rid,
      pub: u8ToB64(kp.publicKey),
      ...enc,
      created_at: new Date().toISOString()
    };
    localStorage.setItem(LS_VAULT, JSON.stringify(vault));

    sessionStorage.setItem(SS_SEED, u8ToB64(seed32));
    setRidSession(rid);

    goWallet();
  }

  // ---------- Restore flow ----------
  async function doRestore(){
    const m = norm($("restoreMnemonic").value);
    const pass = $("restorePass").value || "";
    if (!await BIP39().validateMnemonic(m)) return status($("rStatus"), false, "Фраза некорректная (проверь слова/пробелы)");
    if (pass.length < 6) return status($("rStatus"), false, "Пароль минимум 6 символов");

    status($("rStatus"), true, "Восстанавливаю…");

    const seedBuf = await BIP39().mnemonicToSeed32(m, "");
    const seedU8  = new Uint8Array(seedBuf);
    const seed32  = await sha256(seedU8);

    const kp = nacl.sign.keyPair.fromSeed(seed32);
    const rid = makeRIDFromPub(kp.publicKey);

    const enc = await encryptSeed32(seed32, pass);
    const vault = {
      ver: 1,
      rid,
      pub: u8ToB64(kp.publicKey),
      ...enc,
      created_at: new Date().toISOString()
    };
    localStorage.setItem(LS_VAULT, JSON.stringify(vault));

    sessionStorage.setItem(SS_SEED, u8ToB64(seed32));
    setRidSession(rid);

    goWallet();
  }

  // ---------- Unlock flow ----------
  async function doUnlock(){
    let v = null;
    try { v = JSON.parse(localStorage.getItem(LS_VAULT) || "null"); } catch(_){}
    if (!v || !v.ct) return status($("uStatus"), false, "Vault не найден");
    const pass = $("unlockPass").value || "";
    if (pass.length < 6) return status($("uStatus"), false, "Пароль минимум 6 символов");

    status($("uStatus"), true, "Unlock…");
    try{
      const seed32 = await decryptSeed32(v, pass);
      sessionStorage.setItem(SS_SEED, u8ToB64(seed32));
      setRidSession(v.rid || "");
      goWallet();
    } catch(e){
      status($("uStatus"), false, "Неверный пароль или vault повреждён");
    }
  }

  // ---------- Legacy RID login ----------
  function legacyLogin(){
    const rid = ($("rid").value || "").trim();
    if (!rid) return status($("status"), false, "Введите RID");
    setRidSession(rid);
    status($("status"), true, "OK");
    goWallet();
  }

  function showSavedRid(){
    const rid = (localStorage.getItem(LS_RID2) || localStorage.getItem(LS_RID1) || localStorage.getItem(LS_LAST) || "").trim();
    if (!rid) return status($("status"), false, "RID не найден в браузере");
    $("rid").value = rid;
    status($("status"), true, "RID подставлен из браузера");
  }

  // init
  document.addEventListener("DOMContentLoaded", () => {
    // если vault есть — показываем Unlock кнопку
    try{
      const v = JSON.parse(localStorage.getItem(LS_VAULT) || "null");
      if (v && v.ct) $("btnUnlock").style.display = "";
    }catch(_){}

    $("btnCreate").onclick = startCreate;
    $("btnRestore").onclick = () => go("restoreSection");
    $("btnUnlock").onclick  = () => go("unlockSection");

    $("btnRecorded").onclick = startConfirm;
    $("btnConfirmNext").onclick = doConfirmNext;
    $("btnFinishCreate").onclick = () => finishCreate().catch(e => status($("pStatus"), false, "ERR: " + (e.message||String(e))));

    $("btnDoRestore").onclick = () => doRestore().catch(e => status($("rStatus"), false, "ERR: " + (e.message||String(e))));
    $("btnDoUnlock").onclick  = () => doUnlock().catch(e => status($("uStatus"), false, "ERR: " + (e.message||String(e))));

    $("btnBack0").onclick = () => go("step0");
    $("btnBack1").onclick = () => go("mnemonicSection");
    $("btnBack2").onclick = () => go("confirmSection");
    $("btnBackR").onclick = () => go("step0");
    $("btnBackU").onclick = () => go("step0");

    $("btnLogin").onclick = legacyLogin;
    $("btnShowRid").onclick = showSavedRid;

    // автоподстановка RID
    const rid = (localStorage.getItem(LS_RID2) || localStorage.getItem(LS_RID1) || localStorage.getItem(LS_LAST) || "").trim();
    if (rid) $("rid").value = rid;
  });
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/compat.js`

- Size: 5512 bytes
- Lines: 180

```javascript
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/connect.js`

- Size: 254 bytes
- Lines: 3

```javascript
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/modules/lgn_send.js`

- Size: 4770 bytes
- Lines: 126

```javascript
/* LGN send via /node-api/submit_tx
   Uses sessionStorage logos_sk_seed_b64 (seed32) + tweetnacl ed25519
*/
(() => {
  const NODE_API = `${location.origin}/node-api`;
  const SS_SEED = "logos_sk_seed_b64";

  const byId = (id)=>document.getElementById(id);
  const pick = (...ids)=>ids.map(byId).find(Boolean);

  function setStatus(ok, msg){
    const el = pick("lgnStatus","sendStatus","statusLGN");
    if (el){ el.textContent = msg||""; el.className = ok ? "status ok" : "status err"; }
  }

  function b64ToU8(b64){
    const s = atob(b64);
    const u8 = new Uint8Array(s.length);
    for(let i=0;i<s.length;i++) u8[i]=s.charCodeAt(i);
    return u8;
  }

  function u8tohex(u8){
    return Array.from(u8).map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  function readRID(){
    return (localStorage.getItem("logos_rid") || localStorage.getItem("RID") || "").trim();
  }

  function readToRid(){
    // В твоём UI это именно lgmTo
    const el = pick("lgmTo","lgnTo","toRid","to");
    return (el?.value || "").trim();
  }

  function parseAmountMicro(){
    const el = pick("lgmAmount","lgnAmount","amountLGN","amount");
    const s0 = (el?.value || "").trim().replace(",",".");
    if (!s0) throw new Error("Введите Amount");
    if (!/^\d+(\.\d+)?$/.test(s0)) throw new Error("Некорректный Amount");
    const [a,b=""] = s0.split(".");
    const frac = (b+"000000").slice(0,6);
    const micro = BigInt(a)*1000000n + BigInt(frac);
    if (micro<=0n) throw new Error("Amount должен быть > 0");
    return micro;
  }

  async function getJSON(url){
    const r = await fetch(url,{cache:"no-store",credentials:"omit"});
    const t = await r.text();
    if (!r.ok) throw new Error(`${r.status} ${t}`.slice(0,300));
    try { return JSON.parse(t); } catch { return t; }
  }

  async function postJSON(url, body){
    const r = await fetch(url,{
      method:"POST",
      headers:{"content-type":"application/json"},
      body: JSON.stringify(body),
      cache:"no-store",
      credentials:"omit"
    });
    const t = await r.text();
    if (!r.ok) throw new Error(`${r.status} ${t}`.slice(0,600));
    try { return JSON.parse(t); } catch { return t; }
  }

  async function getNextNonce(rid){
    const j = await getJSON(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    const raw = (j && typeof j==="object" && (j.next_nonce ?? j.nonce ?? j.seq ?? j.sequence));
    if (raw===undefined || raw===null) throw new Error("В /balance нет nonce/next_nonce");
    const bn = BigInt(raw);
    // если отдаёте next_nonce — берём как есть, если nonce — добавим 1
    if (j && typeof j==="object" && j.next_nonce !== undefined) return bn;
    return bn + 1n;
  }

  function canonicalBytes(tx){
    const o = {from:tx.from,to:tx.to,amount:tx.amount,nonce:tx.nonce,memo:tx.memo??null};
    return new TextEncoder().encode(JSON.stringify(o));
  }

  async function sendLGN(){
    try{
      const from = readRID();
      if (!from) throw new Error("Нет RID. Сначала Create/Restore/Unlock или Legacy login.");
      const to = readToRid();
      if (!to) throw new Error("Введите RID получателя.");

      const seedB64 = sessionStorage.getItem(SS_SEED);
      if (!seedB64) throw new Error("Ключ не разблокирован. Вернись на старт и сделай Unlock.");
      if (!window.nacl) throw new Error("tweetnacl не загружен (проверь app.html).");

      const seed32 = b64ToU8(seedB64);
      const kp = nacl.sign.keyPair.fromSeed(seed32);

      const amount = parseAmountMicro();
      const nonce = await getNextNonce(from);

      const tx = { from, to, amount: amount.toString(), nonce: nonce.toString(), memo: null };
      const msg = canonicalBytes(tx);
      const sig = nacl.sign.detached(new Uint8Array(msg), kp.secretKey);

      const body = { ...tx, sig_hex: u8tohex(sig) };
      setStatus(true, "sending…");
      const res = await postJSON(`${NODE_API}/submit_tx`, body);
      setStatus(true, "OK: tx submitted");
      console.log("[lgn_send] submit result:", res);
    }catch(e){
      setStatus(false, "ERR: " + (e.message||String(e)));
      console.warn(e);
    }
  }

  function bind(){
    // найдём кнопку “Send LGN”
    const btn = [...document.querySelectorAll("button")].find(b => /send\s*lgn/i.test(b.textContent||""));
    if (!btn) { console.warn("[lgn_send] button not found"); return; }
    btn.addEventListener("click", (ev)=>{ ev.preventDefault(); sendLGN(); }, true);
    console.log("[lgn_send] ready (seed vault mode)");
  }

  if (document.readyState==="loading") document.addEventListener("DOMContentLoaded", bind);
  else bind();
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/modules/send.js`

- Size: 4208 bytes
- Lines: 136

```javascript
(function(){
  const $ = (id) => document.getElementById(id);

  function esc(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function setStatus(msg){
    const el = $("wdStatus");
    if (el) el.textContent = msg || "";
  }

  function setRaw(obj){
    const pre = $("wdRaw");
    if (!pre) return;
    try{ pre.textContent = JSON.stringify(obj, null, 2); }
    catch(e){ pre.textContent = String(obj); }
  }

  function fillNetworkOptionsFromBalances(balJson){
    const sel = $("wdNetwork");
    if (!sel) return;

    const b = (balJson && balJson.balances) ? balJson.balances : {};
    const opts = [];

    // Withdraw у нас "USDT". Реальные сети вывода: ERC20 (ETH) и TRC20 (TRON)
    if (b.ETH)  opts.push({v:"ETH",  t:"ETH (ERC20)"});
    if (b.TRON) opts.push({v:"TRON", t:"TRON (TRC20)"});

    // fallback если вдруг API не дал balances
    if (opts.length === 0) opts.push({v:"ETH", t:"ETH (ERC20)"});

    const cur = sel.value;
    sel.innerHTML = "";
    for (const o of opts){
      const opt = document.createElement("option");
      opt.value = o.v;
      opt.textContent = o.t;
      sel.appendChild(opt);
    }
    if (cur && [...sel.options].some(x => x.value === cur)) sel.value = cur;
  }

  async function refreshNetworks(){
    try{
      const rid = readRID();
      if (!rid) return;

      const base = window.WALLET_API || "/wallet-api";
      const r = await fetch(base + "/v1/balances/" + encodeURIComponent(rid), { cache: "no-store" });
      if (!r.ok) return;
      const j = await r.json();
      fillNetworkOptionsFromBalances(j);
    }catch(e){}
  }

  function clearForm(){
    if ($("wdAmount")) $("wdAmount").value = "";
    if ($("wdTo")) $("wdTo").value = "";
    setStatus("");
    setRaw("");
  }

  async function doWithdraw(){
    const rid = readRID();
    if (!rid) return setStatus("ERR: RID не найден. Зайди через /wallet/auth.html");

    const base = window.WALLET_API || "/wallet-api";

    const net = ($("wdNetwork") && $("wdNetwork").value) ? $("wdNetwork").value : "ETH";
    const amountStr = String(($("wdAmount") && $("wdAmount").value) || "").trim();
    const to = String(($("wdTo") && $("wdTo").value) || "").trim();

    if (!amountStr) return setStatus("ERR: введи Amount (целое число).");
    if (!/^\d+$/.test(amountStr)) return setStatus("ERR: Amount должен быть целым числом (integer).");
    const amount = Number(amountStr);
    if (!Number.isFinite(amount) || amount <= 0) return setStatus("ERR: Amount должен быть > 0.");

    if (!to || to.length < 8) return setStatus("ERR: введи адрес получателя.");

    setStatus("request…");
    setRaw("");

    try{
      const body = { rid, network: net, amount, to };

      const r = await fetch(base + "/v1/withdraw", {
        method: "POST",
        headers: { "content-type":"application/json" },
        body: JSON.stringify(body),
        cache: "no-store"
      });

      const j = await r.json().catch(()=>({}));
      setRaw(j);

      if (!r.ok){
        return setStatus("ERR: HTTP " + r.status + " — " + (j && (j.error || j.message) ? (j.error || j.message) : "withdraw failed"));
      }

      setStatus("OK: отправлено (" + esc(net) + ").");
    }catch(e){
      setStatus("ERR: " + (e && e.message ? e.message : String(e)));
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    refreshNetworks();

    const btnSend = $("btnWithdraw");
    const btnClear = $("btnWithdrawClear");

    if (btnSend) btnSend.addEventListener("click", doWithdraw);
    if (btnClear) btnClear.addEventListener("click", clearForm);

    // enter = send (в поле адреса)
    const to = $("wdTo");
    if (to){
      to.addEventListener("keydown", (e) => {
        if (e.key === "Enter") doWithdraw();
      });
    }
  });
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/modules/settings.js`

- Size: 9436 bytes
- Lines: 245

```javascript
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();


// PROD hard clear session password
try{sessionStorage.removeItem("PASS");sessionStorage.removeItem("logos_pass");}catch(e){}
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/modules/tx_redirect.js`

- Size: 2810 bytes
- Lines: 90

```javascript
/* tx_redirect.js — redirect old /transfer -> /submit_tx and normalize body to TxIn */
(() => {
  const _fetch = window.fetch.bind(window);

  function isHex(s){
    s = String(s||"").replace(/^0x/,"").trim();
    return s.length > 0 && s.length % 2 === 0 && /^[0-9a-fA-F]+$/.test(s);
  }

  function b64urlToBytes(b64url){
    try{
      let s = String(b64url||"").replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u[i] = bin.charCodeAt(i);
      return u;
    }catch(e){ return null; }
  }

  function bytesToHex(u){
    let out = "";
    for (let i=0;i<u.length;i++) out += u[i].toString(16).padStart(2,"0");
    return out;
  }

  function normalizeTx(body){
    const j = body && typeof body === "object" ? body : {};
    const from = j.from || j.rid_from || j.sender || j.rid || "";
    const to   = j.to   || j.rid_to   || j.receiver || "";
    let amount = j.amount_mic ?? j.amount_micro ?? j.amount ?? 0;
    const nonce = j.nonce ?? j.n ?? j.account_nonce;

    // если вдруг прислали amount_lgn — переводим в micro-LGN
    if (j.amount_lgn !== undefined && j.amount_lgn !== null){
      const a = Number(j.amount_lgn);
      if (isFinite(a)) amount = Math.round(a * 1e6);
    }

    // подпись: sig_hex обязательно
    let sig_hex = j.sig_hex || j.sigHex || "";
    if (!sig_hex){
      const s = j.sig || j.signature || j.sig_b64 || j.sigB64 || "";
      if (s){
        if (isHex(s)) sig_hex = String(s).replace(/^0x/,"");
        else {
          const u = b64urlToBytes(s);
          if (u) sig_hex = bytesToHex(u);
        }
      }
    }

    const memo = (j.memo === undefined ? null : j.memo);

    return { from, to, amount, nonce, memo, sig_hex };
  }

  window.fetch = async (input, init={}) => {
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url.includes("/transfer")){
        const newUrl = url.replace("/transfer", "/submit_tx");

        let bodyObj = {};
        try{ bodyObj = JSON.parse(init.body || "{}"); }catch(e){ bodyObj = {}; }

        const tx = normalizeTx(bodyObj);

        const newInit = {
          ...init,
          method: "POST",
          headers: { ...(init.headers||{}), "Content-Type":"application/json" },
          body: JSON.stringify({
            from: tx.from,
            to: tx.to,
            amount: tx.amount,
            nonce: tx.nonce,
            memo: tx.memo,
            sig_hex: tx.sig_hex
          })
        };

        return _fetch(newUrl, newInit);
      }
    }catch(e){}
    return _fetch(input, init);
  };

  console.log("[tx_redirect] installed: /transfer -> /submit_tx");
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/tabs.js`

- Size: 1290 bytes
- Lines: 37

```javascript
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/ui.js`

- Size: 3447 bytes
- Lines: 115

```javascript
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/vendor/bip39_lite.js`

- Size: 3779 bytes
- Lines: 124

```javascript
/* bip39_lite.js — offline, no deps.
   Requires: window.BIP39_WORDS (2048 english words) loaded before this file.

   Exposes:
     window.bip39lite.generateMnemonic(strengthBits=128) -> Promise<string>
     window.bip39lite.validateMnemonic(mn) -> Promise<boolean>
     window.bip39lite.mnemonicToSeed32(mn, pass="") -> Promise<Uint8Array(32)>
*/
(function(){
  const WORDS = window.BIP39_WORDS;
  if(!Array.isArray(WORDS) || WORDS.length !== 2048){
    console.error("[bip39lite] wordlist missing/invalid");
    return;
  }

  const te = new TextEncoder();
  const wordIndex = new Map(WORDS.map((w,i)=>[w,i]));

  function norm(m){ return (m||"").toLowerCase().trim().replace(/\s+/g," "); }

  async function sha256(u8){
    const h = await crypto.subtle.digest("SHA-256", u8);
    return new Uint8Array(h);
  }

  function bytesToBits(bytes){
    let out="";
    for(const b of bytes) out += b.toString(2).padStart(8,"0");
    return out;
  }

  function bitsToBytes(bits){
    const n = Math.ceil(bits.length/8);
    const out = new Uint8Array(n);
    for(let i=0;i<n;i++){
      const chunk = bits.slice(i*8, i*8+8).padEnd(8,"0");
      out[i] = parseInt(chunk,2);
    }
    return out;
  }

  async function generateMnemonic(strengthBits=128){
    if(strengthBits % 32 !== 0 || strengthBits < 128 || strengthBits > 256){
      throw new Error("strengthBits must be 128..256 and multiple of 32");
    }
    const entropy = crypto.getRandomValues(new Uint8Array(strengthBits/8));
    const hash = await sha256(entropy);

    // checksum length = ENT/32
    const csLen = strengthBits / 32;
    const entBits = bytesToBits(entropy);
    const csBits  = bytesToBits(hash).slice(0, csLen);

    const bits = entBits + csBits; // total multiple of 11
    const words = [];
    for(let i=0;i<bits.length; i+=11){
      const idx = parseInt(bits.slice(i,i+11), 2);
      words.push(WORDS[idx]);
    }
    return words.join(" ");
  }

  async function validateMnemonic(mn){
    mn = norm(mn);
    if(!mn) return false;
    const arr = mn.split(" ");
    if(arr.length % 3 !== 0) return false;
    if(arr.length < 12 || arr.length > 24) return false;

    // rebuild bits from indices
    let bits="";
    for(const w of arr){
      const idx = wordIndex.get(w);
      if(idx === undefined) return false;
      bits += idx.toString(2).padStart(11,"0");
    }

    // derive ENT from word count: ENT = (words*11) - CS, where CS = ENT/32
    // => ENT = words*11 * 32/33
    const total = arr.length * 11;
    const entBitsLen = Math.floor(total * 32 / 33);
    const csLen = total - entBitsLen;

    if(entBitsLen % 8 !== 0) return false;

    const entBits = bits.slice(0, entBitsLen);
    const csBits  = bits.slice(entBitsLen, entBitsLen + csLen);

    const entropy = bitsToBytes(entBits);
    const hash = await sha256(entropy);
    const csCheck = bytesToBits(hash).slice(0, csLen);

    return csBits === csCheck;
  }

  async function mnemonicToSeed32(mn, pass=""){
    mn = norm(mn);
    pass = (pass||"");

    const salt = te.encode("mnemonic" + pass);
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      te.encode(mn),
      "PBKDF2",
      false,
      ["deriveBits"]
    );

    // BIP39 seed = PBKDF2-HMAC-SHA512, 2048 iterations -> 64 bytes
    const bits = await crypto.subtle.deriveBits(
      { name:"PBKDF2", hash:"SHA-512", salt, iterations:2048 },
      keyMaterial,
      512
    );
    const seed64 = new Uint8Array(bits);

    // Нам нужен seed32 для nacl/ed25519 — берём SHA256(seed64)
    const seed32 = await sha256(seed64);
    return seed32; // Uint8Array(32)
  }

  window.bip39lite = { generateMnemonic, validateMnemonic, mnemonicToSeed32 };
  console.log("[bip39lite] ready. wordlist:", WORDS.length);
})();
```

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/vendor/nacl-fast.min.js`

- Size: 32110 bytes
- Lines: 0

> **SKIPPED (minified/sourcemap).**

### `/opt/logos/www/wallet_prod__v555_20260114T103906Z/vendor/wordlist_en.js`

- Size: 19281 bytes
- Lines: 1

```javascript
window.BIP39_WORDS=['abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access', 'accident', 'account', 'accuse', 'achieve', 'acid', 'acoustic', 'acquire', 'across', 'act', 'action', 'actor', 'actress', 'actual', 'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance', 'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent', 'agree', 'ahead', 'aim', 'air', 'airport', 'aisle', 'alarm', 'album', 'alcohol', 'alert', 'alien', 'all', 'alley', 'allow', 'almost', 'alone', 'alpha', 'already', 'also', 'alter', 'always', 'amateur', 'amazing', 'among', 'amount', 'amused', 'analyst', 'anchor', 'ancient', 'anger', 'angle', 'angry', 'animal', 'ankle', 'announce', 'annual', 'another', 'answer', 'antenna', 'antique', 'anxiety', 'any', 'apart', 'apology', 'appear', 'apple', 'approve', 'april', 'arch', 'arctic', 'area', 'arena', 'argue', 'arm', 'armed', 'armor', 'army', 'around', 'arrange', 'arrest', 'arrive', 'arrow', 'art', 'artefact', 'artist', 'artwork', 'ask', 'aspect', 'assault', 'asset', 'assist', 'assume', 'asthma', 'athlete', 'atom', 'attack', 'attend', 'attitude', 'attract', 'auction', 'audit', 'august', 'aunt', 'author', 'auto', 'autumn', 'average', 'avocado', 'avoid', 'awake', 'aware', 'away', 'awesome', 'awful', 'awkward', 'axis', 'baby', 'bachelor', 'bacon', 'badge', 'bag', 'balance', 'balcony', 'ball', 'bamboo', 'banana', 'banner', 'bar', 'barely', 'bargain', 'barrel', 'base', 'basic', 'basket', 'battle', 'beach', 'bean', 'beauty', 'because', 'become', 'beef', 'before', 'begin', 'behave', 'behind', 'believe', 'below', 'belt', 'bench', 'benefit', 'best', 'betray', 'better', 'between', 'beyond', 'bicycle', 'bid', 'bike', 'bind', 'biology', 'bird', 'birth', 'bitter', 'black', 'blade', 'blame', 'blanket', 'blast', 'bleak', 'bless', 'blind', 'blood', 'blossom', 'blouse', 'blue', 'blur', 'blush', 'board', 'boat', 'body', 'boil', 'bomb', 'bone', 'bonus', 'book', 'boost', 'border', 'boring', 'borrow', 'boss', 'bottom', 'bounce', 'box', 'boy', 'bracket', 'brain', 'brand', 'brass', 'brave', 'bread', 'breeze', 'brick', 'bridge', 'brief', 'bright', 'bring', 'brisk', 'broccoli', 'broken', 'bronze', 'broom', 'brother', 'brown', 'brush', 'bubble', 'buddy', 'budget', 'buffalo', 'build', 'bulb', 'bulk', 'bullet', 'bundle', 'bunker', 'burden', 'burger', 'burst', 'bus', 'business', 'busy', 'butter', 'buyer', 'buzz', 'cabbage', 'cabin', 'cable', 'cactus', 'cage', 'cake', 'call', 'calm', 'camera', 'camp', 'can', 'canal', 'cancel', 'candy', 'cannon', 'canoe', 'canvas', 'canyon', 'capable', 'capital', 'captain', 'car', 'carbon', 'card', 'cargo', 'carpet', 'carry', 'cart', 'case', 'cash', 'casino', 'castle', 'casual', 'cat', 'catalog', 'catch', 'category', 'cattle', 'caught', 'cause', 'caution', 'cave', 'ceiling', 'celery', 'cement', 'census', 'century', 'cereal', 'certain', 'chair', 'chalk', 'champion', 'change', 'chaos', 'chapter', 'charge', 'chase', 'chat', 'cheap', 'check', 'cheese', 'chef', 'cherry', 'chest', 'chicken', 'chief', 'child', 'chimney', 'choice', 'choose', 'chronic', 'chuckle', 'chunk', 'churn', 'cigar', 'cinnamon', 'circle', 'citizen', 'city', 'civil', 'claim', 'clap', 'clarify', 'claw', 'clay', 'clean', 'clerk', 'clever', 'click', 'client', 'cliff', 'climb', 'clinic', 'clip', 'clock', 'clog', 'close', 'cloth', 'cloud', 'clown', 'club', 'clump', 'cluster', 'clutch', 'coach', 'coast', 'coconut', 'code', 'coffee', 'coil', 'coin', 'collect', 'color', 'column', 'combine', 'come', 'comfort', 'comic', 'common', 'company', 'concert', 'conduct', 'confirm', 'congress', 'connect', 'consider', 'control', 'convince', 'cook', 'cool', 'copper', 'copy', 'coral', 'core', 'corn', 'correct', 'cost', 'cotton', 'couch', 'country', 'couple', 'course', 'cousin', 'cover', 'coyote', 'crack', 'cradle', 'craft', 'cram', 'crane', 'crash', 'crater', 'crawl', 'crazy', 'cream', 'credit', 'creek', 'crew', 'cricket', 'crime', 'crisp', 'critic', 'crop', 'cross', 'crouch', 'crowd', 'crucial', 'cruel', 'cruise', 'crumble', 'crunch', 'crush', 'cry', 'crystal', 'cube', 'culture', 'cup', 'cupboard', 'curious', 'current', 'curtain', 'curve', 'cushion', 'custom', 'cute', 'cycle', 'dad', 'damage', 'damp', 'dance', 'danger', 'daring', 'dash', 'daughter', 'dawn', 'day', 'deal', 'debate', 'debris', 'decade', 'december', 'decide', 'decline', 'decorate', 'decrease', 'deer', 'defense', 'define', 'defy', 'degree', 'delay', 'deliver', 'demand', 'demise', 'denial', 'dentist', 'deny', 'depart', 'depend', 'deposit', 'depth', 'deputy', 'derive', 'describe', 'desert', 'design', 'desk', 'despair', 'destroy', 'detail', 'detect', 'develop', 'device', 'devote', 'diagram', 'dial', 'diamond', 'diary', 'dice', 'diesel', 'diet', 'differ', 'digital', 'dignity', 'dilemma', 'dinner', 'dinosaur', 'direct', 'dirt', 'disagree', 'discover', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'distance', 'divert', 'divide', 'divorce', 'dizzy', 'doctor', 'document', 'dog', 'doll', 'dolphin', 'domain', 'donate', 'donkey', 'donor', 'door', 'dose', 'double', 'dove', 'draft', 'dragon', 'drama', 'drastic', 'draw', 'dream', 'dress', 'drift', 'drill', 'drink', 'drip', 'drive', 'drop', 'drum', 'dry', 'duck', 'dumb', 'dune', 'during', 'dust', 'dutch', 'duty', 'dwarf', 'dynamic', 'eager', 'eagle', 'early', 'earn', 'earth', 'easily', 'east', 'easy', 'echo', 'ecology', 'economy', 'edge', 'edit', 'educate', 'effort', 'egg', 'eight', 'either', 'elbow', 'elder', 'electric', 'elegant', 'element', 'elephant', 'elevator', 'elite', 'else', 'embark', 'embody', 'embrace', 'emerge', 'emotion', 'employ', 'empower', 'empty', 'enable', 'enact', 'end', 'endless', 'endorse', 'enemy', 'energy', 'enforce', 'engage', 'engine', 'enhance', 'enjoy', 'enlist', 'enough', 'enrich', 'enroll', 'ensure', 'enter', 'entire', 'entry', 'envelope', 'episode', 'equal', 'equip', 'era', 'erase', 'erode', 'erosion', 'error', 'erupt', 'escape', 'essay', 'essence', 'estate', 'eternal', 'ethics', 'evidence', 'evil', 'evoke', 'evolve', 'exact', 'example', 'excess', 'exchange', 'excite', 'exclude', 'excuse', 'execute', 'exercise', 'exhaust', 'exhibit', 'exile', 'exist', 'exit', 'exotic', 'expand', 'expect', 'expire', 'explain', 'expose', 'express', 'extend', 'extra', 'eye', 'eyebrow', 'fabric', 'face', 'faculty', 'fade', 'faint', 'faith', 'fall', 'false', 'fame', 'family', 'famous', 'fan', 'fancy', 'fantasy', 'farm', 'fashion', 'fat', 'fatal', 'father', 'fatigue', 'fault', 'favorite', 'feature', 'february', 'federal', 'fee', 'feed', 'feel', 'female', 'fence', 'festival', 'fetch', 'fever', 'few', 'fiber', 'fiction', 'field', 'figure', 'file', 'film', 'filter', 'final', 'find', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fiscal', 'fish', 'fit', 'fitness', 'fix', 'flag', 'flame', 'flash', 'flat', 'flavor', 'flee', 'flight', 'flip', 'float', 'flock', 'floor', 'flower', 'fluid', 'flush', 'fly', 'foam', 'focus', 'fog', 'foil', 'fold', 'follow', 'food', 'foot', 'force', 'forest', 'forget', 'fork', 'fortune', 'forum', 'forward', 'fossil', 'foster', 'found', 'fox', 'fragile', 'frame', 'frequent', 'fresh', 'friend', 'fringe', 'frog', 'front', 'frost', 'frown', 'frozen', 'fruit', 'fuel', 'fun', 'funny', 'furnace', 'fury', 'future', 'gadget', 'gain', 'galaxy', 'gallery', 'game', 'gap', 'garage', 'garbage', 'garden', 'garlic', 'garment', 'gas', 'gasp', 'gate', 'gather', 'gauge', 'gaze', 'general', 'genius', 'genre', 'gentle', 'genuine', 'gesture', 'ghost', 'giant', 'gift', 'giggle', 'ginger', 'giraffe', 'girl', 'give', 'glad', 'glance', 'glare', 'glass', 'glide', 'glimpse', 'globe', 'gloom', 'glory', 'glove', 'glow', 'glue', 'goat', 'goddess', 'gold', 'good', 'goose', 'gorilla', 'gospel', 'gossip', 'govern', 'gown', 'grab', 'grace', 'grain', 'grant', 'grape', 'grass', 'gravity', 'great', 'green', 'grid', 'grief', 'grit', 'grocery', 'group', 'grow', 'grunt', 'guard', 'guess', 'guide', 'guilt', 'guitar', 'gun', 'gym', 'habit', 'hair', 'half', 'hammer', 'hamster', 'hand', 'happy', 'harbor', 'hard', 'harsh', 'harvest', 'hat', 'have', 'hawk', 'hazard', 'head', 'health', 'heart', 'heavy', 'hedgehog', 'height', 'hello', 'helmet', 'help', 'hen', 'hero', 'hidden', 'high', 'hill', 'hint', 'hip', 'hire', 'history', 'hobby', 'hockey', 'hold', 'hole', 'holiday', 'hollow', 'home', 'honey', 'hood', 'hope', 'horn', 'horror', 'horse', 'hospital', 'host', 'hotel', 'hour', 'hover', 'hub', 'huge', 'human', 'humble', 'humor', 'hundred', 'hungry', 'hunt', 'hurdle', 'hurry', 'hurt', 'husband', 'hybrid', 'ice', 'icon', 'idea', 'identify', 'idle', 'ignore', 'ill', 'illegal', 'illness', 'image', 'imitate', 'immense', 'immune', 'impact', 'impose', 'improve', 'impulse', 'inch', 'include', 'income', 'increase', 'index', 'indicate', 'indoor', 'industry', 'infant', 'inflict', 'inform', 'inhale', 'inherit', 'initial', 'inject', 'injury', 'inmate', 'inner', 'innocent', 'input', 'inquiry', 'insane', 'insect', 'inside', 'inspire', 'install', 'intact', 'interest', 'into', 'invest', 'invite', 'involve', 'iron', 'island', 'isolate', 'issue', 'item', 'ivory', 'jacket', 'jaguar', 'jar', 'jazz', 'jealous', 'jeans', 'jelly', 'jewel', 'job', 'join', 'joke', 'journey', 'joy', 'judge', 'juice', 'jump', 'jungle', 'junior', 'junk', 'just', 'kangaroo', 'keen', 'keep', 'ketchup', 'key', 'kick', 'kid', 'kidney', 'kind', 'kingdom', 'kiss', 'kit', 'kitchen', 'kite', 'kitten', 'kiwi', 'knee', 'knife', 'knock', 'know', 'lab', 'label', 'labor', 'ladder', 'lady', 'lake', 'lamp', 'language', 'laptop', 'large', 'later', 'latin', 'laugh', 'laundry', 'lava', 'law', 'lawn', 'lawsuit', 'layer', 'lazy', 'leader', 'leaf', 'learn', 'leave', 'lecture', 'left', 'leg', 'legal', 'legend', 'leisure', 'lemon', 'lend', 'length', 'lens', 'leopard', 'lesson', 'letter', 'level', 'liar', 'liberty', 'library', 'license', 'life', 'lift', 'light', 'like', 'limb', 'limit', 'link', 'lion', 'liquid', 'list', 'little', 'live', 'lizard', 'load', 'loan', 'lobster', 'local', 'lock', 'logic', 'lonely', 'long', 'loop', 'lottery', 'loud', 'lounge', 'love', 'loyal', 'lucky', 'luggage', 'lumber', 'lunar', 'lunch', 'luxury', 'lyrics', 'machine', 'mad', 'magic', 'magnet', 'maid', 'mail', 'main', 'major', 'make', 'mammal', 'man', 'manage', 'mandate', 'mango', 'mansion', 'manual', 'maple', 'marble', 'march', 'margin', 'marine', 'market', 'marriage', 'mask', 'mass', 'master', 'match', 'material', 'math', 'matrix', 'matter', 'maximum', 'maze', 'meadow', 'mean', 'measure', 'meat', 'mechanic', 'medal', 'media', 'melody', 'melt', 'member', 'memory', 'mention', 'menu', 'mercy', 'merge', 'merit', 'merry', 'mesh', 'message', 'metal', 'method', 'middle', 'midnight', 'milk', 'million', 'mimic', 'mind', 'minimum', 'minor', 'minute', 'miracle', 'mirror', 'misery', 'miss', 'mistake', 'mix', 'mixed', 'mixture', 'mobile', 'model', 'modify', 'mom', 'moment', 'monitor', 'monkey', 'monster', 'month', 'moon', 'moral', 'more', 'morning', 'mosquito', 'mother', 'motion', 'motor', 'mountain', 'mouse', 'move', 'movie', 'much', 'muffin', 'mule', 'multiply', 'muscle', 'museum', 'mushroom', 'music', 'must', 'mutual', 'myself', 'mystery', 'myth', 'naive', 'name', 'napkin', 'narrow', 'nasty', 'nation', 'nature', 'near', 'neck', 'need', 'negative', 'neglect', 'neither', 'nephew', 'nerve', 'nest', 'net', 'network', 'neutral', 'never', 'news', 'next', 'nice', 'night', 'noble', 'noise', 'nominee', 'noodle', 'normal', 'north', 'nose', 'notable', 'note', 'nothing', 'notice', 'novel', 'now', 'nuclear', 'number', 'nurse', 'nut', 'oak', 'obey', 'object', 'oblige', 'obscure', 'observe', 'obtain', 'obvious', 'occur', 'ocean', 'october', 'odor', 'off', 'offer', 'office', 'often', 'oil', 'okay', 'old', 'olive', 'olympic', 'omit', 'once', 'one', 'onion', 'online', 'only', 'open', 'opera', 'opinion', 'oppose', 'option', 'orange', 'orbit', 'orchard', 'order', 'ordinary', 'organ', 'orient', 'original', 'orphan', 'ostrich', 'other', 'outdoor', 'outer', 'output', 'outside', 'oval', 'oven', 'over', 'own', 'owner', 'oxygen', 'oyster', 'ozone', 'pact', 'paddle', 'page', 'pair', 'palace', 'palm', 'panda', 'panel', 'panic', 'panther', 'paper', 'parade', 'parent', 'park', 'parrot', 'party', 'pass', 'patch', 'path', 'patient', 'patrol', 'pattern', 'pause', 'pave', 'payment', 'peace', 'peanut', 'pear', 'peasant', 'pelican', 'pen', 'penalty', 'pencil', 'people', 'pepper', 'perfect', 'permit', 'person', 'pet', 'phone', 'photo', 'phrase', 'physical', 'piano', 'picnic', 'picture', 'piece', 'pig', 'pigeon', 'pill', 'pilot', 'pink', 'pioneer', 'pipe', 'pistol', 'pitch', 'pizza', 'place', 'planet', 'plastic', 'plate', 'play', 'please', 'pledge', 'pluck', 'plug', 'plunge', 'poem', 'poet', 'point', 'polar', 'pole', 'police', 'pond', 'pony', 'pool', 'popular', 'portion', 'position', 'possible', 'post', 'potato', 'pottery', 'poverty', 'powder', 'power', 'practice', 'praise', 'predict', 'prefer', 'prepare', 'present', 'pretty', 'prevent', 'price', 'pride', 'primary', 'print', 'priority', 'prison', 'private', 'prize', 'problem', 'process', 'produce', 'profit', 'program', 'project', 'promote', 'proof', 'property', 'prosper', 'protect', 'proud', 'provide', 'public', 'pudding', 'pull', 'pulp', 'pulse', 'pumpkin', 'punch', 'pupil', 'puppy', 'purchase', 'purity', 'purpose', 'purse', 'push', 'put', 'puzzle', 'pyramid', 'quality', 'quantum', 'quarter', 'question', 'quick', 'quit', 'quiz', 'quote', 'rabbit', 'raccoon', 'race', 'rack', 'radar', 'radio', 'rail', 'rain', 'raise', 'rally', 'ramp', 'ranch', 'random', 'range', 'rapid', 'rare', 'rate', 'rather', 'raven', 'raw', 'razor', 'ready', 'real', 'reason', 'rebel', 'rebuild', 'recall', 'receive', 'recipe', 'record', 'recycle', 'reduce', 'reflect', 'reform', 'refuse', 'region', 'regret', 'regular', 'reject', 'relax', 'release', 'relief', 'rely', 'remain', 'remember', 'remind', 'remove', 'render', 'renew', 'rent', 'reopen', 'repair', 'repeat', 'replace', 'report', 'require', 'rescue', 'resemble', 'resist', 'resource', 'response', 'result', 'retire', 'retreat', 'return', 'reunion', 'reveal', 'review', 'reward', 'rhythm', 'rib', 'ribbon', 'rice', 'rich', 'ride', 'ridge', 'rifle', 'right', 'rigid', 'ring', 'riot', 'ripple', 'risk', 'ritual', 'rival', 'river', 'road', 'roast', 'robot', 'robust', 'rocket', 'romance', 'roof', 'rookie', 'room', 'rose', 'rotate', 'rough', 'round', 'route', 'royal', 'rubber', 'rude', 'rug', 'rule', 'run', 'runway', 'rural', 'sad', 'saddle', 'sadness', 'safe', 'sail', 'salad', 'salmon', 'salon', 'salt', 'salute', 'same', 'sample', 'sand', 'satisfy', 'satoshi', 'sauce', 'sausage', 'save', 'say', 'scale', 'scan', 'scare', 'scatter', 'scene', 'scheme', 'school', 'science', 'scissors', 'scorpion', 'scout', 'scrap', 'screen', 'script', 'scrub', 'sea', 'search', 'season', 'seat', 'second', 'secret', 'section', 'security', 'seed', 'seek', 'segment', 'select', 'sell', 'seminar', 'senior', 'sense', 'sentence', 'series', 'service', 'session', 'settle', 'setup', 'seven', 'shadow', 'shaft', 'shallow', 'share', 'shed', 'shell', 'sheriff', 'shield', 'shift', 'shine', 'ship', 'shiver', 'shock', 'shoe', 'shoot', 'shop', 'short', 'shoulder', 'shove', 'shrimp', 'shrug', 'shuffle', 'shy', 'sibling', 'sick', 'side', 'siege', 'sight', 'sign', 'silent', 'silk', 'silly', 'silver', 'similar', 'simple', 'since', 'sing', 'siren', 'sister', 'situate', 'six', 'size', 'skate', 'sketch', 'ski', 'skill', 'skin', 'skirt', 'skull', 'slab', 'slam', 'sleep', 'slender', 'slice', 'slide', 'slight', 'slim', 'slogan', 'slot', 'slow', 'slush', 'small', 'smart', 'smile', 'smoke', 'smooth', 'snack', 'snake', 'snap', 'sniff', 'snow', 'soap', 'soccer', 'social', 'sock', 'soda', 'soft', 'solar', 'soldier', 'solid', 'solution', 'solve', 'someone', 'song', 'soon', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south', 'space', 'spare', 'spatial', 'spawn', 'speak', 'special', 'speed', 'spell', 'spend', 'sphere', 'spice', 'spider', 'spike', 'spin', 'spirit', 'split', 'spoil', 'sponsor', 'spoon', 'sport', 'spot', 'spray', 'spread', 'spring', 'spy', 'square', 'squeeze', 'squirrel', 'stable', 'stadium', 'staff', 'stage', 'stairs', 'stamp', 'stand', 'start', 'state', 'stay', 'steak', 'steel', 'stem', 'step', 'stereo', 'stick', 'still', 'sting', 'stock', 'stomach', 'stone', 'stool', 'story', 'stove', 'strategy', 'street', 'strike', 'strong', 'struggle', 'student', 'stuff', 'stumble', 'style', 'subject', 'submit', 'subway', 'success', 'such', 'sudden', 'suffer', 'sugar', 'suggest', 'suit', 'summer', 'sun', 'sunny', 'sunset', 'super', 'supply', 'supreme', 'sure', 'surface', 'surge', 'surprise', 'surround', 'survey', 'suspect', 'sustain', 'swallow', 'swamp', 'swap', 'swarm', 'swear', 'sweet', 'swift', 'swim', 'swing', 'switch', 'sword', 'symbol', 'symptom', 'syrup', 'system', 'table', 'tackle', 'tag', 'tail', 'talent', 'talk', 'tank', 'tape', 'target', 'task', 'taste', 'tattoo', 'taxi', 'teach', 'team', 'tell', 'ten', 'tenant', 'tennis', 'tent', 'term', 'test', 'text', 'thank', 'that', 'theme', 'then', 'theory', 'there', 'they', 'thing', 'this', 'thought', 'three', 'thrive', 'throw', 'thumb', 'thunder', 'ticket', 'tide', 'tiger', 'tilt', 'timber', 'time', 'tiny', 'tip', 'tired', 'tissue', 'title', 'toast', 'tobacco', 'today', 'toddler', 'toe', 'together', 'toilet', 'token', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'tool', 'tooth', 'top', 'topic', 'topple', 'torch', 'tornado', 'tortoise', 'toss', 'total', 'tourist', 'toward', 'tower', 'town', 'toy', 'track', 'trade', 'traffic', 'tragic', 'train', 'transfer', 'trap', 'trash', 'travel', 'tray', 'treat', 'tree', 'trend', 'trial', 'tribe', 'trick', 'trigger', 'trim', 'trip', 'trophy', 'trouble', 'truck', 'true', 'truly', 'trumpet', 'trust', 'truth', 'try', 'tube', 'tuition', 'tumble', 'tuna', 'tunnel', 'turkey', 'turn', 'turtle', 'twelve', 'twenty', 'twice', 'twin', 'twist', 'two', 'type', 'typical', 'ugly', 'umbrella', 'unable', 'unaware', 'uncle', 'uncover', 'under', 'undo', 'unfair', 'unfold', 'unhappy', 'uniform', 'unique', 'unit', 'universe', 'unknown', 'unlock', 'until', 'unusual', 'unveil', 'update', 'upgrade', 'uphold', 'upon', 'upper', 'upset', 'urban', 'urge', 'usage', 'use', 'used', 'useful', 'useless', 'usual', 'utility', 'vacant', 'vacuum', 'vague', 'valid', 'valley', 'valve', 'van', 'vanish', 'vapor', 'various', 'vast', 'vault', 'vehicle', 'velvet', 'vendor', 'venture', 'venue', 'verb', 'verify', 'version', 'very', 'vessel', 'veteran', 'viable', 'vibrant', 'vicious', 'victory', 'video', 'view', 'village', 'vintage', 'violin', 'virtual', 'virus', 'visa', 'visit', 'visual', 'vital', 'vivid', 'vocal', 'voice', 'void', 'volcano', 'volume', 'vote', 'voyage', 'wage', 'wagon', 'wait', 'walk', 'wall', 'walnut', 'want', 'warfare', 'warm', 'warrior', 'wash', 'wasp', 'waste', 'water', 'wave', 'way', 'wealth', 'weapon', 'wear', 'weasel', 'weather', 'web', 'wedding', 'weekend', 'weird', 'welcome', 'west', 'wet', 'whale', 'what', 'wheat', 'wheel', 'when', 'where', 'whip', 'whisper', 'wide', 'width', 'wife', 'wild', 'will', 'win', 'window', 'wine', 'wing', 'wink', 'winner', 'winter', 'wire', 'wisdom', 'wise', 'wish', 'witness', 'wolf', 'woman', 'wonder', 'wood', 'wool', 'word', 'work', 'world', 'worry', 'worth', 'wrap', 'wreck', 'wrestle', 'wrist', 'write', 'wrong', 'yard', 'year', 'yellow', 'you', 'young', 'youth', 'zebra', 'zero', 'zone', 'zoo'];
```

### `/opt/logos/www/wallet_prod/vendor/bip39_lite.js`

- Size: 3779 bytes
- Lines: 124

```javascript
/* bip39_lite.js — offline, no deps.
   Requires: window.BIP39_WORDS (2048 english words) loaded before this file.

   Exposes:
     window.bip39lite.generateMnemonic(strengthBits=128) -> Promise<string>
     window.bip39lite.validateMnemonic(mn) -> Promise<boolean>
     window.bip39lite.mnemonicToSeed32(mn, pass="") -> Promise<Uint8Array(32)>
*/
(function(){
  const WORDS = window.BIP39_WORDS;
  if(!Array.isArray(WORDS) || WORDS.length !== 2048){
    console.error("[bip39lite] wordlist missing/invalid");
    return;
  }

  const te = new TextEncoder();
  const wordIndex = new Map(WORDS.map((w,i)=>[w,i]));

  function norm(m){ return (m||"").toLowerCase().trim().replace(/\s+/g," "); }

  async function sha256(u8){
    const h = await crypto.subtle.digest("SHA-256", u8);
    return new Uint8Array(h);
  }

  function bytesToBits(bytes){
    let out="";
    for(const b of bytes) out += b.toString(2).padStart(8,"0");
    return out;
  }

  function bitsToBytes(bits){
    const n = Math.ceil(bits.length/8);
    const out = new Uint8Array(n);
    for(let i=0;i<n;i++){
      const chunk = bits.slice(i*8, i*8+8).padEnd(8,"0");
      out[i] = parseInt(chunk,2);
    }
    return out;
  }

  async function generateMnemonic(strengthBits=128){
    if(strengthBits % 32 !== 0 || strengthBits < 128 || strengthBits > 256){
      throw new Error("strengthBits must be 128..256 and multiple of 32");
    }
    const entropy = crypto.getRandomValues(new Uint8Array(strengthBits/8));
    const hash = await sha256(entropy);

    // checksum length = ENT/32
    const csLen = strengthBits / 32;
    const entBits = bytesToBits(entropy);
    const csBits  = bytesToBits(hash).slice(0, csLen);

    const bits = entBits + csBits; // total multiple of 11
    const words = [];
    for(let i=0;i<bits.length; i+=11){
      const idx = parseInt(bits.slice(i,i+11), 2);
      words.push(WORDS[idx]);
    }
    return words.join(" ");
  }

  async function validateMnemonic(mn){
    mn = norm(mn);
    if(!mn) return false;
    const arr = mn.split(" ");
    if(arr.length % 3 !== 0) return false;
    if(arr.length < 12 || arr.length > 24) return false;

    // rebuild bits from indices
    let bits="";
    for(const w of arr){
      const idx = wordIndex.get(w);
      if(idx === undefined) return false;
      bits += idx.toString(2).padStart(11,"0");
    }

    // derive ENT from word count: ENT = (words*11) - CS, where CS = ENT/32
    // => ENT = words*11 * 32/33
    const total = arr.length * 11;
    const entBitsLen = Math.floor(total * 32 / 33);
    const csLen = total - entBitsLen;

    if(entBitsLen % 8 !== 0) return false;

    const entBits = bits.slice(0, entBitsLen);
    const csBits  = bits.slice(entBitsLen, entBitsLen + csLen);

    const entropy = bitsToBytes(entBits);
    const hash = await sha256(entropy);
    const csCheck = bytesToBits(hash).slice(0, csLen);

    return csBits === csCheck;
  }

  async function mnemonicToSeed32(mn, pass=""){
    mn = norm(mn);
    pass = (pass||"");

    const salt = te.encode("mnemonic" + pass);
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      te.encode(mn),
      "PBKDF2",
      false,
      ["deriveBits"]
    );

    // BIP39 seed = PBKDF2-HMAC-SHA512, 2048 iterations -> 64 bytes
    const bits = await crypto.subtle.deriveBits(
      { name:"PBKDF2", hash:"SHA-512", salt, iterations:2048 },
      keyMaterial,
      512
    );
    const seed64 = new Uint8Array(bits);

    // Нам нужен seed32 для nacl/ed25519 — берём SHA256(seed64)
    const seed32 = await sha256(seed64);
    return seed32; // Uint8Array(32)
  }

  window.bip39lite = { generateMnemonic, validateMnemonic, mnemonicToSeed32 };
  console.log("[bip39lite] ready. wordlist:", WORDS.length);
})();
```

### `/opt/logos/www/wallet_prod/vendor/nacl-fast.min.js`

- Size: 32110 bytes
- Lines: 0

> **SKIPPED (minified/sourcemap).**

### `/opt/logos/www/wallet_prod/vendor/wordlist_en.js`

- Size: 19281 bytes
- Lines: 1

```javascript
window.BIP39_WORDS=['abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access', 'accident', 'account', 'accuse', 'achieve', 'acid', 'acoustic', 'acquire', 'across', 'act', 'action', 'actor', 'actress', 'actual', 'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance', 'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent', 'agree', 'ahead', 'aim', 'air', 'airport', 'aisle', 'alarm', 'album', 'alcohol', 'alert', 'alien', 'all', 'alley', 'allow', 'almost', 'alone', 'alpha', 'already', 'also', 'alter', 'always', 'amateur', 'amazing', 'among', 'amount', 'amused', 'analyst', 'anchor', 'ancient', 'anger', 'angle', 'angry', 'animal', 'ankle', 'announce', 'annual', 'another', 'answer', 'antenna', 'antique', 'anxiety', 'any', 'apart', 'apology', 'appear', 'apple', 'approve', 'april', 'arch', 'arctic', 'area', 'arena', 'argue', 'arm', 'armed', 'armor', 'army', 'around', 'arrange', 'arrest', 'arrive', 'arrow', 'art', 'artefact', 'artist', 'artwork', 'ask', 'aspect', 'assault', 'asset', 'assist', 'assume', 'asthma', 'athlete', 'atom', 'attack', 'attend', 'attitude', 'attract', 'auction', 'audit', 'august', 'aunt', 'author', 'auto', 'autumn', 'average', 'avocado', 'avoid', 'awake', 'aware', 'away', 'awesome', 'awful', 'awkward', 'axis', 'baby', 'bachelor', 'bacon', 'badge', 'bag', 'balance', 'balcony', 'ball', 'bamboo', 'banana', 'banner', 'bar', 'barely', 'bargain', 'barrel', 'base', 'basic', 'basket', 'battle', 'beach', 'bean', 'beauty', 'because', 'become', 'beef', 'before', 'begin', 'behave', 'behind', 'believe', 'below', 'belt', 'bench', 'benefit', 'best', 'betray', 'better', 'between', 'beyond', 'bicycle', 'bid', 'bike', 'bind', 'biology', 'bird', 'birth', 'bitter', 'black', 'blade', 'blame', 'blanket', 'blast', 'bleak', 'bless', 'blind', 'blood', 'blossom', 'blouse', 'blue', 'blur', 'blush', 'board', 'boat', 'body', 'boil', 'bomb', 'bone', 'bonus', 'book', 'boost', 'border', 'boring', 'borrow', 'boss', 'bottom', 'bounce', 'box', 'boy', 'bracket', 'brain', 'brand', 'brass', 'brave', 'bread', 'breeze', 'brick', 'bridge', 'brief', 'bright', 'bring', 'brisk', 'broccoli', 'broken', 'bronze', 'broom', 'brother', 'brown', 'brush', 'bubble', 'buddy', 'budget', 'buffalo', 'build', 'bulb', 'bulk', 'bullet', 'bundle', 'bunker', 'burden', 'burger', 'burst', 'bus', 'business', 'busy', 'butter', 'buyer', 'buzz', 'cabbage', 'cabin', 'cable', 'cactus', 'cage', 'cake', 'call', 'calm', 'camera', 'camp', 'can', 'canal', 'cancel', 'candy', 'cannon', 'canoe', 'canvas', 'canyon', 'capable', 'capital', 'captain', 'car', 'carbon', 'card', 'cargo', 'carpet', 'carry', 'cart', 'case', 'cash', 'casino', 'castle', 'casual', 'cat', 'catalog', 'catch', 'category', 'cattle', 'caught', 'cause', 'caution', 'cave', 'ceiling', 'celery', 'cement', 'census', 'century', 'cereal', 'certain', 'chair', 'chalk', 'champion', 'change', 'chaos', 'chapter', 'charge', 'chase', 'chat', 'cheap', 'check', 'cheese', 'chef', 'cherry', 'chest', 'chicken', 'chief', 'child', 'chimney', 'choice', 'choose', 'chronic', 'chuckle', 'chunk', 'churn', 'cigar', 'cinnamon', 'circle', 'citizen', 'city', 'civil', 'claim', 'clap', 'clarify', 'claw', 'clay', 'clean', 'clerk', 'clever', 'click', 'client', 'cliff', 'climb', 'clinic', 'clip', 'clock', 'clog', 'close', 'cloth', 'cloud', 'clown', 'club', 'clump', 'cluster', 'clutch', 'coach', 'coast', 'coconut', 'code', 'coffee', 'coil', 'coin', 'collect', 'color', 'column', 'combine', 'come', 'comfort', 'comic', 'common', 'company', 'concert', 'conduct', 'confirm', 'congress', 'connect', 'consider', 'control', 'convince', 'cook', 'cool', 'copper', 'copy', 'coral', 'core', 'corn', 'correct', 'cost', 'cotton', 'couch', 'country', 'couple', 'course', 'cousin', 'cover', 'coyote', 'crack', 'cradle', 'craft', 'cram', 'crane', 'crash', 'crater', 'crawl', 'crazy', 'cream', 'credit', 'creek', 'crew', 'cricket', 'crime', 'crisp', 'critic', 'crop', 'cross', 'crouch', 'crowd', 'crucial', 'cruel', 'cruise', 'crumble', 'crunch', 'crush', 'cry', 'crystal', 'cube', 'culture', 'cup', 'cupboard', 'curious', 'current', 'curtain', 'curve', 'cushion', 'custom', 'cute', 'cycle', 'dad', 'damage', 'damp', 'dance', 'danger', 'daring', 'dash', 'daughter', 'dawn', 'day', 'deal', 'debate', 'debris', 'decade', 'december', 'decide', 'decline', 'decorate', 'decrease', 'deer', 'defense', 'define', 'defy', 'degree', 'delay', 'deliver', 'demand', 'demise', 'denial', 'dentist', 'deny', 'depart', 'depend', 'deposit', 'depth', 'deputy', 'derive', 'describe', 'desert', 'design', 'desk', 'despair', 'destroy', 'detail', 'detect', 'develop', 'device', 'devote', 'diagram', 'dial', 'diamond', 'diary', 'dice', 'diesel', 'diet', 'differ', 'digital', 'dignity', 'dilemma', 'dinner', 'dinosaur', 'direct', 'dirt', 'disagree', 'discover', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'distance', 'divert', 'divide', 'divorce', 'dizzy', 'doctor', 'document', 'dog', 'doll', 'dolphin', 'domain', 'donate', 'donkey', 'donor', 'door', 'dose', 'double', 'dove', 'draft', 'dragon', 'drama', 'drastic', 'draw', 'dream', 'dress', 'drift', 'drill', 'drink', 'drip', 'drive', 'drop', 'drum', 'dry', 'duck', 'dumb', 'dune', 'during', 'dust', 'dutch', 'duty', 'dwarf', 'dynamic', 'eager', 'eagle', 'early', 'earn', 'earth', 'easily', 'east', 'easy', 'echo', 'ecology', 'economy', 'edge', 'edit', 'educate', 'effort', 'egg', 'eight', 'either', 'elbow', 'elder', 'electric', 'elegant', 'element', 'elephant', 'elevator', 'elite', 'else', 'embark', 'embody', 'embrace', 'emerge', 'emotion', 'employ', 'empower', 'empty', 'enable', 'enact', 'end', 'endless', 'endorse', 'enemy', 'energy', 'enforce', 'engage', 'engine', 'enhance', 'enjoy', 'enlist', 'enough', 'enrich', 'enroll', 'ensure', 'enter', 'entire', 'entry', 'envelope', 'episode', 'equal', 'equip', 'era', 'erase', 'erode', 'erosion', 'error', 'erupt', 'escape', 'essay', 'essence', 'estate', 'eternal', 'ethics', 'evidence', 'evil', 'evoke', 'evolve', 'exact', 'example', 'excess', 'exchange', 'excite', 'exclude', 'excuse', 'execute', 'exercise', 'exhaust', 'exhibit', 'exile', 'exist', 'exit', 'exotic', 'expand', 'expect', 'expire', 'explain', 'expose', 'express', 'extend', 'extra', 'eye', 'eyebrow', 'fabric', 'face', 'faculty', 'fade', 'faint', 'faith', 'fall', 'false', 'fame', 'family', 'famous', 'fan', 'fancy', 'fantasy', 'farm', 'fashion', 'fat', 'fatal', 'father', 'fatigue', 'fault', 'favorite', 'feature', 'february', 'federal', 'fee', 'feed', 'feel', 'female', 'fence', 'festival', 'fetch', 'fever', 'few', 'fiber', 'fiction', 'field', 'figure', 'file', 'film', 'filter', 'final', 'find', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fiscal', 'fish', 'fit', 'fitness', 'fix', 'flag', 'flame', 'flash', 'flat', 'flavor', 'flee', 'flight', 'flip', 'float', 'flock', 'floor', 'flower', 'fluid', 'flush', 'fly', 'foam', 'focus', 'fog', 'foil', 'fold', 'follow', 'food', 'foot', 'force', 'forest', 'forget', 'fork', 'fortune', 'forum', 'forward', 'fossil', 'foster', 'found', 'fox', 'fragile', 'frame', 'frequent', 'fresh', 'friend', 'fringe', 'frog', 'front', 'frost', 'frown', 'frozen', 'fruit', 'fuel', 'fun', 'funny', 'furnace', 'fury', 'future', 'gadget', 'gain', 'galaxy', 'gallery', 'game', 'gap', 'garage', 'garbage', 'garden', 'garlic', 'garment', 'gas', 'gasp', 'gate', 'gather', 'gauge', 'gaze', 'general', 'genius', 'genre', 'gentle', 'genuine', 'gesture', 'ghost', 'giant', 'gift', 'giggle', 'ginger', 'giraffe', 'girl', 'give', 'glad', 'glance', 'glare', 'glass', 'glide', 'glimpse', 'globe', 'gloom', 'glory', 'glove', 'glow', 'glue', 'goat', 'goddess', 'gold', 'good', 'goose', 'gorilla', 'gospel', 'gossip', 'govern', 'gown', 'grab', 'grace', 'grain', 'grant', 'grape', 'grass', 'gravity', 'great', 'green', 'grid', 'grief', 'grit', 'grocery', 'group', 'grow', 'grunt', 'guard', 'guess', 'guide', 'guilt', 'guitar', 'gun', 'gym', 'habit', 'hair', 'half', 'hammer', 'hamster', 'hand', 'happy', 'harbor', 'hard', 'harsh', 'harvest', 'hat', 'have', 'hawk', 'hazard', 'head', 'health', 'heart', 'heavy', 'hedgehog', 'height', 'hello', 'helmet', 'help', 'hen', 'hero', 'hidden', 'high', 'hill', 'hint', 'hip', 'hire', 'history', 'hobby', 'hockey', 'hold', 'hole', 'holiday', 'hollow', 'home', 'honey', 'hood', 'hope', 'horn', 'horror', 'horse', 'hospital', 'host', 'hotel', 'hour', 'hover', 'hub', 'huge', 'human', 'humble', 'humor', 'hundred', 'hungry', 'hunt', 'hurdle', 'hurry', 'hurt', 'husband', 'hybrid', 'ice', 'icon', 'idea', 'identify', 'idle', 'ignore', 'ill', 'illegal', 'illness', 'image', 'imitate', 'immense', 'immune', 'impact', 'impose', 'improve', 'impulse', 'inch', 'include', 'income', 'increase', 'index', 'indicate', 'indoor', 'industry', 'infant', 'inflict', 'inform', 'inhale', 'inherit', 'initial', 'inject', 'injury', 'inmate', 'inner', 'innocent', 'input', 'inquiry', 'insane', 'insect', 'inside', 'inspire', 'install', 'intact', 'interest', 'into', 'invest', 'invite', 'involve', 'iron', 'island', 'isolate', 'issue', 'item', 'ivory', 'jacket', 'jaguar', 'jar', 'jazz', 'jealous', 'jeans', 'jelly', 'jewel', 'job', 'join', 'joke', 'journey', 'joy', 'judge', 'juice', 'jump', 'jungle', 'junior', 'junk', 'just', 'kangaroo', 'keen', 'keep', 'ketchup', 'key', 'kick', 'kid', 'kidney', 'kind', 'kingdom', 'kiss', 'kit', 'kitchen', 'kite', 'kitten', 'kiwi', 'knee', 'knife', 'knock', 'know', 'lab', 'label', 'labor', 'ladder', 'lady', 'lake', 'lamp', 'language', 'laptop', 'large', 'later', 'latin', 'laugh', 'laundry', 'lava', 'law', 'lawn', 'lawsuit', 'layer', 'lazy', 'leader', 'leaf', 'learn', 'leave', 'lecture', 'left', 'leg', 'legal', 'legend', 'leisure', 'lemon', 'lend', 'length', 'lens', 'leopard', 'lesson', 'letter', 'level', 'liar', 'liberty', 'library', 'license', 'life', 'lift', 'light', 'like', 'limb', 'limit', 'link', 'lion', 'liquid', 'list', 'little', 'live', 'lizard', 'load', 'loan', 'lobster', 'local', 'lock', 'logic', 'lonely', 'long', 'loop', 'lottery', 'loud', 'lounge', 'love', 'loyal', 'lucky', 'luggage', 'lumber', 'lunar', 'lunch', 'luxury', 'lyrics', 'machine', 'mad', 'magic', 'magnet', 'maid', 'mail', 'main', 'major', 'make', 'mammal', 'man', 'manage', 'mandate', 'mango', 'mansion', 'manual', 'maple', 'marble', 'march', 'margin', 'marine', 'market', 'marriage', 'mask', 'mass', 'master', 'match', 'material', 'math', 'matrix', 'matter', 'maximum', 'maze', 'meadow', 'mean', 'measure', 'meat', 'mechanic', 'medal', 'media', 'melody', 'melt', 'member', 'memory', 'mention', 'menu', 'mercy', 'merge', 'merit', 'merry', 'mesh', 'message', 'metal', 'method', 'middle', 'midnight', 'milk', 'million', 'mimic', 'mind', 'minimum', 'minor', 'minute', 'miracle', 'mirror', 'misery', 'miss', 'mistake', 'mix', 'mixed', 'mixture', 'mobile', 'model', 'modify', 'mom', 'moment', 'monitor', 'monkey', 'monster', 'month', 'moon', 'moral', 'more', 'morning', 'mosquito', 'mother', 'motion', 'motor', 'mountain', 'mouse', 'move', 'movie', 'much', 'muffin', 'mule', 'multiply', 'muscle', 'museum', 'mushroom', 'music', 'must', 'mutual', 'myself', 'mystery', 'myth', 'naive', 'name', 'napkin', 'narrow', 'nasty', 'nation', 'nature', 'near', 'neck', 'need', 'negative', 'neglect', 'neither', 'nephew', 'nerve', 'nest', 'net', 'network', 'neutral', 'never', 'news', 'next', 'nice', 'night', 'noble', 'noise', 'nominee', 'noodle', 'normal', 'north', 'nose', 'notable', 'note', 'nothing', 'notice', 'novel', 'now', 'nuclear', 'number', 'nurse', 'nut', 'oak', 'obey', 'object', 'oblige', 'obscure', 'observe', 'obtain', 'obvious', 'occur', 'ocean', 'october', 'odor', 'off', 'offer', 'office', 'often', 'oil', 'okay', 'old', 'olive', 'olympic', 'omit', 'once', 'one', 'onion', 'online', 'only', 'open', 'opera', 'opinion', 'oppose', 'option', 'orange', 'orbit', 'orchard', 'order', 'ordinary', 'organ', 'orient', 'original', 'orphan', 'ostrich', 'other', 'outdoor', 'outer', 'output', 'outside', 'oval', 'oven', 'over', 'own', 'owner', 'oxygen', 'oyster', 'ozone', 'pact', 'paddle', 'page', 'pair', 'palace', 'palm', 'panda', 'panel', 'panic', 'panther', 'paper', 'parade', 'parent', 'park', 'parrot', 'party', 'pass', 'patch', 'path', 'patient', 'patrol', 'pattern', 'pause', 'pave', 'payment', 'peace', 'peanut', 'pear', 'peasant', 'pelican', 'pen', 'penalty', 'pencil', 'people', 'pepper', 'perfect', 'permit', 'person', 'pet', 'phone', 'photo', 'phrase', 'physical', 'piano', 'picnic', 'picture', 'piece', 'pig', 'pigeon', 'pill', 'pilot', 'pink', 'pioneer', 'pipe', 'pistol', 'pitch', 'pizza', 'place', 'planet', 'plastic', 'plate', 'play', 'please', 'pledge', 'pluck', 'plug', 'plunge', 'poem', 'poet', 'point', 'polar', 'pole', 'police', 'pond', 'pony', 'pool', 'popular', 'portion', 'position', 'possible', 'post', 'potato', 'pottery', 'poverty', 'powder', 'power', 'practice', 'praise', 'predict', 'prefer', 'prepare', 'present', 'pretty', 'prevent', 'price', 'pride', 'primary', 'print', 'priority', 'prison', 'private', 'prize', 'problem', 'process', 'produce', 'profit', 'program', 'project', 'promote', 'proof', 'property', 'prosper', 'protect', 'proud', 'provide', 'public', 'pudding', 'pull', 'pulp', 'pulse', 'pumpkin', 'punch', 'pupil', 'puppy', 'purchase', 'purity', 'purpose', 'purse', 'push', 'put', 'puzzle', 'pyramid', 'quality', 'quantum', 'quarter', 'question', 'quick', 'quit', 'quiz', 'quote', 'rabbit', 'raccoon', 'race', 'rack', 'radar', 'radio', 'rail', 'rain', 'raise', 'rally', 'ramp', 'ranch', 'random', 'range', 'rapid', 'rare', 'rate', 'rather', 'raven', 'raw', 'razor', 'ready', 'real', 'reason', 'rebel', 'rebuild', 'recall', 'receive', 'recipe', 'record', 'recycle', 'reduce', 'reflect', 'reform', 'refuse', 'region', 'regret', 'regular', 'reject', 'relax', 'release', 'relief', 'rely', 'remain', 'remember', 'remind', 'remove', 'render', 'renew', 'rent', 'reopen', 'repair', 'repeat', 'replace', 'report', 'require', 'rescue', 'resemble', 'resist', 'resource', 'response', 'result', 'retire', 'retreat', 'return', 'reunion', 'reveal', 'review', 'reward', 'rhythm', 'rib', 'ribbon', 'rice', 'rich', 'ride', 'ridge', 'rifle', 'right', 'rigid', 'ring', 'riot', 'ripple', 'risk', 'ritual', 'rival', 'river', 'road', 'roast', 'robot', 'robust', 'rocket', 'romance', 'roof', 'rookie', 'room', 'rose', 'rotate', 'rough', 'round', 'route', 'royal', 'rubber', 'rude', 'rug', 'rule', 'run', 'runway', 'rural', 'sad', 'saddle', 'sadness', 'safe', 'sail', 'salad', 'salmon', 'salon', 'salt', 'salute', 'same', 'sample', 'sand', 'satisfy', 'satoshi', 'sauce', 'sausage', 'save', 'say', 'scale', 'scan', 'scare', 'scatter', 'scene', 'scheme', 'school', 'science', 'scissors', 'scorpion', 'scout', 'scrap', 'screen', 'script', 'scrub', 'sea', 'search', 'season', 'seat', 'second', 'secret', 'section', 'security', 'seed', 'seek', 'segment', 'select', 'sell', 'seminar', 'senior', 'sense', 'sentence', 'series', 'service', 'session', 'settle', 'setup', 'seven', 'shadow', 'shaft', 'shallow', 'share', 'shed', 'shell', 'sheriff', 'shield', 'shift', 'shine', 'ship', 'shiver', 'shock', 'shoe', 'shoot', 'shop', 'short', 'shoulder', 'shove', 'shrimp', 'shrug', 'shuffle', 'shy', 'sibling', 'sick', 'side', 'siege', 'sight', 'sign', 'silent', 'silk', 'silly', 'silver', 'similar', 'simple', 'since', 'sing', 'siren', 'sister', 'situate', 'six', 'size', 'skate', 'sketch', 'ski', 'skill', 'skin', 'skirt', 'skull', 'slab', 'slam', 'sleep', 'slender', 'slice', 'slide', 'slight', 'slim', 'slogan', 'slot', 'slow', 'slush', 'small', 'smart', 'smile', 'smoke', 'smooth', 'snack', 'snake', 'snap', 'sniff', 'snow', 'soap', 'soccer', 'social', 'sock', 'soda', 'soft', 'solar', 'soldier', 'solid', 'solution', 'solve', 'someone', 'song', 'soon', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south', 'space', 'spare', 'spatial', 'spawn', 'speak', 'special', 'speed', 'spell', 'spend', 'sphere', 'spice', 'spider', 'spike', 'spin', 'spirit', 'split', 'spoil', 'sponsor', 'spoon', 'sport', 'spot', 'spray', 'spread', 'spring', 'spy', 'square', 'squeeze', 'squirrel', 'stable', 'stadium', 'staff', 'stage', 'stairs', 'stamp', 'stand', 'start', 'state', 'stay', 'steak', 'steel', 'stem', 'step', 'stereo', 'stick', 'still', 'sting', 'stock', 'stomach', 'stone', 'stool', 'story', 'stove', 'strategy', 'street', 'strike', 'strong', 'struggle', 'student', 'stuff', 'stumble', 'style', 'subject', 'submit', 'subway', 'success', 'such', 'sudden', 'suffer', 'sugar', 'suggest', 'suit', 'summer', 'sun', 'sunny', 'sunset', 'super', 'supply', 'supreme', 'sure', 'surface', 'surge', 'surprise', 'surround', 'survey', 'suspect', 'sustain', 'swallow', 'swamp', 'swap', 'swarm', 'swear', 'sweet', 'swift', 'swim', 'swing', 'switch', 'sword', 'symbol', 'symptom', 'syrup', 'system', 'table', 'tackle', 'tag', 'tail', 'talent', 'talk', 'tank', 'tape', 'target', 'task', 'taste', 'tattoo', 'taxi', 'teach', 'team', 'tell', 'ten', 'tenant', 'tennis', 'tent', 'term', 'test', 'text', 'thank', 'that', 'theme', 'then', 'theory', 'there', 'they', 'thing', 'this', 'thought', 'three', 'thrive', 'throw', 'thumb', 'thunder', 'ticket', 'tide', 'tiger', 'tilt', 'timber', 'time', 'tiny', 'tip', 'tired', 'tissue', 'title', 'toast', 'tobacco', 'today', 'toddler', 'toe', 'together', 'toilet', 'token', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'tool', 'tooth', 'top', 'topic', 'topple', 'torch', 'tornado', 'tortoise', 'toss', 'total', 'tourist', 'toward', 'tower', 'town', 'toy', 'track', 'trade', 'traffic', 'tragic', 'train', 'transfer', 'trap', 'trash', 'travel', 'tray', 'treat', 'tree', 'trend', 'trial', 'tribe', 'trick', 'trigger', 'trim', 'trip', 'trophy', 'trouble', 'truck', 'true', 'truly', 'trumpet', 'trust', 'truth', 'try', 'tube', 'tuition', 'tumble', 'tuna', 'tunnel', 'turkey', 'turn', 'turtle', 'twelve', 'twenty', 'twice', 'twin', 'twist', 'two', 'type', 'typical', 'ugly', 'umbrella', 'unable', 'unaware', 'uncle', 'uncover', 'under', 'undo', 'unfair', 'unfold', 'unhappy', 'uniform', 'unique', 'unit', 'universe', 'unknown', 'unlock', 'until', 'unusual', 'unveil', 'update', 'upgrade', 'uphold', 'upon', 'upper', 'upset', 'urban', 'urge', 'usage', 'use', 'used', 'useful', 'useless', 'usual', 'utility', 'vacant', 'vacuum', 'vague', 'valid', 'valley', 'valve', 'van', 'vanish', 'vapor', 'various', 'vast', 'vault', 'vehicle', 'velvet', 'vendor', 'venture', 'venue', 'verb', 'verify', 'version', 'very', 'vessel', 'veteran', 'viable', 'vibrant', 'vicious', 'victory', 'video', 'view', 'village', 'vintage', 'violin', 'virtual', 'virus', 'visa', 'visit', 'visual', 'vital', 'vivid', 'vocal', 'voice', 'void', 'volcano', 'volume', 'vote', 'voyage', 'wage', 'wagon', 'wait', 'walk', 'wall', 'walnut', 'want', 'warfare', 'warm', 'warrior', 'wash', 'wasp', 'waste', 'water', 'wave', 'way', 'wealth', 'weapon', 'wear', 'weasel', 'weather', 'web', 'wedding', 'weekend', 'weird', 'welcome', 'west', 'wet', 'whale', 'what', 'wheat', 'wheel', 'when', 'where', 'whip', 'whisper', 'wide', 'width', 'wife', 'wild', 'will', 'win', 'window', 'wine', 'wing', 'wink', 'winner', 'winter', 'wire', 'wisdom', 'wise', 'wish', 'witness', 'wolf', 'woman', 'wonder', 'wood', 'wool', 'word', 'work', 'world', 'worry', 'worth', 'wrap', 'wreck', 'wrestle', 'wrist', 'write', 'wrong', 'yard', 'year', 'yellow', 'you', 'young', 'youth', 'zebra', 'zero', 'zone', 'zoo'];
```

---

## 08_wallet_proxy_api



**Roots:**
- `/opt/logos/wallet-proxy`

- Files total: **3** (Rust: 0 | Py: 3 | JS/TS: 0 | cfg/sh/sql: 0)
- dirs.txt: `/root/logos_project_map_20260121T113413Z/08_wallet_proxy_api/dirs.txt`
- files.txt: `/root/logos_project_map_20260121T113413Z/08_wallet_proxy_api/files.txt`


### Modules (files)

- `/opt/logos/wallet-proxy/app.py`
- `/opt/logos/wallet-proxy/init_db.py`
- `/opt/logos/wallet-proxy/scanner.py`

### Module contents

### `/opt/logos/wallet-proxy/app.py`

- Size: 17272 bytes
- Lines: 455

```python
# (СЮДА ВСТАВЛЯЕМ ЧИСТЫЙ КОД)
# ВАЖНО: ниже я даю компактный prod-фикс поверх твоей текущей логики:
# - receive: XPUB derived per RID
# - topup/request: ВОЗВРАЩАЕТ derived address (не HOT)
# - withdraw: требует request_id + to_address и делает idempotency

import os, time, json, asyncio
from typing import Optional, Dict
from decimal import Decimal, ROUND_DOWN

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import Response

from pydantic import BaseModel, Field

from sqlalchemy import create_engine, Column, Integer, String, BigInteger, Index, select
from sqlalchemy.orm import declarative_base, sessionmaker
from sqlalchemy.exc import IntegrityError

from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

from web3 import Web3
import aiohttp

from bip_utils import Bip84, Bip84Coins, Bip44, Bip44Coins, Bip44Changes


def _load_env_file(path: str = "/etc/logos/wallet-proxy.env"):
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                s = line.strip()
                if not s or s.startswith("#") or "=" not in s:
                    continue
                k, v = s.split("=", 1)
                k = k.strip()
                v = v.strip().strip('"').strip("'")
                if k and k not in os.environ:
                    os.environ[k] = v
    except FileNotFoundError:
        pass
    except Exception as e:
        print("WARN: env load failed:", e)

_load_env_file()

NODE_URL     = (os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080") or "").rstrip("/")
BRIDGE_KEY   = (os.environ.get("LRB_BRIDGE_KEY", "") or "").strip()
CORS_RAW     = os.environ.get("LRB_WALLET_CORS", "*")
CORS         = [o.strip() for o in (CORS_RAW or "*").split(",") if o.strip()]

ETH_RPC      = (os.environ.get("ETH_PROVIDER_URL", "") or "").strip()
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = (os.environ.get("ETH_HOT_WALLET_PK", "") or "").strip()

DB_URL       = os.environ.get("WALLET_PROXY_DB_URL", "sqlite:////opt/logos/wallet-proxy/wproxy.db")

CONFIRMATIONS = int(os.environ.get("ETH_CONFIRMATIONS", "12"))
SCAN_STEP     = int(os.environ.get("ETH_SCAN_STEP", "2000"))
SCAN_POLL_SEC = float(os.environ.get("ETH_SCAN_POLL_SEC", "5"))

ETH_MAX_FEE_GWEI      = Decimal(os.environ.get("ETH_MAX_FEE_GWEI", "30"))
ETH_PRIORITY_FEE_GWEI = Decimal(os.environ.get("ETH_PRIORITY_FEE_GWEI", "1"))
ETH_GAS_LIMIT_USDT    = int(os.environ.get("ETH_GAS_LIMIT_USDT", "90000"))

Base = declarative_base()

class DepositMap(Base):
    __tablename__ = "deposit_map"
    id         = Column(Integer, primary_key=True)
    rid        = Column(String, index=True, nullable=False)
    token      = Column(String, nullable=False)
    network    = Column(String, nullable=False)      # normalized chain: BTC/ETH/TRON
    index      = Column(Integer, nullable=False, default=0)
    address    = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda: int(time.time()))

Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id      = Column(Integer, primary_key=True)
    txid    = Column(String, unique=True, nullable=False)
    rid     = Column(String, index=True)
    token   = Column(String)
    network = Column(String)

class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True)
    v = Column(String, nullable=False)

class WithdrawReq(Base):
    __tablename__ = "withdraw_req"
    id         = Column(Integer, primary_key=True)
    request_id = Column(String, unique=True, nullable=False)
    rid        = Column(String, index=True, nullable=False)
    token      = Column(String, nullable=False)
    network    = Column(String, nullable=False)
    amount     = Column(String, nullable=False)     # human string
    to_address = Column(String, nullable=False)
    status     = Column(String, nullable=False, default="init")
    txid       = Column(String, nullable=True)
    err        = Column(String, nullable=True)
    created_at = Column(BigInteger, default=lambda: int(time.time()))
    updated_at = Column(BigInteger, default=lambda: int(time.time()))

engine = create_engine(DB_URL, future=True)
SessionLocal = sessionmaker(bind=engine, autoflush=False, autocommit=False, expire_on_commit=False, future=True)
Base.metadata.create_all(engine)

PROXY_TOPUP_REQ = Counter("proxy_topup_request_total", "topup request calls")
PROXY_WITHDRAW_OK  = Counter("proxy_withdraw_ok_total", "withdraw ok")
PROXY_WITHDRAW_ERR = Counter("proxy_withdraw_err_total", "withdraw err")

SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

ERC20_ABI = json.loads("""
[
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")

w3: Optional[Web3] = None
USDT = None

def _init_web3():
    global w3, USDT
    if not ETH_RPC:
        w3 = None
        USDT = None
        return
    try:
        _w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout": 10}))
        if not _w3.is_connected():
            w3 = None
            USDT = None
            return
        w3 = _w3
        USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
    except Exception:
        w3 = None
        USDT = None

_init_web3()

def _auth_headers() -> Dict[str,str]:
    if not BRIDGE_KEY:
        return {}
    if BRIDGE_KEY.startswith("ey"):
        return {"Authorization": f"Bearer {BRIDGE_KEY}"}
    return {"X-Bridge-Key": BRIDGE_KEY}

async def http_json(method: str, url: str, body: dict=None, headers: dict=None, timeout: int=25):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers, timeout=timeout) as r:
            t = await r.text()
            try:
                data = json.loads(t) if t else {}
            except Exception:
                data = {"raw": t}
            return r.status, data

def kv_get(key: str, default: str="0") -> str:
    with SessionLocal() as s:
        row = s.get(Kv, key)
        return row.v if row else default

def kv_set(key: str, val: str):
    with SessionLocal() as s:
        row = s.get(Kv, key)
        if row:
            row.v = val
        else:
            s.add(Kv(k=key, v=val))
        s.commit()

def _require_env(name: str) -> str:
    v = (os.environ.get(name, "") or "").strip()
    if not v:
        raise HTTPException(500, f"{name} not configured")
    return v

def _chain_from(token: str, network: str) -> str:
    n = (network or "").upper()
    if n in ("ETH", "ETHEREUM", "ERC20"):
        return "ETH"
    if n in ("TRON", "TRC20"):
        return "TRON"
    if n in ("BTC", "BITCOIN"):
        return "BTC"
    return n

def _derive_address(chain: str, index: int) -> str:
    chain = chain.upper()
    if chain == "BTC":
        key = _require_env("BTC_XPUB")
        acc = Bip84.FromExtendedKey(key, Bip84Coins.BITCOIN)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    if chain == "ETH":
        key = _require_env("ETH_XPUB")
        acc = Bip44.FromExtendedKey(key, Bip44Coins.ETHEREUM)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    if chain == "TRON":
        key = _require_env("TRON_XPUB")
        acc = Bip44.FromExtendedKey(key, Bip44Coins.TRON)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    raise HTTPException(400, f"unsupported chain: {chain}")

def _next_index(sess, chain: str) -> int:
    q = sess.query(DepositMap).filter(DepositMap.network == chain).order_by(DepositMap.index.desc()).first()
    if not q:
        return 0
    try:
        return int(q.index) + 1
    except Exception:
        return 0

def _get_or_create_addr(rid: str, token: str, network: str) -> str:
    chain = _chain_from(token, network)
    with SessionLocal() as sess:
        row = sess.query(DepositMap).filter(DepositMap.rid == rid, DepositMap.network == chain).first()
        if row:
            return row.address

        for i in range(0, 2048):
            idx = _next_index(sess, chain) + i
            addr = _derive_address(chain, idx)
            obj = DepositMap(rid=rid, token=token, network=chain, index=idx, address=addr, created_at=int(time.time()))
            sess.add(obj)
            try:
                sess.commit()
                return addr
            except IntegrityError:
                sess.rollback()
                row2 = sess.query(DepositMap).filter(DepositMap.rid == rid, DepositMap.network == chain).first()
                if row2:
                    return row2.address
                continue
    raise HTTPException(500, "unable to allocate unique address")

TOKEN_DECIMALS = {"USDT": 6}
def to_base_units(amount_human: str, token: str="USDT") -> int:
    dec = TOKEN_DECIMALS.get((token or "USDT").upper(), 6)
    d = Decimal(str(amount_human).strip())
    if d <= 0:
        raise HTTPException(400, "amount<=0")
    q = Decimal(10) ** Decimal(dec)
    return int((d * q).quantize(Decimal("1"), rounding=ROUND_DOWN))

app = FastAPI(title="wallet-proxy", version="prod")

app.add_middleware(
    CORSMiddleware,
    allow_origins=CORS if CORS != ["*"] else ["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
def root():
    return {"ok": True, "eth_connected": bool(w3)}

@app.get("/metrics")
def metrics():
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

@app.get("/v1/receive/{rid}")
def receive(rid: str):
    rid = (rid or "").strip()
    if not rid:
        raise HTTPException(400, "rid is required")
    addrs = {
        "BTC": _get_or_create_addr(rid, "BTC", "BTC"),
        "ETH": _get_or_create_addr(rid, "ETH", "ETH"),
        "TRON": _get_or_create_addr(rid, "TRON", "TRON"),
        "USDT_ERC20": _get_or_create_addr(rid, "USDT", "ETH"),
        "USDT_TRC20": _get_or_create_addr(rid, "USDT", "TRON"),
    }
    return {"rid": rid, "lgn_rid": rid, "addresses": addrs}

class TopupRequest(BaseModel):
    rid: str
    token: str = "USDT"
    network: str = "ETH"

@app.post("/v1/topup/request")
def topup(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    rid = (req.rid or "").strip()
    if not rid:
        raise HTTPException(400, "rid is required")
    token = (req.token or "USDT").strip()
    network = (req.network or "ETH").strip()
    addr = _get_or_create_addr(rid, token, network)
    return {"rid": rid, "token": token, "network": _chain_from(token, network), "address": addr}

class WithdrawRequest(BaseModel):
    rid: str
    token: str = "USDT"
    network: str = "ETH"
    amount: str
    to_address: str
    request_id: str

@app.get("/v1/withdraw/status/{request_id}")
def wd_status(request_id: str):
    request_id = (request_id or "").strip()
    with SessionLocal() as s:
        row = s.execute(select(WithdrawReq).where(WithdrawReq.request_id == request_id)).scalar_one_or_none()
        if not row:
            raise HTTPException(404, "not found")
        return {"request_id": row.request_id, "status": row.status, "txid": row.txid, "err": row.err}

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        rid = (req.rid or "").strip()
        token = (req.token or "USDT").upper().strip()
        network = _chain_from(token, req.network)
        to_addr = (req.to_address or "").strip()
        request_id = (req.request_id or "").strip()

        if not rid: raise HTTPException(400, "rid is required")
        if not request_id: raise HTTPException(400, "request_id is required")
        if token != "USDT" or network != "ETH":
            raise HTTPException(400, "only USDT on ETH supported")

        # idempotency
        with SessionLocal() as s:
            exist = s.execute(select(WithdrawReq).where(WithdrawReq.request_id == request_id)).scalar_one_or_none()
            if exist:
                return {"ok": exist.status in ("broadcasted","done"), "request_id": request_id, "status": exist.status, "txid": exist.txid, "err": exist.err}
            s.add(WithdrawReq(
                request_id=request_id, rid=rid, token=token, network=network,
                amount=str(req.amount).strip(), to_address=to_addr,
                status="init", created_at=int(time.time()), updated_at=int(time.time())
            ))
            s.commit()

        if not ETH_RPC: raise HTTPException(503, "ETH RPC not configured")
        if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")

        global w3, USDT
        if not w3 or not USDT:
            _init_web3()
        if not w3 or not USDT:
            raise HTTPException(503, "ETH RPC not connected")

        base_units = to_base_units(req.amount, "USDT")

        # redeem on node
        hdr = _auth_headers()
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem",
                                  {"rid": rid, "amount": int(Decimal(str(req.amount))), "request_id": request_id},
                                  hdr)
        if st // 100 != 2:
            with SessionLocal() as s:
                row = s.execute(select(WithdrawReq).where(WithdrawReq.request_id == request_id)).scalar_one()
                row.status = "failed"
                row.err = f"redeem_failed: {st} {data}"
                row.updated_at = int(time.time())
                s.commit()
            raise HTTPException(st, f"bridge redeem failed: {data}")

        with SessionLocal() as s:
            row = s.execute(select(WithdrawReq).where(WithdrawReq.request_id == request_id)).scalar_one()
            row.status = "redeemed"
            row.updated_at = int(time.time())
            s.commit()

        acct = w3.eth.account.from_key(HOT_PK)
        tx = USDT.functions.transfer(Web3.to_checksum_address(to_addr), base_units).build_transaction({
            "chainId": w3.eth.chain_id,
            "from": acct.address,
            "nonce": w3.eth.get_transaction_count(acct.address),
            "gas": ETH_GAS_LIMIT_USDT,
            "maxFeePerGas": w3.to_wei(str(ETH_MAX_FEE_GWEI), "gwei"),
            "maxPriorityFeePerGas": w3.to_wei(str(ETH_PRIORITY_FEE_GWEI), "gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        txid = w3.eth.send_raw_transaction(signed.rawTransaction).hex()

        with SessionLocal() as s:
            row = s.execute(select(WithdrawReq).where(WithdrawReq.request_id == request_id)).scalar_one()
            row.status = "broadcasted"
            row.txid = txid
            row.updated_at = int(time.time())
            s.commit()

        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "request_id": request_id, "txid": txid}

    except HTTPException:
        PROXY_WITHDRAW_ERR.inc()
        raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc()
        raise HTTPException(500, f"withdraw error: {e}")

# deposit scanner оставим в следующем патче (чтобы сейчас стабилизировать API/withdraw)


# ===== PATCH: balances endpoints restore (compat + safe) =====
# Provides:
#   GET /v1/balances/{rid}
#   GET /v1/balance/{rid} (alias)
# Goal: never 404 for these endpoints; return at least addresses.

from fastapi import HTTPException

def _best_effort_addresses(rid: str):
    # 1) reuse existing receive endpoint if present
    try:
        if "receive_addresses" in globals():
            r = globals()["receive_addresses"](rid)
            if isinstance(r, dict) and isinstance(r.get("addresses"), dict):
                return r["addresses"]
    except Exception:
        pass

    # 2) fallback: try internal address generator if present
    try:
        if "_get_or_create_addr" in globals():
            g = globals()["_get_or_create_addr"]
            return {
                "BTC": g(rid, "BTC", "BTC"),
                "ETH": g(rid, "ETH", "ETH"),
                "TRON": g(rid, "TRON", "TRON"),
                "USDT_ERC20": g(rid, "USDT", "ETH"),
                "USDT_TRC20": g(rid, "USDT", "TRON"),
            }
    except Exception:
        pass

    return {}

@app.get("/v1/balances/{rid}")
def balances_compat(rid: str):
    rid = (rid or "").strip()
    if not rid:
        raise HTTPException(status_code=400, detail="rid is required")
    addrs = _best_effort_addresses(rid)
    return {"rid": rid, "addresses": addrs, "balances": {}}

@app.get("/v1/balance/{rid}")
def balance_alias_compat(rid: str):
    return balances_compat(rid)

# ===== END PATCH =====
```

### `/opt/logos/wallet-proxy/init_db.py`

- Size: 1607 bytes
- Lines: 50

```python
import os, sqlite3, sys

def db_path_from_url(url: str) -> str:
    url = (url or "").strip()
    if not url:
        return "/opt/logos/wallet-proxy/wallet_proxy.db"
    if url.startswith("sqlite:////"):
        return url[len("sqlite:////")-1:]  # keep leading /
    if url.startswith("sqlite:///"):
        return url[len("sqlite:///"):]
    if url.startswith("sqlite://"):
        # rare, but handle
        return url.replace("sqlite://", "", 1)
    # not sqlite -> do nothing here
    return ""

DB_URL = os.environ.get("WALLET_PROXY_DB_URL") or os.environ.get("DATABASE_URL") or "sqlite:////opt/logos/wallet-proxy/wallet_proxy.db"
path = db_path_from_url(DB_URL)

if not path:
    print("INFO: non-sqlite DB configured, skip init_db")
    sys.exit(0)

os.makedirs(os.path.dirname(path), exist_ok=True)

con = sqlite3.connect(path)
cur = con.cursor()

cur.execute("""
CREATE TABLE IF NOT EXISTS deposit_map (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  rid TEXT NOT NULL,
  token TEXT NOT NULL,
  network TEXT NOT NULL,
  "index" INTEGER NOT NULL DEFAULT 0,
  address TEXT NOT NULL,
  created_at INTEGER NOT NULL
);
""")

# глобальная уникальность адреса (у тебя это уже требуется по логике)
cur.execute("""CREATE UNIQUE INDEX IF NOT EXISTS ux_deposit_map_address ON deposit_map(address);""")

# чтобы быстро находить по (rid, network) — под ваш SELECT
cur.execute("""CREATE INDEX IF NOT EXISTS ix_deposit_map_rid_network ON deposit_map(rid, network);""")

con.commit()
con.close()

print("OK: init_db done ->", path)
```

### `/opt/logos/wallet-proxy/scanner.py`

- Size: 5538 bytes
- Lines: 126

```python
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())
```

---

## 09_runtime_system



**Roots:**
- `/etc/logos`
- `/opt/logos/bin`

- Files total: **1** (Rust: 0 | Py: 0 | JS/TS: 0 | cfg/sh/sql: 1)
- dirs.txt: `/root/logos_project_map_20260121T113413Z/09_runtime_system/dirs.txt`
- files.txt: `/root/logos_project_map_20260121T113413Z/09_runtime_system/files.txt`


> Runtime/system paths are sensitive; listing only, no content dump.

### Modules (files)

- `/etc/logos/genesis.yaml`

### Module contents

---

## Rust crates in repo

```text
# Rust crates (Cargo.toml roots) — /root/logos_lrb
/root/logos_lrb
/root/logos_lrb/lrb_core
/root/logos_lrb/modules/x_guard
/root/logos_lrb/node
/root/logos_lrb/tools/gen_rid
```


# BOOK 1111 — FULL (no truncation, may be split)

Generated: 2026-01-14 10:58:23Z

---

## INVENTORY: wallet folders present

```text
/opt/logos/www/wallet
/opt/logos/www/wallet_prod
/opt/logos/www/wallet_dev
/opt/logos/www/wallet_premium
/var/www/logos/wallet
/var/www/logos/wallet3
```


## FRONTEND ROOT: /opt/logos/www/wallet

### TREE (depth 3)

```text
index.html
compat.js
app.html.bak_rm_connect_20260101T123446Z
app.js
auth.css
_bak_bridge_20260107T102822Z/app.js
_bak_bridge_20260107T102822Z/app.css
_bak_bridge_20260107T102822Z/app.html
auth.html.bak_rm_connect_20260101T123446Z
_bak_entry_20260107T105554Z/index.html
api_base.js
wallet.css
login.html
auth.html.bak_theme_20260101T135217Z
app.html.bak_directbind_20251223T163240Z
_bak_ui_20260107T101342Z/app.js
_bak_ui_20260107T101342Z/app.css
_bak_ui_20260107T101342Z/app.html
app.css
auth.html
auth.html.bak_connect_20251223T113714Z
app.html
ui.js.bak_nodeapi_20260101T122432Z
app.html.bak_theme_20260101T135217Z
auth.js
auth.html.bak_add_connect_20251223T113731Z
auth.html.bak_directbind_20251223T155358Z
_bak_bridge_20260107T102635Z/app.js
_bak_bridge_20260107T102635Z/app.css
_bak_bridge_20260107T102635Z/app.html
compat.js.bak_nodeapi_20260101T121312Z
connect.js
app.js.bak_nodeapi_20260101T122432Z
_bak_entry_20260108T142703Z/index.html
ui.js
```


### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102635Z/app.css

```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */
```


### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102635Z/app.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->

</body>
</html>
```


### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102635Z/app.js

```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */
```


### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102822Z/app.css

```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */


/* ====== Bridge result box ====== */
.bridgeResult{
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  font-size:12px;
  line-height:1.35;
  white-space:pre-wrap;
}
.bridgeResult.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.bridgeResult.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
/* ====== /Bridge result box ====== */
```


### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102822Z/app.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>
```


### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102822Z/app.js

```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```


### FILE: /opt/logos/www/wallet/_bak_entry_20260107T105554Z/index.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="color-scheme" content="dark"/>
  <link rel="stylesheet" href="./wallet.css?v=30"/>
</head>
<body>
  <!-- Верхняя панель -->
  <header class="topbar">
    <div class="topbar-left">
      <div class="logo-dot"></div>
      <div class="topbar-title">
        <span class="brand">LOGOS</span>
        <span class="product">Wallet</span>
      </div>
    </div>
    <div class="topbar-right">
      <span class="endpoint-label">Endpoint</span>
      <span class="endpoint-value" id="endpoint"></span>
      <button id="btn-lock" class="chip chip-ghost">Выйти</button>
    </div>
  </header>

  <main class="page-shell">
    <header class="page-header">
      <div>
        <h1>LOGOS Wallet — Кошелёк</h1>
        <p class="subtitle">
          Non‑custodial кошелёк: ключи и подписи живут только в этом браузере.
          Никакого серверного хранилища.
        </p>
      </div>
    </header>

    <!-- RID / PUB -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Твой RID / Публичный ключ</h2>
          <p class="card-caption">
            RID — адрес аккаунта в сети LOGOS. Публичный ключ (hex) используется для проверки подписи.
          </p>
        </div>
      </header>
      <div class="card-body">
        <textarea id="pub" class="mono-field" readonly></textarea>
        <p class="hint">
          Ключи живут только в памяти этой вкладки. После выхода или закрытия
          вкладки для доступа к кошельку снова нужен пароль.
        </p>
      </div>
    </section>

    <!-- Баланс -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Баланс</h2>
          <p class="card-caption">
            Проверка баланса и nonce для выбранного RID.
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">RID</span>
          <input id="rid-balance" type="text" class="field-input" placeholder="RID"/>
        </label>

        <div class="actions-row">
          <button id="btn-balance" class="btn primary">Показать баланс</button>
        </div>

        <pre id="out-balance" class="mono-output"></pre>
      </div>
    </section>

    <!-- Подпись и отправка -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Подпись и отправка (batch)</h2>
          <p class="card-caption">
            Подписанная Ed25519 транзакция отправляется в ноду как батч (одна транзакция).
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">Получатель (RID)</span>
          <input id="to" type="text" class="field-input" placeholder="RID получателя"/>
        </label>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Сумма (LGN)</span>
            <input id="amount" type="number" min="0" step="1" class="field-input"/>
          </label>

          <label class="field field-nonce">
            <span class="field-label">Nonce (debug)</span>
            <input id="nonce" type="number" class="field-input"/>
          </label>
        </div>

        <div class="actions-row">
          <button id="btn-send" class="btn primary">Подписать и отправить</button>
          <button id="btn-nonce" class="btn ghost">Получить nonce</button>
        </div>

        <pre id="out-send" class="mono-output"></pre>
      </div>
    </section>

    <!-- Стейкинг -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Стейкинг (delegate / undelegate / claim)</h2>
          <p class="card-caption">
            Управление стейкингом текущего RID: делегирование, раз‑делегирование и заявка наград.
          </p>
        </div>
        <button id="btn-stake-refresh" class="chip chip-ghost">Обновить статус</button>
      </header>
      <div class="card-body">
        <pre id="out-stake" class="mono-output"></pre>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Застейкать (delegate, LGN)</span>
            <input id="stake-amount" type="number" min="0" step="1" class="field-input"/>
          </label>
          <button id="btn-stake-delegate" class="btn primary">Делегировать</button>
        </div>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Разстейкать (undelegate, LGN)</span>
            <input id="unstake-amount" type="number" min="0" step="1" class="field-input"/>
          </label>
          <button id="btn-stake-undelegate" class="btn ghost">Разстейкать</button>
        </div>

        <div class="actions-row">
          <button id="btn-stake-claim" class="btn secondary">Заявить награду (claim)</button>
        </div>
      </div>
    </section>

    <!-- Мост rToken -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Мост rToken (депозит, demo)</h2>
          <p class="card-caption">
            Демонстрационный депозит rLGN через внешний txid.
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">RID</span>
          <input id="rid-bridge" type="text" class="field-input" placeholder="RID для депозита rLGN"/>
        </label>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Сумма (rLGN)</span>
            <input id="amount-bridge" type="number" min="0" step="1" class="field-input"/>
          </label>

          <label class="field grow">
            <span class="field-label">ext_txid (например eth_txid_0xabc)</span>
            <input id="ext" type="text" class="field-input"/>
          </label>
        </div>

        <div class="actions-row">
          <button id="btn-deposit" class="btn primary">Deposit rLGN (demo)</button>
        </div>

        <pre id="out-bridge" class="mono-output"></pre>
      </div>
    </section>
  </main>

  <script src="./app.js?v=1" defer></script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet/_bak_entry_20260108T142703Z/index.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>
```


### FILE: /opt/logos/www/wallet/_bak_ui_20260107T101342Z/app.css

```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}
```


### FILE: /opt/logos/www/wallet/_bak_ui_20260107T101342Z/app.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet/_bak_ui_20260107T101342Z/app.js

```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);
```


### FILE: /opt/logos/www/wallet/api_base.js

```js
(() => {
  const origin = window.location.origin.replace(/\/+$/, "");
  window.LOGOS_WALLET_API = origin + "/wallet-api";
  window.LOGOS_NODE_API   = origin + "/node-api";
})();
```


### FILE: /opt/logos/www/wallet/app.css

```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */


/* ====== Bridge result box ====== */
.bridgeResult{
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  font-size:12px;
  line-height:1.35;
  white-space:pre-wrap;
}
.bridgeResult.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.bridgeResult.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
/* ====== /Bridge result box ====== */
```


### FILE: /opt/logos/www/wallet/app.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>
```


### FILE: /opt/logos/www/wallet/app.js

```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```


### FILE: /opt/logos/www/wallet/auth.css

```css
/* Wallet Auth page tweaks (theme in /shared/wallet-theme.css) */

/* ВАЖНО: hidden управляет видимостью, CSS его не должен ломать */
[hidden]{ display:none !important; }

/* НЕ ставим display:none на эти блоки! */
#listWrap{ margin-top:12px; }
#mnemonicSection{ margin-top:14px; }

#mnemonicShow,#mnemonicConfirm,#restoreMnemonic{ min-height:120px; }

#ridList{
  list-style:none;
  padding:0;
  margin:10px 0 0;
  display:grid;
  gap:8px;
}

#ridList li{
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.22);
  cursor:pointer;
  font-family:var(--mono);
  font-size:12.5px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

#ridList li:hover{
  border-color:rgba(77,163,255,.35);
  background:rgba(0,0,0,.28);
}

#out{ min-height:84px; }
```


### FILE: /opt/logos/www/wallet/auth.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Secure</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./authP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · AES‑GCM + PBKDF2 · Ed25519 via tweetnacl</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">HTTPS only</div>
      </div>
    </div>
  </header>

  <main class="container">
    <section class="card hero">
      <h1>Доступ к кошельку</h1>
      <p class="muted">Ключи живут локально в браузере. Сервер получает только подписанные операции.</p>
    </section>

    <div class="grid-2">
      <section class="card">
        <header class="card__head">
          <h2>Вход</h2>
          <p class="muted">Если RID уже есть на этом устройстве — вход по паролю.</p>
        </header>

        <label for="loginRid">RID</label>
        <input id="loginRid" class="mono" placeholder="RID (base58) или выбери ниже" autocomplete="off"/>

        <label for="loginPass">Пароль</label>
        <input id="loginPass" type="password" placeholder="Пароль, которым шифровали ключ" autocomplete="current-password"/>

        <div class="row">
          <button id="btn-login" class="primary" type="button">Войти по RID + пароль</button>
          <button id="btn-list" type="button">Показать сохранённые RID</button>
        </div>

        <div id="listWrap" hidden>
          <div class="muted">Локально сохранённые RID (кликни, чтобы подставить):</div>
          <ul id="ridList"></ul>
        </div>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Создать новый</h2>
          <p class="muted">Ключ генерируется в браузере. Запиши 16 слов — это единственный способ восстановления.</p>
        </header>

        <label for="createPass">Новый пароль</label>
        <input id="createPass" type="password" placeholder="Минимум 10 символов, буквы + цифры" autocomplete="new-password"/>

        <div class="row">
          <button id="btn-create" class="primary" type="button">Создать новый RID + фразу</button>
        </div>

        <div id="mnemonicSection" hidden>
          <h3>Резервная фраза (16 слов)</h3>

          <label for="mnemonicShow">Фраза (только чтение)</label>
          <textarea id="mnemonicShow" class="mono" readonly spellcheck="false"></textarea>

          <label for="mnemonicConfirm">Повтори фразу для проверки ещё раз</label>
          <textarea id="mnemonicConfirm" class="mono" placeholder="введите те же 16 слов через пробел" spellcheck="false"></textarea>

          <div class="row">
            <button id="btn-mnemonic-ok" class="primary" type="button">Я записал фразу, перейти в кошелёк</button>
          </div>
        </div>
      </section>
    </div>

    <section class="card">
      <header class="card__head">
        <h2>Восстановить по фразе</h2>
        <p class="muted">Вводишь 16 слов и задаёшь новый пароль. RID восстановится автоматически.</p>
      </header>

      <label for="restoreMnemonic">Резервная фраза (16 слов)</label>
      <textarea id="restoreMnemonic" class="mono" placeholder="16 слов через пробел" spellcheck="false"></textarea>

      <label for="restorePass">Новый пароль</label>
      <input id="restorePass" type="password" placeholder="Минимум 10 символов, буквы + цифры" autocomplete="new-password"/>

      <div class="row">
        <button id="btn-restore" class="primary" type="button">Восстановить кошелёк</button>
      </div>
    </section>

    <section class="card">
      <header class="card__head">
        <h2>Сервис</h2>
        <p class="muted">Сброс локальных аккаунтов доступен только на localhost (dev).</p>
      </header>
      <div class="row">
        <button id="btn-reset" class="danger" type="button" hidden>Сбросить локальные аккаунты (DEV)</button>
      </div>
      <pre id="out" class="mono">Статус: жду действий…</pre>
    </section>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./auth.js?v=20251212_04" defer></script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet/auth.js

```js
/* connect hook: remember challenge if opened from airdrop */
(() => {
  try {
    const q = new URLSearchParams(location.search);
    if (q.get("connect") === "1") {
      const ch = (q.get("challenge") || "").trim();
      if (ch) sessionStorage.setItem("logos_connect_challenge", ch);
      sessionStorage.setItem("logos_connect_mode", "1");
    }
  } catch (e) {}
})();
'use strict';

// AUTH (mainnet-grade):
// - AES-GCM + PBKDF2 (WebCrypto)
// - Ed25519 via tweetnacl (НЕ зависит от WebCrypto Ed25519)
// - хранение: IndexedDB, зашифрованный PKCS8 (RFC8410 prefix + seed32)
// - CSP-safe: без inline handlers и без element.style

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc     = new TextEncoder();
const ALPH    = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

const MN_WORDS = 16;
const MN_ALPH  = 'abcdefghjkmnpqrstuvwxyz';

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);
const out = (msg) => { const el = $('#out'); if (el) el.textContent = String(msg); };

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function normRid(s) { return (s || '').replace(/\s+/g, '').trim(); }
function normalizeMnemonic(s) { return (s || '').trim().toLowerCase().replace(/\s+/g, ' '); }

function b58encode(bytes) {
  const src = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes || []);
  if (src.length === 0) return '';
  const digits = [0];
  for (let i = 0; i < src.length; i++) {
    let carry = src[i];
    for (let j = 0; j < digits.length; j++) {
      carry += digits[j] << 8;
      digits[j] = carry % 58;
      carry = (carry / 58) | 0;
    }
    while (carry) {
      digits.push(carry % 58);
      carry = (carry / 58) | 0;
    }
  }
  let out = '';
  for (let k = 0; k < src.length && src[k] === 0; k++) out += ALPH[0];
  for (let q = digits.length - 1; q >= 0; q--) out += ALPH[digits[q]];
  return out;
}

function validateNewPassword(pass) {
  if (!pass || pass.length < 10) throw new Error('Пароль ≥10 символов');
  if (!/[A-Za-z]/.test(pass) || !/[0-9]/.test(pass)) throw new Error('Пароль должен содержать буквы и цифры');
  return pass;
}
function ensureLoginPassword(pass) {
  if (!pass || pass.length < 6) throw new Error('Пароль ≥6 символов');
  return pass;
}

async function sha256Bytes(str) {
  const digest = await crypto.subtle.digest('SHA-256', enc.encode(str));
  return new Uint8Array(digest);
}

function randomWord(len = 5) {
  const buf = new Uint8Array(len);
  crypto.getRandomValues(buf);
  let w = '';
  for (let i = 0; i < len; i++) w += MN_ALPH[buf[i] % MN_ALPH.length];
  return w;
}
function generateMnemonic() {
  const words = [];
  for (let i = 0; i < MN_WORDS; i++) words.push(randomWord());
  return words.join(' ');
}

async function mnemonicToSeed(mnemonic) {
  const norm = normalizeMnemonic(mnemonic);
  if (!norm) throw new Error('Резервная фраза пуста');
  return sha256Bytes('logos-lrb-ed25519:' + norm); // 32 bytes
}

function buildPkcs8FromSeed(seed32) {
  if (!(seed32 instanceof Uint8Array) || seed32.length !== 32) throw new Error('seed должен быть 32 байта');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed32, ED25519_PKCS8_PREFIX.length);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

async function deriveKey(pass, saltU8) {
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt: saltU8, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}

async function aesEncrypt(aesKey, plainU8) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = new Uint8Array(await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, plainU8));
  return { iv, ct };
}

async function aesDecrypt(aesKey, ivU8, ctU8) {
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

// ---------- IndexedDB ----------
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}
async function idbSet(key, val) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = () => resolve();
    r.onerror = () => reject(r.error);
  });
}
async function idbDel(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.delete(key);
    r.onsuccess = () => resolve();
    r.onerror = () => reject(r.error);
  });
}

async function listAccounts() { return (await idbGet('accounts')) || []; }
async function addAccount(rid) {
  const list = (await idbGet('accounts')) || [];
  if (!list.includes(rid)) {
    list.push(rid);
    await idbSet('accounts', list);
  }
}

// Pending state
let pendingRid = null;
let pendingMnemonic = null;

async function createAccount(passRaw) {
  ensureEnv();
  const pass = validateNewPassword(passRaw);

  out('Создаём ключ и фразу…');

  const mnemonic = generateMnemonic();
  const seed = await mnemonicToSeed(mnemonic);
  const pkcs8 = buildPkcs8FromSeed(seed);

  const kp = nacl.sign.keyPair.fromSeed(seed);
  const pub = new Uint8Array(kp.publicKey);
  const rid = b58encode(pub);

  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt);
  const { iv, ct } = await aesEncrypt(aes, pkcs8);

  const meta = {
    rid,
    pub: Array.from(pub),
    salt: Array.from(salt),
    iv: Array.from(iv),
    priv: Array.from(ct),
  };

  await idbSet('acct:' + rid, meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass', pass);
  sessionStorage.setItem('logos_rid', rid);

  pendingRid = rid;
  pendingMnemonic = mnemonic;

  const sec = $('#mnemonicSection');
  const disp = $('#mnemonicShow');
  const confirm = $('#mnemonicConfirm');
  if (sec && disp && confirm) {
    disp.value = mnemonic;
    confirm.value = '';
    sec.hidden = false;
    sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  out('RID создан: ' + rid + '. Запиши фразу и подтверди её.');
}

async function loginAccount(ridRaw, passRaw) {
  ensureEnv();
  const rid = normRid(ridRaw);
  const pass = ensureLoginPassword(passRaw);
  if (!rid) throw new Error('Укажи RID');

  const meta = await idbGet('acct:' + rid);
  if (!meta) {
    const list = await listAccounts();
    throw new Error('RID не найден на этом устройстве.\n' + (list.length ? list.join('\n') : '— пусто —'));
  }

  const aes = await deriveKey(pass, new Uint8Array(meta.salt || []));
  try {
    const pkcs8 = await aesDecrypt(aes, new Uint8Array(meta.iv || []), new Uint8Array(meta.priv || []));
    // проверим, что это действительно наш PKCS8 (совместимость/коррупция)
    extractSeedFromPkcs8(pkcs8);
  } catch (_) {
    throw new Error('Неверный пароль или повреждённый ключ');
  }

  sessionStorage.setItem('logos_pass', pass);
  sessionStorage.setItem('logos_rid', rid);
  await idbSet('last_rid', rid);

  out('Вход…');
  location.href = './app.html';
}

async function restoreAccount(mnemonicRaw, passRaw) {
  ensureEnv();
  const pass = validateNewPassword(passRaw);
  const mnemonic = normalizeMnemonic(mnemonicRaw);
  if (!mnemonic) throw new Error('Введи резервную фразу');

  out('Восстанавливаем кошелёк…');

  const seed = await mnemonicToSeed(mnemonic);
  const pkcs8 = buildPkcs8FromSeed(seed);

  const kp = nacl.sign.keyPair.fromSeed(seed);
  const pub = new Uint8Array(kp.publicKey);
  const rid = b58encode(pub);

  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt);
  const { iv, ct } = await aesEncrypt(aes, pkcs8);

  const meta = {
    rid,
    pub: Array.from(pub),
    salt: Array.from(salt),
    iv: Array.from(iv),
    priv: Array.from(ct),
  };

  await idbSet('acct:' + rid, meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass', pass);
  sessionStorage.setItem('logos_rid', rid);

  out('Кошелёк восстановлен: ' + rid + ' → вход…');
  location.href = './app.html';
}

async function resetAll() {
  const ok = confirm('Точно стереть все локальные аккаунты? Это нельзя отменить.');
  if (!ok) return;
  const list = await listAccounts();
  for (const rid of list) await idbDel('acct:' + rid);
  await idbDel('accounts');
  await idbDel('last_rid');
  sessionStorage.clear();
  pendingRid = null;
  pendingMnemonic = null;
  out('Все аккаунты удалены.');
}

function renderRidList(list) {
  const wrap = $('#listWrap');
  const ul = $('#ridList');
  if (!wrap || !ul) return;
  ul.innerHTML = '';
  wrap.hidden = false;

  if (!list.length) {
    const li = document.createElement('li');
    li.textContent = '— пусто —';
    ul.appendChild(li);
    return;
  }

  for (const rid of list) {
    const li = document.createElement('li');
    li.textContent = rid;
    li.addEventListener('click', () => {
      const inp = $('#loginRid');
      if (inp) inp.value = rid;
      out('RID подставлен');
    });
    ul.appendChild(li);
  }
}

// boot helpers
(async () => {
  try {
    // last_rid
    const last = await idbGet('last_rid');
    const loginRid = $('#loginRid');
    if (last && loginRid) loginRid.value = last;

    // DEV reset only on localhost
    const resetBtn = $('#btn-reset');
    if (resetBtn) {
      const isDevHost = (location.hostname === 'localhost' || location.hostname === '127.0.0.1');
      resetBtn.hidden = !isDevHost;
    }
  } catch (e) {
    console.error(e);
  }
})();

// UI wiring
$('#btn-login')?.addEventListener('click', async () => {
  try {
    await loginAccount($('#loginRid')?.value || '', $('#loginPass')?.value || '');
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});

$('#btn-create')?.addEventListener('click', async () => {
  try {
    await createAccount($('#createPass')?.value || '');
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});

$('#btn-list')?.addEventListener('click', async () => {
  try {
    renderRidList(await listAccounts());
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});

$('#btn-reset')?.addEventListener('click', async () => {
  const isDevHost = (location.hostname === 'localhost' || location.hostname === '127.0.0.1');
  if (!isDevHost) {
    out('ERR: reset доступен только на localhost (dev)');
    return;
  }
  try {
    await resetAll();
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});

$('#btn-mnemonic-ok')?.addEventListener('click', () => {
  if (!pendingRid || !pendingMnemonic) {
    out('Нет созданного кошелька для подтверждения');
    return;
  }
  const typed = normalizeMnemonic($('#mnemonicConfirm')?.value || '');
  if (!typed) { out('Повтори фразу для подтверждения'); return; }
  if (typed !== normalizeMnemonic(pendingMnemonic)) { out('Фразы не совпадают'); return; }
  out('Фраза подтверждена, вход…');
  location.href = './app.html';
});

$('#btn-restore')?.addEventListener('click', async () => {
  try {
    await restoreAccount($('#restoreMnemonic')?.value || '', $('#restorePass')?.value || '');
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});
```


### FILE: /opt/logos/www/wallet/compat.js

```js
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```


### FILE: /opt/logos/www/wallet/connect.js

```js
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```


### FILE: /opt/logos/www/wallet/index.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>
```


### FILE: /opt/logos/www/wallet/login.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="refresh" content="0; url=./auth.html"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
</head>
<body>
  <p>Redirect to <a href="./auth.html">auth.html</a>…</p>
</body>
</html>
```


### FILE: /opt/logos/www/wallet/ui.js

```js
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```


### FILE: /opt/logos/www/wallet/wallet.css

```css
:root {
  --bg: #050910;
  --bg-grad-1: rgba(56,189,248,0.18);
  --bg-grad-2: rgba(129,140,248,0.20);

  --card: #020617;
  --card-alt: #020617;

  --border-subtle: rgba(148,163,184,0.30);
  --border-strong: rgba(148,163,184,0.65);

  --accent: #3b82f6;
  --accent-soft: rgba(59,130,246,0.16);
  --accent-strong: #60a5fa;

  --danger: #f97373;

  --text-main: #e5e7eb;
  --text-muted: #9ca3af;

  --radius-card: 20px;
  --radius-sm: 10px;

  --shadow-soft: 0 24px 60px rgba(0,0,0,0.75);

  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
           "Liberation Mono", "Courier New", monospace;
}

/* базовые */

*,
*::before,
*::after {
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
               Roboto, sans-serif;
  background:
    radial-gradient(circle at top left, var(--bg-grad-1), transparent 58%),
    radial-gradient(circle at bottom right, var(--bg-grad-2), transparent 55%),
    var(--bg);
  color: var(--text-main);
  min-height: 100vh;
}

/* верхняя панель */

.topbar {
  position: sticky;
  top: 0;
  z-index: 40;
  background: linear-gradient(95deg, rgba(15,23,42,0.98), rgba(15,23,42,0.96));
  backdrop-filter: blur(16px);
  border-bottom: 1px solid rgba(148,163,184,0.18);
  box-shadow: 0 18px 40px rgba(0,0,0,0.65);
  padding: 10px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.topbar-left {
  display: flex;
  align-items: center;
  gap: 10px;
}

.logo-dot {
  width: 26px;
  height: 26px;
  border-radius: 999px;
  background: radial-gradient(circle at 30% 30%, #22d3ee, #6366f1);
  box-shadow: 0 0 20px rgba(56,189,248,0.55);
}

.topbar-title {
  display: flex;
  flex-direction: column;
  line-height: 1.1;
}

.topbar-title .brand {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  color: #e5e7eb;
}

.topbar-title .product {
  font-size: 13px;
  color: var(--text-muted);
}

.topbar-right {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
}

.endpoint-label {
  color: var(--text-muted);
}

.endpoint-value {
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.9);
}

/* общая раскладка */

.page-shell {
  max-width: 1040px;
  margin: 0 auto;
  padding: 18px 16px 40px;
}

.page-header {
  margin-bottom: 18px;
}

.page-header h1 {
  font-size: 22px;
  margin: 0 0 6px;
}

.subtitle {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

/* карточки */

.card {
  background: radial-gradient(circle at top left, rgba(56,189,248,0.10), transparent 55%),
              var(--card);
  border-radius: var(--radius-card);
  border: 1px solid var(--border-subtle);
  box-shadow: var(--shadow-soft);
  margin-bottom: 18px;
  overflow: hidden;
}

.card-header {
  padding: 14px 18px 10px;
  border-bottom: 1px solid rgba(15,23,42,0.9);
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.card-title {
  font-size: 16px;
  margin: 0 0 4px;
}

.card-caption {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

.card-body {
  padding: 14px 18px 16px;
}

/* поля */

.field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 12px;
}

.field-row {
  display: flex;
  gap: 10px;
  align-items: flex-end;
  margin-bottom: 12px;
}

.field-row .grow {
  flex: 1 1 auto;
}

.field-label {
  font-size: 12px;
  color: var(--text-muted);
}

.field-input {
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.95);
  color: var(--text-main);
  padding: 8px 10px;
  font-size: 14px;
  outline: none;
}

.field-input:focus {
  border-color: var(--accent-strong);
  box-shadow: 0 0 0 1px rgba(59,130,246,0.55);
}

/* текстовые выводы */

.mono-field,
.mono-output {
  width: 100%;
  font-family: var(--mono);
  font-size: 13px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(2,6,23,0.96);
  color: var(--text-main);
  padding: 10px 12px;
  resize: vertical;
  min-height: 80px;
  white-space: pre-wrap;
}

.mono-output {
  margin-top: 8px;
}

/* кнопки */

.actions-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 6px;
  margin-bottom: 6px;
}

.btn {
  border-radius: 999px;
  border: 1px solid transparent;
  padding: 7px 14px;
  font-size: 13px;
  cursor: pointer;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.btn.primary {
  background: linear-gradient(135deg, #2563eb, #3b82f6);
  border-color: rgba(59,130,246,0.8);
  color: #fff;
}

.btn.primary:hover {
  background: linear-gradient(135deg, #1d4ed8, #2563eb);
}

.btn.secondary {
  background: rgba(15,23,42,0.95);
  border-color: var(--border-strong);
  color: var(--text-main);
}

.btn.secondary:hover {
  border-color: var(--accent-strong);
}

.btn.ghost {
  background: transparent;
  border-color: var(--border-subtle);
  color: var(--text-muted);
}

.btn.ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* чипы */

.chip {
  padding: 5px 10px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.92);
  font-size: 12px;
  color: var(--text-muted);
  cursor: pointer;
}

.chip-ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* подсказки */

.hint {
  margin-top: 8px;
  font-size: 12px;
  color: var(--text-muted);
}

/* адаптив */

@media (max-width: 720px) {
  .topbar {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }

  .field-row {
    flex-direction: column;
    align-items: stretch;
  }

  .page-shell {
    padding: 14px 10px 32px;
  }
}
```


## FRONTEND ROOT: /opt/logos/www/wallet_prod

### TREE (depth 3)

```text
assets.js
index.html
app.html.bak_defer_20260113T144828Z
compat.js
app.js
auth.js.bak_fullreplace_20260114T073738Z
auth.css
modules/send.js.bak_broken_20260113T153553Z
modules/send.js.bak_broken_20260113T153640Z
modules/lgn_send.js.bak_seed_20260114T073821Z
modules/lgn_send.js.bak_fix_20260113T173041Z
modules/send.js.bak_20260113T150254Z
modules/tx_redirect.js
modules/lgn_send.js
modules/lgn_send.js.bad_20260113T164615Z
modules/settings.js
modules/lgn_send.js.bak_fix_20260113T171032Z
modules/settings.js.bak_clear_20260113T144947Z
modules/lgn_send.js.bak_fix_20260113T163514Z
modules/lgn_send.js.bak_20260113T161920Z
modules/send.js
auth.js.bak_bip39lite_patch_20260114T092639Z
app.html.bak_lgn_script_20260113T161416Z
app.html.bak_ridfix_20260114T082058Z
auth.js.bak_bip39fix_20260114T083232Z
auth.js.bak_fix_syntax_20260114T095429Z
index.html.bak_20260114T073703Z
api_base.js
auth.js.bak_seed_ui_20260114T102523Z
auth.js.bak_20260113T164701Z
auth.html.bak_seed_ui_20260114T102523Z
wallet.css
login.html
ui.css
auth.html.bad_20260114T075205Z
auth.html.bak_clean_20260114T095410Z
app.css
auth.html
app.html
auth.html.bak_fix_bip39lite_20260114T090446Z
auth.js.bak_profiles_20260114T071654Z
auth.html.bak_bip39lite_20260114T084844Z
vendor/wordlist_en.js
vendor/bip39_lite.js.bak_20260114T092555Z
vendor/bip39_lite.js.bak_20260114T100204Z
vendor/nacl-fast.min.js
vendor/bip39_english.txt
vendor/bip39_lite.js
auth.css.bak_seed_ui_20260114T102523Z
auth.html.bak_bip39loader_20260114T083924Z
auth.js.bak_keysfix_20260113T173340Z
auth.html.bak_fix_loader_20260114T080919Z
auth.js
auth.html.bak_add_bip39lite_20260114T100145Z
auth.js.bak_fix_ed25519_20260114T065333Z
connect.js
auth.js.bak_keypersist_20260113T163557Z
auth.html.bak_20260114T073719Z
app.html.bak_seed_20260114T073805Z
tabs.js
auth.html.bak_bip39_20260114T083211Z
auth.css.bad_20260114T075224Z
app.html.bak_lgn_ui_20260113T160813Z
ui.js
app.js.bak_sendfix_20260114T084901Z
```


### FILE: /opt/logos/www/wallet_prod/api_base.js

```js
/* LOGOS Wallet routes (same-origin). No inline scripts. */
(function(){
  // node backend
  window.API_BASE = "/api";
  // wallet proxy
  window.WALLET_API = "/wallet-api";
})();
```


### FILE: /opt/logos/www/wallet_prod/app.css

```css
:root{
  --bg:#070a12; --txt:#e7ecff; --mut:#9aa7d9;
  --br:rgba(255,255,255,.10); --br2:rgba(255,255,255,.16);
  --acc:#6f7bff; --acc2:#9b5cff;
  --ok:#2dd4bf; --bad:#fb7185;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background:
    radial-gradient(1200px 700px at 20% 0%, rgba(111,123,255,.18), transparent 60%),
    radial-gradient(900px 600px at 80% 10%, rgba(155,92,255,.14), transparent 55%),
    linear-gradient(180deg, #050812, var(--bg));
  color:var(--txt);
}
.mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
.wrap{max-width:1240px;margin:26px auto;padding:0 16px}
.card{
  background: linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.02));
  border:1px solid var(--br);
  border-radius:18px;
  padding:18px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  backdrop-filter: blur(10px);
}
.topbar{
  display:flex;align-items:center;justify-content:space-between;
  padding:14px 16px;border-bottom:1px solid var(--br);
  background: rgba(0,0,0,.25);
  position:sticky;top:0;z-index:10;
  backdrop-filter: blur(12px);
}
.brand{font-weight:800;letter-spacing:.4px}
.topbar-right{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
.pill{
  border:1px solid var(--br2);
  padding:6px 10px;border-radius:999px;
  background: rgba(0,0,0,.25);
  font-size:12px;
}
.h1{font-size:20px;font-weight:800;margin:10px 0 6px}
.h2{font-size:16px;font-weight:800;margin:0 0 8px}
.muted{color:var(--mut);font-size:12px;line-height:1.35}
label{font-size:12px;color:var(--mut)}
input, select, textarea{
  width:100%;
  padding:12px 12px;
  border-radius:14px;
  border:1px solid var(--br);
  background: rgba(0,0,0,.28);
  color:var(--txt);
  outline:none;
}
textarea{min-height:92px;resize:vertical}
input:focus, select:focus, textarea:focus{border-color:rgba(111,123,255,.55)}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
.btn{
  border:1px solid var(--br2);
  background: rgba(0,0,0,.22);
  color:var(--txt);
  padding:10px 12px;
  border-radius:14px;
  cursor:pointer;
  user-select:none;
}
.btn.small{padding:8px 10px;border-radius:12px;font-size:12px}
.btn.primary{
  border-color: rgba(111,123,255,.55);
  background: linear-gradient(135deg, rgba(111,123,255,.35), rgba(155,92,255,.25));
}
.btn.danger{
  border-color: rgba(251,113,133,.55);
  background: rgba(251,113,133,.12);
}
.status{margin-top:10px;color:var(--mut);font-size:12px;min-height:16px}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
@media (max-width: 980px){.grid{grid-template-columns:1fr}}
.big-num{font-size:30px;font-weight:900;letter-spacing:.4px}
.pre{white-space:pre-wrap;word-break:break-word;background:rgba(0,0,0,.24);border:1px solid var(--br);padding:12px;border-radius:14px;color:var(--txt)}
details{margin-top:10px}

.tabs{
  display:flex;gap:10px;flex-wrap:wrap;
  margin:14px 0 16px;
}
.tab{
  border:1px solid var(--br2);
  background: rgba(0,0,0,.18);
  padding:10px 14px;border-radius:999px;
  cursor:pointer;
  font-size:13px;
}
.tab.active{
  border-color: rgba(111,123,255,.55);
  background: linear-gradient(135deg, rgba(111,123,255,.22), rgba(155,92,255,.16));
}
.panel{display:none}
.panel.active{display:block}
.kv{
  display:grid;grid-template-columns: 1fr auto;gap:10px;align-items:center;
  padding:10px;border:1px solid var(--br);border-radius:14px;background:rgba(0,0,0,.18);
  margin-top:10px;
}
.kv .k{color:var(--mut);font-size:12px}
.kv .v{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:12px; overflow-wrap:anywhere}
.badge-ok{color:var(--ok)}
.badge-bad{color:var(--bad)}

/* ===== Settings module helpers ===== */
.devOnly { display:none !important; }
.dev .devOnly { display:block !important; }

.kvRow{
  display:flex; align-items:center; justify-content:space-between;
  gap:12px;
  padding:10px 12px;
  border:1px solid rgba(255,255,255,.06);
  border-radius:12px;
  background: rgba(0,0,0,.10);
}
.btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
.btn.danger{ border-color: rgba(255,107,107,.6); }
.btn.danger:hover{ filter:brightness(1.08); }

/* switch */
.switch{ position:relative; display:inline-block; width:44px; height:24px; }
.switch input{ opacity:0; width:0; height:0; }
.slider{
  position:absolute; cursor:pointer; inset:0;
  background: rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.10);
  transition:.2s;
  border-radius:999px;
}
.slider:before{
  position:absolute; content:"";
  height:18px; width:18px; left:3px; top:50%;
  transform: translateY(-50%);
  background: rgba(255,255,255,.85);
  transition:.2s;
  border-radius:999px;
}
.switch input:checked + .slider{
  background: rgba(120,110,255,.35);
  border-color: rgba(120,110,255,.55);
}
.switch input:checked + .slider:before{
  transform: translateY(-50%) translateX(20px);
}

/* ===== Send module helpers ===== */
.grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
@media (max-width: 780px){ .grid2{ grid-template-columns:1fr; } }
.btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
```


### FILE: /opt/logos/www/wallet_prod/app.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LOGOS Wallet</title>
  <script src="./api_base.js?v=1"></script>
  <link rel="stylesheet" href="./app.css?v=20260111_110230" />
</head>
<body>
  <div class="topbar">
    <div class="brand">LOGOS Wallet</div>
    <div class="topbar-right">
      <div class="pill">API: <span id="api" class="mono">/api</span></div>
      <div class="pill">RID: <span id="topRid" class="mono">—</span></div>
      <div class="pill">LGN: <span id="topBal" class="mono">—</span></div>
      <button id="btnLogout" class="btn small">Выйти</button>
    </div>
  </div>

  <div class="wrap">

    <div class="tabs">
      <div class="tab active" data-tab="assets">Активы</div>
      <div class="tab" data-tab="send">Отправка</div>
      <div class="tab" data-tab="staking">Стейкинг</div>
      <div class="tab" data-tab="bridge">Bridge</div>
      <div class="tab" data-tab="settings">Настройки</div>
    </div>

    <!-- ASSETS -->
    <div class="panel active" id="panel-assets">
      <div class="grid">
        <div class="card">
          <div class="h2">RID / Identity</div>
          <div class="muted">Это твой резонансный адрес. Сервер видит только подпись.</div>

          <label style="margin-top:10px">RID</label>
          <input id="rid" class="mono" readonly />

          <div class="row">
            <button id="btnCopyRid" class="btn">Copy</button>
            <button id="btnRefresh" class="btn primary">Refresh LOGOS</button>
            <span id="netBadge" class="muted"></span>
          </div>

          <div id="status" class="status"></div>
        </div>

        <div class="card">
          <div class="h2">Portfolio</div>
          <div class="muted">LOGOS (LGN) — баланс в сети.</div>

          <div style="margin-top:10px">
            <div class="big-num mono" id="balLgn">—</div>
            <div class="muted mono" id="balMicro">—</div>
          </div>

          <div class="row">
            <div class="pill">nonce: <span id="nonce" class="mono">—</span></div>
            <div class="pill">latency: <span id="lat" class="mono">—</span></div>
          </div>

          <details>
            <summary>Details (raw)</summary>
            <pre id="rawNode" class="pre"></pre>
          </details>
        </div>
      </div>

      <div class="grid" style="margin-top:16px">
        <div class="card">
          <div class="h2">Receive addresses</div>
          <div class="muted">BTC/ETH/TRON/USDT адреса закреплены за RID (wallet-api).</div>
          <div id="recvBox"></div>

          <details>
            <summary>Details (wallet-api raw)</summary>
            <pre id="rawRecv" class="pre"></pre>
          </details>
        </div>

        <div class="card">
          <div class="h2">External balances</div>
          <div class="muted">Баланс внешних сетей (wallet-api).</div>
          <div id="extBalBox"></div>

          <details>
            <summary>Details (wallet-api raw)</summary>
            <pre id="rawExt" class="pre"></pre>
          </details>
        </div>
      </div>
    </div>

    <!-- SEND -->
    <div class="panel" id="panel-send">
      <div class="grid">
        <div class="card">
          <div class="h2">Withdraw (USDT)</div>
          <div class="muted">Отправка через wallet-api /v1/withdraw (по OpenAPI: USDT + ETH).</div>

          <label style="margin-top:10px">Network</label>
          <select id="wdNetwork">
            <option value="ETH">ETH</option>
          </select>

          <label style="margin-top:10px">Amount (integer)</label>
          <input id="wdAmount" class="mono" placeholder="например 100" />

          <label style="margin-top:10px">To address</label>
          <input id="wdTo" class="mono" placeholder="0x... или другое" />

          <div class="row">
            <button id="btnWithdraw" class="btn primary">Send</button>
            <button id="btnWithdrawClear" class="btn">Clear</button>
          </div>

          <div id="wdStatus" class="status"></div>

          <details>
            <summary>Response</summary>
            <pre id="wdRaw" class="pre"></pre>
          </details>
        </div>

        <div class="card">
          <div class="h2">LOGOS transfer</div>
          <div class="muted">Отправка LGN внутри сети LOGOS (node-api /submit_tx).</div>

<div style="margin-top:12px;display:grid;gap:10px">
  <label>To RID</label>
  <input id="lgnTo" class="mono" placeholder="RID получателя..." autocomplete="off" />

  <label>Amount (LGN)</label>
  <input id="lgnAmount" class="mono" placeholder="например 1.25" inputmode="decimal" autocomplete="off" />

  <div class="row">
    <button id="btnLgnSend" class="btn primary" type="button">Send LGN</button>
    <button id="btnLgnClear" class="btn" type="button">Clear</button>
    <button id="btnLgnDetails" class="btn" type="button">Details (raw)</button>
  </div>

  <div id="lgnStatus" class="status"></div>
  <pre id="lgnRaw" class="mono" style="display:none;white-space:pre-wrap"></pre>
</div>
        </div>
      </div>
    </div>

    <!-- STAKING -->
    <div class="panel" id="panel-staking">
      <div class="card">
        <div class="h2">Staking</div>
        <div class="muted">
          Вкладка готова по UI. Чтобы она была “не пустая”, нужен backend endpoint стейкинга (stake/unstake/apy).
          Дай API — подключу. Пока не выдумываю, чтобы не было лжи и “пустых кнопок”.
        </div>
      </div>
    </div>

    <!-- BRIDGE -->
    <div class="panel" id="panel-bridge">
  <div id="bridgeRoot"></div>

      <div class="grid">
        <div class="card">
          <div class="h2">Topup address</div>
          <div class="muted">Получить адрес для пополнения (wallet-api /v1/topup/request).</div>

          <label style="margin-top:10px">Network</label>
          <select id="topNetwork">
            <option value="ETH">ETH</option>
          </select>

          <div class="row">
            <button id="btnTopup" class="btn primary">Get address</button>
          </div>

          <div id="topupStatus" class="status"></div>
          <div id="topupBox"></div>
        </div>

        <div class="card">
          <div class="h2">Quote</div>
          <div class="muted">Расчёт курса (wallet-api /v1/quote). amount — integer.</div>

          <label style="margin-top:10px">From</label>
          <input id="qFrom" class="mono" value="USDT" />

          <label style="margin-top:10px">To</label>
          <input id="qTo" class="mono" value="LGN" />

          <label style="margin-top:10px">Amount</label>
          <input id="qAmount" class="mono" placeholder="например 100" />

          <div class="row">
            <button id="btnQuote" class="btn primary">Get quote</button>
          </div>

          <div id="qStatus" class="status"></div>

          <details>
            <summary>Response</summary>
            <pre id="qRaw" class="pre"></pre>
          </details>
        </div>
      </div>
    </div>

    <!-- SETTINGS -->
    <div class="panel" id="panel-settings">
      <div class="grid">
        <div class="card">
          <div class="h2">Local storage</div>
          <div class="muted">RID и пароль хранятся локально в браузере.</div>

          <div class="row">
            <button id="btnShowLocal" class="btn">Show RID</button>
            <button id="btnClearLocal" class="btn danger">Clear local keys</button>
          </div>

          <div id="setStatus" class="status"></div>
        </div>

        <div class="card">
          <div class="h2">Endpoints</div>
          <div class="muted mono">API_BASE = /api, WALLET_API = /wallet-api</div>
        </div>
      </div>
    </div>

  </div>

  <script src="./app.js?v=20260112_084410" defer></script>
<script src="modules/settings.js?v=20260111_172540" defer></script>
  <script src="modules/tx_redirect.js?v=20260112_070814" defer></script>
<script src="modules/send.js?v=20260113_153723" defer></script>
<script src="/wallet/modules/lgn_send.js?v=20260113161416"></script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_prod/app.js

```js
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }

  function clearSessionPass(){
    try{
      sessionStorage.removeItem("PASS");
      sessionStorage.removeItem("logos_pass");
    }catch(e){}
  }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();



/* ========= SEND LGN MODULE (v2, sig_hex) ========= */
(() => {
  const NODE_API = (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");

  function q(sel, root=document){ return root.querySelector(sel); }
  function qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function utf8(s){ return new TextEncoder().encode(String(s)); }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++){
      out += u8[i].toString(16).padStart(2,"0");
    }
    return out;
  }

  function hexToU8(h){
    h = (h||"").trim().replace(/^0x/,"");
    if (!h || (h.length % 2)) return null;
    const u = new Uint8Array(h.length/2);
    for (let i=0;i<u.length;i++) u[i] = parseInt(h.substr(i*2,2),16);
    return u;
  }

  function getRID(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || "";
  }

  // пытаемся найти private Ed25519 JWK в localStorage (если ключи хранятся так)
  function findEd25519PrivJwk(){
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      const v = localStorage.getItem(k);
      if (!v || v.length < 20) continue;
      try{
        const j = JSON.parse(v);
        if (j && j.crv === "Ed25519" && j.kty && j.d && j.x) return j;
      }catch(e){}
    }
    return null;
  }

  async function importPrivKeyFromJwk(jwk){
    return crypto.subtle.importKey("jwk", jwk, {name:"Ed25519"}, false, ["sign"]);
  }

  async function signEd25519(privKey, msgU8){
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msgU8);
    return new Uint8Array(sig);
  }

  async function getNonce(rid){
    const r = await fetch(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    if(!r.ok) throw new Error(`balance http ${r.status}`);
    const j = await r.json();
    return j.nonce;
  }

  async function getCanonBytes(draft){
    // пробуем debug_canon (если включен на сервере)
    try{
      const r = await fetch(`${NODE_API}/debug_canon`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(draft)
      });
      if (r.ok){
        const t = await r.text();
        // варианты: JSON или просто строка
        try{
          const j = JSON.parse(t);
          const ch = j.canon_hex || j.canon || j.msg_hex || j.message_hex || j.bytes_hex || "";
          const u = hexToU8(ch);
          if (u) return u;
          const s = (j.canon_str || j.message || j.msg || "");
          if (s) return utf8(s);
        }catch(e){
          // если просто строка
          const u = hexToU8(t);
          if (u) return u;
          if (t && t.length) return utf8(t);
        }
      }
    }catch(e){}

    // fallback: стабильная строка (если debug_canon нет)
    const memo = (draft.memo === null || draft.memo === undefined) ? "" : String(draft.memo);
    const s = `LOGOS_TX|from=${draft.from}|to=${draft.to}|amount=${draft.amount}|nonce=${draft.nonce}|memo=${memo}`;
    return utf8(s);
  }

  function setStatus(panel, text, ok=true){
    let el = q(".sendStatus", panel);
    if(!el){
      el = document.createElement("div");
      el.className = "sendStatus";
      el.style.marginTop = "10px";
      el.style.fontSize = "13px";
      el.style.opacity = "0.95";
      panel.appendChild(el);
    }
    el.textContent = text || "";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function findSendPanel(){
    return document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('.panel[data-panel="send"]')
      || null;
  }

  function findSendControls(panel){
      const btnSend = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("send lgn"));
      const btnFillMe = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("мой rid"));

      // ВАЖНО: не по индексу, а по id (иначе withdraw inputs ломают логику)
      const toRid  = document.getElementById("lgnTo") || document.getElementById("lgmTo") || null;
      const amount = document.getElementById("lgnAmount") || document.getElementById("lgmAmount") || null;

      // memo optional
      const memo = document.getElementById("lgnMemo") || document.getElementById("lgmMemo") || null;

      return {btnSend, btnFillMe, toRid, amount, memo};
    }

  async function handleSend(panel, ui){
    const fromRid = getRID();
    const toRid = (ui.toRid?.value || "").trim();
    const memoStr = (ui.memo?.value || "").trim();
    const amtStr = (ui.amount?.value || "").trim();

    if(!fromRid){ setStatus(panel, "ERR: нет RID (ключи не найдены).", false); return; }
    if(!toRid || toRid.length < 10){ setStatus(panel, "ERR: введи RID получателя.", false); return; }

    const amt = Number(amtStr.replace(",", "."));
    if(!isFinite(amt) || amt <= 0){ setStatus(panel, "ERR: введи сумму > 0.", false); return; }

    const amount_mic = Math.round(amt * 1e6);

    setStatus(panel, "Отправляю…", true);

    let nonce;
    try{
      nonce = await getNonce(fromRid);
    }catch(e){
      setStatus(panel, "ERR: не смог получить nonce (balance).", false);
      return;
    }

    // draft по схеме TxIn (без подписи)
    const draft = {
      from: fromRid,
      to: toRid,
      amount: amount_mic,
      nonce: nonce,
      memo: memoStr ? memoStr : None
    };

    // JS не знает None, поэтому:
    if (!memoStr) draft.memo = null;

    // bytes for signing
    const canonBytes = await getCanonBytes(draft);

    // signer
    const jwk = findEd25519PrivJwk();
    if(!jwk){
      setStatus(panel, "ERR: приватный ключ не найден (localStorage). Если ключи в IndexedDB — скажи, сделаем доступ через существующий signer.", false);
      return;
    }

    let privKey;
    try{
      privKey = await importPrivKeyFromJwk(jwk);
    }catch(e){
      setStatus(panel, "ERR: не смог импортировать Ed25519 ключ.", false);
      return;
    }

    let sigU8;
    try{
      sigU8 = await signEd25519(privKey, canonBytes);
    }catch(e){
      setStatus(panel, "ERR: не смог подписать транзакцию.", false);
      return;
    }

    const txIn = {
      from: draft.from,
      to: draft.to,
      amount: draft.amount,
      nonce: draft.nonce,
      memo: draft.memo,
      sig_hex: hex(sigU8)
    };

    try{
      const r = await fetch(`${NODE_API}/submit_tx`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(txIn)
      });
      const text = await r.text();
      if(!r.ok){
        setStatus(panel, `ERR submit_tx: ${r.status} ${text}`.slice(0,500), false);
        return;
      }
      try{
        const j = JSON.parse(text);
        if (j && j.ok){
          setStatus(panel, `✅ Отправлено. txid: ${(j.txid||"")}`.trim(), true);
        } else {
          setStatus(panel, `⚠️ Ответ: ${text}`.slice(0,500), false);
        }
      }catch(e){
        setStatus(panel, `✅ Отправлено. Ответ: ${text}`.slice(0,200), true);
      }
    }catch(e){
      setStatus(panel, "ERR: сеть/submit_tx не доступен.", false);
    }
  }

  function initSend(){
    const panel = findSendPanel();
    if(!panel) return;
    const ui = findSendControls(panel);

    if(ui.btnFillMe){
      ui.btnFillMe.addEventListener("click", () => {
        const rid = getRID();
        if(ui.toRid) ui.toRid.value = rid || "";
      });
    }
    if(ui.btnSend){
      ui.btnSend.addEventListener("click", () => handleSend(panel, ui));
    }
  }

  try{ initSend(); }catch(e){}
})();
```


### FILE: /opt/logos/www/wallet_prod/assets.js

```js
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```


### FILE: /opt/logos/www/wallet_prod/auth.css

```css
/* Premium auth skin (matches dark wallet vibe) */

:root{
  --bg1:#070815;
  --bg2:#0b0f2a;
  --card:#0b0f1f;
  --card2:#0a0d1a;
  --stroke: rgba(255,255,255,.10);
  --stroke2: rgba(255,255,255,.06);
  --txt: rgba(255,255,255,.92);
  --muted: rgba(255,255,255,.62);
  --muted2: rgba(255,255,255,.45);
  --ok: rgba(120,255,200,.95);
  --err: rgba(255,120,120,.95);
}

html,body{height:100%}
body{
  margin:0;
  color:var(--txt);
  background:
    radial-gradient(1200px 600px at 25% 0%, rgba(120,90,255,.25), transparent 60%),
    radial-gradient(900px 500px at 80% 10%, rgba(0,200,255,.18), transparent 55%),
    linear-gradient(180deg, var(--bg1), var(--bg2));
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
}

.authShell{
  min-height:100%;
  display:flex;
  align-items:flex-start;
  justify-content:center;
  padding: 48px 18px;
}

.authCard{
  width: min(560px, 100%);
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  border: 1px solid var(--stroke);
  border-radius: 22px;
  padding: 18px 18px 16px;
  box-shadow: 0 30px 90px rgba(0,0,0,.55);
  backdrop-filter: blur(10px);
}

.authTop{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
}

.authBrand{display:flex; align-items:center; gap:12px;}
.authLogo{
  width:44px;height:44px;border-radius:14px;
  display:flex;align-items:center;justify-content:center;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.22), rgba(255,255,255,.06));
  border: 1px solid var(--stroke2);
  letter-spacing: .6px;
  font-weight: 800;
}
.authTitle{font-weight:800; font-size:18px; letter-spacing:.3px;}
.authHint{font-size:12px; color:var(--muted2); border:1px solid var(--stroke2); padding:6px 10px; border-radius:999px;}

.authSubtitle{
  margin-top:10px;
  color:var(--muted);
  font-size:13px;
  line-height:1.45;
}
.authSubtitleSmall{margin-top:8px; color:var(--muted); font-size:13px;}

.authDivider{
  height:1px;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.10), transparent);
  margin: 16px 0 14px;
}

.authMiniTitle{
  font-size:13px;
  color: rgba(255,255,255,.78);
  margin-bottom:10px;
}

.authLabel{display:block; font-size:12px; color:var(--muted2); margin:10px 0 6px;}

.authInp{
  width:100%;
  box-sizing:border-box;
  background: rgba(0,0,0,.22);
  border: 1px solid var(--stroke2);
  border-radius: 14px;
  padding: 12px 12px;
  outline:none;
  color: var(--txt);
}
.authInp:focus{
  border-color: rgba(140,160,255,.35);
  box-shadow: 0 0 0 3px rgba(120,120,255,.12);
}

.authText{resize:vertical; min-height:120px;}

.authGrid2{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:10px;
}

.authBtn{
  width:100%;
  border-radius: 14px;
  padding: 11px 12px;
  border:1px solid var(--stroke2);
  cursor:pointer;
  color: var(--txt);
  background: rgba(255,255,255,.06);
  transition: transform .08s ease, background .12s ease, border-color .12s ease;
}
.authBtn:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.14);}
.authBtn:active{transform: translateY(0px);}

.authBtn.primary{
  background: linear-gradient(90deg, rgba(120,90,255,.55), rgba(0,200,255,.35));
  border-color: rgba(255,255,255,.16);
}
.authBtn.ghost{
  background: rgba(0,0,0,.20);
}
.authBtn.soft{
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.86);
}

.authStatus{
  margin-top:10px;
  font-size:13px;
  color: var(--muted);
  min-height: 18px;
}

.authWarn{
  margin-top:10px;
  background: rgba(255,180,80,.10);
  border:1px solid rgba(255,180,80,.20);
  color: rgba(255,220,180,.92);
  padding: 10px 12px;
  border-radius: 14px;
  font-size: 13px;
}

.authMnemonic{
  margin-top:10px;
  background: rgba(0,0,0,.22);
  border: 1px solid var(--stroke2);
  border-radius: 14px;
  padding: 12px;
  white-space: pre-wrap;
  word-break: break-word;
  font-size: 14px;
  line-height: 1.55;
}

/* ===== Premium Seed UI (top-wallet style) ===== */

.seedBox{
  margin-top: 14px;
  padding: 14px;
  border-radius: 16px;
  border: 1px solid var(--stroke2);
  background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
}

.seedHead{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
  margin-bottom: 10px;
}

.seedTitle{
  font-weight: 700;
  letter-spacing: .2px;
}

.seedActions{
  display:flex;
  gap: 8px;
}

.chipBtn{
  appearance: none;
  border: 1px solid var(--stroke2);
  background: rgba(255,255,255,.05);
  color: var(--txt);
  border-radius: 999px;
  padding: 8px 12px;
  font-size: 13px;
  cursor: pointer;
}
.chipBtn:hover{ background: rgba(255,255,255,.08); }

.seedWarn{
  border: 1px solid rgba(255,200,120,.25);
  background: rgba(255,170,80,.08);
  color: rgba(255,235,210,.92);
  border-radius: 12px;
  padding: 10px 12px;
  font-size: 13px;
  line-height: 1.4;
  margin-bottom: 12px;
}

.seedGrid{
  display:grid;
  grid-template-columns: repeat(4, minmax(0, 1fr));
  gap: 10px;
}

.seedWord{
  user-select: none;
  display:flex;
  align-items:center;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  border: 1px solid var(--stroke2);
  background: rgba(0,0,0,.22);
  overflow:hidden;
}

.seedNum{
  width: 26px;
  height: 26px;
  border-radius: 9px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size: 12px;
  color: rgba(255,255,255,.75);
  background: rgba(255,255,255,.06);
  flex: 0 0 auto;
}

.seedText{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size: 13px;
  color: rgba(255,255,255,.92);
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
}

.seedGrid.isHidden .seedText{
  color: transparent;
  text-shadow: 0 0 10px rgba(255,255,255,.35);
}

.seedFoot{
  margin-top: 10px;
  display:flex;
  justify-content:space-between;
  gap: 10px;
  color: var(--muted);
  font-size: 12.5px;
}

@media (max-width: 720px){
  .seedGrid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
}
```


### FILE: /opt/logos/www/wallet_prod/auth.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="./app.css"/>
  <link rel="stylesheet" href="./auth.css"/>
</head>
<body>

  <div class="authShell">
    <div class="authCard">
      <div class="authTop">
        <div class="authBrand">
          <div class="authLogo">LOGOS</div>
          <div class="authTitle">LOGOS Wallet</div>
        </div>
        <div class="authHint">HTTPS only</div>
      </div>

      <div class="authSubtitle">
        Create / Restore / Unlock — без email. Ключи локально. Сервер seed не видит.
      </div>

      <!-- STEP 0 -->
      <div id="step0" class="authStep">
        <div class="authGrid2">
          <button id="btnCreate" class="authBtn primary">Создать новый кошелёк</button>
          <button id="btnRestore" class="authBtn ghost">Восстановить по словам</button>
        </div>

        <button id="btnUnlock" class="authBtn soft" style="display:none;margin-top:12px">Unlock (продолжить)</button>

        <div class="authDivider"></div>

        <div class="authMiniTitle">Legacy вход по RID (для старых рабочих RID)</div>

        <label class="authLabel">RID</label>
        <input id="rid" class="authInp" placeholder="RID"/>

        <label class="authLabel">Пароль (legacy, если нужен)</label>
        <input id="pass" class="authInp" type="password" placeholder="Пароль"/>

        <div class="authGrid2" style="margin-top:12px">
          <button id="btnLogin" class="authBtn ghost">Войти по RID</button>
          <button id="btnShowRid" class="authBtn soft">Показать сохранённый RID</button>
        </div>

        <div id="status" class="authStatus"></div>
      </div>

      <!-- CREATE: show mnemonic -->
      <div id="mnemonicSection" class="authStep" style="display:none">
        <div class="authMiniTitle">Seed-фраза (запиши и сохрани)</div>
        <div class="authWarn">Не скринь. Не отправляй никому. Потеряешь — потеряешь доступ.</div>
        
<div class="seedBox">
  <div class="seedHead">
    <div class="seedTitle">Seed-фраза</div>
    <div class="seedActions">
      <button type="button" id="btnSeedHide" class="chipBtn">Скрыть</button>
      <button type="button" id="btnSeedCopy" class="chipBtn">Copy</button>
    </div>
  </div>

  <div class="seedWarn">
    Не делай скриншот и не отправляй никому. Потеряешь фразу — потеряешь доступ.
  </div>

  <div id="mnemonicShow" class="seedGrid" aria-label="seed phrase"></div>

  <div class="seedFoot">
    <span class="seedHint">Проверь, что записал(а) все слова по порядку.</span>
  </div>
</div>


        <div class="authGrid2" style="margin-top:12px">
          <button id="btnRecorded" class="authBtn primary">Я записал</button>
          <button id="btnBack0" class="authBtn soft">Назад</button>
        </div>
      </div>

      <!-- CONFIRM -->
      <div id="confirmSection" class="authStep" style="display:none">
        <div class="authMiniTitle">Проверка seed-фразы</div>
        <div class="authSubtitleSmall">Введи слово № <b id="cIdx"></b></div>
        <input id="confirmWord" class="authInp" placeholder="слово"/>

        <div id="cStatus" class="authStatus"></div>

        <div class="authGrid2" style="margin-top:12px">
          <button id="btnConfirmNext" class="authBtn primary">Дальше</button>
          <button id="btnBack1" class="authBtn soft">Назад</button>
        </div>
      </div>

      <!-- SET PASSWORD -->
      <div id="setPassSection" class="authStep" style="display:none">
        <div class="authMiniTitle">Защита (пароль шифрует seed локально)</div>

        <input id="p1" class="authInp" type="password" placeholder="Пароль (мин 6 символов)"/>
        <input id="p2" class="authInp" type="password" placeholder="Повтори пароль"/>

        <div id="pStatus" class="authStatus"></div>

        <div class="authGrid2" style="margin-top:12px">
          <button id="btnFinishCreate" class="authBtn primary">Создать и войти</button>
          <button id="btnBack2" class="authBtn soft">Назад</button>
        </div>
      </div>

      <!-- RESTORE -->
      <div id="restoreSection" class="authStep" style="display:none">
        <div class="authMiniTitle">Восстановление</div>
        <textarea id="restoreMnemonic" class="authInp authText" rows="4" placeholder="12/24 слова через пробел"></textarea>
        <input id="restorePass" class="authInp" type="password" placeholder="Новый пароль для vault (мин 6 символов)"/>

        <div id="rStatus" class="authStatus"></div>

        <div class="authGrid2" style="margin-top:12px">
          <button id="btnDoRestore" class="authBtn primary">Восстановить и войти</button>
          <button id="btnBackR" class="authBtn soft">Назад</button>
        </div>
      </div>

      <!-- UNLOCK -->
      <div id="unlockSection" class="authStep" style="display:none">
        <div class="authMiniTitle">Unlock</div>
        <input id="unlockPass" class="authInp" type="password" placeholder="Пароль"/>

        <div id="uStatus" class="authStatus"></div>

        <div class="authGrid2" style="margin-top:12px">
          <button id="btnDoUnlock" class="authBtn primary">Войти</button>
          <button id="btnBackU" class="authBtn soft">Назад</button>
        </div>
      </div>

    </div>
  </div>

  <script src="./vendor/nacl-fast.min.js"></script>
<script src="./vendor/wordlist_en.js"></script>
  <script src="./vendor/bip39_lite.js"></script>
<script defer src="./auth.js"></script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_prod/auth.js

```js
(() => {
  const LS_VAULT = "logos_vault_v1";
  const SS_SEED  = "logos_sk_seed_b64";     // sessionStorage (seed32)
  const LS_LAST  = "logos_last_rid";
  const LS_RID1  = "RID";
  const LS_RID2  = "logos_rid";

  const $ = (id) => document.getElementById(id);

  

  // --- BIP39 (local, offline): use window.bip39lite ---
  function BIP39(){
    const b = window.bip39lite;
    if(!b) throw new Error("BIP39 not loaded: check vendor/wordlist_en.js + vendor/bip39_lite.js in auth.html");
    return b;
  }
  const show = (id) => $(id).style.display = "";
  const hide = (id) => $(id).style.display = "none";
  const go = (id) => {
    ["step0","mnemonicSection","confirmSection","setPassSection","restoreSection","unlockSection"].forEach(hide);
    show(id);
  };

  function status(el, ok, msg){
    el.textContent = msg || "";
    el.className = ok ? "status ok" : "status err";
  }

  function norm(s){ return (s||"").toLowerCase().trim().replace(/\s+/g," "); }

  function u8ToB64(u8){
    let s=""; u8.forEach(b=>s+=String.fromCharCode(b));
    return btoa(s);
  }
  function b64ToU8(b64){
    const s = atob(b64);
    const u8 = new Uint8Array(s.length);
    for(let i=0;i<s.length;i++) u8[i]=s.charCodeAt(i);
    return u8;
  }

  async function sha256(u8){
    const h = await crypto.subtle.digest("SHA-256", u8);
    return new Uint8Array(h);
  }

  async function pbkdf2Key(password, saltU8){
    const base = await crypto.subtle.importKey("raw", new TextEncoder().encode(password), "PBKDF2", false, ["deriveKey"]);
    return crypto.subtle.deriveKey(
      {name:"PBKDF2", salt:saltU8, iterations:210000, hash:"SHA-256"},
      base,
      {name:"AES-GCM", length:256},
      false,
      ["encrypt","decrypt"]
    );
  }

  async function encryptSeed32(seed32, password){
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv   = crypto.getRandomValues(new Uint8Array(12));
    const key  = await pbkdf2Key(password, salt);
    const ctBuf = await crypto.subtle.encrypt({name:"AES-GCM", iv}, key, seed32);
    return { salt:u8ToB64(salt), iv:u8ToB64(iv), ct:u8ToB64(new Uint8Array(ctBuf)) };
  }

  async function decryptSeed32(vault, password){
    const salt = b64ToU8(vault.salt);
    const iv   = b64ToU8(vault.iv);
    const ct   = b64ToU8(vault.ct);
    const key  = await pbkdf2Key(password, salt);
    const ptBuf = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct);
    return new Uint8Array(ptBuf);
  }

  // Base58 (fallback RID derivation)
  function base58(u8){
    const A = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let x = 0n;
    for (const b of u8) x = (x<<8n) + BigInt(b);
    let out = "";
    while (x > 0n) {
      const mod = x % 58n;
      out = A[Number(mod)] + out;
      x = x / 58n;
    }
    return out || "1";
  }

  function makeRIDFromPub(pubU8){
    // если где-то есть ваш канон — используем его
    if (typeof window.ridFromPub === "function") return window.ridFromPub(pubU8);
    if (typeof window.makeRID === "function") return window.makeRID(pubU8);
    // fallback формат похожий на текущие Atx...
    return "Atx" + base58(pubU8).slice(0, 44);
  }

  function setRidSession(rid){
    rid = (rid||"").trim();
    if (!rid) return;
    localStorage.setItem(LS_RID1, rid);
    localStorage.setItem(LS_RID2, rid);
    localStorage.setItem(LS_LAST, rid);
    $("rid").value = rid;
  }

  function goWallet(){
    location.href = "./app.html#assets";
  }

  // ---------- Create flow ----------
  let mnemonic = "";

  // --- Premium seed renderer (chips + copy/hide) ---
  function renderSeed(wordsArr){
    const el = $("mnemonicShow");
    if(!el) return;
    el.innerHTML = wordsArr.map((w,i)=>(
      `<div class="seedWord"><div class="seedNum">${i+1}</div><div class="seedText">${w}</div></div>`
    )).join("");
    // default visible
    el.classList.remove("isHidden");
    const b = $("btnSeedHide");
    if (b) b.textContent = "Скрыть";
  }

  function bindSeedActions(){
    const btnCopy = $("btnSeedCopy");
    if (btnCopy && !btnCopy.__bound){
      btnCopy.__bound = true;
      btnCopy.addEventListener("click", async ()=>{
        try{
          if(!mnemonic) return;
          await navigator.clipboard.writeText(mnemonic);
          btnCopy.textContent = "Скопировано";
          setTimeout(()=>btnCopy.textContent="Copy", 900);
        }catch(e){
          console.warn("copy failed", e);
          btnCopy.textContent = "Не удалось";
          setTimeout(()=>btnCopy.textContent="Copy", 900);
        }
      });
    }

    const btnHide = $("btnSeedHide");
    if (btnHide && !btnHide.__bound){
      btnHide.__bound = true;
      btnHide.addEventListener("click", ()=>{
        const el = $("mnemonicShow");
        if(!el) return;
        const on = !el.classList.contains("isHidden");
        el.classList.toggle("isHidden", on);
        btnHide.textContent = on ? "Показать" : "Скрыть";
      });
    }
  }


  let words = [];
  let checkIdx = [];
  let pos = 0;

  async function startCreate(){
    mnemonic = norm(await BIP39().generateMnemonic(256)); // 24 words
    words = mnemonic.split(" ");
    renderSeed(words);
      bindSeedActions();
checkIdx = [3, 11, 17].map(i => Math.min(i, words.length-1));
    pos = 0;
    $("cIdx").textContent = String(checkIdx[pos] + 1);
    $("confirmWord").value = "";
    $("cStatus").textContent = "";

    go("mnemonicSection");
  }

  function startConfirm(){
    $("confirmWord").value = "";
    $("cStatus").textContent = "";
    $("cIdx").textContent = String(checkIdx[pos] + 1);
    go("confirmSection");
  }

  function doConfirmNext(){
    const w = norm($("confirmWord").value);
    const idx = checkIdx[pos];
    if (w !== words[idx]) {
      status($("cStatus"), false, "Неверно. Проверь слово.");
      return;
    }
    pos++;
    if (pos >= checkIdx.length) {
      go("setPassSection");
      return;
    }
    status($("cStatus"), true, "OK");
    $("confirmWord").value = "";
    $("cIdx").textContent = String(checkIdx[pos] + 1);
  }

  async function finishCreate(){
    const p1 = $("p1").value || "";
    const p2 = $("p2").value || "";
    if (p1.length < 6) return status($("pStatus"), false, "Пароль минимум 6 символов");
    if (p1 !== p2) return status($("pStatus"), false, "Пароли не совпадают");

    status($("pStatus"), true, "Создаю…");

    const seedBuf = await BIP39().mnemonicToSeed32(mnemonic, "");
    const seedU8  = new Uint8Array(seedBuf);

    const seed32 = await sha256(seedU8);                 // 32 bytes
    const kp = nacl.sign.keyPair.fromSeed(seed32);
    const rid = makeRIDFromPub(kp.publicKey);

    const enc = await encryptSeed32(seed32, p1);

    const vault = {
      ver: 1,
      rid,
      pub: u8ToB64(kp.publicKey),
      ...enc,
      created_at: new Date().toISOString()
    };
    localStorage.setItem(LS_VAULT, JSON.stringify(vault));

    sessionStorage.setItem(SS_SEED, u8ToB64(seed32));
    setRidSession(rid);

    goWallet();
  }

  // ---------- Restore flow ----------
  async function doRestore(){
    const m = norm($("restoreMnemonic").value);
    const pass = $("restorePass").value || "";
    if (!await BIP39().validateMnemonic(m)) return status($("rStatus"), false, "Фраза некорректная (проверь слова/пробелы)");
    if (pass.length < 6) return status($("rStatus"), false, "Пароль минимум 6 символов");

    status($("rStatus"), true, "Восстанавливаю…");

    const seedBuf = await BIP39().mnemonicToSeed32(m, "");
    const seedU8  = new Uint8Array(seedBuf);
    const seed32  = await sha256(seedU8);

    const kp = nacl.sign.keyPair.fromSeed(seed32);
    const rid = makeRIDFromPub(kp.publicKey);

    const enc = await encryptSeed32(seed32, pass);
    const vault = {
      ver: 1,
      rid,
      pub: u8ToB64(kp.publicKey),
      ...enc,
      created_at: new Date().toISOString()
    };
    localStorage.setItem(LS_VAULT, JSON.stringify(vault));

    sessionStorage.setItem(SS_SEED, u8ToB64(seed32));
    setRidSession(rid);

    goWallet();
  }

  // ---------- Unlock flow ----------
  async function doUnlock(){
    let v = null;
    try { v = JSON.parse(localStorage.getItem(LS_VAULT) || "null"); } catch(_){}
    if (!v || !v.ct) return status($("uStatus"), false, "Vault не найден");
    const pass = $("unlockPass").value || "";
    if (pass.length < 6) return status($("uStatus"), false, "Пароль минимум 6 символов");

    status($("uStatus"), true, "Unlock…");
    try{
      const seed32 = await decryptSeed32(v, pass);
      sessionStorage.setItem(SS_SEED, u8ToB64(seed32));
      setRidSession(v.rid || "");
      goWallet();
    } catch(e){
      status($("uStatus"), false, "Неверный пароль или vault повреждён");
    }
  }

  // ---------- Legacy RID login ----------
  function legacyLogin(){
    const rid = ($("rid").value || "").trim();
    if (!rid) return status($("status"), false, "Введите RID");
    setRidSession(rid);
    status($("status"), true, "OK");
    goWallet();
  }

  function showSavedRid(){
    const rid = (localStorage.getItem(LS_RID2) || localStorage.getItem(LS_RID1) || localStorage.getItem(LS_LAST) || "").trim();
    if (!rid) return status($("status"), false, "RID не найден в браузере");
    $("rid").value = rid;
    status($("status"), true, "RID подставлен из браузера");
  }

  // init
  document.addEventListener("DOMContentLoaded", () => {
    // если vault есть — показываем Unlock кнопку
    try{
      const v = JSON.parse(localStorage.getItem(LS_VAULT) || "null");
      if (v && v.ct) $("btnUnlock").style.display = "";
    }catch(_){}

    $("btnCreate").onclick = startCreate;
    $("btnRestore").onclick = () => go("restoreSection");
    $("btnUnlock").onclick  = () => go("unlockSection");

    $("btnRecorded").onclick = startConfirm;
    $("btnConfirmNext").onclick = doConfirmNext;
    $("btnFinishCreate").onclick = () => finishCreate().catch(e => status($("pStatus"), false, "ERR: " + (e.message||String(e))));

    $("btnDoRestore").onclick = () => doRestore().catch(e => status($("rStatus"), false, "ERR: " + (e.message||String(e))));
    $("btnDoUnlock").onclick  = () => doUnlock().catch(e => status($("uStatus"), false, "ERR: " + (e.message||String(e))));

    $("btnBack0").onclick = () => go("step0");
    $("btnBack1").onclick = () => go("mnemonicSection");
    $("btnBack2").onclick = () => go("confirmSection");
    $("btnBackR").onclick = () => go("step0");
    $("btnBackU").onclick = () => go("step0");

    $("btnLogin").onclick = legacyLogin;
    $("btnShowRid").onclick = showSavedRid;

    // автоподстановка RID
    const rid = (localStorage.getItem(LS_RID2) || localStorage.getItem(LS_RID1) || localStorage.getItem(LS_LAST) || "").trim();
    if (rid) $("rid").value = rid;
  });
})();
```


### FILE: /opt/logos/www/wallet_prod/compat.js

```js
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```


### FILE: /opt/logos/www/wallet_prod/connect.js

```js
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```


### FILE: /opt/logos/www/wallet_prod/index.html

```html
<!doctype html><meta charset="utf-8">
<meta http-equiv="refresh" content="0;url=./auth.html">
```


### FILE: /opt/logos/www/wallet_prod/login.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="refresh" content="0; url=./auth.html"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
</head>
<body>
  <p>Redirect to <a href="./auth.html">auth.html</a>…</p>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_prod/modules/lgn_send.js

```js
/* LGN send via /node-api/submit_tx
   Uses sessionStorage logos_sk_seed_b64 (seed32) + tweetnacl ed25519
*/
(() => {
  const NODE_API = `${location.origin}/node-api`;
  const SS_SEED = "logos_sk_seed_b64";

  const byId = (id)=>document.getElementById(id);
  const pick = (...ids)=>ids.map(byId).find(Boolean);

  function setStatus(ok, msg){
    const el = pick("lgnStatus","sendStatus","statusLGN");
    if (el){ el.textContent = msg||""; el.className = ok ? "status ok" : "status err"; }
  }

  function b64ToU8(b64){
    const s = atob(b64);
    const u8 = new Uint8Array(s.length);
    for(let i=0;i<s.length;i++) u8[i]=s.charCodeAt(i);
    return u8;
  }

  function u8tohex(u8){
    return Array.from(u8).map(b=>b.toString(16).padStart(2,"0")).join("");
  }

  function readRID(){
    return (localStorage.getItem("logos_rid") || localStorage.getItem("RID") || "").trim();
  }

  function readToRid(){
    // В твоём UI это именно lgmTo
    const el = pick("lgmTo","lgnTo","toRid","to");
    return (el?.value || "").trim();
  }

  function parseAmountMicro(){
    const el = pick("lgmAmount","lgnAmount","amountLGN","amount");
    const s0 = (el?.value || "").trim().replace(",",".");
    if (!s0) throw new Error("Введите Amount");
    if (!/^\d+(\.\d+)?$/.test(s0)) throw new Error("Некорректный Amount");
    const [a,b=""] = s0.split(".");
    const frac = (b+"000000").slice(0,6);
    const micro = BigInt(a)*1000000n + BigInt(frac);
    if (micro<=0n) throw new Error("Amount должен быть > 0");
    return micro;
  }

  async function getJSON(url){
    const r = await fetch(url,{cache:"no-store",credentials:"omit"});
    const t = await r.text();
    if (!r.ok) throw new Error(`${r.status} ${t}`.slice(0,300));
    try { return JSON.parse(t); } catch { return t; }
  }

  async function postJSON(url, body){
    const r = await fetch(url,{
      method:"POST",
      headers:{"content-type":"application/json"},
      body: JSON.stringify(body),
      cache:"no-store",
      credentials:"omit"
    });
    const t = await r.text();
    if (!r.ok) throw new Error(`${r.status} ${t}`.slice(0,600));
    try { return JSON.parse(t); } catch { return t; }
  }

  async function getNextNonce(rid){
    const j = await getJSON(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    const raw = (j && typeof j==="object" && (j.next_nonce ?? j.nonce ?? j.seq ?? j.sequence));
    if (raw===undefined || raw===null) throw new Error("В /balance нет nonce/next_nonce");
    const bn = BigInt(raw);
    // если отдаёте next_nonce — берём как есть, если nonce — добавим 1
    if (j && typeof j==="object" && j.next_nonce !== undefined) return bn;
    return bn + 1n;
  }

  function canonicalBytes(tx){
    const o = {from:tx.from,to:tx.to,amount:tx.amount,nonce:tx.nonce,memo:tx.memo??null};
    return new TextEncoder().encode(JSON.stringify(o));
  }

  async function sendLGN(){
    try{
      const from = readRID();
      if (!from) throw new Error("Нет RID. Сначала Create/Restore/Unlock или Legacy login.");
      const to = readToRid();
      if (!to) throw new Error("Введите RID получателя.");

      const seedB64 = sessionStorage.getItem(SS_SEED);
      if (!seedB64) throw new Error("Ключ не разблокирован. Вернись на старт и сделай Unlock.");
      if (!window.nacl) throw new Error("tweetnacl не загружен (проверь app.html).");

      const seed32 = b64ToU8(seedB64);
      const kp = nacl.sign.keyPair.fromSeed(seed32);

      const amount = parseAmountMicro();
      const nonce = await getNextNonce(from);

      const tx = { from, to, amount: amount.toString(), nonce: nonce.toString(), memo: null };
      const msg = canonicalBytes(tx);
      const sig = nacl.sign.detached(new Uint8Array(msg), kp.secretKey);

      const body = { ...tx, sig_hex: u8tohex(sig) };
      setStatus(true, "sending…");
      const res = await postJSON(`${NODE_API}/submit_tx`, body);
      setStatus(true, "OK: tx submitted");
      console.log("[lgn_send] submit result:", res);
    }catch(e){
      setStatus(false, "ERR: " + (e.message||String(e)));
      console.warn(e);
    }
  }

  function bind(){
    // найдём кнопку “Send LGN”
    const btn = [...document.querySelectorAll("button")].find(b => /send\s*lgn/i.test(b.textContent||""));
    if (!btn) { console.warn("[lgn_send] button not found"); return; }
    btn.addEventListener("click", (ev)=>{ ev.preventDefault(); sendLGN(); }, true);
    console.log("[lgn_send] ready (seed vault mode)");
  }

  if (document.readyState==="loading") document.addEventListener("DOMContentLoaded", bind);
  else bind();
})();
```


### FILE: /opt/logos/www/wallet_prod/modules/send.js

```js
(function(){
  const $ = (id) => document.getElementById(id);

  function esc(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function setStatus(msg){
    const el = $("wdStatus");
    if (el) el.textContent = msg || "";
  }

  function setRaw(obj){
    const pre = $("wdRaw");
    if (!pre) return;
    try{ pre.textContent = JSON.stringify(obj, null, 2); }
    catch(e){ pre.textContent = String(obj); }
  }

  function fillNetworkOptionsFromBalances(balJson){
    const sel = $("wdNetwork");
    if (!sel) return;

    const b = (balJson && balJson.balances) ? balJson.balances : {};
    const opts = [];

    // Withdraw у нас "USDT". Реальные сети вывода: ERC20 (ETH) и TRC20 (TRON)
    if (b.ETH)  opts.push({v:"ETH",  t:"ETH (ERC20)"});
    if (b.TRON) opts.push({v:"TRON", t:"TRON (TRC20)"});

    // fallback если вдруг API не дал balances
    if (opts.length === 0) opts.push({v:"ETH", t:"ETH (ERC20)"});

    const cur = sel.value;
    sel.innerHTML = "";
    for (const o of opts){
      const opt = document.createElement("option");
      opt.value = o.v;
      opt.textContent = o.t;
      sel.appendChild(opt);
    }
    if (cur && [...sel.options].some(x => x.value === cur)) sel.value = cur;
  }

  async function refreshNetworks(){
    try{
      const rid = readRID();
      if (!rid) return;

      const base = window.WALLET_API || "/wallet-api";
      const r = await fetch(base + "/v1/balances/" + encodeURIComponent(rid), { cache: "no-store" });
      if (!r.ok) return;
      const j = await r.json();
      fillNetworkOptionsFromBalances(j);
    }catch(e){}
  }

  function clearForm(){
    if ($("wdAmount")) $("wdAmount").value = "";
    if ($("wdTo")) $("wdTo").value = "";
    setStatus("");
    setRaw("");
  }

  async function doWithdraw(){
    const rid = readRID();
    if (!rid) return setStatus("ERR: RID не найден. Зайди через /wallet/auth.html");

    const base = window.WALLET_API || "/wallet-api";

    const net = ($("wdNetwork") && $("wdNetwork").value) ? $("wdNetwork").value : "ETH";
    const amountStr = String(($("wdAmount") && $("wdAmount").value) || "").trim();
    const to = String(($("wdTo") && $("wdTo").value) || "").trim();

    if (!amountStr) return setStatus("ERR: введи Amount (целое число).");
    if (!/^\d+$/.test(amountStr)) return setStatus("ERR: Amount должен быть целым числом (integer).");
    const amount = Number(amountStr);
    if (!Number.isFinite(amount) || amount <= 0) return setStatus("ERR: Amount должен быть > 0.");

    if (!to || to.length < 8) return setStatus("ERR: введи адрес получателя.");

    setStatus("request…");
    setRaw("");

    try{
      const body = { rid, network: net, amount, to };

      const r = await fetch(base + "/v1/withdraw", {
        method: "POST",
        headers: { "content-type":"application/json" },
        body: JSON.stringify(body),
        cache: "no-store"
      });

      const j = await r.json().catch(()=>({}));
      setRaw(j);

      if (!r.ok){
        return setStatus("ERR: HTTP " + r.status + " — " + (j && (j.error || j.message) ? (j.error || j.message) : "withdraw failed"));
      }

      setStatus("OK: отправлено (" + esc(net) + ").");
    }catch(e){
      setStatus("ERR: " + (e && e.message ? e.message : String(e)));
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    refreshNetworks();

    const btnSend = $("btnWithdraw");
    const btnClear = $("btnWithdrawClear");

    if (btnSend) btnSend.addEventListener("click", doWithdraw);
    if (btnClear) btnClear.addEventListener("click", clearForm);

    // enter = send (в поле адреса)
    const to = $("wdTo");
    if (to){
      to.addEventListener("keydown", (e) => {
        if (e.key === "Enter") doWithdraw();
      });
    }
  });
})();
```


### FILE: /opt/logos/www/wallet_prod/modules/settings.js

```js
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();


// PROD hard clear session password
try{sessionStorage.removeItem("PASS");sessionStorage.removeItem("logos_pass");}catch(e){}
```


### FILE: /opt/logos/www/wallet_prod/modules/tx_redirect.js

```js
/* tx_redirect.js — redirect old /transfer -> /submit_tx and normalize body to TxIn */
(() => {
  const _fetch = window.fetch.bind(window);

  function isHex(s){
    s = String(s||"").replace(/^0x/,"").trim();
    return s.length > 0 && s.length % 2 === 0 && /^[0-9a-fA-F]+$/.test(s);
  }

  function b64urlToBytes(b64url){
    try{
      let s = String(b64url||"").replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u[i] = bin.charCodeAt(i);
      return u;
    }catch(e){ return null; }
  }

  function bytesToHex(u){
    let out = "";
    for (let i=0;i<u.length;i++) out += u[i].toString(16).padStart(2,"0");
    return out;
  }

  function normalizeTx(body){
    const j = body && typeof body === "object" ? body : {};
    const from = j.from || j.rid_from || j.sender || j.rid || "";
    const to   = j.to   || j.rid_to   || j.receiver || "";
    let amount = j.amount_mic ?? j.amount_micro ?? j.amount ?? 0;
    const nonce = j.nonce ?? j.n ?? j.account_nonce;

    // если вдруг прислали amount_lgn — переводим в micro-LGN
    if (j.amount_lgn !== undefined && j.amount_lgn !== null){
      const a = Number(j.amount_lgn);
      if (isFinite(a)) amount = Math.round(a * 1e6);
    }

    // подпись: sig_hex обязательно
    let sig_hex = j.sig_hex || j.sigHex || "";
    if (!sig_hex){
      const s = j.sig || j.signature || j.sig_b64 || j.sigB64 || "";
      if (s){
        if (isHex(s)) sig_hex = String(s).replace(/^0x/,"");
        else {
          const u = b64urlToBytes(s);
          if (u) sig_hex = bytesToHex(u);
        }
      }
    }

    const memo = (j.memo === undefined ? null : j.memo);

    return { from, to, amount, nonce, memo, sig_hex };
  }

  window.fetch = async (input, init={}) => {
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url.includes("/transfer")){
        const newUrl = url.replace("/transfer", "/submit_tx");

        let bodyObj = {};
        try{ bodyObj = JSON.parse(init.body || "{}"); }catch(e){ bodyObj = {}; }

        const tx = normalizeTx(bodyObj);

        const newInit = {
          ...init,
          method: "POST",
          headers: { ...(init.headers||{}), "Content-Type":"application/json" },
          body: JSON.stringify({
            from: tx.from,
            to: tx.to,
            amount: tx.amount,
            nonce: tx.nonce,
            memo: tx.memo,
            sig_hex: tx.sig_hex
          })
        };

        return _fetch(newUrl, newInit);
      }
    }catch(e){}
    return _fetch(input, init);
  };

  console.log("[tx_redirect] installed: /transfer -> /submit_tx");
})();
```


### FILE: /opt/logos/www/wallet_prod/tabs.js

```js
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```


### FILE: /opt/logos/www/wallet_prod/ui.css

```css

/* assets ui */
.assetsWrap{display:block;margin-top:16px}
.assetsHead{display:flex;gap:12px;align-items:center;justify-content:space-between;margin:8px 0 14px}
.assetsTitle{font-weight:800;font-size:20px;letter-spacing:.2px}
.assetsSub{margin-top:4px;color:rgba(255,255,255,.62);font-size:12px}
.assetsGrid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:14px}
@media (max-width: 900px){.assetsGrid{grid-template-columns:1fr}}
.assetCard{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:18px;padding:14px;box-shadow:0 16px 50px rgba(0,0,0,.35);backdrop-filter: blur(16px)}
.assetTop{display:flex;gap:12px;align-items:center}
.assetSym{width:48px;height:48px;border-radius:14px;display:flex;align-items:center;justify-content:center;font-weight:800;
  background:radial-gradient(120% 120% at 30% 10%, rgba(78,124,255,.35), rgba(139,92,246,.25), rgba(0,0,0,0));
  border:1px solid rgba(255,255,255,.12)
}
.assetName{font-weight:700}
.assetBal{margin-top:2px;font-size:13px;color:rgba(255,255,255,.75)}
.assetAddrRow{margin-top:12px;display:flex;gap:10px;align-items:center;justify-content:space-between}
.assetAddr{max-width:70%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:rgba(255,255,255,.85)}
.assetNote{margin-top:10px;font-size:12px}

/* ===== LOGOS PREMIUM TABS ===== */
.bottombar{
  position:fixed; left:0; right:0; bottom:0;
  display:flex; gap:10px; padding:12px 12px;
  backdrop-filter: blur(14px);
  background: rgba(10,14,26,.72);
  border-top: 1px solid rgba(255,255,255,.08);
  z-index: 9999;
}
.bottombar .tabBtn{
  flex:1;
  padding:10px 8px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.86);
  font-weight: 600;
  cursor: pointer;
}
.bottombar .tabBtn.active{
  background: rgba(120,140,255,.18);
  border-color: rgba(120,140,255,.35);
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
}
body{ padding-bottom: 86px !important; }

/* чуть “премиумнее” общий вид */
.tabCard{
  border: 1px solid rgba(255,255,255,.08) !important;
  box-shadow: 0 14px 40px rgba(0,0,0,.35) !important;
  border-radius: 18px !important;
}
```


### FILE: /opt/logos/www/wallet_prod/ui.js

```js
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```


### FILE: /opt/logos/www/wallet_prod/vendor/bip39_english.txt

```
abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo
```


### FILE: /opt/logos/www/wallet_prod/vendor/bip39_lite.js

```js
/* bip39_lite.js — offline, no deps.
   Requires: window.BIP39_WORDS (2048 english words) loaded before this file.

   Exposes:
     window.bip39lite.generateMnemonic(strengthBits=128) -> Promise<string>
     window.bip39lite.validateMnemonic(mn) -> Promise<boolean>
     window.bip39lite.mnemonicToSeed32(mn, pass="") -> Promise<Uint8Array(32)>
*/
(function(){
  const WORDS = window.BIP39_WORDS;
  if(!Array.isArray(WORDS) || WORDS.length !== 2048){
    console.error("[bip39lite] wordlist missing/invalid");
    return;
  }

  const te = new TextEncoder();
  const wordIndex = new Map(WORDS.map((w,i)=>[w,i]));

  function norm(m){ return (m||"").toLowerCase().trim().replace(/\s+/g," "); }

  async function sha256(u8){
    const h = await crypto.subtle.digest("SHA-256", u8);
    return new Uint8Array(h);
  }

  function bytesToBits(bytes){
    let out="";
    for(const b of bytes) out += b.toString(2).padStart(8,"0");
    return out;
  }

  function bitsToBytes(bits){
    const n = Math.ceil(bits.length/8);
    const out = new Uint8Array(n);
    for(let i=0;i<n;i++){
      const chunk = bits.slice(i*8, i*8+8).padEnd(8,"0");
      out[i] = parseInt(chunk,2);
    }
    return out;
  }

  async function generateMnemonic(strengthBits=128){
    if(strengthBits % 32 !== 0 || strengthBits < 128 || strengthBits > 256){
      throw new Error("strengthBits must be 128..256 and multiple of 32");
    }
    const entropy = crypto.getRandomValues(new Uint8Array(strengthBits/8));
    const hash = await sha256(entropy);

    // checksum length = ENT/32
    const csLen = strengthBits / 32;
    const entBits = bytesToBits(entropy);
    const csBits  = bytesToBits(hash).slice(0, csLen);

    const bits = entBits + csBits; // total multiple of 11
    const words = [];
    for(let i=0;i<bits.length; i+=11){
      const idx = parseInt(bits.slice(i,i+11), 2);
      words.push(WORDS[idx]);
    }
    return words.join(" ");
  }

  async function validateMnemonic(mn){
    mn = norm(mn);
    if(!mn) return false;
    const arr = mn.split(" ");
    if(arr.length % 3 !== 0) return false;
    if(arr.length < 12 || arr.length > 24) return false;

    // rebuild bits from indices
    let bits="";
    for(const w of arr){
      const idx = wordIndex.get(w);
      if(idx === undefined) return false;
      bits += idx.toString(2).padStart(11,"0");
    }

    // derive ENT from word count: ENT = (words*11) - CS, where CS = ENT/32
    // => ENT = words*11 * 32/33
    const total = arr.length * 11;
    const entBitsLen = Math.floor(total * 32 / 33);
    const csLen = total - entBitsLen;

    if(entBitsLen % 8 !== 0) return false;

    const entBits = bits.slice(0, entBitsLen);
    const csBits  = bits.slice(entBitsLen, entBitsLen + csLen);

    const entropy = bitsToBytes(entBits);
    const hash = await sha256(entropy);
    const csCheck = bytesToBits(hash).slice(0, csLen);

    return csBits === csCheck;
  }

  async function mnemonicToSeed32(mn, pass=""){
    mn = norm(mn);
    pass = (pass||"");

    const salt = te.encode("mnemonic" + pass);
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      te.encode(mn),
      "PBKDF2",
      false,
      ["deriveBits"]
    );

    // BIP39 seed = PBKDF2-HMAC-SHA512, 2048 iterations -> 64 bytes
    const bits = await crypto.subtle.deriveBits(
      { name:"PBKDF2", hash:"SHA-512", salt, iterations:2048 },
      keyMaterial,
      512
    );
    const seed64 = new Uint8Array(bits);

    // Нам нужен seed32 для nacl/ed25519 — берём SHA256(seed64)
    const seed32 = await sha256(seed64);
    return seed32; // Uint8Array(32)
  }

  window.bip39lite = { generateMnemonic, validateMnemonic, mnemonicToSeed32 };
  console.log("[bip39lite] ready. wordlist:", WORDS.length);
})();
```


### FILE: /opt/logos/www/wallet_prod/vendor/nacl-fast.min.js

```js
!function(i){"use strict";var v=function(r){var t,n=new Float64Array(16);if(r)for(t=0;t<r.length;t++)n[t]=r[t];return n},h=function(){throw new Error("no PRNG")},o=new Uint8Array(16),n=new Uint8Array(32);n[0]=9;var s=v(),u=v([1]),p=v([56129,1]),c=v([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),y=v([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),e=v([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),a=v([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),l=v([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function f(r,t,n,e){r[t]=n>>24&255,r[t+1]=n>>16&255,r[t+2]=n>>8&255,r[t+3]=255&n,r[t+4]=e>>24&255,r[t+5]=e>>16&255,r[t+6]=e>>8&255,r[t+7]=255&e}function w(r,t,n,e,o){var i,h=0;for(i=0;i<o;i++)h|=r[t+i]^n[e+i];return(1&h-1>>>8)-1}function b(r,t,n,e){return w(r,t,n,e,16)}function g(r,t,n,e){return w(r,t,n,e,32)}function A(r,t,n,e){!function(r,t,n,e){for(var o,i=255&e[0]|(255&e[1])<<8|(255&e[2])<<16|(255&e[3])<<24,h=255&n[0]|(255&n[1])<<8|(255&n[2])<<16|(255&n[3])<<24,a=255&n[4]|(255&n[5])<<8|(255&n[6])<<16|(255&n[7])<<24,f=255&n[8]|(255&n[9])<<8|(255&n[10])<<16|(255&n[11])<<24,s=255&n[12]|(255&n[13])<<8|(255&n[14])<<16|(255&n[15])<<24,u=255&e[4]|(255&e[5])<<8|(255&e[6])<<16|(255&e[7])<<24,c=255&t[0]|(255&t[1])<<8|(255&t[2])<<16|(255&t[3])<<24,y=255&t[4]|(255&t[5])<<8|(255&t[6])<<16|(255&t[7])<<24,l=255&t[8]|(255&t[9])<<8|(255&t[10])<<16|(255&t[11])<<24,w=255&t[12]|(255&t[13])<<8|(255&t[14])<<16|(255&t[15])<<24,v=255&e[8]|(255&e[9])<<8|(255&e[10])<<16|(255&e[11])<<24,p=255&n[16]|(255&n[17])<<8|(255&n[18])<<16|(255&n[19])<<24,b=255&n[20]|(255&n[21])<<8|(255&n[22])<<16|(255&n[23])<<24,g=255&n[24]|(255&n[25])<<8|(255&n[26])<<16|(255&n[27])<<24,A=255&n[28]|(255&n[29])<<8|(255&n[30])<<16|(255&n[31])<<24,_=255&e[12]|(255&e[13])<<8|(255&e[14])<<16|(255&e[15])<<24,U=i,d=h,E=a,x=f,M=s,m=u,B=c,S=y,k=l,K=w,Y=v,L=p,T=b,z=g,R=A,P=_,N=0;N<20;N+=2)U^=(o=(T^=(o=(k^=(o=(M^=(o=U+T|0)<<7|o>>>25)+U|0)<<9|o>>>23)+M|0)<<13|o>>>19)+k|0)<<18|o>>>14,m^=(o=(d^=(o=(z^=(o=(K^=(o=m+d|0)<<7|o>>>25)+m|0)<<9|o>>>23)+K|0)<<13|o>>>19)+z|0)<<18|o>>>14,Y^=(o=(B^=(o=(E^=(o=(R^=(o=Y+B|0)<<7|o>>>25)+Y|0)<<9|o>>>23)+R|0)<<13|o>>>19)+E|0)<<18|o>>>14,P^=(o=(L^=(o=(S^=(o=(x^=(o=P+L|0)<<7|o>>>25)+P|0)<<9|o>>>23)+x|0)<<13|o>>>19)+S|0)<<18|o>>>14,U^=(o=(x^=(o=(E^=(o=(d^=(o=U+x|0)<<7|o>>>25)+U|0)<<9|o>>>23)+d|0)<<13|o>>>19)+E|0)<<18|o>>>14,m^=(o=(M^=(o=(S^=(o=(B^=(o=m+M|0)<<7|o>>>25)+m|0)<<9|o>>>23)+B|0)<<13|o>>>19)+S|0)<<18|o>>>14,Y^=(o=(K^=(o=(k^=(o=(L^=(o=Y+K|0)<<7|o>>>25)+Y|0)<<9|o>>>23)+L|0)<<13|o>>>19)+k|0)<<18|o>>>14,P^=(o=(R^=(o=(z^=(o=(T^=(o=P+R|0)<<7|o>>>25)+P|0)<<9|o>>>23)+T|0)<<13|o>>>19)+z|0)<<18|o>>>14;U=U+i|0,d=d+h|0,E=E+a|0,x=x+f|0,M=M+s|0,m=m+u|0,B=B+c|0,S=S+y|0,k=k+l|0,K=K+w|0,Y=Y+v|0,L=L+p|0,T=T+b|0,z=z+g|0,R=R+A|0,P=P+_|0,r[0]=U>>>0&255,r[1]=U>>>8&255,r[2]=U>>>16&255,r[3]=U>>>24&255,r[4]=d>>>0&255,r[5]=d>>>8&255,r[6]=d>>>16&255,r[7]=d>>>24&255,r[8]=E>>>0&255,r[9]=E>>>8&255,r[10]=E>>>16&255,r[11]=E>>>24&255,r[12]=x>>>0&255,r[13]=x>>>8&255,r[14]=x>>>16&255,r[15]=x>>>24&255,r[16]=M>>>0&255,r[17]=M>>>8&255,r[18]=M>>>16&255,r[19]=M>>>24&255,r[20]=m>>>0&255,r[21]=m>>>8&255,r[22]=m>>>16&255,r[23]=m>>>24&255,r[24]=B>>>0&255,r[25]=B>>>8&255,r[26]=B>>>16&255,r[27]=B>>>24&255,r[28]=S>>>0&255,r[29]=S>>>8&255,r[30]=S>>>16&255,r[31]=S>>>24&255,r[32]=k>>>0&255,r[33]=k>>>8&255,r[34]=k>>>16&255,r[35]=k>>>24&255,r[36]=K>>>0&255,r[37]=K>>>8&255,r[38]=K>>>16&255,r[39]=K>>>24&255,r[40]=Y>>>0&255,r[41]=Y>>>8&255,r[42]=Y>>>16&255,r[43]=Y>>>24&255,r[44]=L>>>0&255,r[45]=L>>>8&255,r[46]=L>>>16&255,r[47]=L>>>24&255,r[48]=T>>>0&255,r[49]=T>>>8&255,r[50]=T>>>16&255,r[51]=T>>>24&255,r[52]=z>>>0&255,r[53]=z>>>8&255,r[54]=z>>>16&255,r[55]=z>>>24&255,r[56]=R>>>0&255,r[57]=R>>>8&255,r[58]=R>>>16&255,r[59]=R>>>24&255,r[60]=P>>>0&255,r[61]=P>>>8&255,r[62]=P>>>16&255,r[63]=P>>>24&255}(r,t,n,e)}function _(r,t,n,e){!function(r,t,n,e){for(var o,i=255&e[0]|(255&e[1])<<8|(255&e[2])<<16|(255&e[3])<<24,h=255&n[0]|(255&n[1])<<8|(255&n[2])<<16|(255&n[3])<<24,a=255&n[4]|(255&n[5])<<8|(255&n[6])<<16|(255&n[7])<<24,f=255&n[8]|(255&n[9])<<8|(255&n[10])<<16|(255&n[11])<<24,s=255&n[12]|(255&n[13])<<8|(255&n[14])<<16|(255&n[15])<<24,u=255&e[4]|(255&e[5])<<8|(255&e[6])<<16|(255&e[7])<<24,c=255&t[0]|(255&t[1])<<8|(255&t[2])<<16|(255&t[3])<<24,y=255&t[4]|(255&t[5])<<8|(255&t[6])<<16|(255&t[7])<<24,l=255&t[8]|(255&t[9])<<8|(255&t[10])<<16|(255&t[11])<<24,w=255&t[12]|(255&t[13])<<8|(255&t[14])<<16|(255&t[15])<<24,v=255&e[8]|(255&e[9])<<8|(255&e[10])<<16|(255&e[11])<<24,p=255&n[16]|(255&n[17])<<8|(255&n[18])<<16|(255&n[19])<<24,b=255&n[20]|(255&n[21])<<8|(255&n[22])<<16|(255&n[23])<<24,g=255&n[24]|(255&n[25])<<8|(255&n[26])<<16|(255&n[27])<<24,A=255&n[28]|(255&n[29])<<8|(255&n[30])<<16|(255&n[31])<<24,_=255&e[12]|(255&e[13])<<8|(255&e[14])<<16|(255&e[15])<<24,U=0;U<20;U+=2)i^=(o=(b^=(o=(l^=(o=(s^=(o=i+b|0)<<7|o>>>25)+i|0)<<9|o>>>23)+s|0)<<13|o>>>19)+l|0)<<18|o>>>14,u^=(o=(h^=(o=(g^=(o=(w^=(o=u+h|0)<<7|o>>>25)+u|0)<<9|o>>>23)+w|0)<<13|o>>>19)+g|0)<<18|o>>>14,v^=(o=(c^=(o=(a^=(o=(A^=(o=v+c|0)<<7|o>>>25)+v|0)<<9|o>>>23)+A|0)<<13|o>>>19)+a|0)<<18|o>>>14,_^=(o=(p^=(o=(y^=(o=(f^=(o=_+p|0)<<7|o>>>25)+_|0)<<9|o>>>23)+f|0)<<13|o>>>19)+y|0)<<18|o>>>14,i^=(o=(f^=(o=(a^=(o=(h^=(o=i+f|0)<<7|o>>>25)+i|0)<<9|o>>>23)+h|0)<<13|o>>>19)+a|0)<<18|o>>>14,u^=(o=(s^=(o=(y^=(o=(c^=(o=u+s|0)<<7|o>>>25)+u|0)<<9|o>>>23)+c|0)<<13|o>>>19)+y|0)<<18|o>>>14,v^=(o=(w^=(o=(l^=(o=(p^=(o=v+w|0)<<7|o>>>25)+v|0)<<9|o>>>23)+p|0)<<13|o>>>19)+l|0)<<18|o>>>14,_^=(o=(A^=(o=(g^=(o=(b^=(o=_+A|0)<<7|o>>>25)+_|0)<<9|o>>>23)+b|0)<<13|o>>>19)+g|0)<<18|o>>>14;r[0]=i>>>0&255,r[1]=i>>>8&255,r[2]=i>>>16&255,r[3]=i>>>24&255,r[4]=u>>>0&255,r[5]=u>>>8&255,r[6]=u>>>16&255,r[7]=u>>>24&255,r[8]=v>>>0&255,r[9]=v>>>8&255,r[10]=v>>>16&255,r[11]=v>>>24&255,r[12]=_>>>0&255,r[13]=_>>>8&255,r[14]=_>>>16&255,r[15]=_>>>24&255,r[16]=c>>>0&255,r[17]=c>>>8&255,r[18]=c>>>16&255,r[19]=c>>>24&255,r[20]=y>>>0&255,r[21]=y>>>8&255,r[22]=y>>>16&255,r[23]=y>>>24&255,r[24]=l>>>0&255,r[25]=l>>>8&255,r[26]=l>>>16&255,r[27]=l>>>24&255,r[28]=w>>>0&255,r[29]=w>>>8&255,r[30]=w>>>16&255,r[31]=w>>>24&255}(r,t,n,e)}var U=new Uint8Array([101,120,112,97,110,100,32,51,50,45,98,121,116,101,32,107]);function d(r,t,n,e,o,i,h){var a,f,s=new Uint8Array(16),u=new Uint8Array(64);for(f=0;f<16;f++)s[f]=0;for(f=0;f<8;f++)s[f]=i[f];for(;64<=o;){for(A(u,s,h,U),f=0;f<64;f++)r[t+f]=n[e+f]^u[f];for(a=1,f=8;f<16;f++)a=a+(255&s[f])|0,s[f]=255&a,a>>>=8;o-=64,t+=64,e+=64}if(0<o)for(A(u,s,h,U),f=0;f<o;f++)r[t+f]=n[e+f]^u[f];return 0}function E(r,t,n,e,o){var i,h,a=new Uint8Array(16),f=new Uint8Array(64);for(h=0;h<16;h++)a[h]=0;for(h=0;h<8;h++)a[h]=e[h];for(;64<=n;){for(A(f,a,o,U),h=0;h<64;h++)r[t+h]=f[h];for(i=1,h=8;h<16;h++)i=i+(255&a[h])|0,a[h]=255&i,i>>>=8;n-=64,t+=64}if(0<n)for(A(f,a,o,U),h=0;h<n;h++)r[t+h]=f[h];return 0}function x(r,t,n,e,o){var i=new Uint8Array(32);_(i,e,o,U);for(var h=new Uint8Array(8),a=0;a<8;a++)h[a]=e[a+16];return E(r,t,n,h,i)}function M(r,t,n,e,o,i,h){var a=new Uint8Array(32);_(a,i,h,U);for(var f=new Uint8Array(8),s=0;s<8;s++)f[s]=i[s+16];return d(r,t,n,e,o,f,a)}var m=function(r){var t,n,e,o,i,h,a,f;this.buffer=new Uint8Array(16),this.r=new Uint16Array(10),this.h=new Uint16Array(10),this.pad=new Uint16Array(8),this.leftover=0,t=255&r[this.fin=0]|(255&r[1])<<8,this.r[0]=8191&t,n=255&r[2]|(255&r[3])<<8,this.r[1]=8191&(t>>>13|n<<3),e=255&r[4]|(255&r[5])<<8,this.r[2]=7939&(n>>>10|e<<6),o=255&r[6]|(255&r[7])<<8,this.r[3]=8191&(e>>>7|o<<9),i=255&r[8]|(255&r[9])<<8,this.r[4]=255&(o>>>4|i<<12),this.r[5]=i>>>1&8190,h=255&r[10]|(255&r[11])<<8,this.r[6]=8191&(i>>>14|h<<2),a=255&r[12]|(255&r[13])<<8,this.r[7]=8065&(h>>>11|a<<5),f=255&r[14]|(255&r[15])<<8,this.r[8]=8191&(a>>>8|f<<8),this.r[9]=f>>>5&127,this.pad[0]=255&r[16]|(255&r[17])<<8,this.pad[1]=255&r[18]|(255&r[19])<<8,this.pad[2]=255&r[20]|(255&r[21])<<8,this.pad[3]=255&r[22]|(255&r[23])<<8,this.pad[4]=255&r[24]|(255&r[25])<<8,this.pad[5]=255&r[26]|(255&r[27])<<8,this.pad[6]=255&r[28]|(255&r[29])<<8,this.pad[7]=255&r[30]|(255&r[31])<<8};function B(r,t,n,e,o,i){var h=new m(i);return h.update(n,e,o),h.finish(r,t),0}function S(r,t,n,e,o,i){var h=new Uint8Array(16);return B(h,0,n,e,o,i),b(r,t,h,0)}function k(r,t,n,e,o){var i;if(n<32)return-1;for(M(r,0,t,0,n,e,o),B(r,16,r,32,n-32,r),i=0;i<16;i++)r[i]=0;return 0}function K(r,t,n,e,o){var i,h=new Uint8Array(32);if(n<32)return-1;if(x(h,0,32,e,o),0!==S(t,16,t,32,n-32,h))return-1;for(M(r,0,t,0,n,e,o),i=0;i<32;i++)r[i]=0;return 0}function Y(r,t){var n;for(n=0;n<16;n++)r[n]=0|t[n]}function L(r){var t,n,e=1;for(t=0;t<16;t++)n=r[t]+e+65535,e=Math.floor(n/65536),r[t]=n-65536*e;r[0]+=e-1+37*(e-1)}function T(r,t,n){for(var e,o=~(n-1),i=0;i<16;i++)e=o&(r[i]^t[i]),r[i]^=e,t[i]^=e}function z(r,t){var n,e,o,i=v(),h=v();for(n=0;n<16;n++)h[n]=t[n];for(L(h),L(h),L(h),e=0;e<2;e++){for(i[0]=h[0]-65517,n=1;n<15;n++)i[n]=h[n]-65535-(i[n-1]>>16&1),i[n-1]&=65535;i[15]=h[15]-32767-(i[14]>>16&1),o=i[15]>>16&1,i[14]&=65535,T(h,i,1-o)}for(n=0;n<16;n++)r[2*n]=255&h[n],r[2*n+1]=h[n]>>8}function R(r,t){var n=new Uint8Array(32),e=new Uint8Array(32);return z(n,r),z(e,t),g(n,0,e,0)}function P(r){var t=new Uint8Array(32);return z(t,r),1&t[0]}function N(r,t){var n;for(n=0;n<16;n++)r[n]=t[2*n]+(t[2*n+1]<<8);r[15]&=32767}function O(r,t,n){for(var e=0;e<16;e++)r[e]=t[e]+n[e]}function C(r,t,n){for(var e=0;e<16;e++)r[e]=t[e]-n[e]}function F(r,t,n){var e,o,i=0,h=0,a=0,f=0,s=0,u=0,c=0,y=0,l=0,w=0,v=0,p=0,b=0,g=0,A=0,_=0,U=0,d=0,E=0,x=0,M=0,m=0,B=0,S=0,k=0,K=0,Y=0,L=0,T=0,z=0,R=0,P=n[0],N=n[1],O=n[2],C=n[3],F=n[4],I=n[5],Z=n[6],G=n[7],q=n[8],D=n[9],V=n[10],X=n[11],j=n[12],H=n[13],J=n[14],Q=n[15];i+=(e=t[0])*P,h+=e*N,a+=e*O,f+=e*C,s+=e*F,u+=e*I,c+=e*Z,y+=e*G,l+=e*q,w+=e*D,v+=e*V,p+=e*X,b+=e*j,g+=e*H,A+=e*J,_+=e*Q,h+=(e=t[1])*P,a+=e*N,f+=e*O,s+=e*C,u+=e*F,c+=e*I,y+=e*Z,l+=e*G,w+=e*q,v+=e*D,p+=e*V,b+=e*X,g+=e*j,A+=e*H,_+=e*J,U+=e*Q,a+=(e=t[2])*P,f+=e*N,s+=e*O,u+=e*C,c+=e*F,y+=e*I,l+=e*Z,w+=e*G,v+=e*q,p+=e*D,b+=e*V,g+=e*X,A+=e*j,_+=e*H,U+=e*J,d+=e*Q,f+=(e=t[3])*P,s+=e*N,u+=e*O,c+=e*C,y+=e*F,l+=e*I,w+=e*Z,v+=e*G,p+=e*q,b+=e*D,g+=e*V,A+=e*X,_+=e*j,U+=e*H,d+=e*J,E+=e*Q,s+=(e=t[4])*P,u+=e*N,c+=e*O,y+=e*C,l+=e*F,w+=e*I,v+=e*Z,p+=e*G,b+=e*q,g+=e*D,A+=e*V,_+=e*X,U+=e*j,d+=e*H,E+=e*J,x+=e*Q,u+=(e=t[5])*P,c+=e*N,y+=e*O,l+=e*C,w+=e*F,v+=e*I,p+=e*Z,b+=e*G,g+=e*q,A+=e*D,_+=e*V,U+=e*X,d+=e*j,E+=e*H,x+=e*J,M+=e*Q,c+=(e=t[6])*P,y+=e*N,l+=e*O,w+=e*C,v+=e*F,p+=e*I,b+=e*Z,g+=e*G,A+=e*q,_+=e*D,U+=e*V,d+=e*X,E+=e*j,x+=e*H,M+=e*J,m+=e*Q,y+=(e=t[7])*P,l+=e*N,w+=e*O,v+=e*C,p+=e*F,b+=e*I,g+=e*Z,A+=e*G,_+=e*q,U+=e*D,d+=e*V,E+=e*X,x+=e*j,M+=e*H,m+=e*J,B+=e*Q,l+=(e=t[8])*P,w+=e*N,v+=e*O,p+=e*C,b+=e*F,g+=e*I,A+=e*Z,_+=e*G,U+=e*q,d+=e*D,E+=e*V,x+=e*X,M+=e*j,m+=e*H,B+=e*J,S+=e*Q,w+=(e=t[9])*P,v+=e*N,p+=e*O,b+=e*C,g+=e*F,A+=e*I,_+=e*Z,U+=e*G,d+=e*q,E+=e*D,x+=e*V,M+=e*X,m+=e*j,B+=e*H,S+=e*J,k+=e*Q,v+=(e=t[10])*P,p+=e*N,b+=e*O,g+=e*C,A+=e*F,_+=e*I,U+=e*Z,d+=e*G,E+=e*q,x+=e*D,M+=e*V,m+=e*X,B+=e*j,S+=e*H,k+=e*J,K+=e*Q,p+=(e=t[11])*P,b+=e*N,g+=e*O,A+=e*C,_+=e*F,U+=e*I,d+=e*Z,E+=e*G,x+=e*q,M+=e*D,m+=e*V,B+=e*X,S+=e*j,k+=e*H,K+=e*J,Y+=e*Q,b+=(e=t[12])*P,g+=e*N,A+=e*O,_+=e*C,U+=e*F,d+=e*I,E+=e*Z,x+=e*G,M+=e*q,m+=e*D,B+=e*V,S+=e*X,k+=e*j,K+=e*H,Y+=e*J,L+=e*Q,g+=(e=t[13])*P,A+=e*N,_+=e*O,U+=e*C,d+=e*F,E+=e*I,x+=e*Z,M+=e*G,m+=e*q,B+=e*D,S+=e*V,k+=e*X,K+=e*j,Y+=e*H,L+=e*J,T+=e*Q,A+=(e=t[14])*P,_+=e*N,U+=e*O,d+=e*C,E+=e*F,x+=e*I,M+=e*Z,m+=e*G,B+=e*q,S+=e*D,k+=e*V,K+=e*X,Y+=e*j,L+=e*H,T+=e*J,z+=e*Q,_+=(e=t[15])*P,h+=38*(d+=e*O),a+=38*(E+=e*C),f+=38*(x+=e*F),s+=38*(M+=e*I),u+=38*(m+=e*Z),c+=38*(B+=e*G),y+=38*(S+=e*q),l+=38*(k+=e*D),w+=38*(K+=e*V),v+=38*(Y+=e*X),p+=38*(L+=e*j),b+=38*(T+=e*H),g+=38*(z+=e*J),A+=38*(R+=e*Q),i=(e=(i+=38*(U+=e*N))+(o=1)+65535)-65536*(o=Math.floor(e/65536)),h=(e=h+o+65535)-65536*(o=Math.floor(e/65536)),a=(e=a+o+65535)-65536*(o=Math.floor(e/65536)),f=(e=f+o+65535)-65536*(o=Math.floor(e/65536)),s=(e=s+o+65535)-65536*(o=Math.floor(e/65536)),u=(e=u+o+65535)-65536*(o=Math.floor(e/65536)),c=(e=c+o+65535)-65536*(o=Math.floor(e/65536)),y=(e=y+o+65535)-65536*(o=Math.floor(e/65536)),l=(e=l+o+65535)-65536*(o=Math.floor(e/65536)),w=(e=w+o+65535)-65536*(o=Math.floor(e/65536)),v=(e=v+o+65535)-65536*(o=Math.floor(e/65536)),p=(e=p+o+65535)-65536*(o=Math.floor(e/65536)),b=(e=b+o+65535)-65536*(o=Math.floor(e/65536)),g=(e=g+o+65535)-65536*(o=Math.floor(e/65536)),A=(e=A+o+65535)-65536*(o=Math.floor(e/65536)),_=(e=_+o+65535)-65536*(o=Math.floor(e/65536)),i=(e=(i+=o-1+37*(o-1))+(o=1)+65535)-65536*(o=Math.floor(e/65536)),h=(e=h+o+65535)-65536*(o=Math.floor(e/65536)),a=(e=a+o+65535)-65536*(o=Math.floor(e/65536)),f=(e=f+o+65535)-65536*(o=Math.floor(e/65536)),s=(e=s+o+65535)-65536*(o=Math.floor(e/65536)),u=(e=u+o+65535)-65536*(o=Math.floor(e/65536)),c=(e=c+o+65535)-65536*(o=Math.floor(e/65536)),y=(e=y+o+65535)-65536*(o=Math.floor(e/65536)),l=(e=l+o+65535)-65536*(o=Math.floor(e/65536)),w=(e=w+o+65535)-65536*(o=Math.floor(e/65536)),v=(e=v+o+65535)-65536*(o=Math.floor(e/65536)),p=(e=p+o+65535)-65536*(o=Math.floor(e/65536)),b=(e=b+o+65535)-65536*(o=Math.floor(e/65536)),g=(e=g+o+65535)-65536*(o=Math.floor(e/65536)),A=(e=A+o+65535)-65536*(o=Math.floor(e/65536)),_=(e=_+o+65535)-65536*(o=Math.floor(e/65536)),i+=o-1+37*(o-1),r[0]=i,r[1]=h,r[2]=a,r[3]=f,r[4]=s,r[5]=u,r[6]=c,r[7]=y,r[8]=l,r[9]=w,r[10]=v,r[11]=p,r[12]=b,r[13]=g,r[14]=A,r[15]=_}function I(r,t){F(r,t,t)}function Z(r,t){var n,e=v();for(n=0;n<16;n++)e[n]=t[n];for(n=253;0<=n;n--)I(e,e),2!==n&&4!==n&&F(e,e,t);for(n=0;n<16;n++)r[n]=e[n]}function G(r,t){var n,e=v();for(n=0;n<16;n++)e[n]=t[n];for(n=250;0<=n;n--)I(e,e),1!==n&&F(e,e,t);for(n=0;n<16;n++)r[n]=e[n]}function q(r,t,n){var e,o,i=new Uint8Array(32),h=new Float64Array(80),a=v(),f=v(),s=v(),u=v(),c=v(),y=v();for(o=0;o<31;o++)i[o]=t[o];for(i[31]=127&t[31]|64,i[0]&=248,N(h,n),o=0;o<16;o++)f[o]=h[o],u[o]=a[o]=s[o]=0;for(a[0]=u[0]=1,o=254;0<=o;--o)T(a,f,e=i[o>>>3]>>>(7&o)&1),T(s,u,e),O(c,a,s),C(a,a,s),O(s,f,u),C(f,f,u),I(u,c),I(y,a),F(a,s,a),F(s,f,c),O(c,a,s),C(a,a,s),I(f,a),C(s,u,y),F(a,s,p),O(a,a,u),F(s,s,a),F(a,u,y),F(u,f,h),I(f,c),T(a,f,e),T(s,u,e);for(o=0;o<16;o++)h[o+16]=a[o],h[o+32]=s[o],h[o+48]=f[o],h[o+64]=u[o];var l=h.subarray(32),w=h.subarray(16);return Z(l,l),F(w,w,l),z(r,w),0}function D(r,t){return q(r,t,n)}function V(r,t){return h(t,32),D(r,t)}function X(r,t,n){var e=new Uint8Array(32);return q(e,n,t),_(r,o,e,U)}m.prototype.blocks=function(r,t,n){for(var e,o,i,h,a,f,s,u,c,y,l,w,v,p,b,g,A,_,U,d=this.fin?0:2048,E=this.h[0],x=this.h[1],M=this.h[2],m=this.h[3],B=this.h[4],S=this.h[5],k=this.h[6],K=this.h[7],Y=this.h[8],L=this.h[9],T=this.r[0],z=this.r[1],R=this.r[2],P=this.r[3],N=this.r[4],O=this.r[5],C=this.r[6],F=this.r[7],I=this.r[8],Z=this.r[9];16<=n;)y=c=0,y+=(E+=8191&(e=255&r[t+0]|(255&r[t+1])<<8))*T,y+=(x+=8191&(e>>>13|(o=255&r[t+2]|(255&r[t+3])<<8)<<3))*(5*Z),y+=(M+=8191&(o>>>10|(i=255&r[t+4]|(255&r[t+5])<<8)<<6))*(5*I),y+=(m+=8191&(i>>>7|(h=255&r[t+6]|(255&r[t+7])<<8)<<9))*(5*F),c=(y+=(B+=8191&(h>>>4|(a=255&r[t+8]|(255&r[t+9])<<8)<<12))*(5*C))>>>13,y&=8191,y+=(S+=a>>>1&8191)*(5*O),y+=(k+=8191&(a>>>14|(f=255&r[t+10]|(255&r[t+11])<<8)<<2))*(5*N),y+=(K+=8191&(f>>>11|(s=255&r[t+12]|(255&r[t+13])<<8)<<5))*(5*P),y+=(Y+=8191&(s>>>8|(u=255&r[t+14]|(255&r[t+15])<<8)<<8))*(5*R),l=c+=(y+=(L+=u>>>5|d)*(5*z))>>>13,l+=E*z,l+=x*T,l+=M*(5*Z),l+=m*(5*I),c=(l+=B*(5*F))>>>13,l&=8191,l+=S*(5*C),l+=k*(5*O),l+=K*(5*N),l+=Y*(5*P),c+=(l+=L*(5*R))>>>13,l&=8191,w=c,w+=E*R,w+=x*z,w+=M*T,w+=m*(5*Z),c=(w+=B*(5*I))>>>13,w&=8191,w+=S*(5*F),w+=k*(5*C),w+=K*(5*O),w+=Y*(5*N),v=c+=(w+=L*(5*P))>>>13,v+=E*P,v+=x*R,v+=M*z,v+=m*T,c=(v+=B*(5*Z))>>>13,v&=8191,v+=S*(5*I),v+=k*(5*F),v+=K*(5*C),v+=Y*(5*O),p=c+=(v+=L*(5*N))>>>13,p+=E*N,p+=x*P,p+=M*R,p+=m*z,c=(p+=B*T)>>>13,p&=8191,p+=S*(5*Z),p+=k*(5*I),p+=K*(5*F),p+=Y*(5*C),b=c+=(p+=L*(5*O))>>>13,b+=E*O,b+=x*N,b+=M*P,b+=m*R,c=(b+=B*z)>>>13,b&=8191,b+=S*T,b+=k*(5*Z),b+=K*(5*I),b+=Y*(5*F),g=c+=(b+=L*(5*C))>>>13,g+=E*C,g+=x*O,g+=M*N,g+=m*P,c=(g+=B*R)>>>13,g&=8191,g+=S*z,g+=k*T,g+=K*(5*Z),g+=Y*(5*I),A=c+=(g+=L*(5*F))>>>13,A+=E*F,A+=x*C,A+=M*O,A+=m*N,c=(A+=B*P)>>>13,A&=8191,A+=S*R,A+=k*z,A+=K*T,A+=Y*(5*Z),_=c+=(A+=L*(5*I))>>>13,_+=E*I,_+=x*F,_+=M*C,_+=m*O,c=(_+=B*N)>>>13,_&=8191,_+=S*P,_+=k*R,_+=K*z,_+=Y*T,U=c+=(_+=L*(5*Z))>>>13,U+=E*Z,U+=x*I,U+=M*F,U+=m*C,c=(U+=B*O)>>>13,U&=8191,U+=S*N,U+=k*P,U+=K*R,U+=Y*z,E=y=8191&(c=(c=((c+=(U+=L*T)>>>13)<<2)+c|0)+(y&=8191)|0),x=l+=c>>>=13,M=w&=8191,m=v&=8191,B=p&=8191,S=b&=8191,k=g&=8191,K=A&=8191,Y=_&=8191,L=U&=8191,t+=16,n-=16;this.h[0]=E,this.h[1]=x,this.h[2]=M,this.h[3]=m,this.h[4]=B,this.h[5]=S,this.h[6]=k,this.h[7]=K,this.h[8]=Y,this.h[9]=L},m.prototype.finish=function(r,t){var n,e,o,i,h=new Uint16Array(10);if(this.leftover){for(i=this.leftover,this.buffer[i++]=1;i<16;i++)this.buffer[i]=0;this.fin=1,this.blocks(this.buffer,0,16)}for(n=this.h[1]>>>13,this.h[1]&=8191,i=2;i<10;i++)this.h[i]+=n,n=this.h[i]>>>13,this.h[i]&=8191;for(this.h[0]+=5*n,n=this.h[0]>>>13,this.h[0]&=8191,this.h[1]+=n,n=this.h[1]>>>13,this.h[1]&=8191,this.h[2]+=n,h[0]=this.h[0]+5,n=h[0]>>>13,h[0]&=8191,i=1;i<10;i++)h[i]=this.h[i]+n,n=h[i]>>>13,h[i]&=8191;for(h[9]-=8192,e=(1^n)-1,i=0;i<10;i++)h[i]&=e;for(e=~e,i=0;i<10;i++)this.h[i]=this.h[i]&e|h[i];for(this.h[0]=65535&(this.h[0]|this.h[1]<<13),this.h[1]=65535&(this.h[1]>>>3|this.h[2]<<10),this.h[2]=65535&(this.h[2]>>>6|this.h[3]<<7),this.h[3]=65535&(this.h[3]>>>9|this.h[4]<<4),this.h[4]=65535&(this.h[4]>>>12|this.h[5]<<1|this.h[6]<<14),this.h[5]=65535&(this.h[6]>>>2|this.h[7]<<11),this.h[6]=65535&(this.h[7]>>>5|this.h[8]<<8),this.h[7]=65535&(this.h[8]>>>8|this.h[9]<<5),o=this.h[0]+this.pad[0],this.h[0]=65535&o,i=1;i<8;i++)o=(this.h[i]+this.pad[i]|0)+(o>>>16)|0,this.h[i]=65535&o;r[t+0]=this.h[0]>>>0&255,r[t+1]=this.h[0]>>>8&255,r[t+2]=this.h[1]>>>0&255,r[t+3]=this.h[1]>>>8&255,r[t+4]=this.h[2]>>>0&255,r[t+5]=this.h[2]>>>8&255,r[t+6]=this.h[3]>>>0&255,r[t+7]=this.h[3]>>>8&255,r[t+8]=this.h[4]>>>0&255,r[t+9]=this.h[4]>>>8&255,r[t+10]=this.h[5]>>>0&255,r[t+11]=this.h[5]>>>8&255,r[t+12]=this.h[6]>>>0&255,r[t+13]=this.h[6]>>>8&255,r[t+14]=this.h[7]>>>0&255,r[t+15]=this.h[7]>>>8&255},m.prototype.update=function(r,t,n){var e,o;if(this.leftover){for(n<(o=16-this.leftover)&&(o=n),e=0;e<o;e++)this.buffer[this.leftover+e]=r[t+e];if(n-=o,t+=o,this.leftover+=o,this.leftover<16)return;this.blocks(this.buffer,0,16),this.leftover=0}if(16<=n&&(o=n-n%16,this.blocks(r,t,o),t+=o,n-=o),n){for(e=0;e<n;e++)this.buffer[this.leftover+e]=r[t+e];this.leftover+=n}};var j=k,H=K;var J=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591];function Q(r,t,n,e){for(var o,i,h,a,f,s,u,c,y,l,w,v,p,b,g,A,_,U,d,E,x,M,m,B,S=new Int32Array(16),k=new Int32Array(16),K=r[0],Y=r[1],L=r[2],T=r[3],z=r[4],R=r[5],P=r[6],N=r[7],O=t[0],C=t[1],F=t[2],I=t[3],Z=t[4],G=t[5],q=t[6],D=t[7],V=0;128<=e;){for(_=0;_<16;_++)U=8*_+V,S[_]=n[U+0]<<24|n[U+1]<<16|n[U+2]<<8|n[U+3],k[_]=n[U+4]<<24|n[U+5]<<16|n[U+6]<<8|n[U+7];for(_=0;_<80;_++)if(o=Y,i=L,h=T,c=C,y=F,l=I,x=65535&(E=D),M=E>>>16,m=65535&(d=N),B=d>>>16,x+=65535&(E=((w=Z)>>>14|(a=z)<<18)^(Z>>>18|z<<14)^(z>>>9|Z<<23)),M+=E>>>16,m+=65535&(d=(z>>>14|Z<<18)^(z>>>18|Z<<14)^(Z>>>9|z<<23)),B+=d>>>16,x+=65535&(E=Z&(v=G)^~Z&(p=q)),M+=E>>>16,m+=65535&(d=z&(f=R)^~z&(s=P)),B+=d>>>16,d=J[2*_],x+=65535&(E=J[2*_+1]),M+=E>>>16,m+=65535&d,B+=d>>>16,d=S[_%16],M+=(E=k[_%16])>>>16,m+=65535&d,B+=d>>>16,m+=(M+=(x+=65535&E)>>>16)>>>16,x=65535&(E=A=65535&x|M<<16),M=E>>>16,m=65535&(d=g=65535&m|(B+=m>>>16)<<16),B=d>>>16,x+=65535&(E=(O>>>28|K<<4)^(K>>>2|O<<30)^(K>>>7|O<<25)),M+=E>>>16,m+=65535&(d=(K>>>28|O<<4)^(O>>>2|K<<30)^(O>>>7|K<<25)),B+=d>>>16,M+=(E=O&C^O&F^C&F)>>>16,m+=65535&(d=K&Y^K&L^Y&L),B+=d>>>16,u=65535&(m+=(M+=(x+=65535&E)>>>16)>>>16)|(B+=m>>>16)<<16,b=65535&x|M<<16,x=65535&(E=l),M=E>>>16,m=65535&(d=h),B=d>>>16,M+=(E=A)>>>16,m+=65535&(d=g),B+=d>>>16,Y=K,L=o,T=i,z=h=65535&(m+=(M+=(x+=65535&E)>>>16)>>>16)|(B+=m>>>16)<<16,R=a,P=f,N=s,K=u,C=O,F=c,I=y,Z=l=65535&x|M<<16,G=w,q=v,D=p,O=b,_%16==15)for(U=0;U<16;U++)d=S[U],x=65535&(E=k[U]),M=E>>>16,m=65535&d,B=d>>>16,d=S[(U+9)%16],x+=65535&(E=k[(U+9)%16]),M+=E>>>16,m+=65535&d,B+=d>>>16,g=S[(U+1)%16],x+=65535&(E=((A=k[(U+1)%16])>>>1|g<<31)^(A>>>8|g<<24)^(A>>>7|g<<25)),M+=E>>>16,m+=65535&(d=(g>>>1|A<<31)^(g>>>8|A<<24)^g>>>7),B+=d>>>16,g=S[(U+14)%16],M+=(E=((A=k[(U+14)%16])>>>19|g<<13)^(g>>>29|A<<3)^(A>>>6|g<<26))>>>16,m+=65535&(d=(g>>>19|A<<13)^(A>>>29|g<<3)^g>>>6),B+=d>>>16,B+=(m+=(M+=(x+=65535&E)>>>16)>>>16)>>>16,S[U]=65535&m|B<<16,k[U]=65535&x|M<<16;x=65535&(E=O),M=E>>>16,m=65535&(d=K),B=d>>>16,d=r[0],M+=(E=t[0])>>>16,m+=65535&d,B+=d>>>16,B+=(m+=(M+=(x+=65535&E)>>>16)>>>16)>>>16,r[0]=K=65535&m|B<<16,t[0]=O=65535&x|M<<16,x=65535&(E=C),M=E>>>16,m=65535&(d=Y),B=d>>>16,d=r[1],M+=(E=t[1])>>>16,m+=65535&d,B+=d>>>16,B+=(m+=(M+=(x+=65535&E)>>>16)>>>16)>>>16,r[1]=Y=65535&m|B<<16,t[1]=C=65535&x|M<<16,x=65535&(E=F),M=E>>>16,m=65535&(d=L),B=d>>>16,d=r[2],M+=(E=t[2])>>>16,m+=65535&d,B+=d>>>16,B+=(m+=(M+=(x+=65535&E)>>>16)>>>16)>>>16,r[2]=L=65535&m|B<<16,t[2]=F=65535&x|M<<16,x=65535&(E=I),M=E>>>16,m=65535&(d=T),B=d>>>16,d=r[3],M+=(E=t[3])>>>16,m+=65535&d,B+=d>>>16,B+=(m+=(M+=(x+=65535&E)>>>16)>>>16)>>>16,r[3]=T=65535&m|B<<16,t[3]=I=65535&x|M<<16,x=65535&(E=Z),M=E>>>16,m=65535&(d=z),B=d>>>16,d=r[4],M+=(E=t[4])>>>16,m+=65535&d,B+=d>>>16,B+=(m+=(M+=(x+=65535&E)>>>16)>>>16)>>>16,r[4]=z=65535&m|B<<16,t[4]=Z=65535&x|M<<16,x=65535&(E=G),M=E>>>16,m=65535&(d=R),B=d>>>16,d=r[5],M+=(E=t[5])>>>16,m+=65535&d,B+=d>>>16,B+=(m+=(M+=(x+=65535&E)>>>16)>>>16)>>>16,r[5]=R=65535&m|B<<16,t[5]=G=65535&x|M<<16,x=65535&(E=q),M=E>>>16,m=65535&(d=P),B=d>>>16,d=r[6],M+=(E=t[6])>>>16,m+=65535&d,B+=d>>>16,B+=(m+=(M+=(x+=65535&E)>>>16)>>>16)>>>16,r[6]=P=65535&m|B<<16,t[6]=q=65535&x|M<<16,x=65535&(E=D),M=E>>>16,m=65535&(d=N),B=d>>>16,d=r[7],M+=(E=t[7])>>>16,m+=65535&d,B+=d>>>16,B+=(m+=(M+=(x+=65535&E)>>>16)>>>16)>>>16,r[7]=N=65535&m|B<<16,t[7]=D=65535&x|M<<16,V+=128,e-=128}return e}function W(r,t,n){var e,o=new Int32Array(8),i=new Int32Array(8),h=new Uint8Array(256),a=n;for(o[0]=1779033703,o[1]=3144134277,o[2]=1013904242,o[3]=2773480762,o[4]=1359893119,o[5]=2600822924,o[6]=528734635,o[7]=1541459225,i[0]=4089235720,i[1]=2227873595,i[2]=4271175723,i[3]=1595750129,i[4]=2917565137,i[5]=725511199,i[6]=4215389547,i[7]=327033209,Q(o,i,t,n),n%=128,e=0;e<n;e++)h[e]=t[a-n+e];for(h[n]=128,h[(n=256-128*(n<112?1:0))-9]=0,f(h,n-8,a/536870912|0,a<<3),Q(o,i,h,n),e=0;e<8;e++)f(r,8*e,o[e],i[e]);return 0}function $(r,t){var n=v(),e=v(),o=v(),i=v(),h=v(),a=v(),f=v(),s=v(),u=v();C(n,r[1],r[0]),C(u,t[1],t[0]),F(n,n,u),O(e,r[0],r[1]),O(u,t[0],t[1]),F(e,e,u),F(o,r[3],t[3]),F(o,o,y),F(i,r[2],t[2]),O(i,i,i),C(h,e,n),C(a,i,o),O(f,i,o),O(s,e,n),F(r[0],h,a),F(r[1],s,f),F(r[2],f,a),F(r[3],h,s)}function rr(r,t,n){var e;for(e=0;e<4;e++)T(r[e],t[e],n)}function tr(r,t){var n=v(),e=v(),o=v();Z(o,t[2]),F(n,t[0],o),F(e,t[1],o),z(r,e),r[31]^=P(n)<<7}function nr(r,t,n){var e,o;for(Y(r[0],s),Y(r[1],u),Y(r[2],u),Y(r[3],s),o=255;0<=o;--o)rr(r,t,e=n[o/8|0]>>(7&o)&1),$(t,r),$(r,r),rr(r,t,e)}function er(r,t){var n=[v(),v(),v(),v()];Y(n[0],e),Y(n[1],a),Y(n[2],u),F(n[3],e,a),nr(r,n,t)}function or(r,t,n){var e,o=new Uint8Array(64),i=[v(),v(),v(),v()];for(n||h(t,32),W(o,t,32),o[0]&=248,o[31]&=127,o[31]|=64,er(i,o),tr(r,i),e=0;e<32;e++)t[e+32]=r[e];return 0}var ir=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function hr(r,t){var n,e,o,i;for(e=63;32<=e;--e){for(n=0,o=e-32,i=e-12;o<i;++o)t[o]+=n-16*t[e]*ir[o-(e-32)],n=Math.floor((t[o]+128)/256),t[o]-=256*n;t[o]+=n,t[e]=0}for(o=n=0;o<32;o++)t[o]+=n-(t[31]>>4)*ir[o],n=t[o]>>8,t[o]&=255;for(o=0;o<32;o++)t[o]-=n*ir[o];for(e=0;e<32;e++)t[e+1]+=t[e]>>8,r[e]=255&t[e]}function ar(r){var t,n=new Float64Array(64);for(t=0;t<64;t++)n[t]=r[t];for(t=0;t<64;t++)r[t]=0;hr(r,n)}function fr(r,t,n,e){var o,i,h=new Uint8Array(64),a=new Uint8Array(64),f=new Uint8Array(64),s=new Float64Array(64),u=[v(),v(),v(),v()];W(h,e,32),h[0]&=248,h[31]&=127,h[31]|=64;var c=n+64;for(o=0;o<n;o++)r[64+o]=t[o];for(o=0;o<32;o++)r[32+o]=h[32+o];for(W(f,r.subarray(32),n+32),ar(f),er(u,f),tr(r,u),o=32;o<64;o++)r[o]=e[o];for(W(a,r,n+64),ar(a),o=0;o<64;o++)s[o]=0;for(o=0;o<32;o++)s[o]=f[o];for(o=0;o<32;o++)for(i=0;i<32;i++)s[o+i]+=a[o]*h[i];return hr(r.subarray(32),s),c}function sr(r,t,n,e){var o,i=new Uint8Array(32),h=new Uint8Array(64),a=[v(),v(),v(),v()],f=[v(),v(),v(),v()];if(n<64)return-1;if(function(r,t){var n=v(),e=v(),o=v(),i=v(),h=v(),a=v(),f=v();if(Y(r[2],u),N(r[1],t),I(o,r[1]),F(i,o,c),C(o,o,r[2]),O(i,r[2],i),I(h,i),I(a,h),F(f,a,h),F(n,f,o),F(n,n,i),G(n,n),F(n,n,o),F(n,n,i),F(n,n,i),F(r[0],n,i),I(e,r[0]),F(e,e,i),R(e,o)&&F(r[0],r[0],l),I(e,r[0]),F(e,e,i),R(e,o))return 1;P(r[0])===t[31]>>7&&C(r[0],s,r[0]),F(r[3],r[0],r[1])}(f,e))return-1;for(o=0;o<n;o++)r[o]=t[o];for(o=0;o<32;o++)r[o+32]=e[o];if(W(h,r,n),ar(h),nr(a,f,h),er(f,t.subarray(32)),$(a,f),tr(i,a),n-=64,g(t,0,i,0)){for(o=0;o<n;o++)r[o]=0;return-1}for(o=0;o<n;o++)r[o]=t[o+64];return n}function ur(r,t){if(32!==r.length)throw new Error("bad key size");if(24!==t.length)throw new Error("bad nonce size")}function cr(){for(var r=0;r<arguments.length;r++)if(!(arguments[r]instanceof Uint8Array))throw new TypeError("unexpected type, use Uint8Array")}function yr(r){for(var t=0;t<r.length;t++)r[t]=0}i.lowlevel={crypto_core_hsalsa20:_,crypto_stream_xor:M,crypto_stream:x,crypto_stream_salsa20_xor:d,crypto_stream_salsa20:E,crypto_onetimeauth:B,crypto_onetimeauth_verify:S,crypto_verify_16:b,crypto_verify_32:g,crypto_secretbox:k,crypto_secretbox_open:K,crypto_scalarmult:q,crypto_scalarmult_base:D,crypto_box_beforenm:X,crypto_box_afternm:j,crypto_box:function(r,t,n,e,o,i){var h=new Uint8Array(32);return X(h,o,i),j(r,t,n,e,h)},crypto_box_open:function(r,t,n,e,o,i){var h=new Uint8Array(32);return X(h,o,i),H(r,t,n,e,h)},crypto_box_keypair:V,crypto_hash:W,crypto_sign:fr,crypto_sign_keypair:or,crypto_sign_open:sr,crypto_secretbox_KEYBYTES:32,crypto_secretbox_NONCEBYTES:24,crypto_secretbox_ZEROBYTES:32,crypto_secretbox_BOXZEROBYTES:16,crypto_scalarmult_BYTES:32,crypto_scalarmult_SCALARBYTES:32,crypto_box_PUBLICKEYBYTES:32,crypto_box_SECRETKEYBYTES:32,crypto_box_BEFORENMBYTES:32,crypto_box_NONCEBYTES:24,crypto_box_ZEROBYTES:32,crypto_box_BOXZEROBYTES:16,crypto_sign_BYTES:64,crypto_sign_PUBLICKEYBYTES:32,crypto_sign_SECRETKEYBYTES:64,crypto_sign_SEEDBYTES:32,crypto_hash_BYTES:64,gf:v,D:c,L:ir,pack25519:z,unpack25519:N,M:F,A:O,S:I,Z:C,pow2523:G,add:$,set25519:Y,modL:hr,scalarmult:nr,scalarbase:er},i.randomBytes=function(r){var t=new Uint8Array(r);return h(t,r),t},i.secretbox=function(r,t,n){cr(r,t,n),ur(n,t);for(var e=new Uint8Array(32+r.length),o=new Uint8Array(e.length),i=0;i<r.length;i++)e[i+32]=r[i];return k(o,e,e.length,t,n),o.subarray(16)},i.secretbox.open=function(r,t,n){cr(r,t,n),ur(n,t);for(var e=new Uint8Array(16+r.length),o=new Uint8Array(e.length),i=0;i<r.length;i++)e[i+16]=r[i];return e.length<32||0!==K(o,e,e.length,t,n)?null:o.subarray(32)},i.secretbox.keyLength=32,i.secretbox.nonceLength=24,i.secretbox.overheadLength=16,i.scalarMult=function(r,t){if(cr(r,t),32!==r.length)throw new Error("bad n size");if(32!==t.length)throw new Error("bad p size");var n=new Uint8Array(32);return q(n,r,t),n},i.scalarMult.base=function(r){if(cr(r),32!==r.length)throw new Error("bad n size");var t=new Uint8Array(32);return D(t,r),t},i.scalarMult.scalarLength=32,i.scalarMult.groupElementLength=32,i.box=function(r,t,n,e){var o=i.box.before(n,e);return i.secretbox(r,t,o)},i.box.before=function(r,t){cr(r,t),function(r,t){if(32!==r.length)throw new Error("bad public key size");if(32!==t.length)throw new Error("bad secret key size")}(r,t);var n=new Uint8Array(32);return X(n,r,t),n},i.box.after=i.secretbox,i.box.open=function(r,t,n,e){var o=i.box.before(n,e);return i.secretbox.open(r,t,o)},i.box.open.after=i.secretbox.open,i.box.keyPair=function(){var r=new Uint8Array(32),t=new Uint8Array(32);return V(r,t),{publicKey:r,secretKey:t}},i.box.keyPair.fromSecretKey=function(r){if(cr(r),32!==r.length)throw new Error("bad secret key size");var t=new Uint8Array(32);return D(t,r),{publicKey:t,secretKey:new Uint8Array(r)}},i.box.publicKeyLength=32,i.box.secretKeyLength=32,i.box.sharedKeyLength=32,i.box.nonceLength=24,i.box.overheadLength=i.secretbox.overheadLength,i.sign=function(r,t){if(cr(r,t),64!==t.length)throw new Error("bad secret key size");var n=new Uint8Array(64+r.length);return fr(n,r,r.length,t),n},i.sign.open=function(r,t){if(cr(r,t),32!==t.length)throw new Error("bad public key size");var n=new Uint8Array(r.length),e=sr(n,r,r.length,t);if(e<0)return null;for(var o=new Uint8Array(e),i=0;i<o.length;i++)o[i]=n[i];return o},i.sign.detached=function(r,t){for(var n=i.sign(r,t),e=new Uint8Array(64),o=0;o<e.length;o++)e[o]=n[o];return e},i.sign.detached.verify=function(r,t,n){if(cr(r,t,n),64!==t.length)throw new Error("bad signature size");if(32!==n.length)throw new Error("bad public key size");var e,o=new Uint8Array(64+r.length),i=new Uint8Array(64+r.length);for(e=0;e<64;e++)o[e]=t[e];for(e=0;e<r.length;e++)o[e+64]=r[e];return 0<=sr(i,o,o.length,n)},i.sign.keyPair=function(){var r=new Uint8Array(32),t=new Uint8Array(64);return or(r,t),{publicKey:r,secretKey:t}},i.sign.keyPair.fromSecretKey=function(r){if(cr(r),64!==r.length)throw new Error("bad secret key size");for(var t=new Uint8Array(32),n=0;n<t.length;n++)t[n]=r[32+n];return{publicKey:t,secretKey:new Uint8Array(r)}},i.sign.keyPair.fromSeed=function(r){if(cr(r),32!==r.length)throw new Error("bad seed size");for(var t=new Uint8Array(32),n=new Uint8Array(64),e=0;e<32;e++)n[e]=r[e];return or(t,n,!0),{publicKey:t,secretKey:n}},i.sign.publicKeyLength=32,i.sign.secretKeyLength=64,i.sign.seedLength=32,i.sign.signatureLength=64,i.hash=function(r){cr(r);var t=new Uint8Array(64);return W(t,r,r.length),t},i.hash.hashLength=64,i.verify=function(r,t){return cr(r,t),0!==r.length&&0!==t.length&&(r.length===t.length&&0===w(r,0,t,0,r.length))},i.setPRNG=function(r){h=r},function(){var o="undefined"!=typeof self?self.crypto||self.msCrypto:null;if(o&&o.getRandomValues){i.setPRNG(function(r,t){var n,e=new Uint8Array(t);for(n=0;n<t;n+=65536)o.getRandomValues(e.subarray(n,n+Math.min(t-n,65536)));for(n=0;n<t;n++)r[n]=e[n];yr(e)})}else"undefined"!=typeof require&&(o=require("crypto"))&&o.randomBytes&&i.setPRNG(function(r,t){var n,e=o.randomBytes(t);for(n=0;n<t;n++)r[n]=e[n];yr(e)})}()}("undefined"!=typeof module&&module.exports?module.exports:self.nacl=self.nacl||{});
```


### FILE: /opt/logos/www/wallet_prod/vendor/wordlist_en.js

```js
window.BIP39_WORDS=['abandon', 'ability', 'able', 'about', 'above', 'absent', 'absorb', 'abstract', 'absurd', 'abuse', 'access', 'accident', 'account', 'accuse', 'achieve', 'acid', 'acoustic', 'acquire', 'across', 'act', 'action', 'actor', 'actress', 'actual', 'adapt', 'add', 'addict', 'address', 'adjust', 'admit', 'adult', 'advance', 'advice', 'aerobic', 'affair', 'afford', 'afraid', 'again', 'age', 'agent', 'agree', 'ahead', 'aim', 'air', 'airport', 'aisle', 'alarm', 'album', 'alcohol', 'alert', 'alien', 'all', 'alley', 'allow', 'almost', 'alone', 'alpha', 'already', 'also', 'alter', 'always', 'amateur', 'amazing', 'among', 'amount', 'amused', 'analyst', 'anchor', 'ancient', 'anger', 'angle', 'angry', 'animal', 'ankle', 'announce', 'annual', 'another', 'answer', 'antenna', 'antique', 'anxiety', 'any', 'apart', 'apology', 'appear', 'apple', 'approve', 'april', 'arch', 'arctic', 'area', 'arena', 'argue', 'arm', 'armed', 'armor', 'army', 'around', 'arrange', 'arrest', 'arrive', 'arrow', 'art', 'artefact', 'artist', 'artwork', 'ask', 'aspect', 'assault', 'asset', 'assist', 'assume', 'asthma', 'athlete', 'atom', 'attack', 'attend', 'attitude', 'attract', 'auction', 'audit', 'august', 'aunt', 'author', 'auto', 'autumn', 'average', 'avocado', 'avoid', 'awake', 'aware', 'away', 'awesome', 'awful', 'awkward', 'axis', 'baby', 'bachelor', 'bacon', 'badge', 'bag', 'balance', 'balcony', 'ball', 'bamboo', 'banana', 'banner', 'bar', 'barely', 'bargain', 'barrel', 'base', 'basic', 'basket', 'battle', 'beach', 'bean', 'beauty', 'because', 'become', 'beef', 'before', 'begin', 'behave', 'behind', 'believe', 'below', 'belt', 'bench', 'benefit', 'best', 'betray', 'better', 'between', 'beyond', 'bicycle', 'bid', 'bike', 'bind', 'biology', 'bird', 'birth', 'bitter', 'black', 'blade', 'blame', 'blanket', 'blast', 'bleak', 'bless', 'blind', 'blood', 'blossom', 'blouse', 'blue', 'blur', 'blush', 'board', 'boat', 'body', 'boil', 'bomb', 'bone', 'bonus', 'book', 'boost', 'border', 'boring', 'borrow', 'boss', 'bottom', 'bounce', 'box', 'boy', 'bracket', 'brain', 'brand', 'brass', 'brave', 'bread', 'breeze', 'brick', 'bridge', 'brief', 'bright', 'bring', 'brisk', 'broccoli', 'broken', 'bronze', 'broom', 'brother', 'brown', 'brush', 'bubble', 'buddy', 'budget', 'buffalo', 'build', 'bulb', 'bulk', 'bullet', 'bundle', 'bunker', 'burden', 'burger', 'burst', 'bus', 'business', 'busy', 'butter', 'buyer', 'buzz', 'cabbage', 'cabin', 'cable', 'cactus', 'cage', 'cake', 'call', 'calm', 'camera', 'camp', 'can', 'canal', 'cancel', 'candy', 'cannon', 'canoe', 'canvas', 'canyon', 'capable', 'capital', 'captain', 'car', 'carbon', 'card', 'cargo', 'carpet', 'carry', 'cart', 'case', 'cash', 'casino', 'castle', 'casual', 'cat', 'catalog', 'catch', 'category', 'cattle', 'caught', 'cause', 'caution', 'cave', 'ceiling', 'celery', 'cement', 'census', 'century', 'cereal', 'certain', 'chair', 'chalk', 'champion', 'change', 'chaos', 'chapter', 'charge', 'chase', 'chat', 'cheap', 'check', 'cheese', 'chef', 'cherry', 'chest', 'chicken', 'chief', 'child', 'chimney', 'choice', 'choose', 'chronic', 'chuckle', 'chunk', 'churn', 'cigar', 'cinnamon', 'circle', 'citizen', 'city', 'civil', 'claim', 'clap', 'clarify', 'claw', 'clay', 'clean', 'clerk', 'clever', 'click', 'client', 'cliff', 'climb', 'clinic', 'clip', 'clock', 'clog', 'close', 'cloth', 'cloud', 'clown', 'club', 'clump', 'cluster', 'clutch', 'coach', 'coast', 'coconut', 'code', 'coffee', 'coil', 'coin', 'collect', 'color', 'column', 'combine', 'come', 'comfort', 'comic', 'common', 'company', 'concert', 'conduct', 'confirm', 'congress', 'connect', 'consider', 'control', 'convince', 'cook', 'cool', 'copper', 'copy', 'coral', 'core', 'corn', 'correct', 'cost', 'cotton', 'couch', 'country', 'couple', 'course', 'cousin', 'cover', 'coyote', 'crack', 'cradle', 'craft', 'cram', 'crane', 'crash', 'crater', 'crawl', 'crazy', 'cream', 'credit', 'creek', 'crew', 'cricket', 'crime', 'crisp', 'critic', 'crop', 'cross', 'crouch', 'crowd', 'crucial', 'cruel', 'cruise', 'crumble', 'crunch', 'crush', 'cry', 'crystal', 'cube', 'culture', 'cup', 'cupboard', 'curious', 'current', 'curtain', 'curve', 'cushion', 'custom', 'cute', 'cycle', 'dad', 'damage', 'damp', 'dance', 'danger', 'daring', 'dash', 'daughter', 'dawn', 'day', 'deal', 'debate', 'debris', 'decade', 'december', 'decide', 'decline', 'decorate', 'decrease', 'deer', 'defense', 'define', 'defy', 'degree', 'delay', 'deliver', 'demand', 'demise', 'denial', 'dentist', 'deny', 'depart', 'depend', 'deposit', 'depth', 'deputy', 'derive', 'describe', 'desert', 'design', 'desk', 'despair', 'destroy', 'detail', 'detect', 'develop', 'device', 'devote', 'diagram', 'dial', 'diamond', 'diary', 'dice', 'diesel', 'diet', 'differ', 'digital', 'dignity', 'dilemma', 'dinner', 'dinosaur', 'direct', 'dirt', 'disagree', 'discover', 'disease', 'dish', 'dismiss', 'disorder', 'display', 'distance', 'divert', 'divide', 'divorce', 'dizzy', 'doctor', 'document', 'dog', 'doll', 'dolphin', 'domain', 'donate', 'donkey', 'donor', 'door', 'dose', 'double', 'dove', 'draft', 'dragon', 'drama', 'drastic', 'draw', 'dream', 'dress', 'drift', 'drill', 'drink', 'drip', 'drive', 'drop', 'drum', 'dry', 'duck', 'dumb', 'dune', 'during', 'dust', 'dutch', 'duty', 'dwarf', 'dynamic', 'eager', 'eagle', 'early', 'earn', 'earth', 'easily', 'east', 'easy', 'echo', 'ecology', 'economy', 'edge', 'edit', 'educate', 'effort', 'egg', 'eight', 'either', 'elbow', 'elder', 'electric', 'elegant', 'element', 'elephant', 'elevator', 'elite', 'else', 'embark', 'embody', 'embrace', 'emerge', 'emotion', 'employ', 'empower', 'empty', 'enable', 'enact', 'end', 'endless', 'endorse', 'enemy', 'energy', 'enforce', 'engage', 'engine', 'enhance', 'enjoy', 'enlist', 'enough', 'enrich', 'enroll', 'ensure', 'enter', 'entire', 'entry', 'envelope', 'episode', 'equal', 'equip', 'era', 'erase', 'erode', 'erosion', 'error', 'erupt', 'escape', 'essay', 'essence', 'estate', 'eternal', 'ethics', 'evidence', 'evil', 'evoke', 'evolve', 'exact', 'example', 'excess', 'exchange', 'excite', 'exclude', 'excuse', 'execute', 'exercise', 'exhaust', 'exhibit', 'exile', 'exist', 'exit', 'exotic', 'expand', 'expect', 'expire', 'explain', 'expose', 'express', 'extend', 'extra', 'eye', 'eyebrow', 'fabric', 'face', 'faculty', 'fade', 'faint', 'faith', 'fall', 'false', 'fame', 'family', 'famous', 'fan', 'fancy', 'fantasy', 'farm', 'fashion', 'fat', 'fatal', 'father', 'fatigue', 'fault', 'favorite', 'feature', 'february', 'federal', 'fee', 'feed', 'feel', 'female', 'fence', 'festival', 'fetch', 'fever', 'few', 'fiber', 'fiction', 'field', 'figure', 'file', 'film', 'filter', 'final', 'find', 'fine', 'finger', 'finish', 'fire', 'firm', 'first', 'fiscal', 'fish', 'fit', 'fitness', 'fix', 'flag', 'flame', 'flash', 'flat', 'flavor', 'flee', 'flight', 'flip', 'float', 'flock', 'floor', 'flower', 'fluid', 'flush', 'fly', 'foam', 'focus', 'fog', 'foil', 'fold', 'follow', 'food', 'foot', 'force', 'forest', 'forget', 'fork', 'fortune', 'forum', 'forward', 'fossil', 'foster', 'found', 'fox', 'fragile', 'frame', 'frequent', 'fresh', 'friend', 'fringe', 'frog', 'front', 'frost', 'frown', 'frozen', 'fruit', 'fuel', 'fun', 'funny', 'furnace', 'fury', 'future', 'gadget', 'gain', 'galaxy', 'gallery', 'game', 'gap', 'garage', 'garbage', 'garden', 'garlic', 'garment', 'gas', 'gasp', 'gate', 'gather', 'gauge', 'gaze', 'general', 'genius', 'genre', 'gentle', 'genuine', 'gesture', 'ghost', 'giant', 'gift', 'giggle', 'ginger', 'giraffe', 'girl', 'give', 'glad', 'glance', 'glare', 'glass', 'glide', 'glimpse', 'globe', 'gloom', 'glory', 'glove', 'glow', 'glue', 'goat', 'goddess', 'gold', 'good', 'goose', 'gorilla', 'gospel', 'gossip', 'govern', 'gown', 'grab', 'grace', 'grain', 'grant', 'grape', 'grass', 'gravity', 'great', 'green', 'grid', 'grief', 'grit', 'grocery', 'group', 'grow', 'grunt', 'guard', 'guess', 'guide', 'guilt', 'guitar', 'gun', 'gym', 'habit', 'hair', 'half', 'hammer', 'hamster', 'hand', 'happy', 'harbor', 'hard', 'harsh', 'harvest', 'hat', 'have', 'hawk', 'hazard', 'head', 'health', 'heart', 'heavy', 'hedgehog', 'height', 'hello', 'helmet', 'help', 'hen', 'hero', 'hidden', 'high', 'hill', 'hint', 'hip', 'hire', 'history', 'hobby', 'hockey', 'hold', 'hole', 'holiday', 'hollow', 'home', 'honey', 'hood', 'hope', 'horn', 'horror', 'horse', 'hospital', 'host', 'hotel', 'hour', 'hover', 'hub', 'huge', 'human', 'humble', 'humor', 'hundred', 'hungry', 'hunt', 'hurdle', 'hurry', 'hurt', 'husband', 'hybrid', 'ice', 'icon', 'idea', 'identify', 'idle', 'ignore', 'ill', 'illegal', 'illness', 'image', 'imitate', 'immense', 'immune', 'impact', 'impose', 'improve', 'impulse', 'inch', 'include', 'income', 'increase', 'index', 'indicate', 'indoor', 'industry', 'infant', 'inflict', 'inform', 'inhale', 'inherit', 'initial', 'inject', 'injury', 'inmate', 'inner', 'innocent', 'input', 'inquiry', 'insane', 'insect', 'inside', 'inspire', 'install', 'intact', 'interest', 'into', 'invest', 'invite', 'involve', 'iron', 'island', 'isolate', 'issue', 'item', 'ivory', 'jacket', 'jaguar', 'jar', 'jazz', 'jealous', 'jeans', 'jelly', 'jewel', 'job', 'join', 'joke', 'journey', 'joy', 'judge', 'juice', 'jump', 'jungle', 'junior', 'junk', 'just', 'kangaroo', 'keen', 'keep', 'ketchup', 'key', 'kick', 'kid', 'kidney', 'kind', 'kingdom', 'kiss', 'kit', 'kitchen', 'kite', 'kitten', 'kiwi', 'knee', 'knife', 'knock', 'know', 'lab', 'label', 'labor', 'ladder', 'lady', 'lake', 'lamp', 'language', 'laptop', 'large', 'later', 'latin', 'laugh', 'laundry', 'lava', 'law', 'lawn', 'lawsuit', 'layer', 'lazy', 'leader', 'leaf', 'learn', 'leave', 'lecture', 'left', 'leg', 'legal', 'legend', 'leisure', 'lemon', 'lend', 'length', 'lens', 'leopard', 'lesson', 'letter', 'level', 'liar', 'liberty', 'library', 'license', 'life', 'lift', 'light', 'like', 'limb', 'limit', 'link', 'lion', 'liquid', 'list', 'little', 'live', 'lizard', 'load', 'loan', 'lobster', 'local', 'lock', 'logic', 'lonely', 'long', 'loop', 'lottery', 'loud', 'lounge', 'love', 'loyal', 'lucky', 'luggage', 'lumber', 'lunar', 'lunch', 'luxury', 'lyrics', 'machine', 'mad', 'magic', 'magnet', 'maid', 'mail', 'main', 'major', 'make', 'mammal', 'man', 'manage', 'mandate', 'mango', 'mansion', 'manual', 'maple', 'marble', 'march', 'margin', 'marine', 'market', 'marriage', 'mask', 'mass', 'master', 'match', 'material', 'math', 'matrix', 'matter', 'maximum', 'maze', 'meadow', 'mean', 'measure', 'meat', 'mechanic', 'medal', 'media', 'melody', 'melt', 'member', 'memory', 'mention', 'menu', 'mercy', 'merge', 'merit', 'merry', 'mesh', 'message', 'metal', 'method', 'middle', 'midnight', 'milk', 'million', 'mimic', 'mind', 'minimum', 'minor', 'minute', 'miracle', 'mirror', 'misery', 'miss', 'mistake', 'mix', 'mixed', 'mixture', 'mobile', 'model', 'modify', 'mom', 'moment', 'monitor', 'monkey', 'monster', 'month', 'moon', 'moral', 'more', 'morning', 'mosquito', 'mother', 'motion', 'motor', 'mountain', 'mouse', 'move', 'movie', 'much', 'muffin', 'mule', 'multiply', 'muscle', 'museum', 'mushroom', 'music', 'must', 'mutual', 'myself', 'mystery', 'myth', 'naive', 'name', 'napkin', 'narrow', 'nasty', 'nation', 'nature', 'near', 'neck', 'need', 'negative', 'neglect', 'neither', 'nephew', 'nerve', 'nest', 'net', 'network', 'neutral', 'never', 'news', 'next', 'nice', 'night', 'noble', 'noise', 'nominee', 'noodle', 'normal', 'north', 'nose', 'notable', 'note', 'nothing', 'notice', 'novel', 'now', 'nuclear', 'number', 'nurse', 'nut', 'oak', 'obey', 'object', 'oblige', 'obscure', 'observe', 'obtain', 'obvious', 'occur', 'ocean', 'october', 'odor', 'off', 'offer', 'office', 'often', 'oil', 'okay', 'old', 'olive', 'olympic', 'omit', 'once', 'one', 'onion', 'online', 'only', 'open', 'opera', 'opinion', 'oppose', 'option', 'orange', 'orbit', 'orchard', 'order', 'ordinary', 'organ', 'orient', 'original', 'orphan', 'ostrich', 'other', 'outdoor', 'outer', 'output', 'outside', 'oval', 'oven', 'over', 'own', 'owner', 'oxygen', 'oyster', 'ozone', 'pact', 'paddle', 'page', 'pair', 'palace', 'palm', 'panda', 'panel', 'panic', 'panther', 'paper', 'parade', 'parent', 'park', 'parrot', 'party', 'pass', 'patch', 'path', 'patient', 'patrol', 'pattern', 'pause', 'pave', 'payment', 'peace', 'peanut', 'pear', 'peasant', 'pelican', 'pen', 'penalty', 'pencil', 'people', 'pepper', 'perfect', 'permit', 'person', 'pet', 'phone', 'photo', 'phrase', 'physical', 'piano', 'picnic', 'picture', 'piece', 'pig', 'pigeon', 'pill', 'pilot', 'pink', 'pioneer', 'pipe', 'pistol', 'pitch', 'pizza', 'place', 'planet', 'plastic', 'plate', 'play', 'please', 'pledge', 'pluck', 'plug', 'plunge', 'poem', 'poet', 'point', 'polar', 'pole', 'police', 'pond', 'pony', 'pool', 'popular', 'portion', 'position', 'possible', 'post', 'potato', 'pottery', 'poverty', 'powder', 'power', 'practice', 'praise', 'predict', 'prefer', 'prepare', 'present', 'pretty', 'prevent', 'price', 'pride', 'primary', 'print', 'priority', 'prison', 'private', 'prize', 'problem', 'process', 'produce', 'profit', 'program', 'project', 'promote', 'proof', 'property', 'prosper', 'protect', 'proud', 'provide', 'public', 'pudding', 'pull', 'pulp', 'pulse', 'pumpkin', 'punch', 'pupil', 'puppy', 'purchase', 'purity', 'purpose', 'purse', 'push', 'put', 'puzzle', 'pyramid', 'quality', 'quantum', 'quarter', 'question', 'quick', 'quit', 'quiz', 'quote', 'rabbit', 'raccoon', 'race', 'rack', 'radar', 'radio', 'rail', 'rain', 'raise', 'rally', 'ramp', 'ranch', 'random', 'range', 'rapid', 'rare', 'rate', 'rather', 'raven', 'raw', 'razor', 'ready', 'real', 'reason', 'rebel', 'rebuild', 'recall', 'receive', 'recipe', 'record', 'recycle', 'reduce', 'reflect', 'reform', 'refuse', 'region', 'regret', 'regular', 'reject', 'relax', 'release', 'relief', 'rely', 'remain', 'remember', 'remind', 'remove', 'render', 'renew', 'rent', 'reopen', 'repair', 'repeat', 'replace', 'report', 'require', 'rescue', 'resemble', 'resist', 'resource', 'response', 'result', 'retire', 'retreat', 'return', 'reunion', 'reveal', 'review', 'reward', 'rhythm', 'rib', 'ribbon', 'rice', 'rich', 'ride', 'ridge', 'rifle', 'right', 'rigid', 'ring', 'riot', 'ripple', 'risk', 'ritual', 'rival', 'river', 'road', 'roast', 'robot', 'robust', 'rocket', 'romance', 'roof', 'rookie', 'room', 'rose', 'rotate', 'rough', 'round', 'route', 'royal', 'rubber', 'rude', 'rug', 'rule', 'run', 'runway', 'rural', 'sad', 'saddle', 'sadness', 'safe', 'sail', 'salad', 'salmon', 'salon', 'salt', 'salute', 'same', 'sample', 'sand', 'satisfy', 'satoshi', 'sauce', 'sausage', 'save', 'say', 'scale', 'scan', 'scare', 'scatter', 'scene', 'scheme', 'school', 'science', 'scissors', 'scorpion', 'scout', 'scrap', 'screen', 'script', 'scrub', 'sea', 'search', 'season', 'seat', 'second', 'secret', 'section', 'security', 'seed', 'seek', 'segment', 'select', 'sell', 'seminar', 'senior', 'sense', 'sentence', 'series', 'service', 'session', 'settle', 'setup', 'seven', 'shadow', 'shaft', 'shallow', 'share', 'shed', 'shell', 'sheriff', 'shield', 'shift', 'shine', 'ship', 'shiver', 'shock', 'shoe', 'shoot', 'shop', 'short', 'shoulder', 'shove', 'shrimp', 'shrug', 'shuffle', 'shy', 'sibling', 'sick', 'side', 'siege', 'sight', 'sign', 'silent', 'silk', 'silly', 'silver', 'similar', 'simple', 'since', 'sing', 'siren', 'sister', 'situate', 'six', 'size', 'skate', 'sketch', 'ski', 'skill', 'skin', 'skirt', 'skull', 'slab', 'slam', 'sleep', 'slender', 'slice', 'slide', 'slight', 'slim', 'slogan', 'slot', 'slow', 'slush', 'small', 'smart', 'smile', 'smoke', 'smooth', 'snack', 'snake', 'snap', 'sniff', 'snow', 'soap', 'soccer', 'social', 'sock', 'soda', 'soft', 'solar', 'soldier', 'solid', 'solution', 'solve', 'someone', 'song', 'soon', 'sorry', 'sort', 'soul', 'sound', 'soup', 'source', 'south', 'space', 'spare', 'spatial', 'spawn', 'speak', 'special', 'speed', 'spell', 'spend', 'sphere', 'spice', 'spider', 'spike', 'spin', 'spirit', 'split', 'spoil', 'sponsor', 'spoon', 'sport', 'spot', 'spray', 'spread', 'spring', 'spy', 'square', 'squeeze', 'squirrel', 'stable', 'stadium', 'staff', 'stage', 'stairs', 'stamp', 'stand', 'start', 'state', 'stay', 'steak', 'steel', 'stem', 'step', 'stereo', 'stick', 'still', 'sting', 'stock', 'stomach', 'stone', 'stool', 'story', 'stove', 'strategy', 'street', 'strike', 'strong', 'struggle', 'student', 'stuff', 'stumble', 'style', 'subject', 'submit', 'subway', 'success', 'such', 'sudden', 'suffer', 'sugar', 'suggest', 'suit', 'summer', 'sun', 'sunny', 'sunset', 'super', 'supply', 'supreme', 'sure', 'surface', 'surge', 'surprise', 'surround', 'survey', 'suspect', 'sustain', 'swallow', 'swamp', 'swap', 'swarm', 'swear', 'sweet', 'swift', 'swim', 'swing', 'switch', 'sword', 'symbol', 'symptom', 'syrup', 'system', 'table', 'tackle', 'tag', 'tail', 'talent', 'talk', 'tank', 'tape', 'target', 'task', 'taste', 'tattoo', 'taxi', 'teach', 'team', 'tell', 'ten', 'tenant', 'tennis', 'tent', 'term', 'test', 'text', 'thank', 'that', 'theme', 'then', 'theory', 'there', 'they', 'thing', 'this', 'thought', 'three', 'thrive', 'throw', 'thumb', 'thunder', 'ticket', 'tide', 'tiger', 'tilt', 'timber', 'time', 'tiny', 'tip', 'tired', 'tissue', 'title', 'toast', 'tobacco', 'today', 'toddler', 'toe', 'together', 'toilet', 'token', 'tomato', 'tomorrow', 'tone', 'tongue', 'tonight', 'tool', 'tooth', 'top', 'topic', 'topple', 'torch', 'tornado', 'tortoise', 'toss', 'total', 'tourist', 'toward', 'tower', 'town', 'toy', 'track', 'trade', 'traffic', 'tragic', 'train', 'transfer', 'trap', 'trash', 'travel', 'tray', 'treat', 'tree', 'trend', 'trial', 'tribe', 'trick', 'trigger', 'trim', 'trip', 'trophy', 'trouble', 'truck', 'true', 'truly', 'trumpet', 'trust', 'truth', 'try', 'tube', 'tuition', 'tumble', 'tuna', 'tunnel', 'turkey', 'turn', 'turtle', 'twelve', 'twenty', 'twice', 'twin', 'twist', 'two', 'type', 'typical', 'ugly', 'umbrella', 'unable', 'unaware', 'uncle', 'uncover', 'under', 'undo', 'unfair', 'unfold', 'unhappy', 'uniform', 'unique', 'unit', 'universe', 'unknown', 'unlock', 'until', 'unusual', 'unveil', 'update', 'upgrade', 'uphold', 'upon', 'upper', 'upset', 'urban', 'urge', 'usage', 'use', 'used', 'useful', 'useless', 'usual', 'utility', 'vacant', 'vacuum', 'vague', 'valid', 'valley', 'valve', 'van', 'vanish', 'vapor', 'various', 'vast', 'vault', 'vehicle', 'velvet', 'vendor', 'venture', 'venue', 'verb', 'verify', 'version', 'very', 'vessel', 'veteran', 'viable', 'vibrant', 'vicious', 'victory', 'video', 'view', 'village', 'vintage', 'violin', 'virtual', 'virus', 'visa', 'visit', 'visual', 'vital', 'vivid', 'vocal', 'voice', 'void', 'volcano', 'volume', 'vote', 'voyage', 'wage', 'wagon', 'wait', 'walk', 'wall', 'walnut', 'want', 'warfare', 'warm', 'warrior', 'wash', 'wasp', 'waste', 'water', 'wave', 'way', 'wealth', 'weapon', 'wear', 'weasel', 'weather', 'web', 'wedding', 'weekend', 'weird', 'welcome', 'west', 'wet', 'whale', 'what', 'wheat', 'wheel', 'when', 'where', 'whip', 'whisper', 'wide', 'width', 'wife', 'wild', 'will', 'win', 'window', 'wine', 'wing', 'wink', 'winner', 'winter', 'wire', 'wisdom', 'wise', 'wish', 'witness', 'wolf', 'woman', 'wonder', 'wood', 'wool', 'word', 'work', 'world', 'worry', 'worth', 'wrap', 'wreck', 'wrestle', 'wrist', 'write', 'wrong', 'yard', 'year', 'yellow', 'you', 'young', 'youth', 'zebra', 'zero', 'zone', 'zoo'];
```


### FILE: /opt/logos/www/wallet_prod/wallet.css

```css
:root {
  --bg: #050910;
  --bg-grad-1: rgba(56,189,248,0.18);
  --bg-grad-2: rgba(129,140,248,0.20);

  --card: #020617;
  --card-alt: #020617;

  --border-subtle: rgba(148,163,184,0.30);
  --border-strong: rgba(148,163,184,0.65);

  --accent: #3b82f6;
  --accent-soft: rgba(59,130,246,0.16);
  --accent-strong: #60a5fa;

  --danger: #f97373;

  --text-main: #e5e7eb;
  --text-muted: #9ca3af;

  --radius-card: 20px;
  --radius-sm: 10px;

  --shadow-soft: 0 24px 60px rgba(0,0,0,0.75);

  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
           "Liberation Mono", "Courier New", monospace;
}

/* базовые */

*,
*::before,
*::after {
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
               Roboto, sans-serif;
  background:
    radial-gradient(circle at top left, var(--bg-grad-1), transparent 58%),
    radial-gradient(circle at bottom right, var(--bg-grad-2), transparent 55%),
    var(--bg);
  color: var(--text-main);
  min-height: 100vh;
}

/* верхняя панель */

.topbar {
  position: sticky;
  top: 0;
  z-index: 40;
  background: linear-gradient(95deg, rgba(15,23,42,0.98), rgba(15,23,42,0.96));
  backdrop-filter: blur(16px);
  border-bottom: 1px solid rgba(148,163,184,0.18);
  box-shadow: 0 18px 40px rgba(0,0,0,0.65);
  padding: 10px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.topbar-left {
  display: flex;
  align-items: center;
  gap: 10px;
}

.logo-dot {
  width: 26px;
  height: 26px;
  border-radius: 999px;
  background: radial-gradient(circle at 30% 30%, #22d3ee, #6366f1);
  box-shadow: 0 0 20px rgba(56,189,248,0.55);
}

.topbar-title {
  display: flex;
  flex-direction: column;
  line-height: 1.1;
}

.topbar-title .brand {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  color: #e5e7eb;
}

.topbar-title .product {
  font-size: 13px;
  color: var(--text-muted);
}

.topbar-right {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
}

.endpoint-label {
  color: var(--text-muted);
}

.endpoint-value {
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.9);
}

/* общая раскладка */

.page-shell {
  max-width: 1040px;
  margin: 0 auto;
  padding: 18px 16px 40px;
}

.page-header {
  margin-bottom: 18px;
}

.page-header h1 {
  font-size: 22px;
  margin: 0 0 6px;
}

.subtitle {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

/* карточки */

.card {
  background: radial-gradient(circle at top left, rgba(56,189,248,0.10), transparent 55%),
              var(--card);
  border-radius: var(--radius-card);
  border: 1px solid var(--border-subtle);
  box-shadow: var(--shadow-soft);
  margin-bottom: 18px;
  overflow: hidden;
}

.card-header {
  padding: 14px 18px 10px;
  border-bottom: 1px solid rgba(15,23,42,0.9);
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.card-title {
  font-size: 16px;
  margin: 0 0 4px;
}

.card-caption {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

.card-body {
  padding: 14px 18px 16px;
}

/* поля */

.field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 12px;
}

.field-row {
  display: flex;
  gap: 10px;
  align-items: flex-end;
  margin-bottom: 12px;
}

.field-row .grow {
  flex: 1 1 auto;
}

.field-label {
  font-size: 12px;
  color: var(--text-muted);
}

.field-input {
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.95);
  color: var(--text-main);
  padding: 8px 10px;
  font-size: 14px;
  outline: none;
}

.field-input:focus {
  border-color: var(--accent-strong);
  box-shadow: 0 0 0 1px rgba(59,130,246,0.55);
}

/* текстовые выводы */

.mono-field,
.mono-output {
  width: 100%;
  font-family: var(--mono);
  font-size: 13px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(2,6,23,0.96);
  color: var(--text-main);
  padding: 10px 12px;
  resize: vertical;
  min-height: 80px;
  white-space: pre-wrap;
}

.mono-output {
  margin-top: 8px;
}

/* кнопки */

.actions-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 6px;
  margin-bottom: 6px;
}

.btn {
  border-radius: 999px;
  border: 1px solid transparent;
  padding: 7px 14px;
  font-size: 13px;
  cursor: pointer;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.btn.primary {
  background: linear-gradient(135deg, #2563eb, #3b82f6);
  border-color: rgba(59,130,246,0.8);
  color: #fff;
}

.btn.primary:hover {
  background: linear-gradient(135deg, #1d4ed8, #2563eb);
}

.btn.secondary {
  background: rgba(15,23,42,0.95);
  border-color: var(--border-strong);
  color: var(--text-main);
}

.btn.secondary:hover {
  border-color: var(--accent-strong);
}

.btn.ghost {
  background: transparent;
  border-color: var(--border-subtle);
  color: var(--text-muted);
}

.btn.ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* чипы */

.chip {
  padding: 5px 10px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.92);
  font-size: 12px;
  color: var(--text-muted);
  cursor: pointer;
}

.chip-ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* подсказки */

.hint {
  margin-top: 8px;
  font-size: 12px;
  color: var(--text-muted);
}

/* адаптив */

@media (max-width: 720px) {
  .topbar {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }

  .field-row {
    flex-direction: column;
    align-items: stretch;
  }

  .page-shell {
    padding: 14px 10px 32px;
  }
}
```


## FRONTEND ROOT: /opt/logos/www/wallet_dev

### TREE (depth 3)

```text
app.js.bak_send_endpoint_20260111T165637Z
app.html.bak_fix_links_20260109T122714Z
app.html.bak_fixTxIn_20260112T062533Z
app.html.bak_submit_20260111T172540Z
assets.js
app.html.bak_sendmod_20260111T150430Z
app.css.bak_tabscss_20260110T105400Z
app.html.bak_topbal_20260111T081455Z
app.js.bak_fix_login_20260109T130402Z
app.html.bak_fullui_20260109T170643Z
app.html.bak_ridui_20260111T091512Z
index.html
index.html.bak_fix_20260109T131516Z
_bak_premiumtabs_20260109T063827Z/app.js
_bak_premiumtabs_20260109T063827Z/ui.css
_bak_premiumtabs_20260109T063827Z/app.html
app.css.bak_assetsfix_20260110T071124Z
compat.js
app.html.bak_rm_connect_20260101T123446Z
app.js
auth.js.bak_fix_20260109T131516Z
app.html.bak_vbump_20260111T064142Z
auth.css
index.html.bak_premium_20260109T123537Z
_bak_bridge_20260107T102822Z/app.js
_bak_bridge_20260107T102822Z/app.css
_bak_bridge_20260107T102822Z/app.html
auth.js.bak_fix_login_20260109T130421Z
app.css.bak_assets_20260110T080352Z
app.html.bak_tabs_20260111T110201Z
app.html.bak_assetsfix_20260110T071213Z
api_base.js.bak_fix_base_20260111T065527Z
app.js.bak_fix_or_20260111T080227Z
modules/send.js.bak_fixTxIn_20260112T062533Z
modules/tx_redirect.js
modules/send.js.bak_restore_sendui_20260112T070813Z
modules/settings.js
modules/send.js.bak_real_20260112T084410Z
modules/send.js.bak_submit_20260111T172540Z
modules/send.js
app.html.bak_assetsfix_20260110T084839Z
api_base.js.bak_fix_base_20260111T064058Z
app.js.bak_assets_20260110T080352Z
auth.html.bak_rm_connect_20260101T123446Z
app.js.bak_fix_ext_20260109T122800Z
_bak_entry_20260107T105554Z/index.html
api_base.js.bak_fix_20260111T062231Z
app.html.bak_assets_20260110T080352Z
app.html.bak_assetsfix_20260110T091111Z
app.html.bak_nacl_20260109T140204Z
app.html.bak_assetsui_20260108T143744Z
app.js.bak_fix_balanceep_20260111T064121Z
app.js.bak_fix_or_20260111T080255Z
app.js.bak_before_fix_20260111T072300Z
api_base.js
app.js.bak_uiclean_20260111T112205Z
app.js.bak_before_router_20260111T074254Z
wallet.css
login.html
app.js.bak_bootfix_20260111T081518Z
ui.css
auth.html.bak_theme_20260101T135217Z
app.html.bak_directbind_20251223T163240Z
app.js.bak_amountfix_20260110T113232Z
app.html.bak_ridui_20260111T091544Z
app.html.bak_fullui_20260110T070800Z
app.js.bak_balances_20260110T091213Z
app.js.bak_tabs_20260111T110230Z
api_base.js.bak_routes_20260111T072318Z
app.html.bak_nacl_20260110T115935Z
app.html.bak_ridinput_20260111T093714Z
app.html.bak_bust2_20260111_081542
app.html.bak_premium_20260109T123537Z
_bak_ui_20260107T101342Z/app.js
_bak_ui_20260107T101342Z/app.css
_bak_ui_20260107T101342Z/app.html
app.js.bak_ridui_20260111T091512Z
app.html.bak_bust_20260111_074349
app.js.bak_ridui_20260111T092451Z
app.css.bak_tabs_20260111T110230Z
app.css.bak_assetsfix_20260110T071057Z
app.css
app.html.bak_ridbal_20260110T082857Z
app.html.bak_tabsfix_20260110T072648Z
app.js.bak_sendfix_20260111T155340Z
auth.html
app.css.bak_hideInjectedRid_20260111T093737Z
tabs.js.bak_tabsfix_20260110T105255Z
app.html.bak_real_20260112T084410Z
app.html.bak_tabs_20260111T110230Z
auth.html.bak_connect_20251223T113714Z
app.js.bak_NOW_20260110T114809Z
app.html.bak_renderfix_20260111T085559Z
app.html
ui.js.bak_nodeapi_20260101T122432Z
app.html.bak_txredir_20260111T161223Z
auth.html.bak_fix_login_20260109T130443Z
app.js.bak_renderfix_20260111T085559Z
app.html.bak_fullui_20260109T170804Z
app.html.bak_settingsmod_20260111T145133Z
app.html.bak_theme_20260101T135217Z
app.js.bak_ridui_20260111T091544Z
app.css.bak_settingsmod_20260111T145133Z
app.js.bak_fix_balanceep_20260111T065528Z
auth.js
app.html.bak_extnet_20260112T082246Z
auth.html.bak_add_connect_20251223T113731Z
api_base.js.bak_fix_20260111T062153Z
app.html.bak_restore_sendui_20260112T070813Z
auth.html.bak_fix_20260109T131516Z
auth.html.bak_nacl_20260110T115935Z
auth.html.bak_directbind_20251223T155358Z
_bak_bridge_20260107T102635Z/app.js
_bak_bridge_20260107T102635Z/app.css
_bak_bridge_20260107T102635Z/app.html
app.html.bak_send_endpoint_20260111T165637Z
app.js.bak_ridbal_20260110T082857Z
compat.js.bak_nodeapi_20260101T121312Z
connect.js
app.css.bak_sendmod_20260111T150430Z
app.js.bak_nodeapi_20260101T122432Z
tabs.js
app.css.bak_tabs_20260111T110201Z
app.js.bak_before_router_20260111T074237Z
tabs.js.bak_tabsfix_20260110T072648Z
auth.html.bak_nacl_20260109T140204Z
_bak_entry_20260108T142703Z/index.html
tabs.js.bak_tabsfix_20260110T105225Z
app.html.bak_vbump_20260111T065529Z
app.css.bak_tabsfix_20260110T072648Z
app.js.bak_tabs_20260111T110201Z
app.html.bak_ridui_20260111T092451Z
ui.js
```


### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.css

```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */
```


### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->

</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.js

```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */
```


### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.css

```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */


/* ====== Bridge result box ====== */
.bridgeResult{
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  font-size:12px;
  line-height:1.35;
  white-space:pre-wrap;
}
.bridgeResult.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.bridgeResult.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
/* ====== /Bridge result box ====== */
```


### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.js

```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```


### FILE: /opt/logos/www/wallet_dev/_bak_entry_20260107T105554Z/index.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="color-scheme" content="dark"/>
  <link rel="stylesheet" href="./wallet.css?v=30"/>
</head>
<body>
  <!-- Верхняя панель -->
  <header class="topbar">
    <div class="topbar-left">
      <div class="logo-dot"></div>
      <div class="topbar-title">
        <span class="brand">LOGOS</span>
        <span class="product">Wallet</span>
      </div>
    </div>
    <div class="topbar-right">
      <span class="endpoint-label">Endpoint</span>
      <span class="endpoint-value" id="endpoint"></span>
      <button id="btn-lock" class="chip chip-ghost">Выйти</button>
    </div>
  </header>

  <main class="page-shell">
    <header class="page-header">
      <div>
        <h1>LOGOS Wallet — Кошелёк</h1>
        <p class="subtitle">
          Non‑custodial кошелёк: ключи и подписи живут только в этом браузере.
          Никакого серверного хранилища.
        </p>
      </div>
    </header>

    <!-- RID / PUB -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Твой RID / Публичный ключ</h2>
          <p class="card-caption">
            RID — адрес аккаунта в сети LOGOS. Публичный ключ (hex) используется для проверки подписи.
          </p>
        </div>
      </header>
      <div class="card-body">
        <textarea id="pub" class="mono-field" readonly></textarea>
        <p class="hint">
          Ключи живут только в памяти этой вкладки. После выхода или закрытия
          вкладки для доступа к кошельку снова нужен пароль.
        </p>
      </div>
    </section>

    <!-- Баланс -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Баланс</h2>
          <p class="card-caption">
            Проверка баланса и nonce для выбранного RID.
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">RID</span>
          <input id="rid-balance" type="text" class="field-input" placeholder="RID"/>
        </label>

        <div class="actions-row">
          <button id="btn-balance" class="btn primary">Показать баланс</button>
        </div>

        <pre id="out-balance" class="mono-output"></pre>
      </div>
    </section>

    <!-- Подпись и отправка -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Подпись и отправка (batch)</h2>
          <p class="card-caption">
            Подписанная Ed25519 транзакция отправляется в ноду как батч (одна транзакция).
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">Получатель (RID)</span>
          <input id="to" type="text" class="field-input" placeholder="RID получателя"/>
        </label>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Сумма (LGN)</span>
            <input id="amount" type="number" min="0" step="1" class="field-input"/>
          </label>

          <label class="field field-nonce">
            <span class="field-label">Nonce (debug)</span>
            <input id="nonce" type="number" class="field-input"/>
          </label>
        </div>

        <div class="actions-row">
          <button id="btn-send" class="btn primary">Подписать и отправить</button>
          <button id="btn-nonce" class="btn ghost">Получить nonce</button>
        </div>

        <pre id="out-send" class="mono-output"></pre>
      </div>
    </section>

    <!-- Стейкинг -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Стейкинг (delegate / undelegate / claim)</h2>
          <p class="card-caption">
            Управление стейкингом текущего RID: делегирование, раз‑делегирование и заявка наград.
          </p>
        </div>
        <button id="btn-stake-refresh" class="chip chip-ghost">Обновить статус</button>
      </header>
      <div class="card-body">
        <pre id="out-stake" class="mono-output"></pre>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Застейкать (delegate, LGN)</span>
            <input id="stake-amount" type="number" min="0" step="1" class="field-input"/>
          </label>
          <button id="btn-stake-delegate" class="btn primary">Делегировать</button>
        </div>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Разстейкать (undelegate, LGN)</span>
            <input id="unstake-amount" type="number" min="0" step="1" class="field-input"/>
          </label>
          <button id="btn-stake-undelegate" class="btn ghost">Разстейкать</button>
        </div>

        <div class="actions-row">
          <button id="btn-stake-claim" class="btn secondary">Заявить награду (claim)</button>
        </div>
      </div>
    </section>

    <!-- Мост rToken -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Мост rToken (депозит, demo)</h2>
          <p class="card-caption">
            Демонстрационный депозит rLGN через внешний txid.
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">RID</span>
          <input id="rid-bridge" type="text" class="field-input" placeholder="RID для депозита rLGN"/>
        </label>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Сумма (rLGN)</span>
            <input id="amount-bridge" type="number" min="0" step="1" class="field-input"/>
          </label>

          <label class="field grow">
            <span class="field-label">ext_txid (например eth_txid_0xabc)</span>
            <input id="ext" type="text" class="field-input"/>
          </label>
        </div>

        <div class="actions-row">
          <button id="btn-deposit" class="btn primary">Deposit rLGN (demo)</button>
        </div>

        <pre id="out-bridge" class="mono-output"></pre>
      </div>
    </section>
  </main>

  <script src="./app.js?v=1" defer></script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/_bak_entry_20260108T142703Z/index.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/app.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

<script src="assets.js?v=1"></script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/app.js

```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */
```


### FILE: /opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/ui.css

```css

/* assets ui */
.assetsWrap{display:block;margin-top:16px}
.assetsHead{display:flex;gap:12px;align-items:center;justify-content:space-between;margin:8px 0 14px}
.assetsTitle{font-weight:800;font-size:20px;letter-spacing:.2px}
.assetsSub{margin-top:4px;color:rgba(255,255,255,.62);font-size:12px}
.assetsGrid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:14px}
@media (max-width: 900px){.assetsGrid{grid-template-columns:1fr}}
.assetCard{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:18px;padding:14px;box-shadow:0 16px 50px rgba(0,0,0,.35);backdrop-filter: blur(16px)}
.assetTop{display:flex;gap:12px;align-items:center}
.assetSym{width:48px;height:48px;border-radius:14px;display:flex;align-items:center;justify-content:center;font-weight:800;
  background:radial-gradient(120% 120% at 30% 10%, rgba(78,124,255,.35), rgba(139,92,246,.25), rgba(0,0,0,0));
  border:1px solid rgba(255,255,255,.12)
}
.assetName{font-weight:700}
.assetBal{margin-top:2px;font-size:13px;color:rgba(255,255,255,.75)}
.assetAddrRow{margin-top:12px;display:flex;gap:10px;align-items:center;justify-content:space-between}
.assetAddr{max-width:70%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:rgba(255,255,255,.85)}
.assetNote{margin-top:10px;font-size:12px}
```


### FILE: /opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.css

```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}
```


### FILE: /opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.html

```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.js

```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);
```


### FILE: /opt/logos/www/wallet_dev/api_base.js

```js
(() => {
  // same-origin only
  window.API_BASE   = "/api";        // node backend (nginx -> 127.0.0.1:8080)
  window.WALLET_API = "/wallet-api"; // wallet proxy (FastAPI)
})();
```


### FILE: /opt/logos/www/wallet_dev/app.css

```css
:root{
  --bg:#070a12; --txt:#e7ecff; --mut:#9aa7d9;
  --br:rgba(255,255,255,.10); --br2:rgba(255,255,255,.16);
  --acc:#6f7bff; --acc2:#9b5cff;
  --ok:#2dd4bf; --bad:#fb7185;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background:
    radial-gradient(1200px 700px at 20% 0%, rgba(111,123,255,.18), transparent 60%),
    radial-gradient(900px 600px at 80% 10%, rgba(155,92,255,.14), transparent 55%),
    linear-gradient(180deg, #050812, var(--bg));
  color:var(--txt);
}
.mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
.wrap{max-width:1240px;margin:26px auto;padding:0 16px}
.card{
  background: linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.02));
  border:1px solid var(--br);
  border-radius:18px;
  padding:18px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  backdrop-filter: blur(10px);
}
.topbar{
  display:flex;align-items:center;justify-content:space-between;
  padding:14px 16px;border-bottom:1px solid var(--br);
  background: rgba(0,0,0,.25);
  position:sticky;top:0;z-index:10;
  backdrop-filter: blur(12px);
}
.brand{font-weight:800;letter-spacing:.4px}
.topbar-right{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
.pill{
  border:1px solid var(--br2);
  padding:6px 10px;border-radius:999px;
  background: rgba(0,0,0,.25);
  font-size:12px;
}
.h1{font-size:20px;font-weight:800;margin:10px 0 6px}
.h2{font-size:16px;font-weight:800;margin:0 0 8px}
.muted{color:var(--mut);font-size:12px;line-height:1.35}
label{font-size:12px;color:var(--mut)}
input, select, textarea{
  width:100%;
  padding:12px 12px;
  border-radius:14px;
  border:1px solid var(--br);
  background: rgba(0,0,0,.28);
  color:var(--txt);
  outline:none;
}
textarea{min-height:92px;resize:vertical}
input:focus, select:focus, textarea:focus{border-color:rgba(111,123,255,.55)}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
.btn{
  border:1px solid var(--br2);
  background: rgba(0,0,0,.22);
  color:var(--txt);
  padding:10px 12px;
  border-radius:14px;
  cursor:pointer;
  user-select:none;
}
.btn.small{padding:8px 10px;border-radius:12px;font-size:12px}
.btn.primary{
  border-color: rgba(111,123,255,.55);
  background: linear-gradient(135deg, rgba(111,123,255,.35), rgba(155,92,255,.25));
}
.btn.danger{
  border-color: rgba(251,113,133,.55);
  background: rgba(251,113,133,.12);
}
.status{margin-top:10px;color:var(--mut);font-size:12px;min-height:16px}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
@media (max-width: 980px){.grid{grid-template-columns:1fr}}
.big-num{font-size:30px;font-weight:900;letter-spacing:.4px}
.pre{white-space:pre-wrap;word-break:break-word;background:rgba(0,0,0,.24);border:1px solid var(--br);padding:12px;border-radius:14px;color:var(--txt)}
details{margin-top:10px}

.tabs{
  display:flex;gap:10px;flex-wrap:wrap;
  margin:14px 0 16px;
}
.tab{
  border:1px solid var(--br2);
  background: rgba(0,0,0,.18);
  padding:10px 14px;border-radius:999px;
  cursor:pointer;
  font-size:13px;
}
.tab.active{
  border-color: rgba(111,123,255,.55);
  background: linear-gradient(135deg, rgba(111,123,255,.22), rgba(155,92,255,.16));
}
.panel{display:none}
.panel.active{display:block}
.kv{
  display:grid;grid-template-columns: 1fr auto;gap:10px;align-items:center;
  padding:10px;border:1px solid var(--br);border-radius:14px;background:rgba(0,0,0,.18);
  margin-top:10px;
}
.kv .k{color:var(--mut);font-size:12px}
.kv .v{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:12px; overflow-wrap:anywhere}
.badge-ok{color:var(--ok)}
.badge-bad{color:var(--bad)}

/* ===== Settings module helpers ===== */
.devOnly { display:none !important; }
.dev .devOnly { display:block !important; }

.kvRow{
  display:flex; align-items:center; justify-content:space-between;
  gap:12px;
  padding:10px 12px;
  border:1px solid rgba(255,255,255,.06);
  border-radius:12px;
  background: rgba(0,0,0,.10);
}
.btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
.btn.danger{ border-color: rgba(255,107,107,.6); }
.btn.danger:hover{ filter:brightness(1.08); }

/* switch */
.switch{ position:relative; display:inline-block; width:44px; height:24px; }
.switch input{ opacity:0; width:0; height:0; }
.slider{
  position:absolute; cursor:pointer; inset:0;
  background: rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.10);
  transition:.2s;
  border-radius:999px;
}
.slider:before{
  position:absolute; content:"";
  height:18px; width:18px; left:3px; top:50%;
  transform: translateY(-50%);
  background: rgba(255,255,255,.85);
  transition:.2s;
  border-radius:999px;
}
.switch input:checked + .slider{
  background: rgba(120,110,255,.35);
  border-color: rgba(120,110,255,.55);
}
.switch input:checked + .slider:before{
  transform: translateY(-50%) translateX(20px);
}

/* ===== Send module helpers ===== */
.grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
@media (max-width: 780px){ .grid2{ grid-template-columns:1fr; } }
.btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
```


### FILE: /opt/logos/www/wallet_dev/app.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="./app.css?v=20260111_110230" />
  <script>
    // fixed routes (same-origin)
    window.API_BASE="/api";            // node backend
    window.WALLET_API="/wallet-api";   // wallet proxy
  </script>
</head>
<body>
  <div class="topbar">
    <div class="brand">LOGOS Wallet</div>
    <div class="topbar-right">
      <div class="pill">API: <span id="api" class="mono">/api</span></div>
      <div class="pill">RID: <span id="topRid" class="mono">—</span></div>
      <div class="pill">LGN: <span id="topBal" class="mono">—</span></div>
      <button id="btnLogout" class="btn small">Выйти</button>
    </div>
  </div>

  <div class="wrap">

    <div class="tabs">
      <div class="tab active" data-tab="assets">Активы</div>
      <div class="tab" data-tab="send">Отправка</div>
      <div class="tab" data-tab="staking">Стейкинг</div>
      <div class="tab" data-tab="bridge">Bridge</div>
      <div class="tab" data-tab="settings">Настройки</div>
    </div>

    <!-- ASSETS -->
    <div class="panel active" id="panel-assets">
      <div class="grid">
        <div class="card">
          <div class="h2">RID / Identity</div>
          <div class="muted">Это твой резонансный адрес. Сервер видит только подпись.</div>

          <label style="margin-top:10px">RID</label>
          <input id="rid" class="mono" readonly />

          <div class="row">
            <button id="btnCopyRid" class="btn">Copy</button>
            <button id="btnRefresh" class="btn primary">Refresh LOGOS</button>
            <span id="netBadge" class="muted"></span>
          </div>

          <div id="status" class="status"></div>
        </div>

        <div class="card">
          <div class="h2">Portfolio</div>
          <div class="muted">LOGOS (LGN) — баланс в сети.</div>

          <div style="margin-top:10px">
            <div class="big-num mono" id="balLgn">—</div>
            <div class="muted mono" id="balMicro">—</div>
          </div>

          <div class="row">
            <div class="pill">nonce: <span id="nonce" class="mono">—</span></div>
            <div class="pill">latency: <span id="lat" class="mono">—</span></div>
          </div>

          <details>
            <summary>Details (raw)</summary>
            <pre id="rawNode" class="pre"></pre>
          </details>
        </div>
      </div>

      <div class="grid" style="margin-top:16px">
        <div class="card">
          <div class="h2">Receive addresses</div>
          <div class="muted">BTC/ETH/TRON/USDT адреса закреплены за RID (wallet-api).</div>
          <div id="recvBox"></div>

          <details>
            <summary>Details (wallet-api raw)</summary>
            <pre id="rawRecv" class="pre"></pre>
          </details>
        </div>

        <div class="card">
          <div class="h2">External balances</div>
          <div class="muted">Баланс внешних сетей (wallet-api).</div>
          <div id="extBalBox"></div>

          <details>
            <summary>Details (wallet-api raw)</summary>
            <pre id="rawExt" class="pre"></pre>
          </details>
        </div>
      </div>
    </div>

    <!-- SEND -->
    <div class="panel" id="panel-send">
      <div class="grid">
        <div class="card">
          <div class="h2">Withdraw (USDT)</div>
          <div class="muted">Отправка через wallet-api /v1/withdraw (по OpenAPI: USDT + ETH).</div>

          <label style="margin-top:10px">Network</label>
          <select id="wdNetwork">
            <option value="ETH">ETH</option>
          </select>

          <label style="margin-top:10px">Amount (integer)</label>
          <input id="wdAmount" class="mono" placeholder="например 100" />

          <label style="margin-top:10px">To address</label>
          <input id="wdTo" class="mono" placeholder="0x... или другое" />

          <div class="row">
            <button id="btnWithdraw" class="btn primary">Send</button>
            <button id="btnWithdrawClear" class="btn">Clear</button>
          </div>

          <div id="wdStatus" class="status"></div>

          <details>
            <summary>Response</summary>
            <pre id="wdRaw" class="pre"></pre>
          </details>
        </div>

        <div class="card">
          <div class="h2">LOGOS transfer</div>
          <div class="muted">
            Для LGN-трансфера нужен endpoint в node-api (например /tx/send). Сейчас у тебя подтверждён только /balance.
            Как только дашь ручку отправки — подключу в эту вкладку.
          </div>
        </div>
      </div>
    </div>

    <!-- STAKING -->
    <div class="panel" id="panel-staking">
      <div class="card">
        <div class="h2">Staking</div>
        <div class="muted">
          Вкладка готова по UI. Чтобы она была “не пустая”, нужен backend endpoint стейкинга (stake/unstake/apy).
          Дай API — подключу. Пока не выдумываю, чтобы не было лжи и “пустых кнопок”.
        </div>
      </div>
    </div>

    <!-- BRIDGE -->
    <div class="panel" id="panel-bridge">
  <div id="bridgeRoot"></div>

      <div class="grid">
        <div class="card">
          <div class="h2">Topup address</div>
          <div class="muted">Получить адрес для пополнения (wallet-api /v1/topup/request).</div>

          <label style="margin-top:10px">Network</label>
          <select id="topNetwork">
            <option value="ETH">ETH</option>
          </select>

          <div class="row">
            <button id="btnTopup" class="btn primary">Get address</button>
          </div>

          <div id="topupStatus" class="status"></div>
          <div id="topupBox"></div>
        </div>

        <div class="card">
          <div class="h2">Quote</div>
          <div class="muted">Расчёт курса (wallet-api /v1/quote). amount — integer.</div>

          <label style="margin-top:10px">From</label>
          <input id="qFrom" class="mono" value="USDT" />

          <label style="margin-top:10px">To</label>
          <input id="qTo" class="mono" value="LGN" />

          <label style="margin-top:10px">Amount</label>
          <input id="qAmount" class="mono" placeholder="например 100" />

          <div class="row">
            <button id="btnQuote" class="btn primary">Get quote</button>
          </div>

          <div id="qStatus" class="status"></div>

          <details>
            <summary>Response</summary>
            <pre id="qRaw" class="pre"></pre>
          </details>
        </div>
      </div>
    </div>

    <!-- SETTINGS -->
    <div class="panel" id="panel-settings">
      <div class="grid">
        <div class="card">
          <div class="h2">Local storage</div>
          <div class="muted">RID и пароль хранятся локально в браузере.</div>

          <div class="row">
            <button id="btnShowLocal" class="btn">Show RID</button>
            <button id="btnClearLocal" class="btn danger">Clear local keys</button>
          </div>

          <div id="setStatus" class="status"></div>
        </div>

        <div class="card">
          <div class="h2">Endpoints</div>
          <div class="muted mono">API_BASE = /api, WALLET_API = /wallet-api</div>
        </div>
      </div>
    </div>

  </div>

  <script src="./app.js?v=20260112_084410" defer></script>
<script src="modules/settings.js?v=20260111_172540"></script>
  <script src="modules/tx_redirect.js?v=20260112_070814"></script>
<script src="modules/send.js?v=20260112_084410"></script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/app.js

```js
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();



/* ========= SEND LGN MODULE (v2, sig_hex) ========= */
(() => {
  const NODE_API = (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");

  function q(sel, root=document){ return root.querySelector(sel); }
  function qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function utf8(s){ return new TextEncoder().encode(String(s)); }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++){
      out += u8[i].toString(16).padStart(2,"0");
    }
    return out;
  }

  function hexToU8(h){
    h = (h||"").trim().replace(/^0x/,"");
    if (!h || (h.length % 2)) return null;
    const u = new Uint8Array(h.length/2);
    for (let i=0;i<u.length;i++) u[i] = parseInt(h.substr(i*2,2),16);
    return u;
  }

  function getRID(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || "";
  }

  // пытаемся найти private Ed25519 JWK в localStorage (если ключи хранятся так)
  function findEd25519PrivJwk(){
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      const v = localStorage.getItem(k);
      if (!v || v.length < 20) continue;
      try{
        const j = JSON.parse(v);
        if (j && j.crv === "Ed25519" && j.kty && j.d && j.x) return j;
      }catch(e){}
    }
    return null;
  }

  async function importPrivKeyFromJwk(jwk){
    return crypto.subtle.importKey("jwk", jwk, {name:"Ed25519"}, false, ["sign"]);
  }

  async function signEd25519(privKey, msgU8){
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msgU8);
    return new Uint8Array(sig);
  }

  async function getNonce(rid){
    const r = await fetch(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    if(!r.ok) throw new Error(`balance http ${r.status}`);
    const j = await r.json();
    return j.nonce;
  }

  async function getCanonBytes(draft){
    // пробуем debug_canon (если включен на сервере)
    try{
      const r = await fetch(`${NODE_API}/debug_canon`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(draft)
      });
      if (r.ok){
        const t = await r.text();
        // варианты: JSON или просто строка
        try{
          const j = JSON.parse(t);
          const ch = j.canon_hex || j.canon || j.msg_hex || j.message_hex || j.bytes_hex || "";
          const u = hexToU8(ch);
          if (u) return u;
          const s = (j.canon_str || j.message || j.msg || "");
          if (s) return utf8(s);
        }catch(e){
          // если просто строка
          const u = hexToU8(t);
          if (u) return u;
          if (t && t.length) return utf8(t);
        }
      }
    }catch(e){}

    // fallback: стабильная строка (если debug_canon нет)
    const memo = (draft.memo === null || draft.memo === undefined) ? "" : String(draft.memo);
    const s = `LOGOS_TX|from=${draft.from}|to=${draft.to}|amount=${draft.amount}|nonce=${draft.nonce}|memo=${memo}`;
    return utf8(s);
  }

  function setStatus(panel, text, ok=true){
    let el = q(".sendStatus", panel);
    if(!el){
      el = document.createElement("div");
      el.className = "sendStatus";
      el.style.marginTop = "10px";
      el.style.fontSize = "13px";
      el.style.opacity = "0.95";
      panel.appendChild(el);
    }
    el.textContent = text || "";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function findSendPanel(){
    return document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('.panel[data-panel="send"]')
      || null;
  }

  function findSendControls(panel){
    const btnSend = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("send lgn"));
    const inputs = qa("input", panel);
    const toRid   = inputs[0] || null;
    const amount  = inputs[1] || null;
    const memo    = inputs[2] || null;
    const btnFillMe = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("мой rid"));
    return {btnSend, btnFillMe, toRid, amount, memo};
  }

  async function handleSend(panel, ui){
    const fromRid = getRID();
    const toRid = (ui.toRid?.value || "").trim();
    const memoStr = (ui.memo?.value || "").trim();
    const amtStr = (ui.amount?.value || "").trim();

    if(!fromRid){ setStatus(panel, "ERR: нет RID (ключи не найдены).", false); return; }
    if(!toRid || toRid.length < 10){ setStatus(panel, "ERR: введи RID получателя.", false); return; }

    const amt = Number(amtStr.replace(",", "."));
    if(!isFinite(amt) || amt <= 0){ setStatus(panel, "ERR: введи сумму > 0.", false); return; }

    const amount_mic = Math.round(amt * 1e6);

    setStatus(panel, "Отправляю…", true);

    let nonce;
    try{
      nonce = await getNonce(fromRid);
    }catch(e){
      setStatus(panel, "ERR: не смог получить nonce (balance).", false);
      return;
    }

    // draft по схеме TxIn (без подписи)
    const draft = {
      from: fromRid,
      to: toRid,
      amount: amount_mic,
      nonce: nonce,
      memo: memoStr ? memoStr : None
    };

    // JS не знает None, поэтому:
    if (!memoStr) draft.memo = null;

    // bytes for signing
    const canonBytes = await getCanonBytes(draft);

    // signer
    const jwk = findEd25519PrivJwk();
    if(!jwk){
      setStatus(panel, "ERR: приватный ключ не найден (localStorage). Если ключи в IndexedDB — скажи, сделаем доступ через существующий signer.", false);
      return;
    }

    let privKey;
    try{
      privKey = await importPrivKeyFromJwk(jwk);
    }catch(e){
      setStatus(panel, "ERR: не смог импортировать Ed25519 ключ.", false);
      return;
    }

    let sigU8;
    try{
      sigU8 = await signEd25519(privKey, canonBytes);
    }catch(e){
      setStatus(panel, "ERR: не смог подписать транзакцию.", false);
      return;
    }

    const txIn = {
      from: draft.from,
      to: draft.to,
      amount: draft.amount,
      nonce: draft.nonce,
      memo: draft.memo,
      sig_hex: hex(sigU8)
    };

    try{
      const r = await fetch(`${NODE_API}/submit_tx`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(txIn)
      });
      const text = await r.text();
      if(!r.ok){
        setStatus(panel, `ERR submit_tx: ${r.status} ${text}`.slice(0,500), false);
        return;
      }
      try{
        const j = JSON.parse(text);
        if (j && j.ok){
          setStatus(panel, `✅ Отправлено. txid: ${(j.txid||"")}`.trim(), true);
        } else {
          setStatus(panel, `⚠️ Ответ: ${text}`.slice(0,500), false);
        }
      }catch(e){
        setStatus(panel, `✅ Отправлено. Ответ: ${text}`.slice(0,200), true);
      }
    }catch(e){
      setStatus(panel, "ERR: сеть/submit_tx не доступен.", false);
    }
  }

  function initSend(){
    const panel = findSendPanel();
    if(!panel) return;
    const ui = findSendControls(panel);

    if(ui.btnFillMe){
      ui.btnFillMe.addEventListener("click", () => {
        const rid = getRID();
        if(ui.toRid) ui.toRid.value = rid || "";
      });
    }
    if(ui.btnSend){
      ui.btnSend.addEventListener("click", () => handleSend(panel, ui));
    }
  }

  try{ initSend(); }catch(e){}
})();
```


### FILE: /opt/logos/www/wallet_dev/assets.js

```js
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();
```


### FILE: /opt/logos/www/wallet_dev/auth.css

```css
/* Wallet Auth page tweaks (theme in /shared/wallet-theme.css) */

/* ВАЖНО: hidden управляет видимостью, CSS его не должен ломать */
[hidden]{ display:none !important; }

/* НЕ ставим display:none на эти блоки! */
#listWrap{ margin-top:12px; }
#mnemonicSection{ margin-top:14px; }

#mnemonicShow,#mnemonicConfirm,#restoreMnemonic{ min-height:120px; }

#ridList{
  list-style:none;
  padding:0;
  margin:10px 0 0;
  display:grid;
  gap:8px;
}

#ridList li{
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.22);
  cursor:pointer;
  font-family:var(--mono);
  font-size:12.5px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

#ridList li:hover{
  border-color:rgba(77,163,255,.35);
  background:rgba(0,0,0,.28);
}

#out{ min-height:84px; }
```


### FILE: /opt/logos/www/wallet_dev/auth.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LOGOS Wallet — Login</title>
  <link rel="stylesheet" href="./app.css?v=1" />
  <script src="./api_base.js?v=1"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar" style="position:static;border:0;padding:0;background:transparent">
        <div class="brand">LOGOS Wallet</div>
        <div class="pill">HTTPS only</div>
      </div>

      <div class="h1">Доступ к кошельку</div>
      <div class="muted">Ключи живут локально в браузере. Сервер получает только подписанные операции.</div>

      <div style="margin-top:14px;display:grid;gap:10px">
        <label>RID</label>
        <input id="rid" class="mono" placeholder="RID..." autocomplete="off" />

        <label>Пароль</label>
        <input id="pass" type="password" placeholder="Пароль" autocomplete="off" />

        <div class="row">
          <button id="btnLogin" class="btn primary">Войти</button>
          <button id="btnSaved" class="btn">Показать сохранённый RID</button>
        </div>

        <div id="status" class="status"></div>
      </div>
    </div>
  </div>

<script>
(function(){
  const ridEl = document.getElementById("rid");
  const passEl = document.getElementById("pass");
  const statusEl = document.getElementById("status");

  function setStatus(t){ statusEl.textContent = t || ""; }

  function loadSaved(){
    try{
      const rid = localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "";
      if (rid) ridEl.value = rid;
    }catch(e){}
  }
  loadSaved();

  document.getElementById("btnSaved").addEventListener("click", () => {
    loadSaved();
    setStatus(ridEl.value ? "RID подставлен из браузера." : "Сохранённого RID нет.");
  });

  document.getElementById("btnLogin").addEventListener("click", () => {
    const rid = (ridEl.value||"").trim();
    const pass = (passEl.value||"").trim();
    if (!rid || rid.length < 20) return setStatus("ERR: введи корректный RID.");
    if (!pass) return setStatus("ERR: введи пароль.");

    try{
      localStorage.setItem("RID", rid);
      localStorage.setItem("logos_rid", rid);
      localStorage.setItem("PASS", pass);
      localStorage.setItem("logos_pass", pass);
    }catch(e){}

    setStatus("OK: сохранено локально. Переход…");
    location.href = "./app.html?v=1";
  });
})();
</script>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/auth.js

```js
'use strict';

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30,0x2e,0x02,0x01,0x00,
  0x30,0x05,0x06,0x03,0x2b,0x65,0x70,
  0x04,0x22,0x04,0x20
]);

const $ = (id) => document.getElementById(id);

function setStatus(t){
  const el = $('status');
  if (el) el.textContent = 'Статус: ' + t;
}

function ensureEnv(){
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto?.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error('tweetnacl не загружен (нет window.nacl)');
}

const B58_ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function base58encode(bytes){
  const b = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
  if (b.length === 0) return "";
  let digits = [0];
  for (let i=0;i<b.length;i++){
    let carry = b[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j]*256 + carry;
      digits[j] = x % 58;
      carry = (x/58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry/58) | 0;
    }
  }
  let out = "";
  for (let k=0;k<b.length && b[k]===0;k++) out += "1";
  for (let q=digits.length-1;q>=0;q--) out += B58_ALPH[digits[q]];
  return out;
}

async function sha256(u8){
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

function pkcs8FromSeed(seed32){
  const seed = (seed32 instanceof Uint8Array) ? seed32 : new Uint8Array(seed32||[]);
  if (seed.length !== 32) throw new Error('seed must be 32 bytes');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed, ED25519_PKCS8_PREFIX.length);
  return out;
}

async function deriveKey(pass, saltU8, usage=['encrypt','decrypt']){
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltU8, iterations:120000, hash:'SHA-256' },
    keyMat,
    { name:'AES-GCM', length:256 },
    false,
    usage
  );
}

async function aesEncrypt(aesKey, plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plainU8);
  return { iv, ct: new Uint8Array(ct) };
}

async function aesDecrypt(aesKey, ivU8, ctU8){
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

let DBP = null;
function openDb(){
  if (DBP) return DBP;
  DBP = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbPut(key, val){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = ()=>resolve(true);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbListRids(){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const out = [];
    const req = st.openCursor();
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve(out);
      const k = String(cur.key||'');
      if (k.startsWith('acct:')) out.push(k.slice(5));
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

function setSession(rid, pass){
  // mirror to localStorage for app.js compatibility
  try {
    localStorage.setItem("logos_rid", String(rid||""));
    localStorage.setItem("RID", String(rid||""));
    if (pass != null) localStorage.setItem("logos_pass", String(pass||""));
  } catch(e) {}

  sessionStorage.setItem('logos_rid', rid);
  sessionStorage.setItem('logos_pass', pass);
  localStorage.setItem('logos_rid', rid);
  localStorage.setItem('logos_pass', pass);
}

function validatePass(p){
  const s = String(p||'').trim();
  if (s.length < 10) throw new Error('Пароль слишком короткий (мин 10)');
  return s;
}

function normalizePhrase(ph){
  return String(ph||'').trim().replace(/\s+/g,' ').toLowerCase();
}

const WORDS = [
  "alpha","bravo","canyon","delta","eagle","frost","galaxy","harbor","ivory","jungle","karma","legend",
  "matrix","nebula","orbit","pioneer","quantum","raven","signal","temple","union","vector","wander","xenon",
  "yellow","zenith","acoustic","breeze","crystal","drift","ember","forest","glimmer","horizon","island","jewel",
  "kernel","lunar","mirror","nova","oasis","prism","quiet","river","stone","thunder","ultra","vivid","whisper","zero"
];

function genPhrase16(){
  const rnd = crypto.getRandomValues(new Uint8Array(16));
  const w = [];
  for (let i=0;i<16;i++) w.push(WORDS[rnd[i] % WORDS.length]);
  return w.join(' ');
}

async function seedFromPhrase(phrase){
  const p = normalizePhrase(phrase);
  if (!p) throw new Error('Фраза пустая');
  const h = await sha256(enc.encode(p));
  return h.slice(0,32);
}

function ridFromSeed(seed32){
  const kp = nacl.sign.keyPair.fromSeed(seed32);
  const pub = new Uint8Array(kp.publicKey);
  return base58encode(pub);
}

async function storeAccount(rid, pass, seed32){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt, ['encrypt','decrypt']);
  const pkcs8 = pkcs8FromSeed(seed32);
  const {iv, ct} = await aesEncrypt(aes, pkcs8);

  const meta = { salt: Array.from(salt), iv: Array.from(iv), priv: Array.from(ct), ts: Date.now() };
  await idbPut('acct:' + rid, meta);
}

async function loadAndVerify(rid, pass){
  const meta = await idbGet('acct:' + rid);
  if (!meta) throw new Error('RID не найден на этом устройстве (нет локальной записи)');
  const salt = new Uint8Array(meta.salt || []);
  const iv   = new Uint8Array(meta.iv || []);
  const ct   = new Uint8Array(meta.priv || []);
  const aes  = await deriveKey(pass, salt, ['decrypt']);
  const pkcs8 = await aesDecrypt(aes, iv, ct);
  const seed = pkcs8.slice(ED25519_PKCS8_PREFIX.length);
  const checkRid = ridFromSeed(seed);
  if (checkRid !== rid) throw new Error('Неверный пароль');
  return true;
}

async function doShow(){
  try{
    ensureEnv();
    const list = await idbListRids();
    const box = $('savedList');
    if (box){
      box.style.display = '';
      box.textContent = list.length ? list.map(x=>'• '+x).join('\n') : '— пусто —';
    }
    setStatus('saved RID: ' + list.length);
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doLogin(){
  try{
    ensureEnv();
    const rid = String($('ridIn')?.value||'').trim();
    const pass = validatePass($('passIn')?.value||'');
    if (!rid) throw new Error('RID пустой');
    setStatus('checking…');
    await loadAndVerify(rid, pass);
    setSession(rid, pass);
    setStatus('ok → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doCreate(){
  try{
    ensureEnv();
    const pass = validatePass($('newPass')?.value||'');
    const phrase = genPhrase16();
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    const out = $('newPhraseOut');
    if (out) out.value = phrase;
    setSession(rid, pass);
    setStatus('created: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doRestore(){
  try{
    ensureEnv();
    const phrase = normalizePhrase($('phraseIn')?.value||'');
    const pass = validatePass($('restorePass')?.value||'');
    if (!phrase) throw new Error('Фраза пустая');
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    setSession(rid, pass);
    setStatus('restored: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  $('btnShow')?.addEventListener('click', doShow);
  $('btnLogin')?.addEventListener('click', doLogin);
  $('btnCreate')?.addEventListener('click', doCreate);
  $('btnRestore')?.addEventListener('click', doRestore);
  setStatus('ready');
});
```


### FILE: /opt/logos/www/wallet_dev/compat.js

```js
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```


### FILE: /opt/logos/www/wallet_dev/connect.js

```js
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };
```


### FILE: /opt/logos/www/wallet_dev/index.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta http-equiv="refresh" content="0; url=./auth.html?v=20260109_20"/>
  <title>LOGOS Wallet</title>
</head>
<body>
  Redirecting… <a href="./auth.html?v=20260109_20">Open LOGOS Wallet</a>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/login.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="refresh" content="0; url=./auth.html"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
</head>
<body>
  <p>Redirect to <a href="./auth.html">auth.html</a>…</p>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_dev/modules/send.js

```js
/* modules/send.js — REAL SEND LGN (TxIn -> /api/submit_tx) */
(() => {
  function $(sel, root=document){ return root.querySelector(sel); }

  function ridGet(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || sessionStorage.getItem("logos_rid")
      || "";
  }

  function nodeApi(){
    return (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");
  }

  function setMsg(panel, text, ok=true){
    const el = $("#sendMsg", panel) || $(".sendMsg", panel);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function b64ToU8(b64){
    b64 = (b64||"").replace(/-/g,'+').replace(/_/g,'/');
    while (b64.length % 4) b64 += "=";
    const s = atob(b64);
    const u = new Uint8Array(s.length);
    for (let i=0;i<s.length;i++) u[i] = s.charCodeAt(i);
    return u;
  }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++) out += u8[i].toString(16).padStart(2,"0");
    return out;
  }

  // точное преобразование LGN -> micro-LGN (6 decimals)
  function lgnToMicro(s){
    s = String(s||"").trim().replace(",",".");
    if (!s) return null;
    const m = s.match(/^(\d+)(?:\.(\d{0,6})\d*)?$/);
    if (!m) return null;
    const a = m[1];
    const frac = (m[2]||"").padEnd(6,"0");
    const microStr = a + frac;
    // без BigInt не рискуем переполнением? у нас u64 — используем BigInt
    return BigInt(microStr);
  }

  async function getJSON(url){
    const r = await fetch(url, {method:"GET"});
    const t = await r.text();
    let j=null; try{ j=JSON.parse(t);}catch(_){}
    if (!r.ok){
      const msg = j?.detail || j?.error || j?.message || t;
      throw new Error("HTTP " + r.status + ": " + msg);
    }
    return j ?? t;
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method:"POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j=null; try{ j=JSON.parse(t);}catch(_){}
    if (!r.ok){
      const msg = j?.detail || j?.error || j?.message || t;
      throw new Error("HTTP " + r.status + ": " + msg);
    }
    return j ?? t;
  }

  // Пытаемся найти приватный ключ в localStorage (PKCS8 base64/base64url) — без знания имени.
  async function findEd25519PrivKeyForRid(rid){
    const keys = [];
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      const v = localStorage.getItem(k);
      if (!v) continue;
      if (v.length < 40) continue;
      keys.push([k,v]);
    }

    for (const [k,v] of keys){
      // пропускаем явно не ключи
      if (k.toLowerCase().includes("theme")) continue;
      if (k.toLowerCase().includes("lang")) continue;

      // пробуем как pkcs8 base64/base64url
      let u8 = null;
      try { u8 = b64ToU8(v); } catch(_){}
      if (!u8 || u8.length < 40) continue;

      try{
        const priv = await crypto.subtle.importKey(
          "pkcs8",
          u8,
          { name:"Ed25519" },
          false,
          ["sign"]
        );

        // проверяем: подпись должна валидироваться на pubkey, который соответствует RID
        // (RID у тебя base58(pubkey) — но мы не будем вычислять pubkey: просто вернём ключ и надеемся что он правильный;
        // если неправильный — сервер вернёт bad_signature)
        return priv;
      }catch(_){
        // not a pkcs8 ed25519
      }
    }
    return null;
  }

  function canonBytes(tx){
    // ВАЖНО: это канонизация “по-человечески”.
    // Если на ноде другой формат — сразу увидим "bad_signature", и тогда сделаем canon-endpoint.
    const memo = tx.memo ? String(tx.memo) : "";
    const s = `${tx.from}|${tx.to}|${tx.amount}|${tx.nonce}|${memo}`;
    return new TextEncoder().encode(s);
  }

  async function signTx(privKey, tx){
    const msg = canonBytes(tx);
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msg);
    return hex(new Uint8Array(sig));
  }

  function render(){
    const panel =
      document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('[data-panel="send"]')
      || document.querySelector('#panel-send');

    if (!panel) return;

    const btnSend = $("#btnSendLGN", panel) || $("#sendBtn", panel) || panel.querySelector("button");
    if (!btnSend) return;

    btnSend.addEventListener("click", async () => {
      try{
        const from = ridGet();
        const to = ($("#sendToRid", panel)?.value || "").trim();
        const amountStr = ($("#sendAmount", panel)?.value || "").trim();
        const memo = ($("#sendMemo", panel)?.value || "").trim();

        if (!from) return setMsg(panel, "RID не найден. Перезайди в кошелёк.", false);
        if (!to || to.length < 12) return setMsg(panel, "Введи правильный RID получателя.", false);

        const micro = lgnToMicro(amountStr);
        if (micro === null) return setMsg(panel, "Введи сумму (например 1 или 0.5).", false);
        if (micro <= 0n) return setMsg(panel, "Сумма должна быть больше 0.", false);

        setMsg(panel, "Получаю nonce…", true);
        const bal = await getJSON(nodeApi() + "/balance/" + encodeURIComponent(from));
        const nonceNow = (bal && (bal.nonce ?? bal.nonce_u64 ?? bal.account_nonce)) ;
        if (nonceNow === undefined || nonceNow === null) {
          return setMsg(panel, "Не смог прочитать nonce из /balance. Нужно уточнить формат ответа.", false);
        }
        const nonce = BigInt(nonceNow) + 1n;

        setMsg(panel, "Ищу ключ…", true);
        const priv = await findEd25519PrivKeyForRid(from);
        if (!priv){
          return setMsg(panel, "Нет приватного ключа в браузере. Нужен импорт/создание ключа (добавим в Настройки).", false);
        }

        const tx = {
          from,
          to,
          amount: micro.toString(),
          nonce: nonce.toString(),
          memo: memo || null
        };

        setMsg(panel, "Подписываю…", true);
        const sig_hex = await signTx(priv, tx);

        setMsg(panel, "Отправляю в сеть…", true);
        const res = await postJSON(nodeApi() + "/submit_tx", {
          from: tx.from,
          to: tx.to,
          amount: Number(tx.amount), // u64 — у тебя тут маленькие суммы; если будут огромные — переведём на строку на сервере
          nonce: Number(tx.nonce),
          memo: tx.memo,
          sig_hex
        });

        setMsg(panel, "✅ Отправлено. " + (res?.txid ? ("txid: " + res.txid) : (res?.info ? res.info : "")), true);
      }catch(e){
        setMsg(panel, "ERR: " + (e?.message || e), false);
      }
    });
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", render);
  else render();
})();
```


### FILE: /opt/logos/www/wallet_dev/modules/settings.js

```js
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();
```


### FILE: /opt/logos/www/wallet_dev/modules/tx_redirect.js

```js
/* tx_redirect.js — redirect old /transfer -> /submit_tx and normalize body to TxIn */
(() => {
  const _fetch = window.fetch.bind(window);

  function isHex(s){
    s = String(s||"").replace(/^0x/,"").trim();
    return s.length > 0 && s.length % 2 === 0 && /^[0-9a-fA-F]+$/.test(s);
  }

  function b64urlToBytes(b64url){
    try{
      let s = String(b64url||"").replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u[i] = bin.charCodeAt(i);
      return u;
    }catch(e){ return null; }
  }

  function bytesToHex(u){
    let out = "";
    for (let i=0;i<u.length;i++) out += u[i].toString(16).padStart(2,"0");
    return out;
  }

  function normalizeTx(body){
    const j = body && typeof body === "object" ? body : {};
    const from = j.from || j.rid_from || j.sender || j.rid || "";
    const to   = j.to   || j.rid_to   || j.receiver || "";
    let amount = j.amount_mic ?? j.amount_micro ?? j.amount ?? 0;
    const nonce = j.nonce ?? j.n ?? j.account_nonce;

    // если вдруг прислали amount_lgn — переводим в micro-LGN
    if (j.amount_lgn !== undefined && j.amount_lgn !== null){
      const a = Number(j.amount_lgn);
      if (isFinite(a)) amount = Math.round(a * 1e6);
    }

    // подпись: sig_hex обязательно
    let sig_hex = j.sig_hex || j.sigHex || "";
    if (!sig_hex){
      const s = j.sig || j.signature || j.sig_b64 || j.sigB64 || "";
      if (s){
        if (isHex(s)) sig_hex = String(s).replace(/^0x/,"");
        else {
          const u = b64urlToBytes(s);
          if (u) sig_hex = bytesToHex(u);
        }
      }
    }

    const memo = (j.memo === undefined ? null : j.memo);

    return { from, to, amount, nonce, memo, sig_hex };
  }

  window.fetch = async (input, init={}) => {
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url.includes("/transfer")){
        const newUrl = url.replace("/transfer", "/submit_tx");

        let bodyObj = {};
        try{ bodyObj = JSON.parse(init.body || "{}"); }catch(e){ bodyObj = {}; }

        const tx = normalizeTx(bodyObj);

        const newInit = {
          ...init,
          method: "POST",
          headers: { ...(init.headers||{}), "Content-Type":"application/json" },
          body: JSON.stringify({
            from: tx.from,
            to: tx.to,
            amount: tx.amount,
            nonce: tx.nonce,
            memo: tx.memo,
            sig_hex: tx.sig_hex
          })
        };

        return _fetch(newUrl, newInit);
      }
    }catch(e){}
    return _fetch(input, init);
  };

  console.log("[tx_redirect] installed: /transfer -> /submit_tx");
})();
```


### FILE: /opt/logos/www/wallet_dev/tabs.js

```js
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();
```


### FILE: /opt/logos/www/wallet_dev/ui.css

```css

/* assets ui */
.assetsWrap{display:block;margin-top:16px}
.assetsHead{display:flex;gap:12px;align-items:center;justify-content:space-between;margin:8px 0 14px}
.assetsTitle{font-weight:800;font-size:20px;letter-spacing:.2px}
.assetsSub{margin-top:4px;color:rgba(255,255,255,.62);font-size:12px}
.assetsGrid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:14px}
@media (max-width: 900px){.assetsGrid{grid-template-columns:1fr}}
.assetCard{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:18px;padding:14px;box-shadow:0 16px 50px rgba(0,0,0,.35);backdrop-filter: blur(16px)}
.assetTop{display:flex;gap:12px;align-items:center}
.assetSym{width:48px;height:48px;border-radius:14px;display:flex;align-items:center;justify-content:center;font-weight:800;
  background:radial-gradient(120% 120% at 30% 10%, rgba(78,124,255,.35), rgba(139,92,246,.25), rgba(0,0,0,0));
  border:1px solid rgba(255,255,255,.12)
}
.assetName{font-weight:700}
.assetBal{margin-top:2px;font-size:13px;color:rgba(255,255,255,.75)}
.assetAddrRow{margin-top:12px;display:flex;gap:10px;align-items:center;justify-content:space-between}
.assetAddr{max-width:70%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:rgba(255,255,255,.85)}
.assetNote{margin-top:10px;font-size:12px}

/* ===== LOGOS PREMIUM TABS ===== */
.bottombar{
  position:fixed; left:0; right:0; bottom:0;
  display:flex; gap:10px; padding:12px 12px;
  backdrop-filter: blur(14px);
  background: rgba(10,14,26,.72);
  border-top: 1px solid rgba(255,255,255,.08);
  z-index: 9999;
}
.bottombar .tabBtn{
  flex:1;
  padding:10px 8px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.86);
  font-weight: 600;
  cursor: pointer;
}
.bottombar .tabBtn.active{
  background: rgba(120,140,255,.18);
  border-color: rgba(120,140,255,.35);
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
}
body{ padding-bottom: 86px !important; }

/* чуть “премиумнее” общий вид */
.tabCard{
  border: 1px solid rgba(255,255,255,.08) !important;
  box-shadow: 0 14px 40px rgba(0,0,0,.35) !important;
  border-radius: 18px !important;
}
```


### FILE: /opt/logos/www/wallet_dev/ui.js

```js
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```


### FILE: /opt/logos/www/wallet_dev/wallet.css

```css
:root {
  --bg: #050910;
  --bg-grad-1: rgba(56,189,248,0.18);
  --bg-grad-2: rgba(129,140,248,0.20);

  --card: #020617;
  --card-alt: #020617;

  --border-subtle: rgba(148,163,184,0.30);
  --border-strong: rgba(148,163,184,0.65);

  --accent: #3b82f6;
  --accent-soft: rgba(59,130,246,0.16);
  --accent-strong: #60a5fa;

  --danger: #f97373;

  --text-main: #e5e7eb;
  --text-muted: #9ca3af;

  --radius-card: 20px;
  --radius-sm: 10px;

  --shadow-soft: 0 24px 60px rgba(0,0,0,0.75);

  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
           "Liberation Mono", "Courier New", monospace;
}

/* базовые */

*,
*::before,
*::after {
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
               Roboto, sans-serif;
  background:
    radial-gradient(circle at top left, var(--bg-grad-1), transparent 58%),
    radial-gradient(circle at bottom right, var(--bg-grad-2), transparent 55%),
    var(--bg);
  color: var(--text-main);
  min-height: 100vh;
}

/* верхняя панель */

.topbar {
  position: sticky;
  top: 0;
  z-index: 40;
  background: linear-gradient(95deg, rgba(15,23,42,0.98), rgba(15,23,42,0.96));
  backdrop-filter: blur(16px);
  border-bottom: 1px solid rgba(148,163,184,0.18);
  box-shadow: 0 18px 40px rgba(0,0,0,0.65);
  padding: 10px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.topbar-left {
  display: flex;
  align-items: center;
  gap: 10px;
}

.logo-dot {
  width: 26px;
  height: 26px;
  border-radius: 999px;
  background: radial-gradient(circle at 30% 30%, #22d3ee, #6366f1);
  box-shadow: 0 0 20px rgba(56,189,248,0.55);
}

.topbar-title {
  display: flex;
  flex-direction: column;
  line-height: 1.1;
}

.topbar-title .brand {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  color: #e5e7eb;
}

.topbar-title .product {
  font-size: 13px;
  color: var(--text-muted);
}

.topbar-right {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
}

.endpoint-label {
  color: var(--text-muted);
}

.endpoint-value {
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.9);
}

/* общая раскладка */

.page-shell {
  max-width: 1040px;
  margin: 0 auto;
  padding: 18px 16px 40px;
}

.page-header {
  margin-bottom: 18px;
}

.page-header h1 {
  font-size: 22px;
  margin: 0 0 6px;
}

.subtitle {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

/* карточки */

.card {
  background: radial-gradient(circle at top left, rgba(56,189,248,0.10), transparent 55%),
              var(--card);
  border-radius: var(--radius-card);
  border: 1px solid var(--border-subtle);
  box-shadow: var(--shadow-soft);
  margin-bottom: 18px;
  overflow: hidden;
}

.card-header {
  padding: 14px 18px 10px;
  border-bottom: 1px solid rgba(15,23,42,0.9);
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.card-title {
  font-size: 16px;
  margin: 0 0 4px;
}

.card-caption {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

.card-body {
  padding: 14px 18px 16px;
}

/* поля */

.field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 12px;
}

.field-row {
  display: flex;
  gap: 10px;
  align-items: flex-end;
  margin-bottom: 12px;
}

.field-row .grow {
  flex: 1 1 auto;
}

.field-label {
  font-size: 12px;
  color: var(--text-muted);
}

.field-input {
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.95);
  color: var(--text-main);
  padding: 8px 10px;
  font-size: 14px;
  outline: none;
}

.field-input:focus {
  border-color: var(--accent-strong);
  box-shadow: 0 0 0 1px rgba(59,130,246,0.55);
}

/* текстовые выводы */

.mono-field,
.mono-output {
  width: 100%;
  font-family: var(--mono);
  font-size: 13px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(2,6,23,0.96);
  color: var(--text-main);
  padding: 10px 12px;
  resize: vertical;
  min-height: 80px;
  white-space: pre-wrap;
}

.mono-output {
  margin-top: 8px;
}

/* кнопки */

.actions-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 6px;
  margin-bottom: 6px;
}

.btn {
  border-radius: 999px;
  border: 1px solid transparent;
  padding: 7px 14px;
  font-size: 13px;
  cursor: pointer;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.btn.primary {
  background: linear-gradient(135deg, #2563eb, #3b82f6);
  border-color: rgba(59,130,246,0.8);
  color: #fff;
}

.btn.primary:hover {
  background: linear-gradient(135deg, #1d4ed8, #2563eb);
}

.btn.secondary {
  background: rgba(15,23,42,0.95);
  border-color: var(--border-strong);
  color: var(--text-main);
}

.btn.secondary:hover {
  border-color: var(--accent-strong);
}

.btn.ghost {
  background: transparent;
  border-color: var(--border-subtle);
  color: var(--text-muted);
}

.btn.ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* чипы */

.chip {
  padding: 5px 10px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.92);
  font-size: 12px;
  color: var(--text-muted);
  cursor: pointer;
}

.chip-ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* подсказки */

.hint {
  margin-top: 8px;
  font-size: 12px;
  color: var(--text-muted);
}

/* адаптив */

@media (max-width: 720px) {
  .topbar {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }

  .field-row {
    flex-direction: column;
    align-items: stretch;
  }

  .page-shell {
    padding: 14px 10px 32px;
  }
}
```


## FRONTEND ROOT: /opt/logos/www/wallet_premium

### TREE (depth 3)

```text
app.js
i18n.js
ui.css
app.html.bak_before_premiumfix_20260104T144415Z
app.html
ui.css.bak_before_premiumfix_20260104T144415Z
premium.css
```


### FILE: /opt/logos/www/wallet_premium/app.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>

  <link rel="stylesheet" href="./ui.css?v=premium_v1"/>
  <script src="./i18n.js?v=premium_v1" defer></script>
  <script src="./app.js?v=premium_v1" defer></script>
  <link rel="stylesheet" href="./premium.css?v=premium_fix_01"/>
</head>
<body>
  <div class="bg">
    <div class="noise"></div>
    <div class="glow g1"></div>
    <div class="glow g2"></div>
    <div class="glow g3"></div>
  </div>

  <header class="topbar">
    <div class="wrap">
      <div class="brand">
        <div class="logo"></div>
        <div class="brandText">
          <div class="brandTitle">LOGOS Wallet</div>
          <div class="brandSub" id="brandSub">Secure account-wallet for LGN & multi-assets</div>
        </div>
      </div>

      <div class="topRight">
        <div class="pill mono" id="pillNode">NODE: …</div>
        <div class="pill mono" id="pillWallet">WALLET: …</div>

        <button class="pill btn" id="btnLang">RU</button>
        <button class="pill btn" id="btnTheme">Theme</button>
      </div>
    </div>
  </header>

  <main class="main">
    <div class="wrap">
      <section class="heroCard">
        <div class="heroHead">
          <div>
            <div class="h1" id="pageTitle">—</div>
            <div class="sub" id="pageSub">—</div>
          </div>

          <div class="ridBox">
            <div class="ridLabel" id="ridLabel">RID</div>
            <div class="ridValue mono" id="ridValue">—</div>
            <div class="ridActions">
              <button class="btnSmall" id="btnCopyRid">Copy</button>
              <button class="btnSmall ghost" id="btnManageRid">Create / Restore</button>
            </div>
          </div>
        </div>
      </section>

      <section class="content" id="content"></section>
    </div>
  </main>

  <nav class="tabs" id="tabs">
    <button class="tab active" data-tab="home">
      <div class="ico">⌂</div>
      <div class="t" data-i18n="tab_home">Home</div>
    </button>

    <button class="tab" data-tab="assets">
      <div class="ico">◈</div>
      <div class="t" data-i18n="tab_assets">Assets</div>
    </button>

    <button class="tab" data-tab="staking">
      <div class="ico">◎</div>
      <div class="t" data-i18n="tab_staking">Staking</div>
    </button>

    <button class="tab" data-tab="card">
      <div class="ico">▢</div>
      <div class="t" data-i18n="tab_card">Card</div>
    </button>

    <button class="tab" data-tab="settings">
      <div class="ico">⚙</div>
      <div class="t" data-i18n="tab_settings">Settings</div>
    </button>
  </nav>

  <div class="toast" id="toast"></div>

  <div class="modal" id="modal" aria-hidden="true">
    <div class="modalBack" id="modalBack"></div>
    <div class="modalCard">
      <div class="modalTop">
        <div class="modalTitle" id="modalTitle">—</div>
        <button class="modalClose" id="modalClose">×</button>
      </div>
      <div class="modalBody" id="modalBody"></div>
      <div class="modalFoot" id="modalFoot"></div>
    </div>
  </div>
</body>
</html>
```


### FILE: /opt/logos/www/wallet_premium/app.js

```js
"use strict";

(() => {
  const $ = (q, el=document) => el.querySelector(q);
  const $$ = (q, el=document) => Array.from(el.querySelectorAll(q));

  function normalize(u){ return (u||"").toString().trim().replace(/\/+$/,""); }

  // ===== THEME / LANG =====
  function applyTheme(){
    const t = localStorage.getItem("logos_theme") || "dark";
    document.documentElement.dataset.theme = (t === "light") ? "light" : "dark";
  }
  function toggleTheme(){
    const cur = document.documentElement.dataset.theme || "dark";
    const next = (cur === "dark") ? "light" : "dark";
    document.documentElement.dataset.theme = next;
    localStorage.setItem("logos_theme", next);
    toast("Theme: " + next);
  }

  function applyLang(){
    const lang = I18N.getLang();
    $("#btnLang").textContent = lang.toUpperCase();
    $("#brandSub").textContent = I18N.t("brand_sub");

    $$("[data-i18n]").forEach(el=>{
      const k = el.getAttribute("data-i18n");
      el.textContent = I18N.t(k);
    });

    // current page titles will be re-rendered by setTab()
  }
  function toggleLang(){
    const cur = I18N.getLang();
    const next = (cur === "ru") ? "en" : "ru";
    I18N.setLang(next);
    applyLang();
    render();
  }

  // ===== RID STORAGE (compat with your old keys) =====
  function getRid(){
    try{
      const a = JSON.parse(localStorage.getItem("logos_onb_v1") || "{}");
      if (a && a.rid) return String(a.rid);
    }catch(_){}
    const rid = localStorage.getItem("logos_rid") || localStorage.getItem("RID") || "";
    return String(rid || "");
  }

  function setRid(rid){
    const r = String(rid||"").trim();
    if (!r) return;
    localStorage.setItem("logos_rid", r);
    localStorage.setItem("RID", r);
  }

  async function copyText(text){
    try{
      await navigator.clipboard.writeText(String(text||""));
      toast(I18N.t("ok_copied"));
      return true;
    }catch(_){
      toast(I18N.t("err_copy"));
      return false;
    }
  }

  // ===== API BASE =====
  function apiBase(){
    // IMPORTANT: we keep same paths you already have on domain
    const origin = normalize(window.location.origin);
    return {
      node: origin + "/node-api",
      wallet: origin + "/wallet-api"
    };
  }

  async function fetchJson(url, opts={}, timeoutMs=6000){
    const ctrl = new AbortController();
    const t = setTimeout(()=>ctrl.abort(), timeoutMs);
    try{
      const res = await fetch(url, { ...opts, signal: ctrl.signal, cache: "no-store" });
      const ct = res.headers.get("content-type") || "";
      const txt = await res.text();
      if (!res.ok) throw new Error("HTTP " + res.status + " " + txt.slice(0,140));
      if (ct.includes("application/json")) return JSON.parse(txt);
      // allow plain text
      return { ok:true, text: txt };
    } finally {
      clearTimeout(t);
    }
  }

  // ===== UI helpers =====
  let toastTimer = null;
  function toast(msg){
    const el = $("#toast");
    el.textContent = msg;
    el.classList.add("show");
    clearTimeout(toastTimer);
    toastTimer = setTimeout(()=>el.classList.remove("show"), 1800);
  }

  function modalOpen(title, bodyHtml, footHtml=""){
    $("#modalTitle").textContent = title;
    $("#modalBody").innerHTML = bodyHtml;
    $("#modalFoot").innerHTML = footHtml;
    $("#modal").setAttribute("aria-hidden","false");
  }
  function modalClose(){
    $("#modal").setAttribute("aria-hidden","true");
  }

  // ===== STATUS pills =====
  async function updateStatus(){
    const base = apiBase();
    const rid = getRid();

    // NODE
    try{
      const j = await fetchJson(base.node + "/healthz");
      $("#pillNode").textContent = (j && j.status === "ok") ? "NODE: ON" : "NODE: ?";
      $("#pillNode").style.borderColor = (j && j.status === "ok") ? "rgba(34,197,94,.55)" : "";
    }catch(_){
      $("#pillNode").textContent = "NODE: OFF";
      $("#pillNode").style.borderColor = "rgba(248,113,113,.55)";
    }

    // WALLET
    if (!rid){
      $("#pillWallet").textContent = "WALLET: —";
      $("#pillWallet").style.borderColor = "";
      return;
    }
    try{
      // health endpoint may not exist; we still show OK if RID exists
      await fetchJson(base.wallet + "/healthz").catch(()=>null);
      $("#pillWallet").textContent = "WALLET: OK";
      $("#pillWallet").style.borderColor = "rgba(79,124,255,.55)";
    }catch(_){
      $("#pillWallet").textContent = "WALLET: OK";
      $("#pillWallet").style.borderColor = "rgba(79,124,255,.55)";
    }
  }

  // ===== RENDER =====
  const state = { tab: "home" };

  function setTab(tab){
    state.tab = tab;
    $$(".tab").forEach(b => b.classList.toggle("active", b.dataset.tab === tab));
    render();
  }

  function renderHeader(){
    const rid = getRid();
    $("#ridLabel").textContent = I18N.t("rid_label");
    $("#ridValue").textContent = rid ? rid : I18N.t("rid_missing");
    $("#btnCopyRid").textContent = I18N.t("btn_copy");
    $("#btnManageRid").textContent = I18N.t("btn_manage");
  }

  function viewHome(){
    $("#pageTitle").textContent = I18N.t("home_title");
    $("#pageSub").textContent = I18N.t("home_sub");

    const rid = getRid();

    const actions = `
      <div class="actions">
        <button class="btn primary" id="actReceive">${I18N.t("act_receive")}</button>
        <button class="btn" id="actSend">${I18N.t("act_send")}</button>
        <button class="btn" id="actSwap">${I18N.t("act_swap")}</button>
        <button class="btn" id="actFiat">${I18N.t("act_fiat")}</button>
        <button class="btn success" id="actStake">${I18N.t("act_stake")}</button>
      </div>
    `;

    const content = `
      <div class="grid two">
        <div class="card">
          <div class="cardIn">
            <div class="row">
              <div>
                <div class="cardTitle">${I18N.t("total_balance")}</div>
                <div class="cardSub">${I18N.t("lgn_first")}</div>
              </div>
              <div class="badge mono" id="currencyBadge">LGN</div>
            </div>

            <div class="row" style="align-items:flex-end">
              <div class="bigAmount" id="totalAmount">—</div>
              <div class="actions" style="margin:0">
                <button class="btn ghost" id="viewUSD">${I18N.t("view_usd")}</button>
                <button class="btn ghost" id="viewEUR">${I18N.t("view_eur")}</button>
              </div>
            </div>

            ${rid ? "" : `<div class="empty">${I18N.t("empty_need_rid")}</div>`}
            ${actions}
          </div>
        </div>

        <div class="card">
          <div class="cardIn">
            <div class="cardTitle">Activity</div>
            <div class="cardSub">History & notifications (next step)</div>
            <div class="empty">${I18N.t("empty_api")}</div>
          </div>
        </div>
      </div>
    `;

    $("#content").innerHTML = content;

    // set mock total
    $("#totalAmount").textContent = rid ? "0.00" : "—";

    $("#actReceive").onclick = () => openReceive();
    $("#actSend").onclick = () => openSend();
    $("#actSwap").onclick = () => openSwap();
    $("#actFiat").onclick = () => openFiat();
    $("#actStake").onclick = () => setTab("staking");

    $("#viewUSD").onclick = () => {
      $("#currencyBadge").textContent = "USD";
      $("#totalAmount").textContent = rid ? "0.00" : "—";
    };
    $("#viewEUR").onclick = () => {
      $("#currencyBadge").textContent = "EUR";
      $("#totalAmount").textContent = rid ? "0.00" : "—";
    };
  }

  function viewAssets(){
    $("#pageTitle").textContent = I18N.t("assets_title");
    $("#pageSub").textContent = I18N.t("assets_sub");

    const rid = getRid();
    const list = `
      <div class="list">
        <div class="item">
          <div class="itL">
            <div class="coin"></div>
            <div>
              <div class="sym">LGN</div>
              <div class="name">LOGOS Network</div>
            </div>
          </div>
          <div class="itR">
            <div class="val">0.00</div>
            <div class="small">≈ 0.00 USD</div>
          </div>
        </div>

        <div class="item">
          <div class="itL">
            <div class="coin" style="background: radial-gradient(10px 10px at 30% 30%, rgba(255,255,255,.55), transparent 65%), linear-gradient(135deg, rgba(34,197,94,.35), rgba(79,124,255,.25));"></div>
            <div>
              <div class="sym">USDT</div>
              <div class="name">Tether (bridge)</div>
            </div>
          </div>
          <div class="itR">
            <div class="val">0.00</div>
            <div class="small">≈ 0.00 USD</div>
          </div>
        </div>

        <div class="item">
          <div class="itL">
            <div class="coin" style="background: radial-gradient(10px 10px at 30% 30%, rgba(255,255,255,.55), transparent 65%), linear-gradient(135deg, rgba(251,191,36,.35), rgba(147,51,234,.25));"></div>
            <div>
              <div class="sym">BTC</div>
              <div class="name">Bitcoin (bridge)</div>
            </div>
          </div>
          <div class="itR">
            <div class="val">0.00</div>
            <div class="small">≈ 0.00 USD</div>
          </div>
        </div>
      </div>
    `;

    $("#content").innerHTML = `
      <div class="card">
        <div class="cardIn">
          <div class="row" style="margin-top:0">
            <div>
              <div class="cardTitle">Portfolio</div>
              <div class="cardSub">LGN first • multi-assets next</div>
            </div>
            <div class="actions" style="margin:0">
              <button class="btn primary" id="btnReceive">${I18N.t("act_receive")}</button>
              <button class="btn" id="btnSend">${I18N.t("act_send")}</button>
            </div>
          </div>

          ${rid ? "" : `<div class="empty">${I18N.t("empty_need_rid")}</div>`}
          ${list}
          <div class="empty">${I18N.t("empty_api")}</div>
        </div>
      </div>
    `;

    $("#btnReceive").onclick = () => openReceive();
    $("#btnSend").onclick = () => openSend();
  }

  function viewStaking(){
    $("#pageTitle").textContent = I18N.t("staking_title");
    $("#pageSub").textContent = I18N.t("staking_sub");

    const rid = getRid();
    $("#content").innerHTML = `
      <div class="grid two">
        <div class="card">
          <div class="cardIn">
            <div class="cardTitle">LGN Staking</div>
            <div class="cardSub">Stake • Unstake • Claim • Auto-compound (next)</div>

            ${rid ? "" : `<div class="empty">${I18N.t("empty_need_rid")}</div>`}

            <div class="row">
              <div>
                <div class="small">Staked</div>
                <div class="val" style="font-size:22px">0.00 LGN</div>
              </div>
              <div>
                <div class="small">Rewards</div>
                <div class="val" style="font-size:22px">0.00 LGN</div>
              </div>
            </div>

            <div class="row">
              <div class="badge">APR: —</div>
              <div class="badge">Unbonding: —</div>
            </div>

            <div class="actions">
              <button class="btn success" id="btnStake">Stake</button>
              <button class="btn" id="btnUnstake">Unstake</button>
              <button class="btn primary" id="btnClaim">Claim</button>
            </div>

            <div class="empty">${I18N.t("empty_api")}</div>
          </div>
        </div>

        <div class="card">
          <div class="cardIn">
            <div class="cardTitle">Validators</div>
            <div class="cardSub">Choose validator • delegation stats (next)</div>
            <div class="empty">${I18N.t("empty_api")}</div>
          </div>
        </div>
      </div>
    `;

    $("#btnStake").onclick = () => openStake();
    $("#btnUnstake").onclick = () => openStake("unstake");
    $("#btnClaim").onclick = () => openStake("claim");
  }

  function viewCard(){
    $("#pageTitle").textContent = I18N.t("card_title");
    $("#pageSub").textContent = I18N.t("card_sub");

    $("#content").innerHTML = `
      <div class="grid two">
        <div class="card">
          <div class="cardIn">
            <div class="cardTitle">LOGOS Card</div>
            <div class="cardSub">Premium spending layer (fiat integration later)</div>

            <div class="row">
              <div>
                <div class="small">Spending pocket</div>
                <div class="val" style="font-size:26px">0.00</div>
              </div>
              <div class="badge">KYC: —</div>
            </div>

            <div class="actions">
              <button class="btn primary" id="btnTopupPocket">Top up</button>
              <button class="btn" id="btnLimits">Limits</button>
              <button class="btn ghost" id="btnHistory">History</button>
            </div>

            <div class="empty">${I18N.t("empty_api")}</div>
          </div>
        </div>

        <div class="card">
          <div class="cardIn">
            <div class="cardTitle">Security</div>
            <div class="cardSub">Anti-fraud • time-lock • address whitelist (next)</div>
            <div class="empty">${I18N.t("empty_api")}</div>
          </div>
        </div>
      </div>
    `;

    $("#btnTopupPocket").onclick = () => openFiat();
    $("#btnLimits").onclick = () => openFiat();
    $("#btnHistory").onclick = () => openFiat();
  }

  function viewSettings(){
    $("#pageTitle").textContent = I18N.t("settings_title");
    $("#pageSub").textContent = I18N.t("settings_sub");

    $("#content").innerHTML = `
      <div class="grid two">
        <div class="card">
          <div class="cardIn">
            <div class="cardTitle">Security</div>
            <div class="cardSub">Seed control • passphrase • passkey (next)</div>

            <div class="actions">
              <button class="btn" id="btnSeed">Seed check</button>
              <button class="btn" id="btnPasskey">Passkey</button>
              <button class="btn" id="btnLimits2">Limits</button>
            </div>
            <div class="empty">${I18N.t("empty_api")}</div>
          </div>
        </div>

        <div class="card">
          <div class="cardIn">
            <div class="cardTitle">About</div>
            <div class="cardSub">Version • endpoints • diagnostics</div>

            <div class="list">
              <div class="item">
                <div class="itL"><div class="sym">Node API</div></div>
                <div class="itR"><div class="small mono" id="aboutNode">—</div></div>
              </div>
              <div class="item">
                <div class="itL"><div class="sym">Wallet API</div></div>
                <div class="itR"><div class="small mono" id="aboutWallet">—</div></div>
              </div>
            </div>

            <div class="actions">
              <button class="btn primary" id="btnDiag">Diagnostics</button>
            </div>
          </div>
        </div>
      </div>
    `;

    const base = apiBase();
    $("#aboutNode").textContent = base.node;
    $("#aboutWallet").textContent = base.wallet;

    $("#btnDiag").onclick = () => openDiag();
    $("#btnSeed").onclick = () => openOnboarding();
    $("#btnPasskey").onclick = () => openDiag();
    $("#btnLimits2").onclick = () => openDiag();
  }

  function render(){
    renderHeader();
    const tab = state.tab;
    if (tab === "home") return viewHome();
    if (tab === "assets") return viewAssets();
    if (tab === "staking") return viewStaking();
    if (tab === "card") return viewCard();
    if (tab === "settings") return viewSettings();
    viewHome();
  }

  // ===== Modals =====
  function openReceive(){
    const rid = getRid();
    if (!rid) return openOnboarding();
    modalOpen(I18N.t("m_receive_title"),
      `
      <div class="label">Asset</div>
      <select class="input" id="mAsset">
        <option>LGN</option>
        <option>USDT</option>
        <option>BTC</option>
      </select>
      <div class="label">Address / RID</div>
      <input class="input mono" value="${rid}" readonly/>
      <div class="hr"></div>
      <div class="empty">${I18N.t("empty_api")}</div>
      `,
      `<button class="btn primary" id="mCopy">Copy</button><button class="btn ghost" id="mClose">Close</button>`
    );
    $("#mCopy").onclick = () => copyText(rid);
    $("#mClose").onclick = () => modalClose();
  }

  function openSend(){
    const rid = getRid();
    if (!rid) return openOnboarding();
    modalOpen(I18N.t("m_send_title"),
      `
      <div class="label">To (RID / address)</div>
      <input class="input mono" id="toRid" placeholder="RID..."/>
      <div class="label">Amount (LGN)</div>
      <input class="input" id="amt" placeholder="0.00"/>
      <div class="hr"></div>
      <div class="empty">${I18N.t("empty_api")}</div>
      `,
      `<button class="btn primary" id="mSubmit">Sign & send</button><button class="btn ghost" id="mClose">Close</button>`
    );
    $("#mSubmit").onclick = () => toast("Next step: connect /withdraw + intent-sign");
    $("#mClose").onclick = () => modalClose();
  }

  function openSwap(){
    const rid = getRid();
    if (!rid) return openOnboarding();
    modalOpen(I18N.t("m_swap_title"),
      `
      <div class="label">From</div>
      <select class="input"><option>LGN</option><option>USDT</option></select>
      <div class="label">To</div>
      <select class="input"><option>USDT</option><option>LGN</option></select>
      <div class="label">Amount</div>
      <input class="input" placeholder="0.00"/>
      <div class="hr"></div>
      <div class="empty">${I18N.t("empty_api")}</div>
      `,
      `<button class="btn primary" id="mSwap">Continue</button><button class="btn ghost" id="mClose">Close</button>`
    );
    $("#mSwap").onclick = () => toast("Next step: bridge/swap endpoints");
    $("#mClose").onclick = () => modalClose();
  }

  function openFiat(){
    modalOpen(I18N.t("m_fiat_title"),
      `
      <div class="cardSub">SEPA / cards / KYC — after integration</div>
      <div class="empty">${I18N.t("empty_api")}</div>
      `,
      `<button class="btn ghost" id="mClose">Close</button>`
    );
    $("#mClose").onclick = () => modalClose();
  }

  function openStake(mode="stake"){
    const rid = getRid();
    if (!rid) return openOnboarding();
    const title = (mode==="claim") ? "Claim" : (mode==="unstake" ? "Unstake" : I18N.t("m_stake_title"));
    modalOpen(title,
      `
      <div class="label">Amount (LGN)</div>
      <input class="input" placeholder="0.00"/>
      <div class="label">Validator</div>
      <input class="input mono" placeholder="validator RID / key"/>
      <div class="hr"></div>
      <div class="empty">${I18N.t("empty_api")}</div>
      `,
      `<button class="btn primary" id="mDo">Continue</button><button class="btn ghost" id="mClose">Close</button>`
    );
    $("#mDo").onclick = () => toast("Next step: staking endpoints (delegate/undelegate/claim)");
    $("#mClose").onclick = () => modalClose();
  }

  function openDiag(){
    const base = apiBase();
    modalOpen("Diagnostics",
      `
      <div class="label">Node API</div>
      <input class="input mono" value="${base.node}" readonly/>
      <div class="label">Wallet API</div>
      <input class="input mono" value="${base.wallet}" readonly/>
      <div class="hr"></div>
      <div class="empty">UI is premium-ready. Next step: connect balance/history/topup/withdraw/staking.</div>
      `,
      `<button class="btn primary" id="mPing">Ping node</button><button class="btn ghost" id="mClose">Close</button>`
    );
    $("#mPing").onclick = async () => {
      try{
        const j = await fetchJson(base.node + "/healthz");
        toast("node: " + (j.status || "ok"));
      }catch(e){
        toast("node: OFF");
      }
    };
    $("#mClose").onclick = () => modalClose();
  }

  function openOnboarding(){
    toast(I18N.t("open_onboarding"));
    // Пока просто перекидываем на твой онбординг путь (можно заменить на SPA-экран)
    // Если у тебя другой путь — поменяем тут одной строкой.
    window.location.href = "/wallet_dev/welcome.html";
  }

  // ===== INIT =====
  function bind(){
    $("#btnTheme").onclick = toggleTheme;
    $("#btnLang").onclick = toggleLang;

    $("#btnCopyRid").onclick = () => {
      const rid = getRid();
      if (!rid) return toast(I18N.t("empty_need_rid"));
      copyText(rid);
    };
    $("#btnManageRid").onclick = openOnboarding;

    $$(".tab").forEach(b => b.onclick = () => setTab(b.dataset.tab));

    $("#modalBack").onclick = modalClose;
    $("#modalClose").onclick = modalClose;

    // default tab
    const hash = (location.hash || "").replace("#","");
    if (hash) state.tab = hash;
  }

  function boot(){
    applyTheme();
    applyLang();
    bind();
    render();
    updateStatus();
    setInterval(updateStatus, 7000);
  }

  document.addEventListener("DOMContentLoaded", boot);
})();
```


### FILE: /opt/logos/www/wallet_premium/i18n.js

```js
(() => {
  const dict = {
    ru: {
      brand_sub: "Безопасный аккаунт-кошелёк для LGN и мультикрипты",
      tab_home: "Главная",
      tab_assets: "Активы",
      tab_staking: "Стейкинг",
      tab_card: "Карта",
      tab_settings: "Настройки",

      home_title: "Главная",
      home_sub: "Баланс, быстрые действия и операции",
      assets_title: "Активы",
      assets_sub: "Портфель, получение/отправка и история",
      staking_title: "Стейкинг",
      staking_sub: "LGN: stake / unstake / claim",
      card_title: "Карта",
      card_sub: "Spending pocket, лимиты и статусы",
      settings_title: "Настройки",
      settings_sub: "Безопасность, язык/тема, интеграции",

      rid_label: "RID",
      rid_missing: "RID не создан — нажми Create / Restore",
      btn_copy: "Копировать",
      btn_manage: "Создать / Восстановить",

      act_receive: "Получить",
      act_send: "Отправить",
      act_swap: "Обмен",
      act_fiat: "Фиат",
      act_stake: "Стейкинг",

      total_balance: "Общий баланс",
      view_usd: "В USD",
      view_eur: "В EUR",
      lgn_first: "LGN — основной актив",

      empty_need_rid: "Сначала создай/восстанови кошелёк (RID).",
      empty_api: "API пока не подключён. UI готов — подключим ручки следующим шагом.",

      m_receive_title: "Получить",
      m_send_title: "Отправить",
      m_swap_title: "Обмен",
      m_fiat_title: "Фиат",
      m_stake_title: "Стейкинг",

      ok_copied: "Скопировано",
      err_copy: "Не удалось скопировать",
      open_onboarding: "Открываю онбординг…"
    },
    en: {
      brand_sub: "Secure account-wallet for LGN & multi-assets",
      tab_home: "Home",
      tab_assets: "Assets",
      tab_staking: "Staking",
      tab_card: "Card",
      tab_settings: "Settings",

      home_title: "Home",
      home_sub: "Balance, quick actions and operations",
      assets_title: "Assets",
      assets_sub: "Portfolio, receive/send and history",
      staking_title: "Staking",
      staking_sub: "LGN: stake / unstake / claim",
      card_title: "Card",
      card_sub: "Spending pocket, limits and statuses",
      settings_title: "Settings",
      settings_sub: "Security, language/theme, integrations",

      rid_label: "RID",
      rid_missing: "RID not set — press Create / Restore",
      btn_copy: "Copy",
      btn_manage: "Create / Restore",

      act_receive: "Receive",
      act_send: "Send",
      act_swap: "Swap",
      act_fiat: "Fiat",
      act_stake: "Stake",

      total_balance: "Total balance",
      view_usd: "In USD",
      view_eur: "In EUR",
      lgn_first: "LGN is the primary asset",

      empty_need_rid: "Create/restore wallet first (RID).",
      empty_api: "API not connected yet. UI is ready — we'll plug endpoints next.",

      m_receive_title: "Receive",
      m_send_title: "Send",
      m_swap_title: "Swap",
      m_fiat_title: "Fiat",
      m_stake_title: "Staking",

      ok_copied: "Copied",
      err_copy: "Copy failed",
      open_onboarding: "Opening onboarding…"
    }
  };

  function getLang(){
    const v = (localStorage.getItem("logos_lang") || "ru").toLowerCase();
    return (v === "en") ? "en" : "ru";
  }

  window.I18N = {
    getLang,
    t(key){
      const lang = getLang();
      return (dict[lang] && dict[lang][key]) || (dict.ru[key] || key);
    },
    setLang(lang){
      const v = (String(lang||"").toLowerCase() === "en") ? "en" : "ru";
      localStorage.setItem("logos_lang", v);
    }
  };
})();
```


### FILE: /opt/logos/www/wallet_premium/premium.css

```css
/* LOGOS Wallet Premium Override */
:root{
  --bg0:#050812;
  --bg1:#070B18;
  --glass: rgba(255,255,255,.06);
  --glass2: rgba(255,255,255,.04);
  --stroke: rgba(255,255,255,.10);
  --stroke2: rgba(255,255,255,.07);
  --txt: rgba(255,255,255,.92);
  --muted: rgba(255,255,255,.62);
  --shadow: 0 20px 60px rgba(0,0,0,.55);
  --r16: 16px;
  --r20: 20px;
  --r24: 24px;
  --pad: clamp(14px, 2.2vw, 22px);
  --w: 1120px;
}

/* фон “премиум” */
html,body{ height:100%; }
body{
  color: var(--txt);
  background:
    radial-gradient(900px 520px at 20% 8%, rgba(70,120,255,.18), transparent 60%),
    radial-gradient(820px 520px at 78% 16%, rgba(0,255,180,.14), transparent 60%),
    radial-gradient(720px 520px at 55% 92%, rgba(160,90,255,.12), transparent 65%),
    linear-gradient(180deg, var(--bg0), var(--bg1));
}

/* контейнер */
.container{
  max-width: var(--w) !important;
  padding-left: var(--pad) !important;
  padding-right: var(--pad) !important;
}

/* верхняя панель — плотнее и “дороже” */
.topbar{
  backdrop-filter: blur(18px);
  -webkit-backdrop-filter: blur(18px);
  border-bottom: 1px solid var(--stroke2);
}
.brand__t{ font-size: 16px; letter-spacing: .2px; }
.brand__s{ color: var(--muted); }

/* карточки */
.card, .panel, .box, .section{
  background: linear-gradient(180deg, var(--glass), var(--glass2));
  border: 1px solid var(--stroke2);
  border-radius: var(--r24);
  box-shadow: var(--shadow);
}
.card{ padding: clamp(16px, 2.1vw, 22px); }
.card h1, .h1{ font-size: clamp(26px, 3.2vw, 34px); letter-spacing: .2px; }
.card h2, .h2{ font-size: clamp(18px, 2.4vw, 22px); color: var(--txt); }
.muted, .sub, .hint{ color: var(--muted) !important; }

/* кнопки — единая система */
button, .btn{
  border-radius: 14px !important;
  border: 1px solid var(--stroke2) !important;
  background: rgba(255,255,255,.06) !important;
  color: var(--txt) !important;
  transition: transform .12s ease, filter .12s ease, background .12s ease;
}
button:hover, .btn:hover{ filter: brightness(1.08); }
button:active, .btn:active{ transform: translateY(1px); }

.btnPrimary, .primary, .btn.primary{
  background: linear-gradient(135deg, rgba(80,120,255,.92), rgba(120,80,255,.75)) !important;
  border-color: rgba(170,190,255,.25) !important;
}
.btnSuccess, .success{
  background: linear-gradient(135deg, rgba(0,220,160,.92), rgba(0,170,120,.72)) !important;
  border-color: rgba(120,255,210,.22) !important;
}

/* поля ввода */
input, textarea, select{
  border-radius: 14px !important;
  background: rgba(0,0,0,.22) !important;
  border: 1px solid var(--stroke2) !important;
  color: var(--txt) !important;
}
input::placeholder, textarea::placeholder{ color: rgba(255,255,255,.35); }

/* нижняя навигация — “как приложение” */
.tabs{
  backdrop-filter: blur(18px);
  -webkit-backdrop-filter: blur(18px);
  background: rgba(10,14,25,.55) !important;
  border-top: 1px solid var(--stroke2);
}
.tab{
  border-radius: 16px !important;
}
.tab.active{
  background: rgba(255,255,255,.08) !important;
  border: 1px solid rgba(255,255,255,.12) !important;
}

/* чтобы не было ощущения “пустоты”: контентный блок ниже */
.content, #content{
  min-height: calc(100vh - 180px);
}

/* мобила */
@media (max-width: 520px){
  .brand__s{ display:none; }
  .card{ border-radius: 18px; }
  button, .btn{ width: 100%; }
  .tabs{ padding-bottom: env(safe-area-inset-bottom); }
}
```


### FILE: /opt/logos/www/wallet_premium/ui.css

```css
:root{
  --bg0:#070A12;
  --bg1:#0B1020;
  --txt:#EAF0FF;
  --mut:#98A3C7;

  --card: rgba(255,255,255,.06);
  --card2: rgba(255,255,255,.04);
  --stroke: rgba(255,255,255,.10);
  --stroke2: rgba(255,255,255,.14);

  --shadow: 0 18px 80px rgba(0,0,0,.55);
  --blur: blur(18px);

  --r16: 16px;
  --r20: 20px;
  --r24: 24px;

  --s8:8px; --s10:10px; --s12:12px; --s14:14px;
  --s16:16px; --s18:18px; --s20:20px; --s24:24px; --s28:28px;

  --accent: #4F7CFF;
  --accent2:#22C55E;
  --warn:#FBBF24;
  --bad:#F87171;

  --tabH: 74px;
  --maxW: 1120px;

  --font: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
}

:root[data-theme="light"]{
  --bg0:#F6F8FF;
  --bg1:#EEF2FF;
  --txt:#0C1222;
  --mut:#4B5563;
  --card: rgba(10,20,40,.06);
  --card2: rgba(10,20,40,.04);
  --stroke: rgba(10,20,40,.10);
  --stroke2: rgba(10,20,40,.14);
  --shadow: 0 20px 90px rgba(10,20,40,.14);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: var(--font);
  color: var(--txt);
  background: radial-gradient(1200px 700px at 20% 10%, rgba(79,124,255,.18), transparent 60%),
              radial-gradient(900px 600px at 80% 20%, rgba(34,197,94,.12), transparent 55%),
              linear-gradient(180deg, var(--bg0), var(--bg1));
  overflow-x:hidden;
}

/* Background */
.bg{position:fixed; inset:0; pointer-events:none; z-index:-1;}
.noise{
  position:absolute; inset:-40px;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='220' height='220'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='220' height='220' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
  opacity:.18;
  mix-blend-mode: overlay;
}
.glow{position:absolute; width:520px; height:520px; border-radius:999px; filter: blur(70px); opacity:.20;}
.g1{left:-120px; top:-120px; background: rgba(79,124,255,.85);}
.g2{right:-160px; top:60px; background: rgba(34,197,94,.75);}
.g3{left:35%; bottom:-220px; background: rgba(147,51,234,.60);}

/* Layout */
.wrap{max-width: var(--maxW); margin:0 auto; padding: 0 var(--s20);}
.topbar{
  position:sticky; top:0; z-index:20;
  backdrop-filter: var(--blur);
  background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0));
  border-bottom: 1px solid rgba(255,255,255,.06);
}
:root[data-theme="light"] .topbar{
  background: linear-gradient(180deg, rgba(255,255,255,.75), rgba(255,255,255,0));
  border-bottom: 1px solid rgba(10,20,40,.08);
}
.topbar .wrap{
  display:flex; align-items:center; justify-content:space-between;
  padding: 14px var(--s20);
}

.brand{display:flex; align-items:center; gap:12px;}
.logo{
  width:38px; height:38px; border-radius: 14px;
  background:
    radial-gradient(12px 12px at 30% 30%, rgba(255,255,255,.65), transparent 60%),
    radial-gradient(18px 18px at 70% 60%, rgba(79,124,255,.95), transparent 60%),
    linear-gradient(135deg, rgba(34,197,94,.35), rgba(147,51,234,.35));
  box-shadow: 0 10px 30px rgba(79,124,255,.18);
  border: 1px solid rgba(255,255,255,.12);
}
.brandTitle{font-weight: 800; letter-spacing:.2px;}
.brandSub{font-size: 12px; color: var(--mut); margin-top:2px;}

.topRight{display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;}
.pill{
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: var(--txt);
  padding: 8px 12px;
  border-radius: 999px;
  font-size: 12px;
  line-height: 1;
  box-shadow: 0 10px 40px rgba(0,0,0,.12);
}
:root[data-theme="light"] .pill{
  background: rgba(10,20,40,.06);
  border:1px solid rgba(10,20,40,.10);
  box-shadow: 0 10px 40px rgba(10,20,40,.08);
}
.pill.mono{font-family: var(--mono);}
.pill.btn{
  cursor:pointer;
  transition: transform .12s ease, background .12s ease, border-color .12s ease;
}
.pill.btn:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.18); background: rgba(255,255,255,.08);}

.main{padding: 18px 0 calc(var(--tabH) + 28px);}
.heroCard{
  border-radius: var(--r24);
  background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: var(--shadow);
  overflow:hidden;
}
:root[data-theme="light"] .heroCard{
  background: linear-gradient(180deg, rgba(10,20,40,.06), rgba(10,20,40,.03));
  border: 1px solid rgba(10,20,40,.10);
}
.heroHead{
  padding: 18px 18px 16px;
  display:flex; align-items:flex-start; justify-content:space-between; gap: 16px;
}
.h1{font-size: 28px; font-weight: 900; letter-spacing:.2px;}
.sub{margin-top:6px; font-size: 13px; color: var(--mut);}

.ridBox{
  min-width: 320px;
  max-width: 520px;
  border-radius: 18px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  padding: 12px 12px 10px;
}
:root[data-theme="light"] .ridBox{background: rgba(255,255,255,.55);}
.ridLabel{font-size:12px; color: var(--mut);}
.ridValue{
  margin-top:6px;
  font-family: var(--mono);
  font-size: 12px;
  word-break: break-all;
  opacity:.95;
}
.ridActions{margin-top:10px; display:flex; gap:8px; justify-content:flex-end;}
.btnSmall{
  cursor:pointer;
  border-radius: 12px;
  padding: 8px 10px;
  font-size: 12px;
  color: var(--txt);
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  transition: transform .12s ease, background .12s ease, border-color .12s ease;
}
.btnSmall:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.18); background: rgba(255,255,255,.09);}
.btnSmall.ghost{background: transparent;}

.content{margin-top: 16px;}
.grid{display:grid; grid-template-columns: 1fr; gap: 14px;}
@media (min-width: 900px){
  .grid.two{grid-template-columns: 1fr 1fr;}
}

.card{
  border-radius: var(--r20);
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  box-shadow: 0 16px 70px rgba(0,0,0,.25);
  overflow:hidden;
}
:root[data-theme="light"] .card{
  background: rgba(10,20,40,.05);
  border:1px solid rgba(10,20,40,.10);
  box-shadow: 0 16px 70px rgba(10,20,40,.10);
}
.cardIn{padding: 16px;}
.cardTitle{font-weight: 800; font-size: 14px;}
.cardSub{margin-top:6px; font-size: 12px; color: var(--mut);}

.row{display:flex; align-items:center; justify-content:space-between; gap: 12px; margin-top: 12px;}
.mono{font-family: var(--mono);}

.bigAmount{
  font-size: 34px;
  font-weight: 900;
  letter-spacing:.2px;
}
.badge{
  font-size: 12px;
  padding: 6px 10px;
  border-radius: 999px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: var(--mut);
}

.actions{
  display:flex; gap: 10px; flex-wrap:wrap;
  margin-top: 12px;
}
.btn{
  cursor:pointer;
  border-radius: 16px;
  padding: 12px 14px;
  font-weight: 800;
  font-size: 13px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: var(--txt);
  transition: transform .12s ease, background .12s ease, border-color .12s ease;
}
.btn:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.18); background: rgba(255,255,255,.09);}
.btn.primary{background: linear-gradient(135deg, rgba(79,124,255,.95), rgba(79,124,255,.55)); border-color: rgba(79,124,255,.70);}
.btn.success{background: linear-gradient(135deg, rgba(34,197,94,.95), rgba(34,197,94,.55)); border-color: rgba(34,197,94,.70);}
.btn.ghost{background: transparent;}
.btn.w100{width:100%}

.list{
  margin-top: 12px;
  border-radius: 16px;
  overflow:hidden;
  border:1px solid rgba(255,255,255,.08);
}
.item{
  display:flex; align-items:center; justify-content:space-between;
  padding: 12px 12px;
  border-top:1px solid rgba(255,255,255,.06);
  background: rgba(0,0,0,.14);
}
.item:first-child{border-top:none;}
:root[data-theme="light"] .item{background: rgba(255,255,255,.55);}
.itL{display:flex; align-items:center; gap: 10px;}
.coin{
  width: 34px; height: 34px; border-radius: 14px;
  border:1px solid rgba(255,255,255,.14);
  background: radial-gradient(10px 10px at 30% 30%, rgba(255,255,255,.55), transparent 65%),
              linear-gradient(135deg, rgba(79,124,255,.45), rgba(147,51,234,.35));
}
.sym{font-weight: 900;}
.name{font-size: 12px; color: var(--mut); margin-top:2px;}
.itR{text-align:right;}
.val{font-weight: 900;}
.small{font-size: 12px; color: var(--mut); margin-top:2px;}

.empty{
  margin-top: 10px;
  padding: 14px;
  border-radius: 16px;
  border:1px dashed rgba(255,255,255,.14);
  color: var(--mut);
}

/* Tabs */
.tabs{
  position:fixed; left:0; right:0; bottom:0;
  height: var(--tabH);
  display:flex; gap:10px;
  padding: 10px 12px;
  backdrop-filter: var(--blur);
  background: rgba(0,0,0,.32);
  border-top: 1px solid rgba(255,255,255,.06);
  z-index: 30;
}
:root[data-theme="light"] .tabs{
  background: rgba(255,255,255,.75);
  border-top: 1px solid rgba(10,20,40,.08);
}
.tab{
  flex:1;
  cursor:pointer;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  color: var(--txt);
  padding: 10px 6px;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  gap: 6px;
  transition: transform .12s ease, background .12s ease, border-color .12s ease;
}
.tab:hover{transform: translateY(-1px); border-color: rgba(255,255,255,.16); background: rgba(255,255,255,.08);}
.tab.active{
  background: linear-gradient(135deg, rgba(79,124,255,.35), rgba(34,197,94,.16));
  border-color: rgba(79,124,255,.26);
}
.ico{opacity:.95; font-size: 14px;}
.t{font-size: 12px; font-weight: 800; opacity:.95;}

/* Toast */
.toast{
  position:fixed; left:50%; transform:translateX(-50%);
  bottom: calc(var(--tabH) + 16px);
  padding: 10px 14px;
  border-radius: 999px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(0,0,0,.35);
  backdrop-filter: var(--blur);
  color: var(--txt);
  font-size: 13px;
  opacity:0; pointer-events:none;
  transition: opacity .18s ease, transform .18s ease;
  z-index: 40;
}
.toast.show{opacity:1; transform:translateX(-50%) translateY(-2px);}

/* Modal */
.modal{position:fixed; inset:0; display:none; z-index:50;}
.modal[aria-hidden="false"]{display:block;}
.modalBack{position:absolute; inset:0; background: rgba(0,0,0,.55);}
.modalCard{
  position:absolute; left:50%; top:50%;
  transform: translate(-50%,-50%);
  width: min(560px, calc(100vw - 26px));
  border-radius: 22px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(10,14,24,.78);
  backdrop-filter: var(--blur);
  box-shadow: 0 30px 120px rgba(0,0,0,.65);
  overflow:hidden;
}
:root[data-theme="light"] .modalCard{background: rgba(255,255,255,.92);}
.modalTop{
  display:flex; align-items:center; justify-content:space-between;
  padding: 14px 14px;
  border-bottom:1px solid rgba(255,255,255,.08);
}
.modalTitle{font-weight: 900;}
.modalClose{
  cursor:pointer;
  width: 34px; height: 34px;
  border-radius: 12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: var(--txt);
  font-size: 18px;
}
.modalBody{padding: 14px;}
.modalFoot{padding: 0 14px 14px; display:flex; gap:10px; justify-content:flex-end;}

.input{
  width:100%;
  border-radius: 16px;
  padding: 12px 12px;
  border:1px solid rgba(255,255,255,.12);
  background: rgba(255,255,255,.06);
  color: var(--txt);
  outline:none;
  font-size: 13px;
}
.input::placeholder{color: rgba(152,163,199,.75);}
.label{font-size: 12px; color: var(--mut); margin: 10px 0 6px;}
.hr{height:1px; background: rgba(255,255,255,.08); margin: 12px 0;}

/* =========================
   PREMIUM V2 OVERRIDES
   ========================= */

/* softer, richer background motion */
@keyframes logosFloat {
  from { transform: translate3d(0,0,0) scale(1); opacity:.20; }
  to   { transform: translate3d(0,-18px,0) scale(1.03); opacity:.24; }
}
.glow{ animation: logosFloat 18s ease-in-out infinite alternate; }
.g2{ animation-duration: 22s; }
.g3{ animation-duration: 26s; }

.topbar{
  border-bottom: 1px solid rgba(255,255,255,.07);
}
:root[data-theme="light"] .topbar{
  border-bottom: 1px solid rgba(10,20,40,.09);
}

.heroCard, .card, .modalCard{
  position: relative;
}

/* premium gradient border */
.heroCard::before, .card::before, .modalCard::before{
  content:"";
  position:absolute; inset:0;
  border-radius: inherit;
  padding: 1px;
  background: linear-gradient(135deg,
    rgba(255,255,255,.18),
    rgba(79,124,255,.18),
    rgba(34,197,94,.14),
    rgba(255,255,255,.10)
  );
  -webkit-mask: linear-gradient(#000 0 0) content-box, linear-gradient(#000 0 0);
  -webkit-mask-composite: xor;
  mask-composite: exclude;
  pointer-events:none;
  opacity:.55;
}

.heroCard{
  background:
    radial-gradient(900px 420px at 20% 0%, rgba(79,124,255,.16), transparent 55%),
    radial-gradient(900px 420px at 80% 0%, rgba(34,197,94,.12), transparent 55%),
    linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
}

.card{
  background:
    radial-gradient(680px 340px at 15% 0%, rgba(255,255,255,.06), transparent 60%),
    rgba(255,255,255,.06);
}

:root[data-theme="light"] .heroCard{
  background:
    radial-gradient(900px 420px at 20% 0%, rgba(79,124,255,.11), transparent 55%),
    radial-gradient(900px 420px at 80% 0%, rgba(34,197,94,.10), transparent 55%),
    linear-gradient(180deg, rgba(10,20,40,.06), rgba(10,20,40,.03));
}

/* typography tighter */
.h1{ font-size: 30px; letter-spacing:.15px; }
.sub{ font-size: 13px; line-height: 1.35; }

/* RID box more premium */
.ridBox{
  background: rgba(0,0,0,.22);
  border: 1px solid rgba(255,255,255,.10);
  box-shadow: 0 18px 70px rgba(0,0,0,.35);
}
:root[data-theme="light"] .ridBox{
  background: rgba(255,255,255,.70);
  box-shadow: 0 18px 70px rgba(10,20,40,.10);
}

/* buttons: consistent height, better shine */
.btn, .btnSmall{
  letter-spacing: .15px;
}
.btn{
  padding: 12px 16px;
  border-radius: 16px;
  box-shadow: 0 14px 50px rgba(0,0,0,.18);
}
.btn.primary{
  background: linear-gradient(135deg, rgba(79,124,255,1), rgba(79,124,255,.55));
  box-shadow: 0 18px 60px rgba(79,124,255,.18);
}
.btn.success{
  background: linear-gradient(135deg, rgba(34,197,94,1), rgba(34,197,94,.55));
  box-shadow: 0 18px 60px rgba(34,197,94,.16);
}
.btn.ghost{
  background: rgba(255,255,255,.04);
}
.btn:hover{ background: rgba(255,255,255,.10); }
.btn.primary:hover{ filter: brightness(1.03); }
.btn.success:hover{ filter: brightness(1.03); }

/* empty state: remove dashed, make it premium block */
.empty{
  border: 1px solid rgba(255,255,255,.10);
  border-radius: 16px;
  background: rgba(255,255,255,.05);
  color: rgba(152,163,199,.95);
}

/* tabs: safe-area + tighter premium feel */
.tabs{
  padding-bottom: calc(10px + env(safe-area-inset-bottom));
  height: calc(var(--tabH) + env(safe-area-inset-bottom));
  background: rgba(0,0,0,.42);
}
:root[data-theme="light"] .tabs{
  background: rgba(255,255,255,.86);
}

.tab{
  border-radius: 18px;
}
.tab.active{
  background: linear-gradient(135deg, rgba(79,124,255,.40), rgba(34,197,94,.18));
  box-shadow: 0 18px 60px rgba(0,0,0,.22);
}

/* responsive: phone/tablet */
@media (max-width: 980px){
  .heroHead{ flex-direction: column; align-items: stretch; }
  .ridBox{ min-width: 0; width: 100%; }
  .topbar .wrap{ gap: 10px; }
  .topRight{ justify-content: flex-start; }
}

@media (max-width: 520px){
  .wrap{ padding: 0 14px; }
  .h1{ font-size: 24px; }
  .pill{ padding: 7px 10px; font-size: 11px; }
  .btn{ width: 100%; justify-content:center; }
  .actions{ gap: 8px; }
  .tabs{ gap: 8px; }
  .t{ font-size: 11px; }
}
```


## FRONTEND ROOT: /var/www/logos/wallet

### TREE (depth 3)

```text
js/api.js
js/core.js
js/vault_bridge.js
js/app.js
js/vault.js
js/app_wallet.js
js/unlock.js
index.html
css/styles.css
app.js
wallet.js
wallet.css
login.html
app.v3.js
app.html
app.v2.js
auth.js
ping.html
staking.js
```


### FILE: /var/www/logos/wallet/app.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c;position:sticky;top:0}
    h1{font-size:18px;margin:0}
    main{max-width:1024px;margin:24px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    input,button,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    small{opacity:.8}
  </style>
</head>
<body>
<header>
  <h1>LOGOS Wallet — Кошелёк</h1>
</header>
<main>
  <section>
    <div class="grid">
      <div>
        <h3>Твой RID / Публичный ключ</h3>
        <textarea id="pub" class="mono" rows="4" readonly></textarea>
        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="btn-lock" class="secondary">Выйти (заблокировать)</button>
          <button id="btn-nonce" class="secondary">Получить nonce</button>
        </div>
        <p><small>Ключ в памяти. Закроешь вкладку — понадобится пароль на странице входа.</small></p>
      </div>
      <div>
        <h3>Баланс</h3>
        <div class="grid">
          <div><label>RID</label><input id="rid-balance" class="mono" placeholder="RID (base58)"/></div>
          <div><label>&nbsp;</label><button id="btn-balance">Показать баланс</button></div>
        </div>
        <pre id="out-balance" class="mono" style="margin-top:12px"></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>Подпись и отправка (batch)</h3>
    <div class="grid">
      <div><label>Получатель (RID)</label><input id="to" class="mono" placeholder="RID получателя"/></div>
      <div><label>Сумма (LGN)</label><input id="amount" type="number" min="1" step="1" value="1"/></div>
    </div>
    <div class="grid">
      <div><label>Nonce</label><input id="nonce" type="number" min="1" step="1" placeholder="нажми 'Получить nonce'"/></div>
      <div><label>&nbsp;</label><button id="btn-send">Подписать и отправить</button></div>
    </div>
    <pre id="out-send" class="mono" style="margin-top:12px"></pre>
  </section>

  <section>
    <h3>Мост rToken (депозит, демо)</h3>
    <div class="grid">
      <div><label>ext_txid</label><input id="ext" class="mono" placeholder="например eth_txid_0xabc"/></div>
      <div><label>&nbsp;</label><button id="btn-deposit">Deposit rLGN</button></div>
    </div>
    <pre id="out-bridge" class="mono" style="margin-top:12px"></pre>
  </section>
</main>
<script src="./app.js?v=20250906_01" defer></script>
</body>
</html>
```


### FILE: /var/www/logos/wallet/app.js

```js
// === БАЗА ===
const API = location.origin + '/api/';     // ГАРАНТИРОВАННЫЙ префикс
const enc = new TextEncoder();

const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));

function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }

// === НАДЁЖНЫЙ fetchJSON: ВСЕГДА JSON (даже при ошибке) ===
async function fetchJSON(url, opts) {
  const r = await fetch(url, opts);
  const text = await r.text();
  try {
    const json = text ? JSON.parse(text) : {};
    if (!r.ok) throw json;
    return json;
  } catch(e) {
    // если прилетел текст/HTML — упакуем в JSON с сообщением
    throw { ok:false, error: (typeof e==='object' && e.error) ? e.error : (text || 'not json') };
  }
}

// === КЛЮЧИ/SESSION ===
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('./login.html'); throw new Error('locked'); }

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey = await deriveKey(pass, new Uint8Array(meta.salt));
  const pkcs8  = await aesDecrypt(aesKey, new Uint8Array(meta.iv_priv), new Uint8Array(meta.priv));
  const pubraw = await aesDecrypt(aesKey, new Uint8Array(meta.iv_pub),  new Uint8Array(meta.pub));
  const privateKey = await crypto.subtle.importKey('pkcs8', pkcs8, {name:'Ed25519'}, false, ['sign']);
  const publicKey  = await crypto.subtle.importKey('raw',   pubraw, {name:'Ed25519'}, true,  ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}

let KEYS=null, META=null;
(async ()=>{
  META = await idbGet('acct:'+RID);
  if (!META) { sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS = await importKey(PASS, META);
  $('#pub') && ($('#pub').value = `RID: ${RID}\npub: ${KEYS.pub_hex}`);
  $('#rid-balance') && ($('#rid-balance').value = RID);
})();

// === КАНОНИКА/ПОДПИСЬ ===
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(privateKey, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', privateKey, msg);
  return toHex(sig);
}

// === API HELPERS ===
async function getBalance(rid){ return fetchJSON(`${API}balance/${encodeURIComponent(rid)}`); }
async function submitTxBatch(txs){
  return fetchJSON(`${API}submit_tx_batch`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ txs })
  });
}
async function stakeDelegate(delegator, validator, amount){
  return fetchJSON(`${API}stake/delegate`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ delegator, validator, amount:Number(amount) })
  });
}
async function stakeUndelegate(delegator, validator, amount){
  return fetchJSON(`${API}stake/undelegate`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ delegator, validator, amount:Number(amount) })
  });
}
async function stakeClaim(delegator, validator){
  return fetchJSON(`${API}stake/claim`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ delegator, validator, amount:0 })
  });
}
async function stakeMy(rid){ return fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`); }

// === UI ===
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid = ($('#rid-balance')?.value || RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ alert(`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to     = $('#to')?.value.trim();
    const amount = $('#amount')?.value.trim();
    const nonce  = $('#nonce')?.value.trim();
    if (!to || !amount || !nonce) throw {error:'fill to/amount/nonce'};
    const ch = await canonHex(RID, to, amount, nonce, KEYS.pub_hex);
    const sigHex = await signCanon(KEYS.privateKey, ch);
    const tx = { from_rid:RID, to_rid:to, amount:Number(amount), nonce:Number(nonce), pubkey_hex:KEYS.pub_hex, sig_hex:sigHex };
    const res = await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent = JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent = `ERR: ${JSON.stringify(e)}`); }
});

$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')?.value || RID).trim();
    const amount = ($('#stake-amount')?.value || '').trim() || ($('#amount')?.value || '').trim();
    const res = await stakeDelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')?.value || RID).trim();
    const amount = ($('#stake-amount')?.value || '').trim() || ($('#amount')?.value || '').trim();
    const res = await stakeUndelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')?.value || RID).trim();
    const res = await stakeClaim(RID, val);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{
    const res = await stakeMy(RID);
    $('#out-my') && ($('#out-my').textContent = JSON.stringify(res));
  }catch(e){ $('#out-my') && ($('#out-my').textContent = `ERR: ${JSON.stringify(e)}`); }
});

// кнопка NONCE (если есть)
$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); $('#nonce') && ($('#nonce').value = String(j.nonce||0)); }
  catch(e){ alert(`ERR: ${JSON.stringify(e)}`); }
});
```


### FILE: /var/www/logos/wallet/app.v2.js

```js
// == CONFIG ==
const API = location.origin + '/api/';
const enc = new TextEncoder();

// == utils ==
const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));
function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }

// == robust fetch: always JSON ==
async function fetchJSON(url, opts){
  try{
    const r = await fetch(url, opts);
    const text = await r.text();
    try {
      const js = text ? JSON.parse(text) : {};
      if(!r.ok) throw js;
      return js;
    } catch(parseErr){
      throw { ok:false, error:(text||'not json'), status:r.status||0 };
    }
  }catch(netErr){
    throw { ok:false, error:(netErr?.message||'network error') };
  }
}

// == session/keys ==
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('./login.html'); throw new Error('locked'); }

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8 =await aesDecrypt(aesKey,new Uint8Array(meta.iv_priv),new Uint8Array(meta.priv));
  const pubraw=await aesDecrypt(aesKey,new Uint8Array(meta.iv_pub), new Uint8Array(meta.pub));
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},false,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',  pubraw,{name:'Ed25519'},true, ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}
let KEYS=null, META=null;
(async()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS, META);
  $('#pub') && ($('#pub').value=`RID: ${RID}\npub: ${KEYS.pub_hex}`);
  ($('#rid-balance')||{}).value = RID;
})();

// == canonical/sign ==
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(priv, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', priv, msg);
  return toHex(sig);
}

// == API wrappers ==
async function getBalance(rid){ return fetchJSON(`${API}balance/${encodeURIComponent(rid)}`); }
async function submitTxBatch(txs){
  return fetchJSON(`${API}submit_tx_batch`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ txs }) });
}
async function stakeDelegate(delegator,validator,amount){
  return fetchJSON(`${API}stake/delegate`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({delegator,validator,amount:Number(amount)}) });
}
async function stakeUndelegate(delegator,validator,amount){
  return fetchJSON(`${API}stake/undelegate`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({delegator,validator,amount:Number(amount)}) });
}
async function stakeClaim(delegator,validator){
  return fetchJSON(`${API}stake/claim`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({delegator,validator,amount:0}) });
}
async function stakeMy(rid){ return fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`); }

// == UI handlers ==
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid=($('#rid-balance')?.value||RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ $('#out-balance') && ($('#out-balance').textContent=`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to = ($('#to')||$('#rid-to'))?.value.trim();
    const amount = ($('#amount')||$('#sum')||$('#stake-amount'))?.value.trim();
    const nonce  = ($('#nonce')||$('#tx-nonce'))?.value.trim();
    if(!to||!amount||!nonce) throw {error:'fill to/amount/nonce'};
    const ch = await canonHex(RID, to, amount, nonce, KEYS.pub_hex);
    const sigHex = await signCanon(KEYS.privateKey, ch);
    const tx = { from_rid:RID, to_rid:to, amount:Number(amount), nonce:Number(nonce), pubkey_hex:KEYS.pub_hex, sig_hex:sigHex };
    const res = await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent = JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent = `ERR: ${JSON.stringify(e)}`); }
});

$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')||$('#val')||$('#rid-validator'))?.value.trim() || RID;
    const amount = ($('#stake-amount')||$('#amount')||$('#sum'))?.value.trim();
    const res = await stakeDelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')||$('#val')||$('#rid-validator'))?.value.trim() || RID;
    const amount = ($('#stake-amount')||$('#amount')||$('#sum'))?.value.trim();
    const res = await stakeUndelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')||$('#val')||$('#rid-validator'))?.value.trim() || RID;
    const res = await stakeClaim(RID, val);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{ const res = await stakeMy(RID); $('#out-my') && ($('#out-my').textContent = JSON.stringify(res)); }
  catch(e){ $('#out-my') && ($('#out-my').textContent = `ERR: ${JSON.stringify(e)}`); }
});

// nonce helper
$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); ($('#nonce')||$('#tx-nonce')) && ((($('#nonce')||$('#tx-nonce')).value)=String(j.nonce||0)); }
  catch(e){ /* ignore */ }
});
```


### FILE: /var/www/logos/wallet/app.v3.js

```js
const API = location.origin + '/api/';
const enc = new TextEncoder();

// utils
const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));
function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }

// robust fetch → всегда JSON
async function fetchJSON(url, opts){
  const r = await fetch(url, opts);
  const text = await r.text();
  try {
    const js = text ? JSON.parse(text) : {};
    if (!r.ok) throw js;
    return js;
  } catch(e) {
    throw { ok:false, error:(typeof e==='object'&&e.error)?e.error:(text||'not json'), status:r.status||0 };
  }
}

// session/keys
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('./login.html'); throw new Error('locked'); }

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8 =await aesDecrypt(aesKey,new Uint8Array(meta.iv_priv),new Uint8Array(meta.priv));
  const pubraw=await aesDecrypt(aesKey,new Uint8Array(meta.iv_pub), new Uint8Array(meta.pub));
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},false,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',  pubraw,{name:'Ed25519'},true, ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}
let KEYS=null, META=null;
(async()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS, META);
  const pubEl=$('#pub'); if(pubEl) pubEl.value=`RID: ${RID}\npub: ${KEYS.pub_hex}`;
  const rb=$('#rid-balance'); if(rb) rb.value=RID;
})();

// canonical+sign
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(priv, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', priv, msg);
  return toHex(sig);
}

// API wrappers
const getBalance = (rid)=>fetchJSON(`${API}balance/${encodeURIComponent(rid)}`);
const submitTxBatch = (txs)=>fetchJSON(`${API}submit_tx_batch`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({txs})});
const stakeDelegate   = (delegator,validator,amount)=>fetchJSON(`${API}stake/delegate`,  {method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeUndelegate = (delegator,validator,amount)=>fetchJSON(`${API}stake/undelegate`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeClaim      = (delegator,validator)=>fetchJSON(`${API}stake/claim`,            {method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:0})});
const stakeMy         = (rid)=>fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`);

// UI handlers
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid=($('#rid-balance')?.value||RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ $('#out-balance') && ($('#out-balance').textContent=`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); const n=($('#nonce')); if(n) n.value=String(j.nonce||0); } catch(e){}
});

$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to=$('#to')?.value.trim(); const amount=$('#amount')?.value.trim(); const nonce=$('#nonce')?.value.trim();
    if(!to||!amount||!nonce) throw {error:'fill to/amount/nonce'};
    const ch=await canonHex(RID,to,amount,nonce,KEYS.pub_hex);
    const sig=await signCanon(KEYS.privateKey,ch);
    const tx={from_rid:RID,to_rid:to,amount:Number(amount),nonce:Number(nonce),pubkey_hex:KEYS.pub_hex,sig_hex:sig};
    const res=await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent=JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent=`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim(); const amount=$('#stake-amount')?.value.trim();
    const res=await stakeDelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim(); const amount=$('#stake-amount')?.value.trim();
    const res=await stakeUndelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const res=await stakeClaim(RID,val);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{ const res=await stakeMy(RID); $('#out-my') && ($('#out-my').textContent=JSON.stringify(res)); }
  catch(e){ $('#out-my') && ($('#out-my').textContent=`ERR: ${JSON.stringify(e)}`); }
});
```


### FILE: /var/www/logos/wallet/auth.js

```js
// AUTH v3: RID + пароль. Сохраняем под "acct:<RID>".
// Фичи: авто-подстановка last_rid, кликабельный список, чистка всех пробелов/переносов в RID.

const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const $ = s => document.querySelector(s);
const out = msg => { const el=$('#out'); if(el) el.textContent=String(msg); };

function normRid(s){ return (s||'').replace(/\s+/g,'').trim(); } // убираем все пробелы/переносы

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!crypto || !crypto.subtle) throw new Error('WebCrypto недоступен');
}

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};
const idbSet=async (k,v)=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).put(v,k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};
const idbDel=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).delete(k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){
  const keyMat=await crypto.subtle.importKey('raw',enc.encode(pass),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
}
async function aesEncrypt(aesKey,data){const iv=crypto.getRandomValues(new Uint8Array(12));const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,data);return{iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))}}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}

function b58(bytes){
  const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const hex=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');
  let x=BigInt('0x'+hex), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } return out||'1';
}

async function addAccount(rid){ const list=(await idbGet('accounts'))||[]; if(!list.includes(rid)){ list.push(rid); await idbSet('accounts',list); } }
async function listAccounts(){ return (await idbGet('accounts'))||[]; }

async function createAccount(pass){
  ensureEnv();
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  out('Создаём ключ…');
  const kp=await crypto.subtle.generateKey({name:'Ed25519'},true,['sign','verify']);
  const rawPub=new Uint8Array(await crypto.subtle.exportKey('raw',kp.publicKey));
  const rid=b58(rawPub);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey('pkcs8',kp.privateKey));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const aes=await deriveKey(pass,salt);
  const {iv,ct}=await aesEncrypt(aes,pkcs8);
  const meta={rid,pub:Array.from(rawPub),salt:Array.from(salt),iv,priv:ct};

  await idbSet('acct:'+rid,meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  out('RID создан: '+rid+' → вход…');
  location.href='./app.html';
}

async function loginAccount(rid, pass){
  ensureEnv();
  rid = normRid(rid);
  if(!rid) throw new Error('Укажи RID');
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  const meta=await idbGet('acct:'+rid);
  if(!meta){
    const list=await listAccounts();
    throw new Error('RID не найден на этом устройстве. Сохранённые RID:\n'+(list.length?list.join('\n'):'—'));
  }
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  try{ await aesDecrypt(aes,meta.iv,meta.priv); } catch(e){ throw new Error('Неверный пароль'); }

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  await idbSet('last_rid', rid);
  out('Вход…'); location.href='./app.html';
}

async function resetAll(){
  const list=await listAccounts();
  for(const rid of list){ await idbDel('acct:'+rid); }
  await idbDel('accounts'); await idbDel('last_rid');
  sessionStorage.clear();
  out('Все аккаунты удалены (DEV).');
}

function renderRidList(list){
  const wrap=$('#listWrap'), ul=$('#ridList'); ul.innerHTML='';
  if(!list.length){ wrap.style.display='block'; ul.innerHTML='<li>— пусто —</li>'; return; }
  wrap.style.display='block';
  list.forEach(rid=>{
    const li=document.createElement('li'); li.textContent=rid;
    li.addEventListener('click', ()=>{ $('#loginRid').value=rid; out('RID подставлен'); });
    ul.appendChild(li);
  });
}

// авто-подстановка last_rid при загрузке
(async ()=>{
  const last=await idbGet('last_rid'); if(last){ $('#loginRid').value=last; }
})();

// wire UI
$('#btn-login').addEventListener('click', async ()=>{
  const rid=$('#loginRid').value; const pass=$('#pass').value;
  try{ await loginAccount(rid,pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-create').addEventListener('click', async ()=>{
  const pass=$('#pass').value;
  try{ await createAccount(pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-list').addEventListener('click', async ()=>{
  try{ renderRidList(await listAccounts()); }catch(e){ out('ERR: '+e); }
});
$('#btn-reset').addEventListener('click', resetAll);
```


### FILE: /var/www/logos/wallet/css/styles.css

```css
:root{color-scheme:dark}
*{box-sizing:border-box}
body{margin:0;background:#0b1016;color:#e7eef7;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
.wrap{max-width:1100px;margin:24px auto;padding:0 16px}
.card{background:#0f1723;border:1px solid #243048;border-radius:16px;padding:18px;margin:12px 0}
h1,h2,h3{margin:0 0 10px}
.muted{color:#9fb2c9}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.grid{display:grid;gap:12px}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:1fr 1fr 1fr}
.mt10{margin-top:10px}
@media(max-width:980px){.cols-2,.cols-3{grid-template-columns:1fr}}
input,button,textarea{border-radius:12px;border:1px solid #28344c;background:#0d1420;color:#e7eef7;padding:12px;width:100%}
textarea{min-height:100px;resize:vertical}
input:focus,textarea:focus{outline:none;border-color:#3a70ff;box-shadow:0 0 0 2px #3a70ff26}
button{background:#3366ff;border:none;cursor:pointer;transition:.15s}
button.secondary{background:#1a2333}
button.ghost{background:#0d1420;border:1px dashed #2a3a56}
.badge{background:#141e2d;border:1px solid #2a3a56;border-radius:999px;padding:6px 10px;font-size:12px}
.kpi{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace;word-break:break-all}
.table{width:100%;border-collapse:collapse}
.table th,.table td{border-bottom:1px solid #1a2436;padding:10px 8px;text-align:left;font-size:13px}
.table th{color:#9fb2c9;font-weight:600}
.scroll{overflow:auto}
.toast{position:fixed;right:16px;bottom:16px;display:none;background:#0e1520;border:1px solid #20406f;color:#bfe0ff;padding:12px 14px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);max-width:80%}
.toast.show{display:block}

/* Secure overlay */
#lockOverlay{position:fixed;inset:0;background:rgba(11,16,22,.96);backdrop-filter:saturate(120%) blur(2px);display:flex;align-items:center;justify-content:center;z-index:9999}
#lockCard{width:min(620px,92%);background:#0f1723;border:1px solid #243048;border-radius:18px;padding:18px}
#brand{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
#phish{background:#0c1420;border:1px solid #2a3a56;border-radius:12px;padding:10px;font-size:12px;color:#9fb2c9}
.hidden{display:none}
```


### FILE: /var/www/logos/wallet/index.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="./css/styles.css?v=1757930528">
</head>
<body>
<div class="wrap">
  <h1>LOGOS Wallet</h1>

  <!-- App (показывается после unlock) -->
  <section id="viewApp" class="card hidden">
    <h3>Кошелёк разблокирован</h3>
    <div class="kpi">
      <span class="badge">RID: <b class="mono" id="kpiRid">—</b></span>
      <span class="badge">balance: <b id="kpiBal">—</b></span>
      <span class="badge">nonce: <b id="kpiNonce">—</b></span>
      <span class="badge">head: <b id="kpiHead">—</b></span>
      <span class="badge">delegated: <b id="kpiDelegated">—</b></span>
      <span class="badge">entries: <b id="kpiEntries">—</b></span>
      <span class="badge">claimable: <b id="kpiClaimable">—</b></span>
    </div>
  </section>

  <section id="viewSend" class="card hidden">
    <h3>Отправка</h3>
    <div class="grid cols-2">
      <div><label>RID получателя</label><input id="sendTo" class="mono" placeholder="RID"/></div>
      <div><label>Сумма</label><input id="sendAmount" type="number" min="1" step="1" placeholder="amount (u64)"/></div>
    </div>
    <div class="row mt10"><button id="btnSendTx">Отправить</button></div>
  </section>

  <section id="viewStake" class="card hidden">
    <h3>Стейкинг</h3>
    <div class="grid cols-3">
      <div><label>RID валидатора (SELF = свой RID)</label><input id="stakeValidator" class="mono" readonly/></div>
      <div><label>Сумма</label><input id="stakeAmount" type="number" min="1" step="1" placeholder="amount (u64)"/></div>
      <div class="row" style="align-items:end">
        <button id="btnStakeDel">Delegate</button>
        <button id="btnStakeUn" class="secondary">Undelegate</button>
        <button id="btnStakeClaim" class="secondary">Claim</button>
      </div>
    </div>
  </section>

  <section id="viewHistory" class="card hidden">
    <h3>История</h3>
    <div class="scroll">
      <table class="table">
        <thead><tr><th>type</th><th>counterparty</th><th>amount</th><th>nonce</th><th>height</th><th>tx</th></tr></thead>
        <tbody id="histBody"></tbody>
      </table>
    </div>
  </section>
</div>

<!-- Secure Unlock overlay -->
<div id="lockOverlay">
  <div id="lockCard">
    <div id="brand">
      <div><b>LOGOS Wallet — Secure Unlock</b></div>
      <div class="badge mono" id="rpHost">—</div>
    </div>
    <div id="phish">Проверь домен и значок 🔒 TLS. Никому не сообщай пароль.</div>

    <!-- Лэндинг -->
    <div id="viewLanding">
      <p class="muted">Выберите действие:</p>
      <div class="row">
        <button id="goCreate">Создать новый</button>
        <button id="goImport" class="secondary">Импортировать</button>
        <button id="goUnlock" class="ghost">Разблокировать</button>
      </div>
    </div>

    <!-- Создать: пароль -->
    <div id="viewCreatePwd" class="hidden mt10">
      <h3>Создать пароль</h3>
      <div class="grid cols-2">
        <div><label>Пароль</label><input id="newPwd1" type="password" autocomplete="new-password" placeholder="(≥8)"/></div>
        <div><label>Повтор</label><input id="newPwd2" type="password" autocomplete="new-password" placeholder="повтор"/></div>
      </div>
      <div class="row mt10"><button id="createNext">Далее</button><button id="back1" class="ghost">Назад</button></div>
    </div>

    <!-- Создать: бэкап -->
    <div id="viewBackup" class="hidden mt10">
      <h3>Резервный ключ</h3>
      <p class="muted">Сохраните PKCS8 Base64 (как seed). Без него восстановление невозможно.</p>
      <textarea id="backupArea" class="mono" readonly></textarea>
      <label class="row mt10" style="gap:8px;align-items:center"><input type="checkbox" id="chkSaved"/> Я записал ключ</label>
      <div class="row mt10"><button id="finishCreate" disabled>Завершить и разблокировать</button><button id="back2" class="ghost">Назад</button></div>
    </div>

    <!-- Импорт -->
    <div id="viewImport" class="hidden mt10">
      <h3>Импорт</h3>
      <label>PKCS8 Base64</label><textarea id="impKey" class="mono" placeholder="----- base64 -----"></textarea>
      <div class="grid cols-2 mt10">
        <div><label>Пароль</label><input id="impPwd1" type="password" autocomplete="new-password" placeholder="(≥8)"/></div>
        <div><label>Повтор</label><input id="impPwd2" type="password" autocomplete="new-password" placeholder="повтор"/></div>
      </div>
      <div class="row mt10"><button id="doImport">Импортировать и разблокировать</button><button id="back3" class="ghost">Назад</button></div>
    </div>

    <!-- Разблокировать -->
    <div id="viewUnlock" class="hidden mt10">
      <h3>Разблокировать</h3>
      <label>Пароль</label><input id="unPwd" type="password" autocomplete="current-password" placeholder="Пароль"/>
      <div class="row mt10"><button id="btnUnlock">Разблокировать</button><button id="btnReset" class="secondary">Сбросить</button></div>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<!-- Модули -->
<script type="module" src="./js/core.js?v=1757930528"></script>
<script type="module" src="./js/vault.js?v=1757930528"></script>
<script type="module" src="./js/unlock.js?v=1757930528"></script>
<script type="module" src="./js/app.js?v=1757930528"></script>
</body>
</html>
```


### FILE: /var/www/logos/wallet/js/api.js

```js
export const API = "/api";

export async function apiGet(p){
  const r = await fetch(API+p);
  if(!r.ok) throw new Error(`GET ${p} -> ${r.status}`);
  return r.json();
}
export async function apiPost(p,b){
  const r = await fetch(API+p,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(b)});
  if(!r.ok){ const t=await r.text().catch(()=> ""); throw new Error(`POST ${p} -> ${r.status} ${t}`); }
  return r.json();
}
```


### FILE: /var/www/logos/wallet/js/app.js

```js
import { $, toast, canon, short, fmt } from "./core.js";
import { apiGet, apiPost } from "./core.js";   // API в core.js
import { currentRID, ensureSessionKey, signEd25519 } from "./vault.js";

async function loadPassport(){
  const rid = currentRID(); if(!rid){ toast("RID отсутствует"); return; }
  const [p,s,h] = await Promise.allSettled([
    apiGet(`/profile/${rid}`),
    apiGet(`/stake/summary/${rid}`),
    apiGet(`/history/${rid}?limit=50`)
  ]);
  const prof=p.status==="fulfilled"?p.value:{}, sum=s.status==="fulfilled"?s.value:{}, items=h.status==="fulfilled"?(h.value.items||[]):[];
  $('#kpiRid').textContent = rid;
  $('#kpiBal').textContent = fmt(prof.balance??0);
  $('#kpiNonce').textContent = (prof.nonce&&prof.nonce.next)??"-";
  $('#kpiHead').textContent = prof.head??"-";
  $('#kpiDelegated').textContent = fmt(sum.delegated??0);
  $('#kpiEntries').textContent  = fmt(sum.entries??0);
  $('#kpiClaimable').textContent= fmt(sum.claimable??0);

  $('#stakeValidator').value = rid;
  const tb=$('#histBody'); tb.innerHTML="";
  for(const it of items){
    const e=it.evt||{}; const cp=e.dir==="out"?e.to:(e.dir==="in"?e.from:(e.rid||"-"));
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${e.type||"transfer"}</td><td class="mono">${short(cp,24)}</td><td>${fmt(e.amount??0)}</td><td>${e.nonce??"-"}</td><td>${e.height??"-"}</td><td class="mono">${short(e.tx,28)}</td>`;
    tb.appendChild(tr);
  }
}

async function sendTx(){
  const rid=currentRID(); const to=($('#sendTo').value||"").trim(); const amount=Number($('#sendAmount').value||"0");
  if(!rid){ toast("Разблокируйте кошелёк"); return; }
  if(!to||!amount){ toast("RID/сумма?"); return;}
  const nn=await apiGet(`/nonce/${rid}`); const nonce=nn.next;
  await ensureSessionKey();
  const sig=await signEd25519(canon(rid,to,amount,nonce));
  const b=$('#btnSendTx'); const orig=b.textContent; b.disabled=true; b.textContent="Отправляем…";
  try{ const r=await apiPost(`/submit_tx`,{from:rid,to,amount,nonce,sig}); toast(r?.status==="queued"?"Tx отправлена":"Отправлено"); await loadPassport(); }
  catch(e){ toast("Ошибка: "+e.message); }
  finally{ b.disabled=false; b.textContent=orig; }
}
async function stakeDel(){ const rid=currentRID(); const a=Number($('#stakeAmount').value||"0"); if(!rid||!a){toast("RID/сумма?");return;} const r=await apiPost(`/stake/delegate`,{validator:rid,amount:a}); toast(r.ok?"Delegated":"Delegate failed"); await loadPassport(); }
async function stakeUn(){  const rid=currentRID(); const a=Number($('#stakeAmount').value||"0"); if(!rid||!a){toast("RID/сумма?");return;} const r=await apiPost(`/stake/undelegate`,{validator:rid,amount:a}); toast(r.ok?"Undelegated":"Undelegate failed"); await loadPassport(); }
async function stakeClaim(){const rid=currentRID(); if(!rid){toast("RID?");return;} const r=await apiPost(`/stake/claim`,{rid}); toast(r.ok?`Claimed ${r.claimed}`:"Claim failed"); await loadPassport(); }

document.addEventListener('DOMContentLoaded', ()=>{
  // если App уже показан (после unlock) — инициализируем
  if(!document.getElementById('viewApp').classList.contains('hidden')){
    loadPassport().catch(e=>toast(String(e)));
  }
  // действия
  $('#btnSendTx').onclick = ()=>sendTx().catch(e=>toast(String(e)));
  $('#btnStakeDel').onclick= ()=>stakeDel().catch(e=>toast(String(e)));
  $('#btnStakeUn').onclick = ()=>stakeUn().catch(e=>toast(String(e)));
  $('#btnStakeClaim').onclick=()=>stakeClaim().catch(e=>toast(String(e)));
});
```


### FILE: /var/www/logos/wallet/js/app_wallet.js

```js
import { $, toast, canon, short, fmtInt, be8, enc } from "./core.js";
import { apiGet, apiPost } from "./api.js";
import { currentRID, signEd25519, ensureSessionKey } from "./vault_bridge.js";

function ui(){
  return {
    passport: $("#viewApp"),
    ridOut:   $("#ridOut"),
    // поля отправки
    to: $("#sendTo"),
    amount: $("#sendAmount"),
    btnSend: $("#btnSendTx"),
    // профиль/паспорт KPI
    kpiBal: $("#kpiBal"), kpiNonce: $("#kpiNonce"), kpiHead: $("#kpiHead"),
    kpiDel: $("#kpiDelegated"), kpiEnt: $("#kpiEntries"), kpiClaim: $("#kpiClaimable"),
    // история
    histBody: $("#histBody"),
    // стейкинг
    val: $("#stakeValidator"), stakeAmt: $("#stakeAmount"),
    btnDel: $("#btnStakeDel"), btnUn: $("#btnStakeUn"), btnClaim: $("#btnStakeClaim"),
  };
}

async function loadPassport(){
  const rid = currentRID();
  const u = ui();
  u.ridOut.textContent = rid || "—";
  if(!rid){ toast("RID не найден. Разблокируйте кошелёк."); return; }

  const [p,s,h] = await Promise.allSettled([
    apiGet(`/profile/${rid}`),
    apiGet(`/stake/summary/${rid}`),
    apiGet(`/history/${rid}?limit=25`)
  ]);

  const prof = p.status==="fulfilled" ? p.value : {};
  const sum  = s.status==="fulfilled" ? s.value : {};
  const hist = h.status==="fulfilled" ? (h.value.items||[]) : [];

  u.kpiBal.textContent   = fmtInt(prof.balance ?? 0);
  u.kpiNonce.textContent = (prof.nonce && prof.nonce.next) ?? "-";
  u.kpiHead.textContent  = prof.head ?? "-";
  u.kpiDel.textContent   = fmtInt(sum.delegated ?? 0);
  u.kpiEnt.textContent   = fmtInt(sum.entries ?? 0);
  u.kpiClaim.textContent = fmtInt(sum.claimable ?? 0);

  // история
  u.histBody.innerHTML = "";
  for(const it of hist){
    const e = it.evt || {};
    const cp = e.dir==="out" ? e.to : (e.dir==="in" ? e.from : (e.rid||"-"));
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${e.type||"transfer"}</td>
      <td class="mono">${short(cp,24)}</td>
      <td>${fmtInt(e.amount ?? 0)}</td>
      <td>${e.nonce ?? "-"}</td>
      <td>${e.height ?? "-"}</td>
      <td class="mono">${short(e.tx,28)}</td>`;
    u.histBody.appendChild(tr);
  }
}

async function sendTx(){
  const rid = currentRID();
  const u = ui();
  const to = (u.to.value||"").trim();
  const amount = Number(u.amount.value||"0");
  if(!rid){ toast("Разблокируйте кошелёк"); return; }
  if(!to || !amount){ toast("Укажите получателя и сумму"); return; }

  // ensure key in memory (может запросить пароль один раз)
  await ensureSessionKey();

  const nn = await apiGet(`/nonce/${rid}`);
  const nonce = nn.next;
  const msg = canon(rid, to, amount, nonce);
  const sigB64 = await signEd25519(msg);

  u.btnSend.disabled = true;
  u.btnSend.textContent = "Отправляем…";
  try{
    const res = await apiPost(`/submit_tx`, {from: rid, to, amount, nonce, sig: sigB64});
    toast(res?.status==="queued" ? "Tx отправлена" : "Отправлено");
    await loadPassport();
  }catch(e){ toast("Ошибка: "+e.message); }
  finally{ u.btnSend.disabled=false; u.btnSend.textContent = "Отправить"; }
}

async function stakeDelegate(){
  const u = ui(); const rid = currentRID(); const a = Number(u.stakeAmt.value||"0");
  if(!rid || !a){ toast("RID/сумма?"); return; }
  try{
    const r = await apiPost(`/stake/delegate`, {validator: rid, amount: a});
    toast(r.ok ? "Delegated" : "Delegate failed");
    await loadPassport();
  }catch(e){ toast("Ошибка: "+e.message); }
}
async function stakeUndelegate(){
  const u = ui(); const rid = currentRID(); const a = Number(u.stakeAmt.value||"0");
  if(!rid || !a){ toast("RID/сумма?"); return; }
  try{
    const r = await apiPost(`/stake/undelegate`, {validator: rid, amount: a});
    toast(r.ok ? "Undelegated" : "Undelegate failed");
    await loadPassport();
  }catch(e){ toast("Ошибка: "+e.message); }
}
async function stakeClaim(){
  const rid = currentRID();
  if(!rid){ toast("RID?"); return; }
  try{
    const r = await apiPost(`/stake/claim`, {rid});
    toast(r.ok ? `Claimed ${r.claimed}` : "Claim failed");
    await loadPassport();
  }catch(e){ toast("Ошибка: "+e.message); }
}

export function initAppWallet(){
  $("#kpiRid").textContent = currentRID() || "—";
  $("#btnSendTx").addEventListener("click", ()=>sendTx().catch(e=>toast(String(e))));
  $("#btnStakeDel").addEventListener("click", ()=>stakeDelegate().catch(e=>toast(String(e))));
  $("#btnStakeUn").addEventListener("click", ()=>stakeUndelegate().catch(e=>toast(String(e))));
  $("#btnStakeClaim").addEventListener("click", ()=>stakeClaim().catch(e=>toast(String(e))));
  loadPassport().catch(e=>toast(String(e)));
}
```


### FILE: /var/www/logos/wallet/js/core.js

```js
export const enc = new TextEncoder();
export const API = "/api";
export const $ = (sel)=>document.querySelector(sel);

export function toast(m){ const t=document.getElementById('toast'); if(!t) return; t.textContent=m; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000); }

export function be8(n){ const a=new Uint8Array(8); new DataView(a.buffer).setBigUint64(0, BigInt(n)); return a; }
export function cat(...xs){ let L=0; for(const a of xs)L+=a.length; const out=new Uint8Array(L); let o=0; for(const a of xs){ out.set(a,o); o+=a.length; } return out; }
export function canon(from,to,amount,nonce){ return cat(new TextEncoder().encode(from),Uint8Array.of(0x7c),new TextEncoder().encode(to),Uint8Array.of(0x7c),be8(amount),Uint8Array.of(0x7c),be8(nonce)); }
export function fmt(x){ return (x??0).toLocaleString('ru-RU'); }
export function short(s,n=28){ if(!s) return "-"; return s.length>n ? s.slice(0,n-3)+"…" : s; }
const B58="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
export function b58(bytes){ let x=0n; for(const v of bytes) x=(x<<8n)+BigInt(v); let s=""; while(x>0n){const r=Number(x%58n);x/=58n;s=B58[r]+s;} for(const v of bytes){ if(v===0)s="1"+s; else break;} return s||"1"; }

export async function apiGet(p){ const r=await fetch(API+p); if(!r.ok) throw new Error(`GET ${p} -> ${r.status}`); return r.json(); }
export async function apiPost(p,b){ const r=await fetch(API+p,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(b)}); if(!r.ok){const t=await r.text().catch(()=> ""); throw new Error(`POST ${p} -> ${r.status} ${t}`);} return r.json(); }
```


### FILE: /var/www/logos/wallet/js/unlock.js

```js
import { $, toast } from "./core.js";
import { hasVault, createPairAndBackup, finalizeCreate, importVault, unlockWith, currentRID } from "./vault.js";

function show(id){ ['#viewLanding','#viewCreatePwd','#viewBackup','#viewImport','#viewUnlock'].forEach(v=>$(v).classList.add('hidden')); $(id).classList.remove('hidden'); }
function showApp(){ document.getElementById('lockOverlay').style.display='none'; ['#viewApp','#viewSend','#viewStake','#viewHistory'].forEach(id=>$(id).classList.remove('hidden')); }

document.addEventListener('DOMContentLoaded', ()=>{
  $('#rpHost').textContent = location.host + ' JS✓';
  if(hasVault()) show('#viewUnlock'); else show('#viewLanding');

  // роутинг
  $('#goCreate').onclick = ()=> show('#viewCreatePwd');
  $('#goImport').onclick = ()=> show('#viewImport');
  $('#goUnlock').onclick = ()=> show('#viewUnlock');
  $('#back1').onclick = ()=> show('#viewLanding');
  $('#back2').onclick = ()=> show('#viewCreatePwd');
  $('#back3').onclick = ()=> show('#viewLanding');

  // создание шаг1
  $('#createNext').onclick = async ()=>{
    const p1=$('#newPwd1').value.trim(), p2=$('#newPwd2').value.trim();
    if(p1.length<8){ toast('Пароль минимум 8 символов'); return;}
    if(p1!==p2){ toast('Пароли не совпадают'); return;}
    try{
      const b64 = await createPairAndBackup(p1);
      $('#backupArea').value = b64; $('#chkSaved').checked=false; $('#finishCreate').disabled=true;
      show('#viewBackup');
    }catch(e){ toast('Крипто-ошибка. Обнови браузер.'); }
  };
  $('#chkSaved').onchange = ()=> $('#finishCreate').disabled = !$('#chkSaved').checked;
  $('#finishCreate').onclick = async ()=>{
    try{ await finalizeCreate(); toast('Кошелёк создан'); show('#viewUnlock'); }
    catch(e){ toast('Не удалось сохранить'); }
  };

  // импорт
  $('#doImport').onclick = async ()=>{
    const b64=$('#impKey').value.trim(), p1=$('#impPwd1').value.trim(), p2=$('#impPwd2').value.trim();
    if(!b64){ toast('Вставьте ключ'); return;}
    if(p1.length<8){ toast('Пароль минимум 8 символов'); return;}
    if(p1!==p2){ toast('Пароли не совпадают'); return;}
    try{ await importVault(b64,p1); toast('Импорт выполнен'); show('#viewUnlock'); }
    catch(e){ toast('Импорт не удался'); }
  };

  // разблокировать
  $('#btnUnlock').onclick = async ()=>{
    const pass=$('#unPwd').value.trim();
    if(pass.length<8){ toast('Пароль минимум 8 символов'); return; }
    const b=$('#btnUnlock'); const orig=b.textContent; b.disabled=true; b.textContent='Разблокируем…';
    try{
      await Promise.race([ unlockWith(pass), new Promise((_,rej)=>setTimeout(()=>rej(new Error('TIMEOUT')),12000)) ]);
      $('#kpiRid').textContent = currentRID() || "—";
      showApp(); toast('Готово');
    }catch(e){
      const code=String(e&&e.message||e);
      if(code==='NO_KEY') toast('Кошелёк не найден');
      else if(code==='BAD_PASS') toast('Неверный пароль');
      else if(code==='TIMEOUT') toast('Долго думает… повторите');
      else toast('Ошибка разблокировки');
    }finally{ b.disabled=false; b.textContent=orig; }
  };

  $('#btnReset').onclick = ()=>{ if(confirm('Очистить локальный ключ?')){ try{localStorage.removeItem('logos_secure_v3_vault');}catch{} toast('Сброшено'); show('#viewLanding'); } };
});
```


### FILE: /var/www/logos/wallet/js/vault.js

```js
import { enc, b58, toast } from "./core.js";

const LS="logos_secure_v3_vault";
const ITER=250000;

function getVault(){ const raw=localStorage.getItem(LS); if(!raw) return null; try{ return JSON.parse(raw);}catch{ return null; } }
function saveVault(salt,iv,ct,pub){ localStorage.setItem(LS, JSON.stringify({
  salt:btoa(String.fromCharCode(...salt)), iv:btoa(String.fromCharCode(...iv)), ct:btoa(String.fromCharCode(...ct)), pub:btoa(String.fromCharCode(...pub)), iter:ITER
})); }
async function kdf(pass,salt){ const base=await crypto.subtle.importKey("raw",enc.encode(pass),{name:"PBKDF2"},false,["deriveKey"]); return crypto.subtle.deriveKey({name:"PBKDF2",salt,iterations:ITER,hash:"SHA-256"},base,{name:"AES-GCM",length:256},false,["encrypt","decrypt"]); }

export const hasVault = ()=> !!getVault();
export const currentRID = ()=>{ const v=getVault(); if(!v) return ""; const pub=Uint8Array.from(atob(v.pub),c=>c.charCodeAt(0)); return b58(pub); };

let __priv=null, __pub=null, __timer=null;
function sessionSet(priv,pub){ __priv=priv; __pub=pub; clearTimeout(__timer); __timer=setTimeout(()=>{__priv=null;__pub=null;}, 5*60*1000); }
export const hasSession = ()=> !!__priv;

export async function createPairAndBackup(pw){
  const kp=await crypto.subtle.generateKey({name:"Ed25519"},true,["sign","verify"]);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey("pkcs8",kp.privateKey));
  const pub=new Uint8Array(await crypto.subtle.exportKey("raw",kp.publicKey));
  sessionStorage.setItem('TMP_PK', btoa(String.fromCharCode(...pkcs8)));
  sessionStorage.setItem('TMP_PW', pw);
  sessionStorage.setItem('TMP_PUB', btoa(String.fromCharCode(...pub)));
  return btoa(String.fromCharCode(...pkcs8));
}
export async function finalizeCreate(){
  const b64=sessionStorage.getItem('TMP_PK'), p1=sessionStorage.getItem('TMP_PW'), pubB=sessionStorage.getItem('TMP_PUB');
  if(!b64||!p1||!pubB) throw new Error("CREATE_SESSION_LOST");
  const pk = Uint8Array.from(atob(b64),c=>c.charCodeAt(0));
  const pub= Uint8Array.from(atob(pubB),c=>c.charCodeAt(0));
  const s=new Uint8Array(16); crypto.getRandomValues(s);
  const iv=new Uint8Array(12); crypto.getRandomValues(iv);
  const key=await kdf(p1,s); const ct=new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM",iv},key,pk));
  saveVault(s,iv,ct,pub); sessionStorage.clear();
}
export async function importVault(b64,p1){
  const pk = Uint8Array.from(atob(b64),c=>c.charCodeAt(0));
  const tmp=await crypto.subtle.generateKey({name:"Ed25519"},true,["sign","verify"]);
  const pub=new Uint8Array(await crypto.subtle.exportKey("raw",tmp.publicKey));
  const s=new Uint8Array(16); crypto.getRandomValues(s);
  const iv=new Uint8Array(12); crypto.getRandomValues(iv);
  const key=await kdf(p1,s); const ct=new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM",iv},key,pk));
  saveVault(s,iv,ct,pub);
}
export async function unlockWith(pass){
  const v=getVault(); if(!v) throw new Error("NO_KEY");
  const s=Uint8Array.from(atob(v.salt),c=>c.charCodeAt(0));
  const iv=Uint8Array.from(atob(v.iv),c=>c.charCodeAt(0));
  const ct=Uint8Array.from(atob(v.ct),c=>c.charCodeAt(0));
  const key=await kdf(pass,s);
  const pk8=await crypto.subtle.decrypt({name:"AES-GCM",iv},key,ct).catch(()=>{throw new Error("BAD_PASS")});
  const priv=await crypto.subtle.importKey("pkcs8",pk8,{name:"Ed25519"},false,["sign"]);
  const pub =Uint8Array.from(atob(v.pub),c=>c.charCodeAt(0));
  sessionSet(priv,pub);
}
export async function ensureSessionKey(){
  if(__priv) return {priv:__priv, pub:__pub};
  const v=getVault(); if(!v){ toast("Кошелёк не найден"); throw new Error("NO_KEY"); }
  const pass = prompt("Пароль для подписи"); if(!pass||pass.length<8){ throw new Error("PASS_SHORT"); }
  await unlockWith(pass); return {priv:__priv, pub:__pub};
}
export async function signEd25519(bytes){
  const {priv}=await ensureSessionKey();
  const sig=new Uint8Array(await crypto.subtle.sign({name:"Ed25519"},priv,bytes));
  let bin=""; for(let i=0;i<sig.length;i++) bin+=String.fromCharCode(sig[i]); return btoa(bin);
}
```


### FILE: /var/www/logos/wallet/js/vault_bridge.js

```js
import { enc, b58, toast } from "./core.js";

// Шифрованный сейф (как на экране unlock)
const LS = "logos_secure_v3_vault";
const ITER = 250000;

function getVault(){
  const raw = localStorage.getItem(LS);
  if(!raw) return null;
  try{ return JSON.parse(raw); }catch{ return null; }
}

async function kdf(pass, salt){
  const base = await crypto.subtle.importKey("raw", enc.encode(pass), {name:"PBKDF2"}, false, ["deriveKey"]);
  return crypto.subtle.deriveKey({name:"PBKDF2", salt, iterations:ITER, hash:"SHA-256"}, base, {name:"AES-GCM", length:256}, false, ["encrypt","decrypt"]);
}

// Сессионный приватник (в памяти страницы), авто-очистка через 5 минут
let __priv = null, __pubRaw = null, __timer = null;
function sessionSet(priv, pub){
  __priv = priv; __pubRaw = pub;
  clearTimeout(__timer); __timer = setTimeout(()=>{ __priv=null; __pubRaw=null; }, 5*60*1000);
}

export function hasSession(){ return !!__priv; }
export function currentRID(){ const v=getVault(); if(!v) return ""; const pub = Uint8Array.from(atob(v.pub),c=>c.charCodeAt(0)); return b58(pub); }

// Гарантирует, что в памяти есть приватник. Если нет — запросит пароль и расшифрует.
export async function ensureSessionKey(){
  if(__priv) return {priv:__priv, pubRaw: __pubRaw};
  const v = getVault();
  if(!v){ toast("Кошелёк не найден. Создайте/импортируйте."); throw new Error("NO_KEY"); }
  const pass = prompt("Введите пароль кошелька для подписи");
  if(!pass || pass.length<8){ toast("Пароль минимум 8 символов"); throw new Error("PASS_SHORT"); }

  const salt = Uint8Array.from(atob(v.salt), c=>c.charCodeAt(0));
  const iv   = Uint8Array.from(atob(v.iv),   c=>c.charCodeAt(0));
  const ct   = Uint8Array.from(atob(v.ct),   c=>c.charCodeAt(0));
  const pub  = Uint8Array.from(atob(v.pub),  c=>c.charCodeAt(0));

  const key  = await kdf(pass, salt);
  let pkcs8;
  try{ pkcs8 = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct); }
  catch{ toast("Неверный пароль"); throw new Error("BAD_PASS"); }

  const priv = await crypto.subtle.importKey("pkcs8", pkcs8, {name:"Ed25519"}, false, ["sign"]);
  sessionSet(priv, pub);
  return {priv, pubRaw: pub};
}

export async function signEd25519(bytes){
  const { priv } = await ensureSessionKey();
  const sig = new Uint8Array(await crypto.subtle.sign({name:"Ed25519"}, priv, bytes));
  let bin=""; for(let i=0;i<sig.length;i++) bin += String.fromCharCode(sig[i]);
  return btoa(bin);
}
```


### FILE: /var/www/logos/wallet/login.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Вход</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c}
    h1{font-size:18px;margin:0}
    main{max-width:720px;margin:48px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    small{opacity:.8}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    ul{list-style:none;padding:0;margin:8px 0}
    li{padding:8px;border:1px solid #2a313a;border-radius:8px;margin-bottom:6px;cursor:pointer;background:#0b0f14}
  </style>
</head>
<body>
<header><h1>LOGOS Wallet — Secure (WebCrypto + IndexedDB)</h1></header>
<main>
  <section>
    <h3>Вход в аккаунт</h3>
    <label>Логин (RID)</label>
    <input id="loginRid" class="mono" placeholder="Вставь RID (base58) или выбери из списка ниже"/>
    <label>Пароль</label>
    <input id="pass" type="password" placeholder="Пароль для шифрования ключа"/>

    <div class="grid" style="margin-top:12px">
      <button id="btn-login">Войти по RID + пароль</button>
      <button id="btn-create">Создать новый RID</button>
    </div>

    <div style="margin-top:12px">
      <button id="btn-list" class="secondary">Показать сохранённые RID</button>
      <button id="btn-reset" class="secondary">Сбросить все аккаунты (DEV)</button>
    </div>

    <div id="listWrap" style="display:none;margin-top:10px">
      <small>Сохранённые на этом устройстве RID (тапни, чтобы подставить):</small>
      <ul id="ridList"></ul>
    </div>

    <p><small>Ключ Ed25519 хранится зашифрованным AES-GCM (PBKDF2) в IndexedDB. Ничего не уходит в сеть.</small></p>
    <pre id="out" class="mono"></pre>
  </section>
</main>
<script src="./auth.js?v=20250906_03" defer></script>
</body>
</html>
```


### FILE: /var/www/logos/wallet/ping.html

```html
<!doctype html><meta charset="utf-8">
<title>Wallet JS Ping</title>
<button onclick="alert('JS OK')">JS TEST</button>
```


### FILE: /var/www/logos/wallet/staking.js

```js
// LOGOS Wallet — staking (prod)
async function stakeSign(op, validator, amount, nonce){
  const msg = `${session.rid}|${op}|${validator}|${amount||0}|${nonce}`;
  return await crypto.subtle.sign('Ed25519', session.privKey, new TextEncoder().encode(msg)).then(buf=>{
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
  });
}
document.getElementById('btnDelegate').onclick = async ()=>{
  try{
    const b=await (await fetch(`${location.origin + '/api'}/balance/${encodeURIComponent(session.rid)}`)).json();
    const validator=document.getElementById('valRid').value.trim();
    const amount=Number(document.getElementById('stakeAmt').value);
    const nonce=(b.nonce??0)+1;
    const sig_hex=await stakeSign('delegate',validator,amount,nonce);
    const r=await fetch(`${location.origin + '/api'}/stake/submit`,{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,op:'delegate',validator,amount,nonce,sig_hex})});
    const j=await r.json(); document.getElementById('stakeStatus').textContent = j.ok?'Delegate OK':'ERR '+j.info;
  }catch(e){ document.getElementById('stakeStatus').textContent='Ошибка delegate'; }
};
document.getElementById('btnUndelegate').onclick = async ()=>{
  try{
    const b=await (await fetch(`${location.origin + '/api'}/balance/${encodeURIComponent(session.rid)}`)).json();
    const validator=document.getElementById('valRid').value.trim();
    const amount=Number(document.getElementById('stakeAmt').value);
    const nonce=(b.nonce??0)+1;
    const sig_hex=await stakeSign('undelegate',validator,amount,nonce);
    const r=await fetch(`${location.origin + '/api'}/stake/submit`,{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,op:'undelegate',validator,amount,nonce,sig_hex})});
    const j=await r.json(); document.getElementById('stakeStatus').textContent = j.ok?'Undelegate OK':'ERR '+j.info;
  }catch(e){ document.getElementById('stakeStatus').textContent='Ошибка undelegate'; }
};
document.getElementById('btnClaim').onclick = async ()=>{
  try{
    const b=await (await fetch(`${location.origin + '/api'}/balance/${encodeURIComponent(session.rid)}`)).json();
    const validator=document.getElementById('valRid').value.trim();
    const nonce=(b.nonce??0)+1;
    const sig_hex=await stakeSign('claim',validator,0,nonce);
    const r=await fetch(`${location.origin + '/api'}/stake/submit`,{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,op:'claim',validator,amount:0,nonce,sig_hex})});
    const j=await r.json(); document.getElementById('stakeStatus').textContent = j.ok?'Claim OK':'ERR '+j.info;
  }catch(e){ document.getElementById('stakeStatus').textContent='Ошибка claim'; }
};
```


### FILE: /var/www/logos/wallet/wallet.css

```css
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}
```


### FILE: /var/www/logos/wallet/wallet.js

```js
// LOGOS Wallet core — PROD
// Подключение к API через /api (nginx proxy)
const BASE = location.origin + '/api';

// ===== IndexedDB =====
const DB_NAME='logos_wallet', DB_STORE='keys';
function idbOpen(){return new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=e=>{const db=e.target.result;if(!db.objectStoreNames.contains(DB_STORE))db.createObjectStore(DB_STORE,{keyPath:'rid'})};r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});}
async function idbPut(rec){const db=await idbOpen();await new Promise((res,rej)=>{const tx=db.transaction(DB_STORE,'readwrite');tx.objectStore(DB_STORE).put(rec);tx.oncomplete=res;tx.onerror=()=>rej(tx.error)});db.close();}
async function idbGet(rid){const db=await idbOpen();return await new Promise((res,rej)=>{const tx=db.transaction(DB_STORE,'readonly');const rq=tx.objectStore(DB_STORE).get(rid);rq.onsuccess=()=>res(rq.result||null);rq.onerror=()=>rej(rq.error);tx.oncomplete=()=>db.close()});}

// ===== UI refs =====
const ui={
  loginRid:document.getElementById('loginRid'), loginPass:document.getElementById('loginPass'),
  btnLogin:document.getElementById('btnLogin'), loginStatus:document.getElementById('loginStatus'),
  newPass:document.getElementById('newPass'), btnCreate:document.getElementById('btnCreate'), createStatus:document.getElementById('createStatus'),
  panel:document.getElementById('walletPanel'),
  ridView:document.getElementById('ridView'), balView:document.getElementById('balView'), nonceView:document.getElementById('nonceView'),
  toRid:document.getElementById('toRid'), amount:document.getElementById('amount'), btnSend:document.getElementById('btnSend'), sendStatus:document.getElementById('sendStatus'),
  ridStake:document.getElementById('ridStake'),
  histBody:document.getElementById('histBody'), btnMoreHist:document.getElementById('btnMoreHist'),
  tabs:[...document.querySelectorAll('.tab')],
  btnExport:document.getElementById('btnExport'), btnImport:document.getElementById('btnImport'), impFile:document.getElementById('impFile'),
  settingsInfo:document.getElementById('settingsInfo'), exportStatus:document.getElementById('exportStatus')
};

// ===== WebCrypto helpers =====
function hex(buf){return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');}
async function sha256(s){const h=await crypto.subtle.digest('SHA-256', new TextEncoder().encode(s)); return hex(h);}
async function pbkdf2(pass,salt,iters=300000){const key=await crypto.subtle.importKey('raw', new TextEncoder().encode(pass), 'PBKDF2', false, ['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2', hash:'SHA-256', salt, iterations:iters}, key, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);}
async function signHex(bytes){const sig=await crypto.subtle.sign('Ed25519', session.privKey, bytes); return hex(sig);}

// ===== Anti-bot PoW (на создание) =====
async function powCreate(){const ts=Date.now().toString();let n=0;for(;;){const h=await sha256(ts+'|'+n);if(h.startsWith('00000'))return{ts,nonce:n,h};n++; if(n%5000===0) await new Promise(r=>setTimeout(r));}}

// ===== Session =====
let session={rid:null, privKey:null, pubKeyRaw:null};

// ===== Balance/nonce =====
async function refreshBalance(){
  const enc=encodeURIComponent(session.rid);
  const r=await fetch(`${BASE}/balance/${enc}`); const j=await r.json();
  ui.balView.textContent=j.balance??0; ui.nonceView.textContent=j.nonce??0;
  return j;
}

// ===== Create wallet =====
ui.btnCreate.onclick = async ()=>{
  try{
    ui.createStatus.textContent='Генерация…';
    const pass = ui.newPass.value.trim();
    if(pass.length<8){ ui.createStatus.textContent='Сложнее пароль'; return; }
    await powCreate();

    const kp = await crypto.subtle.generateKey({name:'Ed25519'}, true, ['sign','verify']);
    const pubRaw = await crypto.subtle.exportKey('raw', kp.publicKey);
    const privRaw = await crypto.subtle.exportKey('pkcs8', kp.privateKey);

    const rid = 'Λ0@7.83Hzφ' + (await sha256(hex(pubRaw))).slice(0,6);

    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv   = crypto.getRandomValues(new Uint8Array(12));
    const aek  = await pbkdf2(pass, salt);
    const enc  = await crypto.subtle.encrypt({name:'AES-GCM', iv}, aek, privRaw);

    await idbPut({ rid, pub_hex: hex(pubRaw), enc_priv_b64: btoa(String.fromCharCode(...new Uint8Array(enc))), salt_hex: hex(salt), iv_hex: hex(iv) });

    ui.loginRid.value = rid; ui.loginPass.value = pass;
    ui.createStatus.textContent='OK — кошелёк создан';
  }catch(e){ console.error(e); ui.createStatus.textContent='Ошибка создания'; }
};

// ===== Login =====
ui.btnLogin.onclick = async ()=>{
  try{
    ui.loginStatus.textContent = 'Поиск…';
    const rid = ui.loginRid.value.trim(), pass = ui.loginPass.value.trim();
    const rec = await idbGet(rid);
    if(!rec){ ui.loginStatus.textContent = 'RID не найден в этом браузере'; return; }

    const salt = Uint8Array.from(rec.salt_hex.match(/.{2}/g).map(h=>parseInt(h,16)));
    const iv   = Uint8Array.from(rec.iv_hex.match(/.{2}/g).map(h=>parseInt(h,16)));
    const enc  = Uint8Array.from(atob(rec.enc_priv_b64), c=>c.charCodeAt(0));
    const aek  = await pbkdf2(pass, salt);
    const privRaw = await crypto.subtle.decrypt({name:'AES-GCM', iv}, aek, enc);
    const privKey = await crypto.subtle.importKey('pkcs8', privRaw, {name:'Ed25519'}, false, ['sign']);

    session = { rid, privKey, pubKeyRaw: Uint8Array.from(rec.pub_hex.match(/.{2}/g).map(h=>parseInt(h,16))).buffer };

    // UI
    document.getElementById('walletPanel').style.display='';
    document.getElementById('ridView').textContent = rid;
    document.getElementById('ridStake').textContent = rid;
    ui.loginStatus.textContent='OK';

    await refreshBalance();
    histCursor=null; ui.histBody.innerHTML=''; await loadHistoryPage();
  }catch(e){ console.error(e); ui.loginStatus.textContent='Ошибка входа'; }
};

// ===== Send TX =====
ui.btnSend.onclick = async ()=>{
  try{
    ui.sendStatus.textContent='Отправка…';
    const b=await refreshBalance();
    const to=ui.toRid.value.trim();
    const amt=Number(ui.amount.value);
    const nonce=(b.nonce??0)+1;

    const msg=`${session.rid}|${to}|${amt}|${nonce}`;
    const sig_hex = await signHex(new TextEncoder().encode(msg));

    // Лёгкий локальный троттлинг (anti-bot throttle)
    await new Promise(r=>setTimeout(r, 300 + Math.random()*500));

    const res = await fetch(`${BASE}/submit_tx`,{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,to,amount:amt,nonce,sig_hex})
    });
    const j=await res.json();
    ui.sendStatus.textContent = j.ok ? ('OK: '+(j.txid||'')) : ('ERR: '+j.info);
    await refreshBalance();
  }catch(e){ console.error(e); ui.sendStatus.textContent='Ошибка'; }
};

// ===== History (пагинация by height) =====
let histCursor=null;
async function loadHistoryPage(){
  const enc=encodeURIComponent(session.rid);
  let url=`${BASE}/archive/history/${enc}`; if(histCursor!=null) url+=`?before_height=${histCursor}`;
  const r=await fetch(url); const list=await r.json(); if(!Array.isArray(list) || list.length===0) return;
  histCursor = Number(list[list.length-1].height) - 1;
  const frag=document.createDocumentFragment();
  for(const t of list){
    const tr=document.createElement('tr');
    tr.innerHTML=`<td class="mono">${String(t.txid).slice(0,16)}…</td><td class="mono">${t.from}</td><td class="mono">${t.to}</td><td>${t.amount}</td><td>${t.height}</td><td>${t.ts??''}</td>`;
    ui.histBody.appendChild(tr);
  }
}
ui.btnMoreHist.onclick = ()=> loadHistoryPage();

// ===== Tabs =====
ui.tabs.forEach(tab=>{
  tab.onclick=()=>{
    ui.tabs.forEach(t=>t.classList.remove('active')); tab.classList.add('active');
    const name=tab.dataset.tab;
    document.getElementById('tab-send').classList.toggle('hide', name!=='send');
    document.getElementById('tab-stake').classList.toggle('hide', name!=='stake');
    document.getElementById('tab-history').classList.toggle('hide', name!=='history');
    document.getElementById('tab-settings').classList.toggle('hide', name!=='settings');
  };
});

// ===== Export / Import =====
ui.btnExport.onclick = async ()=>{
  const rec = await idbGet(session.rid);
  const blob = new Blob([JSON.stringify(rec)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = `logos_wallet_${session.rid}.json`; a.click();
  ui.exportStatus.textContent='Экспортирован зашифрованный бэкап';
};
ui.btnImport.onclick = ()=> ui.impFile.click();
ui.impFile.onchange = async (e)=>{
  try{
    const f=e.target.files[0]; const text=await f.text(); const rec=JSON.parse(text);
    if(!rec.rid || !rec.enc_priv_b64) throw new Error('bad backup');
    await idbPut(rec); ui.exportStatus.textContent='Импорт OK';
  }catch(err){ ui.exportStatus.textContent='Ошибка импорта'; }
};
```


## FRONTEND ROOT: /var/www/logos/wallet3

### TREE (depth 3)

```text
index.html
app.v3.js
```


### FILE: /var/www/logos/wallet3/app.v3.js

```js
const API = location.origin + '/api/';
const enc = new TextEncoder();

// utils
const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));
function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }
async function fetchJSON(url, opts){
  const r = await fetch(url, opts);
  const t = await r.text();
  try { const j = t?JSON.parse(t):{}; if(!r.ok) throw j; return j; }
  catch(e){ throw { ok:false, error:(typeof e==='object'&&e.error)?e.error:(t||'not json'), status:r.status||0 }; }
}

// session/keys
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('../wallet/login.html'); throw new Error('locked'); } // переиспользуем старую страницу логина

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8 =await aesDecrypt(aesKey,new Uint8Array(meta.iv_priv),new Uint8Array(meta.priv));
  const pubraw=await aesDecrypt(aesKey,new Uint8Array(meta.iv_pub), new Uint8Array(meta.pub));
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},false,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',  pubraw,{name:'Ed25519'},true, ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}
let KEYS=null, META=null;
(async()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('../wallet/login.html'); return; }
  KEYS=await importKey(PASS, META);
})();

// canonical + sign
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(priv, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', priv, msg);
  return toHex(sig);
}

// API
const getBalance=(rid)=>fetchJSON(`${API}balance/${encodeURIComponent(rid)}`);
const submitTxBatch=(txs)=>fetchJSON(`${API}submit_tx_batch`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({txs})});
const stakeDelegate=(delegator,validator,amount)=>fetchJSON(`${API}stake/delegate`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeUndelegate=(delegator,validator,amount)=>fetchJSON(`${API}stake/undelegate`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeClaim=(delegator,validator)=>fetchJSON(`${API}stake/claim`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:0})});
const stakeMy=(rid)=>fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`);

// UI
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid=($('#rid-balance')?.value||RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ $('#out-balance') && ($('#out-balance').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); const n=$('#nonce'); if(n) n.value=String(j.nonce||0); }catch(e){}
});
$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to=$('#to')?.value.trim(), amount=$('#amount')?.value.trim(), nonce=$('#nonce')?.value.trim();
    if(!to||!amount||!nonce) throw {error:'fill to/amount/nonce'};
    const ch=await canonHex(RID,to,amount,nonce,KEYS.pub_hex);
    const sig=await signCanon(KEYS.privateKey,ch);
    const tx={from_rid:RID,to_rid:to,amount:Number(amount),nonce:Number(nonce),pubkey_hex:KEYS.pub_hex,sig_hex:sig};
    const res=await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent=JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const amount=$('#stake-amount')?.value.trim();
    const res=await stakeDelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const amount=$('#stake-amount')?.value.trim();
    const res=await stakeUndelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const res=await stakeClaim(RID,val);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{ const res=await stakeMy(RID); $('#out-my') && ($('#out-my').textContent=JSON.stringify(res)); }
  catch(e){ $('#out-my') && ($('#out-my').textContent=`ERR: ${JSON.stringify(e)}`); }
});
```


### FILE: /var/www/logos/wallet3/index.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; connect-src 'self'; img-src 'self'; script-src 'self'; style-src 'self'">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>LOGOS Wallet (v3)</title>
  <style>
    body{font-family:system-ui,Roboto,Arial,sans-serif;background:#0b0e11;color:#e6e6e6;margin:0}
    header{padding:12px 20px;background:#12161a;border-bottom:1px solid #1b2026}
    main{padding:20px} h3{margin:0}
    section{margin-bottom:20px}
    input,button{padding:8px 10px;border-radius:6px;border:none;font-size:14px}
    button{background:#2d6cdf;color:#fff;cursor:pointer;margin:4px 2px}
    .out{margin-top:10px;font-family:monospace;font-size:13px;white-space:pre-wrap}
  </style>
  <script>
    (async()=>{ // убьём SW/Cache на всякий случай
      try{
        if('serviceWorker' in navigator){
          for(const r of await navigator.serviceWorker.getRegistrations()) try{await r.unregister()}catch{}
        }
        if(window.caches){ for(const k of await caches.keys()) try{await caches.delete(k)}catch{} }
      }catch(e){}
    })();
  </script>
</head>
<body>
<header>
  <h3>LOGOS Wallet (v3)</h3>
  <div>node: <span id="node-url"></span> | head: <span id="head"></span></div>
</header>
<main>
  <section>
    <h4>Настройки</h4>
    <div>RID: <span id="rid"></span></div>
    <div>Баланс: <span id="balance"></span> | Nonce: <span id="nonce-show"></span></div>
    <input id="rid-balance" placeholder="RID для проверки"/>
    <button id="btn-balance">Баланс</button>
    <div id="out-balance" class="out"></div>
  </section>

  <section>
    <h4>Отправка</h4>
    <input id="to" placeholder="RID получателя"/>
    <input id="amount" type="number" placeholder="Сумма (микро-LGN)"/>
    <input id="nonce" type="number" placeholder="Nonce"/>
    <button id="btn-nonce">NONCE</button>
    <button id="btn-send">Отправить</button>
    <div id="out-send" class="out"></div>
  </section>

  <section>
    <h4>Стейкинг</h4>
    <input id="validator" placeholder="RID валидатора"/>
    <input id="stake-amount" type="number" placeholder="Сумма (микро-LGN)"/>
    <button id="btn-delegate">Delegate</button>
    <button id="btn-undelegate">Undelegate</button>
    <button id="btn-claim">Claim</button>
    <button id="btn-my">Мои делегации</button>
    <div id="out-stake" class="out"></div>
    <div id="out-my" class="out"></div>
  </section>
</main>

<script src="app.v3.js?v=3"></script>
<script>
  document.getElementById('node-url').textContent = location.origin;
  (async function tick(){
    try{
      const h=await (await fetch(location.origin+'/api/head')).json();
      document.getElementById('head').textContent=h.height;
      const rid=sessionStorage.getItem('logos_rid');
      if(rid){
        const bj=await (await fetch(location.origin+'/api/balance/'+encodeURIComponent(rid))).json();
        document.getElementById('rid').textContent=rid;
        document.getElementById('balance').textContent=bj.balance;
        document.getElementById('nonce-show').textContent=bj.nonce;
      }
    }catch(e){}
    setTimeout(tick,1500);
  })();
</script>
</body>
</html>
```


---
## NGINX CONFIG FILES


### FILE: /etc/nginx/sites-enabled/logos-node-8000.conf

```conf
server {
    listen 8000;
    server_name _;
    # если будете раздавать фронт-кошелёк со статикой — пропишите root
    # root /var/www/wallet;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```


### FILE: /etc/nginx/sites-enabled/logos.conf

```conf
# Лимиты запросов к API
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

upstream logos_node_backend {
    server 127.0.0.1:8080;
    keepalive 32;
}

upstream logos_wallet_api {
    server 127.0.0.1:9090;
    keepalive 16;
}

server {
    listen 80;
    server_name mw-expedition.com www.mw-expedition.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name mw-expedition.com www.mw-expedition.com;

    ssl_certificate     /etc/letsencrypt/live/mw-expedition.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/mw-expedition.com/privkey.pem;

    root /opt/logos/www;
    index index.html;

    location = / {
        root /var/www/logos/landing;
        try_files /index.html =404;
        add_header Cache-Control "no-store" always;
    }

    location ^~ /wallet_v2/ {
        try_files $uri $uri/ /wallet_v2/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/node-api https://mw-expedition.com/wallet-api; img-src 'self' data:; font-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline';" always;
    }
    location ^~ /wallet_dev/ {
        alias /opt/logos/www/wallet_dev/;
        index index.html;
        try_files $uri $uri/ /wallet_dev/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/node-api https://mw-expedition.com/wallet-api; img-src 'self' data:; font-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline';" always;
    }
    location ^~ /wallet/ {
        alias /opt/logos/www/wallet_prod/;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/node-api https://mw-expedition.com/wallet-api; img-src 'self' data:; font-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self';" always;
    }

location ^~ /explorer/ {
        try_files $uri /explorer/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/node-api;" always;
    }

    location = /node-api { return 301 /node-api/; }
    location ^~ /node-api/ {
        limit_req zone=api_zone burst=60 nodelay;
        proxy_pass http://logos_node_backend/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location = /wallet-api { return 301 /wallet-api/; }
    location ^~ /wallet-api/ {
        limit_req zone=api_zone burst=60 nodelay;
        proxy_pass http://logos_wallet_api/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Совместимость (старые пути)
    location ^~ /api/ {
        limit_req zone=api_zone burst=60 nodelay;
        proxy_pass http://logos_node_backend/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ^~ /proxy/ {
        limit_req zone=api_zone burst=60 nodelay;
        proxy_pass http://logos_wallet_api/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ~* \.(?:css|js|ico|png|jpg|jpeg|svg|woff2?)$ {
        try_files $uri =404;
        add_header Cache-Control "no-store" always;
    }
}
```


### FILE: /etc/nginx/sites-available/logos-node-8000.conf

```conf
server {
    listen 8000;
    server_name _;
    # если будете раздавать фронт-кошелёк со статикой — пропишите root
    # root /var/www/wallet;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```


### FILE: /etc/nginx/sites-available/logos.conf

```conf
# Лимиты запросов к API
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;

# WebSocket/upgrade helper
map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

# Узел LOGOS (REST API)
upstream logos_node_backend {
    server 127.0.0.1:8080;
    keepalive 32;
}

# Wallet-proxy (депозиты USDT -> rLGN)
upstream logos_wallet_api {
    server 127.0.0.1:9090;
    keepalive 16;
}

# Airdrop API — upstream объявлен в /etc/nginx/conf.d/logos_airdrop_upstream.conf
# upstream logos_airdrop_api { ... }

server {
    listen 80;
    server_name mw-expedition.com www.mw-expedition.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name mw-expedition.com www.mw-expedition.com;

    ssl_certificate     /etc/letsencrypt/live/mw-expedition.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/mw-expedition.com/privkey.pem;

    # По умолчанию — статика кошелька/эксплорера
    root /opt/logos/www;
    index index.html;

    # === Лендинг ===
    location = / {
        root /var/www/logos/landing;
        try_files /index.html =404;
        add_header Cache-Control "no-store" always;
    }

    # Страница аирдропа /airdrop.html
    # === Wallet SPA ===
    location /wallet/ {
        try_files $uri /wallet/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/api https://mw-expedition.com/proxy https://vnet.web3games.org https://mainnet.infura.io;" always;
    }

    # === Explorer SPA ===
    location /explorer/ {
        try_files $uri /explorer/index.html;
        add_header Cache-Control "no-store" always;
        # Разрешаем inline-стили и скрипты для explorer, API остаётся только self
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/api;" always;
    }

    # === REST API ноды ===
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_pass http://logos_node_backend/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # === Wallet-proxy API ===
    location /proxy/ {
        proxy_pass http://logos_wallet_api/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # === Airdrop API ===
    # Общая статика (JS/CSS/иконки)
    location ~* \.(?:css|js|ico|png|jpg|jpeg|svg|woff2?)$ {
        try_files $uri =404;
        add_header Cache-Control "no-store" always;
    }
}
```


### FILE: /etc/nginx/nginx.conf

```conf
user www-data;
worker_processes auto;
pid /run/nginx.pid;
include /etc/nginx/modules-enabled/*.conf;

events {
    worker_connections 4096;
    multi_accept on;
}

http {
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 4096;

    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    access_log /var/log/nginx/access.log;
    error_log  /var/log/nginx/error.log warn;

    # ВАЖНО: эти include обязаны быть внутри http{}
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
```


## NGINX -T (filtered: mw-expedition.com + upstreams + wallet/api)

**CMD:** `nginx -T 2>/dev/null | awk 'BEGIN{p=0} /server_name mw-expedition.com/{p=1} p{print} /}\s*$/{if(p){print; exit}}'`

```text
server_name mw-expedition.com www.mw-expedition.com;
    return 301 https://$host$request_uri;
}
}
```


---
## SYSTEMD UNITS


## SYSTEMD: systemctl cat logos-node@main

**CMD:** `systemctl cat logos-node@main --no-pager 2>/dev/null || true`

```text
# /etc/systemd/system/logos-node@.service
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
EnvironmentFile=/etc/logos/node-%i.env
ExecStart=/opt/logos/bin/logos_node
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=strict
ProtectHome=read-only
PrivateDevices=yes
ProtectKernelTunables=yes
ProtectKernelModules=yes
ProtectControlGroups=yes
LockPersonality=yes
MemoryDenyWriteExecute=yes
CapabilityBoundingSet=
SystemCallFilter=@system-service @network-io ~keyctl
ReadWritePaths=/var/lib/logos /var/log/logos
RuntimeDirectory=logos
UMask=0077
[Install]
WantedBy=multi-user.target

# /etc/systemd/system/logos-node@.service.d/10-restart-policy.conf
[Service]
Restart=on-failure
RestartSec=3
StartLimitIntervalSec=60
StartLimitBurst=5

# /etc/systemd/system/logos-node@.service.d/20-env.conf
[Service]
EnvironmentFile=-/etc/logos/node-%i.env

# /etc/systemd/system/logos-node@.service.d/30-hardening.conf
[Service]
# Sandbox
NoNewPrivileges=true
PrivateTmp=true
ProtectHome=true
ProtectSystem=full
ProtectKernelTunables=true
ProtectKernelModules=true
ProtectControlGroups=true
LockPersonality=true
MemoryDenyWriteExecute=true
RestrictRealtime=true
RestrictSUIDSGID=true
SystemCallArchitectures=native

# Разрешаем запись ТОЛЬКО где нужно
ReadWritePaths=/var/lib/logos
ReadWritePaths=/var/log/logos

# Ресурсные лимиты
LimitNOFILE=262144
LimitNPROC=8192

# Capabilities обрезаем в ноль
CapabilityBoundingSet=
AmbientCapabilities=

# /etc/systemd/system/logos-node@.service.d/31-bridge-key.conf
[Service]
Environment=LRB_BRIDGE_KEY=supersecret

# /etc/systemd/system/logos-node@.service.d/40-log.conf
[Service]
Environment=RUST_LOG=trace,logos=trace,consensus=trace,axum=info,h2=info,tokio=info

# /etc/systemd/system/logos-node@.service.d/41-faucet.conf
[Service]
# Типичные ключи, которые встречаются в таких сборках:
Environment=LOGOS_FAUCET_ENABLED=true
Environment=LRB_FAUCET_ENABLED=true
# (на некоторых билдах есть явный биндинг — пусть будет)
Environment=LOGOS_FAUCET_PATH=/faucet

# /etc/systemd/system/logos-node@.service.d/env.conf
[Service]
# Per-instance env (например /etc/logos/node-main.env)
EnvironmentFile=/etc/logos/node-%i.env
# Общие секреты (тот самый "keys", чтобы один раз положил — и все инстансы видят)
EnvironmentFile=/etc/logos/keys.env

# /etc/systemd/system/logos-node@.service.d/override.conf
[Service]
Environment=LOGOS_GENESIS_PATH=/etc/logos/genesis.yaml
Environment=LOGOS_NODE_KEY_PATH=/var/lib/logos/node_key
```


## SYSTEMD: systemctl show logos-node@main

**CMD:** `systemctl show -p FragmentPath -p WorkingDirectory -p ExecStart -p EnvironmentFile logos-node@main --no-pager 2>/dev/null || true`

```text
ExecStart={ path=/opt/logos/bin/logos_node ; argv[]=/opt/logos/bin/logos_node ; ignore_errors=no ; start_time=[Wed 2026-01-14 03:41:28 GMT] ; stop_time=[n/a] ; pid=1610448 ; code=(null) ; status=0/0 }
WorkingDirectory=
FragmentPath=/etc/systemd/system/logos-node@.service
```


## SYSTEMD: systemctl cat logos-wallet-proxy

**CMD:** `systemctl cat logos-wallet-proxy --no-pager 2>/dev/null || true`

```text
# /etc/systemd/system/logos-wallet-proxy.service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI + Uvicorn)
After=network-online.target
Wants=network-online.target

[Service]
EnvironmentFile=/etc/logos/wallet-proxy.env
User=logos
Group=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/wallet-proxy.env

ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app \
  --host 0.0.0.0 \
  --port 9090 \
  --workers 2

Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

# /etc/systemd/system/logos-wallet-proxy.service.d/override.conf
[Service]
EnvironmentFile=
EnvironmentFile=/etc/logos/wallet-proxy.env

# гарантируем, что таблица есть до старта uvicorn
ExecStartPre=/opt/logos/wallet-proxy/venv/bin/python3 /opt/logos/wallet-proxy/init_db.py
```


## SYSTEMD: systemctl show logos-wallet-proxy

**CMD:** `systemctl show -p FragmentPath -p WorkingDirectory -p ExecStart -p EnvironmentFile logos-wallet-proxy --no-pager 2>/dev/null || true`

```text
ExecStart={ path=/opt/logos/wallet-proxy/venv/bin/uvicorn ; argv[]=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2 ; ignore_errors=no ; start_time=[Wed 2026-01-14 06:53:02 GMT] ; stop_time=[n/a] ; pid=1620733 ; code=(null) ; status=0/0 }
WorkingDirectory=/opt/logos/wallet-proxy
FragmentPath=/etc/systemd/system/logos-wallet-proxy.service
```


## SYSTEMD: systemctl cat lrb-proxy

**CMD:** `systemctl cat lrb-proxy --no-pager 2>/dev/null || true`

```text
# /etc/systemd/system/lrb-proxy.service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
```


## SYSTEMD: systemctl show lrb-proxy

**CMD:** `systemctl show -p FragmentPath -p WorkingDirectory -p ExecStart -p EnvironmentFile lrb-proxy --no-pager 2>/dev/null || true`

```text
ExecStart={ path=/opt/logos/wallet-proxy/venv/bin/uvicorn ; argv[]=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2 ; ignore_errors=no ; start_time=[Wed 2026-01-14 06:53:02 GMT] ; stop_time=[n/a] ; pid=1620728 ; code=(null) ; status=0/0 }
WorkingDirectory=/opt/logos/wallet-proxy
FragmentPath=/etc/systemd/system/lrb-proxy.service
```


## SYSTEMD: systemctl cat lrb-scanner

**CMD:** `systemctl cat lrb-scanner --no-pager 2>/dev/null || true`

```text
# /etc/systemd/system/lrb-scanner.service
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
```


## SYSTEMD: systemctl show lrb-scanner

**CMD:** `systemctl show -p FragmentPath -p WorkingDirectory -p ExecStart -p EnvironmentFile lrb-scanner --no-pager 2>/dev/null || true`

```text
ExecStart={ path=/opt/logos/wallet-proxy/venv/bin/python ; argv[]=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py ; ignore_errors=no ; start_time=[Wed 2026-01-14 06:53:02 GMT] ; stop_time=[n/a] ; pid=1620726 ; code=(null) ; status=0/0 }
WorkingDirectory=/opt/logos/wallet-proxy
FragmentPath=/etc/systemd/system/lrb-scanner.service
```


---
## OPENAPI


### FILE: /root/logos_lrb/node/openapi/openapi.json

```json
{
  "openapi": "3.0.3",
  "info": {
    "title": "LOGOS LRB — Core API",
    "version": "0.1.0",
    "description": "Public & Admin API for LOGOS LRB (strict CSP, JWT admin, rToken bridge, archive)"
  },
  "servers": [{ "url": "https://45-159-248-232.sslip.io" }],
  "paths": {
    "/healthz": {
      "get": { "summary": "Healthcheck", "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/OkMsg" } } } } } }
    },
    "/head": {
      "get": { "summary": "Chain head", "responses": { "200": { "description": "Head", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Head" } } } } } }
    },
    "/balance/{rid}": {
      "get": {
        "summary": "Account balance & nonce",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": { "200": { "description": "Balance", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Balance" } } } } }
      }
    },
    "/submit_tx": {
      "post": {
        "summary": "Submit transaction",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TxIn" } } } },
        "responses": { "200": { "description": "Result", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitResult" } } } } }
      }
    },
    "/economy": {
      "get": { "summary": "Economy snapshot", "responses": { "200": { "description": "Economy", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Economy" } } } } } }
    },
    "/history/{rid}": {
      "get": {
        "summary": "History by RID (from sled index)",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "History", "content": { "application/json": { "schema": { "type": "array", "items": { "$ref": "#/components/schemas/HistoryItem" } } } } }
        }
      }
    },
    "/archive/history/{rid}": {
      "get": {
        "summary": "History by RID (archive backend: SQLite/PG)",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "History", "content": { "application/json": { "schema": { "type": "array", "items": { "type": "object" } } } } }
        }
      }
    },
    "/archive/tx/{txid}": {
      "get": {
        "summary": "Get TX by txid (archive backend)",
        "parameters": [{ "name": "txid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "TX (if any)", "content": { "application/json": { "schema": { "type": "object" } } } }
        }
      }
    },
    "/bridge/deposit": {
      "post": {
        "summary": "Register external deposit to rToken",
        "security": [{ "BridgeKey": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DepositReq" } } } },
        "responses": { "200": { "description": "BridgeResp", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeResp" } } } } }
      }
    },
    "/bridge/redeem": {
      "post": {
        "summary": "Request redeem from rToken to external chain",
        "security": [{ "BridgeKey": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/RedeemReq" } } } },
        "responses": { "200": { "description": "BridgeResp", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeResp" } } } } }
      }
    },
    "/bridge/verify": {
      "post": {
        "summary": "Verify bridge operation",
        "security": [{ "BridgeKey": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/VerifyReq" } } } },
        "responses": { "200": { "description": "BridgeResp", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeResp" } } } } }
      }
    },
    "/admin/set_balance": {
      "post": {
        "summary": "Set balance (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SetBalanceReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    },
    "/admin/set_nonce": {
      "post": {
        "summary": "Set nonce (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SetNonceReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    },
    "/admin/bump_nonce": {
      "post": {
        "summary": "Bump nonce (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BumpNonceReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    },
    "/admin/mint": {
      "post": {
        "summary": "Add minted amount (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/MintReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    },
    "/admin/burn": {
      "post": {
        "summary": "Add burned amount (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BurnReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "AdminJWT": { "type": "apiKey", "in": "header", "name": "X-Admin-JWT" },
      "BridgeKey": { "type": "apiKey", "in": "header", "name": "X-Bridge-Key" }
    },
    "schemas": {
      "OkMsg": { "type": "object", "properties": { "status": { "type": "string" } }, "required": ["status"] },
      "Head":  { "type": "object", "properties": { "height": { "type": "integer", "format": "uint64" } }, "required": ["height"] },
      "Balance": {
        "type": "object",
        "properties": { "rid": { "type": "string" }, "balance": { "type": "string" }, "nonce": { "type": "integer", "format": "uint64" } },
        "required": ["rid","balance","nonce"]
      },
      "TxIn": {
        "type": "object",
        "properties": {
          "from": { "type": "string" }, "to": { "type": "string" },
          "amount": { "type": "integer", "format": "uint64" },
          "nonce": { "type": "integer", "format": "uint64" },
          "memo": { "type": "string", "nullable": true },
          "sig_hex": { "type": "string" }
        },
        "required": ["from","to","amount","nonce","sig_hex"]
      },
      "SubmitResult": {
        "type": "object",
        "properties": {
          "ok": { "type": "boolean" },
          "txid": { "type": "string", "nullable": true },
          "info": { "type": "string" }
        }, "required": ["ok","info"]
      },
      "Economy": {
        "type": "object",
        "properties": { "supply": { "type": "integer" }, "burned": { "type": "integer" }, "cap": { "type": "integer" } },
        "required": ["supply","burned","cap"]
      },
      "HistoryItem": {
        "type": "object",
        "properties": {
          "txid": { "type": "string" }, "height": { "type": "integer" }, "from": { "type": "string" },
          "to": { "type": "string" }, "amount": { "type": "integer" }, "nonce": { "type": "integer" }, "ts": { "type": "integer", "nullable": true }
        },
        "required": ["txid","height","from","to","amount","nonce"]
      },
      "DepositReq": {
        "type": "object",
        "properties": { "txid":{ "type": "string" }, "amount":{ "type": "integer" }, "from_chain":{ "type": "string" }, "to_rid":{ "type": "string" } },
        "required": ["txid","amount","from_chain","to_rid"]
      },
      "RedeemReq": {
        "type": "object",
        "properties": { "rtoken_tx":{ "type": "string" }, "to_chain":{ "type": "string" }, "to_addr":{ "type": "string" }, "amount":{ "type": "integer" } },
        "required": ["rtoken_tx","to_chain","to_addr","amount"]
      },
      "VerifyReq": {
        "type": "object",
        "properties": { "op_id":{ "type": "string" } }, "required": ["op_id"]
      },
      "BridgeResp": {
        "type": "object",
        "properties": { "ok":{ "type": "boolean" }, "op_id":{ "type": "string" }, "info":{ "type": "string" } },
        "required": ["ok","op_id","info"]
      },
      "SetBalanceReq": { "type": "object", "properties": { "rid":{"type":"string"}, "amount":{"type":"string"} }, "required": ["rid","amount"] },
      "SetNonceReq":   { "type": "object", "properties": { "rid":{"type":"string"}, "value":{"type":"integer"} }, "required": ["rid","value"] },
      "BumpNonceReq":  { "type": "object", "properties": { "rid":{"type":"string"} }, "required": ["rid"] },
      "MintReq":       { "type": "object", "properties": { "amount":{"type":"integer"} }, "required": ["amount"] },
      "BurnReq":       { "type": "object", "properties": { "amount":{"type":"integer"} }, "required": ["amount"] }
    }
  }
}
```


---
## WALLET-PROXY PROJECT (/opt/logos/wallet-proxy)

### TREE (depth 4)

```text
app.py.bak_before_receive_20260106T111020Z
app.py.bak_addbalances_20260106T163304Z
app.py.bak_fix_nextindex_args_20260107T072107Z
app.py.bak_fix_nextidx_20260107T063609Z
app.py.bak_envload_20260106T141419Z
venv/bin/pip3
venv/bin/activate
venv/bin/watchfiles
venv/bin/dotenv
venv/bin/pip
venv/bin/websockets
venv/bin/cbor2
venv/bin/activate.csh
venv/bin/Activate.ps1
venv/bin/edsig
venv/bin/wheel
venv/bin/pip3.12
venv/bin/normalizer
venv/bin/fastapi
venv/bin/uvicorn
venv/bin/activate.fish
venv/pyvenv.cfg
app.py.bak_fix_nextindex_args_20260107T072131Z
app.py.bak_fix_now_20260107T065738Z
app.py.bak_sessionlocal_20260106T151700Z
app.py.bak_addreceive_20260106T145800Z
app.py.bak_fixenv_20260106T142425Z
app.py.bak_fix_nextidx_20260107T063537Z
app.py.bak_racefix_20260106T172201Z
app.py.bak_racefix2_20260106T173142Z
__pycache__/app.cpython-312.pyc
app.py.bak_before_receive_20260106T111045Z
scanner.py
app.py.broken.2025-12-08-1514
app.py.bak_fix_nextindex_call_20260107T064842Z
app.py.bak_racefix_20260106T171015Z
app.py.bak_allocfix_20260106T144700Z
app.py.bak_receive_force_20260106T113739Z
wproxy.db
init_db.py
wallet_proxy.db
app.py
requirements.txt
app.py.bak_addr_20260106T105843Z
app.py.bak_sessionlocal_20260106T151727Z
app.py.bak_fix_nextidx_global_20260107T064301Z
```


### FILE: /opt/logos/wallet-proxy/app.py

```py
import os, json, time, asyncio

# ====== DB session fallback (SessionLocal) ======
# Ensures SessionLocal exists even if earlier patches removed DB setup.
try:
    SessionLocal  # noqa
except NameError:
    try:
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
    except Exception as e:
        raise RuntimeError(f"SQLAlchemy missing or broken: {e}")

    _engine = globals().get("engine") or globals().get("ENGINE")
    if _engine is None:
        DB_URL = (
            os.environ.get("WALLET_PROXY_DB_URL")
            or os.environ.get("DATABASE_URL")
            or "sqlite:////opt/logos/wallet-proxy/wallet_proxy.db"
        )
        if DB_URL.startswith("sqlite"):
            _engine = create_engine(DB_URL, connect_args={"check_same_thread": False})
        else:
            _engine = create_engine(DB_URL)
        globals()["engine"] = _engine

    SessionLocal = sessionmaker(bind=_engine, autocommit=False, autoflush=False)
    globals()["SessionLocal"] = SessionLocal
# ====== /DB session fallback ======
from typing import Optional, Literal

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import Response
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from bip_utils import Bip84, Bip84Coins, Bip44, Bip44Coins, Bip44Changes
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST


# ====== env fallback loader (so systemd/envfile issues won't break XPUB) ======
def _load_env_file(path="/etc/logos/wallet-proxy.env"):
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" not in line:
                    continue
                k, v = line.split("=", 1)
                k = k.strip()
                v = v.strip().strip('"').strip("'")
                # do not override existing env
                if k and k not in os.environ:
                    os.environ[k] = v
    except FileNotFoundError:
        pass
    except Exception as e:
        print("WARN: failed to load env file:", e)

_load_env_file()

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
BTC_XPUB     = os.environ.get("BTC_XPUB", "")
ETH_XPUB     = os.environ.get("ETH_XPUB", "")
TRON_XPUB    = os.environ.get("TRON_XPUB", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()

class DepositMap(Base):
    __tablename__ = "deposit_map"
    id         = Column(Integer, primary_key=True)
    rid        = Column(String, index=True, nullable=False)
    token      = Column(String, nullable=False)
    network    = Column(String, nullable=False)
    index      = Column(Integer, nullable=False, default=0)
    address    = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda: int(time.time()))

Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id      = Column(Integer, primary_key=True)
    txid    = Column(String, unique=True, nullable=False)
    rid     = Column(String, index=True)
    token   = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout": 10}))
        if w3.is_connected():
            USDT = w3.eth.contract(
                address=Web3.to_checksum_address(USDT_ADDRESS),
                abi=ERC20_ABI,
            )
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable")
            w3 = None
    except Exception as e:
        print("WARN web3 init error:", e)
        w3 = None
        USDT = None

# ====== HTTP helper ======
async def http_json(method: str, url: str, body: dict = None, headers: dict = None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try:
                data = json.loads(t) if t else {}
            except Exception:
                data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(
    CORSMiddleware,
    allow_origins=CORS if CORS else ["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"

class TopupResponse(BaseModel):
    rid: str
    token: str
    network: str
    address: str

class WithdrawRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
    amount: int
    to_address: str
    request_id: str

class QuoteRequest(BaseModel):
    from_token: str
    to_token: str
    amount: int

class QuoteResponse(BaseModel):
    price: float
    expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ    = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK  = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR = Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)



# ====== Address derivation (watch-only) ======

# ====== Address derivation (watch-only) ======
# NOTE: address must be globally unique in deposit_map.address
# so we allocate a unique index per chain and retry on collisions.

from sqlalchemy.exc import IntegrityError
from bip_utils import Bip84, Bip84Coins, Bip44, Bip44Coins, Bip44Changes

def _require_env(name: str) -> str:
    v = (os.environ.get(name, "") or "").strip()
    if not v:
        raise HTTPException(status_code=500, detail=f"{name} not configured")
    return v

def _derive_address(chain: str, index: int) -> str:
    chain = chain.upper()
    if chain == "BTC":
        key = _require_env("BTC_XPUB")  # actually zpub ok
        acc = Bip84.FromExtendedKey(key, Bip84Coins.BITCOIN)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    if chain == "ETH":
        key = _require_env("ETH_XPUB")
        acc = Bip44.FromExtendedKey(key, Bip44Coins.ETHEREUM)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    if chain == "TRON":
        key = _require_env("TRON_XPUB")
        acc = Bip44.FromExtendedKey(key, Bip44Coins.TRON)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    raise HTTPException(status_code=400, detail=f"unsupported chain: {chain}")

def _chain_from(token: str, network: str) -> str:
    # нормализуем в "цепь", чтобы USDT на ETH использовал тот же пул адресов ETH
    n = (network or "").upper()
    if n in ("ETH", "ETHEREUM", "ERC20"):
        return "ETH"
    if n in ("TRON", "TRC20"):
        return "TRON"
    if n in ("BTC", "BITCOIN"):
        return "BTC"
    return n

def _next_index(sess, chain: str) -> int:
    # глобальный next index по цепи (не по RID!)
    q = sess.query(DepositMap).filter(DepositMap.network == chain).order_by(DepositMap.index.desc()).first()
    if not q:
        return 0
    try:
        return int(q.index) + 1
    except Exception:
        return 0

def _get_or_create_addr(rid: str, token: str, network: str) -> str:
    chain = _chain_from(token, network)

    # 1) если уже есть адрес для rid+chain — вернём
    with SessionLocal() as sess:
        row = sess.query(DepositMap).filter(
            DepositMap.rid == rid,
            DepositMap.network == chain
        ).first()
        if row:
            return row.address

        # 2) выделяем уникальный индекс по chain
        for _ in range(0, 2048):
            idx = _next_index(sess, chain) + _
            addr = _derive_address(chain, idx)

            obj = DepositMap(
                rid=rid,
                token=token,
                network=chain,
                index=idx,
                address=addr,
                created_at=int(time.time()),
            )

            sess.add(obj)

            # --- race-safe commit ---
            try:
                sess.commit()
                return addr
            except IntegrityError:
                sess.rollback()

                # 1) если параллельный запрос уже создал маппинг для этого кошелька — просто вернём его
                row2 = sess.query(DepositMap).filter(
                    DepositMap.rid == rid,
                    DepositMap.token == token,
                    DepositMap.network == chain
                ).first()
                if row2:
                    return row2.address

                # 2) иначе это коллизия по address/index (или другой UNIQUE) — пробуем следующий idx
                continue

        raise HTTPException(status_code=500, detail="unable to allocate unique address")
# ====== Endpoints ======

# --- receive addresses (watch-only) ---
@app.get("/v1/receive/{rid}")
def receive_addresses(rid: str):
    rid = (rid or "").strip()
    if not rid:
        raise HTTPException(status_code=400, detail="rid is required")

    # BTC / ETH / TRON: один адрес на цепь.
    # USDT на ETH/TRON использует тот же адрес соответствующей цепи.
    addrs = {
        "BTC": _get_or_create_addr(rid, "BTC", "BTC"),
        "ETH": _get_or_create_addr(rid, "ETH", "ETH"),
        "TRON": _get_or_create_addr(rid, "TRON", "TRON"),
        "USDT_ERC20": _get_or_create_addr(rid, "USDT", "ETH"),
        "USDT_TRC20": _get_or_create_addr(rid, "USDT", "TRON"),
    }
    return {"rid": rid, "lgn_rid": rid, "addresses": addrs}



# --- balances (live) ---
from decimal import Decimal
import time

_USDT_ETH = "0xdAC17F958D2ee523a2206206994597C13D831ec7"  # USDT ERC20 mainnet
_USDT_TRON = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"         # USDT TRC20 (Tether)

_ERC20_ABI_MIN = [
    {"name":"balanceOf","type":"function","stateMutability":"view",
     "inputs":[{"name":"account","type":"address"}],
     "outputs":[{"name":"","type":"uint256"}]},
    {"name":"decimals","type":"function","stateMutability":"view",
     "inputs":[], "outputs":[{"name":"","type":"uint8"}]},
]

def _d(x, q=18):
    try:
        return str((Decimal(x) / (Decimal(10) ** Decimal(q))).normalize())
    except Exception:
        return None

def _http_get_json(url: str, params=None, timeout=12):
    # requests может не быть -> fallback на urllib
    try:
        import requests
        r = requests.get(url, params=params, timeout=timeout, headers={"User-Agent":"logos-wallet-proxy/1.0"})
        r.raise_for_status()
        return r.json()
    except Exception:
        import json, urllib.request, urllib.parse
        if params:
            url = url + ("&" if "?" in url else "?") + urllib.parse.urlencode(params)
        req = urllib.request.Request(url, headers={"User-Agent":"logos-wallet-proxy/1.0"})
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            return json.loads(resp.read().decode("utf-8", "ignore"))

def _btc_balance_blockstream(addr: str):
    # confirmed + mempool balances in sats
    j = _http_get_json(f"https://blockstream.info/api/address/{addr}")
    cs = j.get("chain_stats") or {}
    ms = j.get("mempool_stats") or {}
    confirmed = int(cs.get("funded_txo_sum", 0)) - int(cs.get("spent_txo_sum", 0))
    mempool = int(ms.get("funded_txo_sum", 0)) - int(ms.get("spent_txo_sum", 0))
    total = confirmed + mempool
    return {
        "confirmed_sat": confirmed,
        "mempool_sat": mempool,
        "total_sat": total,
        "total_btc": _d(total, 8),
        "source": "blockstream.info"
    }

def _eth_balances_web3(addr: str):
    # web3 instance
    try:
        w3 = globals().get("w3") or globals().get("W3")
        if w3 is None:
            from web3 import Web3
            w3 = Web3(Web3.HTTPProvider(_require_env("ETH_PROVIDER_URL"), request_kwargs={"timeout": 12}))
            globals()["w3"] = w3
        if not w3.is_connected():
            return {"error": "ETH provider not connected"}

        wei = int(w3.eth.get_balance(addr))
        out = {"wei": wei, "eth": _d(wei, 18), "source": "web3"}

        # USDT ERC20
        c = w3.eth.contract(address=w3.to_checksum_address(_USDT_ETH), abi=_ERC20_ABI_MIN)
        try:
            dec = int(c.functions.decimals().call())
        except Exception:
            dec = 6
        raw = int(c.functions.balanceOf(w3.to_checksum_address(addr)).call())
        out["usdt_erc20"] = {"raw": raw, "usdt": _d(raw, dec), "decimals": dec, "contract": _USDT_ETH}
        return out
    except Exception as e:
        return {"error": f"eth_web3_failed: {e}"}

def _tron_balances(addr: str):
    # 1) try tronpy (if installed)
    try:
        from tronpy import Tron
        client = Tron()
        trx = client.get_account_balance(addr)  # float TRX
        # TRC20 USDT
        usdt = client.get_contract(_USDT_TRON).functions.balanceOf(addr)
        usdt_raw = int(usdt)
        return {
            "trx": str(trx),
            "sun": int(Decimal(trx) * Decimal(1_000_000)),
            "usdt_trc20": {"raw": usdt_raw, "usdt": _d(usdt_raw, 6), "decimals": 6, "contract": _USDT_TRON},
            "source": "tronpy"
        }
    except Exception:
        pass

    # 2) fallback: tronscan public api
    try:
        j = _http_get_json("https://apilist.tronscanapi.com/api/account", params={"address": addr})
        # TRX
        bal_sun = int(j.get("balance", 0))
        out = {
            "sun": bal_sun,
            "trx": _d(bal_sun, 6),
            "source": "tronscan"
        }
        # USDT TRC20 from token balances
        tb = j.get("trc20token_balances") or j.get("trc20TokenBalances") or []
        usdt_raw = None
        for it in tb:
            ca = (it.get("contract_address") or it.get("contractAddress") or "").strip()
            if ca == _USDT_TRON:
                usdt_raw = it.get("balance") or it.get("tokenBalance") or it.get("quantity")
                break
        if usdt_raw is not None:
            try:
                usdt_raw = int(str(usdt_raw))
            except Exception:
                usdt_raw = None
        out["usdt_trc20"] = {"raw": usdt_raw, "usdt": _d(usdt_raw or 0, 6), "decimals": 6, "contract": _USDT_TRON}
        return out
    except Exception as e:
        return {"error": f"tron_failed: {e}"}

@app.get("/v1/balances/{rid}")
def balances(rid: str):
    rid = (rid or "").strip()
    if not rid:
        raise HTTPException(status_code=400, detail="rid is required")

    # addresses (ensure mapping exists)
    addrs = {
        "BTC": _get_or_create_addr(rid, "BTC", "BTC"),
        "ETH": _get_or_create_addr(rid, "ETH", "ETH"),
        "TRON": _get_or_create_addr(rid, "TRON", "TRON"),
        "USDT_ERC20": _get_or_create_addr(rid, "USDT", "ETH"),
        "USDT_TRC20": _get_or_create_addr(rid, "USDT", "TRON"),
    }

    t0 = time.time()
    out = {
        "rid": rid,
        "addresses": addrs,
        "balances": {},
        "ts": int(time.time())
    }

    # BTC
    try:
        out["balances"]["BTC"] = _btc_balance_blockstream(addrs["BTC"])
    except Exception as e:
        out["balances"]["BTC"] = {"error": f"btc_failed: {e}"}

    # ETH + USDT_ERC20
    out["balances"]["ETH"] = _eth_balances_web3(addrs["ETH"])

    # TRON + USDT_TRC20
    out["balances"]["TRON"] = _tron_balances(addrs["TRON"])

    out["latency_ms"] = int((time.time() - t0) * 1000)
    return out
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3:
        raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK:
        raise HTTPException(500, "HOT wallet not configured")

    deposit_address = w3.eth.account.from_key(HOT_PK).address

    with Session(engine) as s:
        dm = s.execute(
            select(DepositMap).where(
                DepositMap.rid == req.rid,
                DepositMap.token == req.token,
                DepositMap.network == req.network,
            )
        ).scalar_one_or_none()
        if dm is None:
            s.add(
                DepositMap(
                    rid=req.rid,
                    token=req.token,
                    network=req.network,
                    address=deposit_address,
                )
            )
            s.commit()

    return TopupResponse(
        rid=req.rid,
        token=req.token,
        network=req.network,
        address=deposit_address,
    )

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount <= 0:
            raise HTTPException(400, "amount<=0")
        if not w3 or not USDT:
            raise HTTPException(503, "ETH RPC not connected")

        acct = w3.eth.account.from_key(HOT_PK)

        # redeem из LRB-ноды
        hdr = (
            {"X-Bridge-Key": BRIDGE_KEY}
            if not BRIDGE_KEY.startswith("ey")
            else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        )
        st, data = await http_json(
            "POST",
            f"{NODE_URL}/bridge/redeem",
            {
                "rid": req.rid,
                "amount": req.amount,
                "request_id": req.request_id,
            },
            hdr,
        )
        if st // 100 != 2:
            raise HTTPException(st, f"bridge redeem failed: {data}")

        # ERC-20 перевод USDT
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(
            Web3.to_checksum_address(req.to_address),
            int(req.amount),
        ).build_transaction(
            {
                "chainId": w3.eth.chain_id,
                "from": acct.address,
                "nonce": nonce,
                "gas": 90000,
                "maxFeePerGas": w3.to_wei("30", "gwei"),
                "maxPriorityFeePerGas": w3.to_wei("1", "gwei"),
            }
        )
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()

        with Session(engine) as s:
            s.add(
                SeenTx(
                    txid=tx_hash,
                    rid=req.rid,
                    token=req.token,
                    network=req.network,
                )
            )
            s.commit()

        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc()
        raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc()
        raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))
```


### FILE: /opt/logos/wallet-proxy/init_db.py

```py
import os, sqlite3, sys

def db_path_from_url(url: str) -> str:
    url = (url or "").strip()
    if not url:
        return "/opt/logos/wallet-proxy/wallet_proxy.db"
    if url.startswith("sqlite:////"):
        return url[len("sqlite:////")-1:]  # keep leading /
    if url.startswith("sqlite:///"):
        return url[len("sqlite:///"):]
    if url.startswith("sqlite://"):
        # rare, but handle
        return url.replace("sqlite://", "", 1)
    # not sqlite -> do nothing here
    return ""

DB_URL = os.environ.get("WALLET_PROXY_DB_URL") or os.environ.get("DATABASE_URL") or "sqlite:////opt/logos/wallet-proxy/wallet_proxy.db"
path = db_path_from_url(DB_URL)

if not path:
    print("INFO: non-sqlite DB configured, skip init_db")
    sys.exit(0)

os.makedirs(os.path.dirname(path), exist_ok=True)

con = sqlite3.connect(path)
cur = con.cursor()

cur.execute("""
CREATE TABLE IF NOT EXISTS deposit_map (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  rid TEXT NOT NULL,
  token TEXT NOT NULL,
  network TEXT NOT NULL,
  "index" INTEGER NOT NULL DEFAULT 0,
  address TEXT NOT NULL,
  created_at INTEGER NOT NULL
);
""")

# глобальная уникальность адреса (у тебя это уже требуется по логике)
cur.execute("""CREATE UNIQUE INDEX IF NOT EXISTS ux_deposit_map_address ON deposit_map(address);""")

# чтобы быстро находить по (rid, network) — под ваш SELECT
cur.execute("""CREATE INDEX IF NOT EXISTS ix_deposit_map_rid_network ON deposit_map(rid, network);""")

con.commit()
con.close()

print("OK: init_db done ->", path)
```


### FILE: /opt/logos/wallet-proxy/requirements.txt

```
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1
```


### FILE: /opt/logos/wallet-proxy/scanner.py

```py
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())
```


---
## NODE-API / WALLET-API RELATED SOURCES (found by grep)

Found files: 16

```text
/opt/logos/wallet-proxy/app.py
/root/logos_lrb/Cargo.toml
/root/logos_lrb/LOGOS_LRB_FULL_BOOK.md
/root/logos_lrb/docs/LRB_SNAPSHOT_20250904_1426.txt
/root/logos_lrb/infra/nginx/lrb_wallet.conf
/root/logos_lrb/infra/systemd/lrb-proxy.service
/root/logos_lrb/modules/x_guard/Cargo.toml
/root/logos_lrb/node/Cargo.toml
/root/logos_lrb/node/openapi/openapi.json
/root/logos_lrb/node/src/openapi.json
/root/logos_lrb/node/src/openapi/openapi.json
/root/logos_lrb/www/wallet/api_base.js
/root/logos_lrb/www/wallet/app.html
/root/logos_lrb/www/wallet/app.js
/root/logos_lrb/www/wallet/compat.js
/root/logos_lrb/www/wallet/ui.js
```


### FILE: /opt/logos/wallet-proxy/app.py

```py
import os, json, time, asyncio

# ====== DB session fallback (SessionLocal) ======
# Ensures SessionLocal exists even if earlier patches removed DB setup.
try:
    SessionLocal  # noqa
except NameError:
    try:
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
    except Exception as e:
        raise RuntimeError(f"SQLAlchemy missing or broken: {e}")

    _engine = globals().get("engine") or globals().get("ENGINE")
    if _engine is None:
        DB_URL = (
            os.environ.get("WALLET_PROXY_DB_URL")
            or os.environ.get("DATABASE_URL")
            or "sqlite:////opt/logos/wallet-proxy/wallet_proxy.db"
        )
        if DB_URL.startswith("sqlite"):
            _engine = create_engine(DB_URL, connect_args={"check_same_thread": False})
        else:
            _engine = create_engine(DB_URL)
        globals()["engine"] = _engine

    SessionLocal = sessionmaker(bind=_engine, autocommit=False, autoflush=False)
    globals()["SessionLocal"] = SessionLocal
# ====== /DB session fallback ======
from typing import Optional, Literal

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import Response
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from bip_utils import Bip84, Bip84Coins, Bip44, Bip44Coins, Bip44Changes
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST


# ====== env fallback loader (so systemd/envfile issues won't break XPUB) ======
def _load_env_file(path="/etc/logos/wallet-proxy.env"):
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" not in line:
                    continue
                k, v = line.split("=", 1)
                k = k.strip()
                v = v.strip().strip('"').strip("'")
                # do not override existing env
                if k and k not in os.environ:
                    os.environ[k] = v
    except FileNotFoundError:
        pass
    except Exception as e:
        print("WARN: failed to load env file:", e)

_load_env_file()

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
BTC_XPUB     = os.environ.get("BTC_XPUB", "")
ETH_XPUB     = os.environ.get("ETH_XPUB", "")
TRON_XPUB    = os.environ.get("TRON_XPUB", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()

class DepositMap(Base):
    __tablename__ = "deposit_map"
    id         = Column(Integer, primary_key=True)
    rid        = Column(String, index=True, nullable=False)
    token      = Column(String, nullable=False)
    network    = Column(String, nullable=False)
    index      = Column(Integer, nullable=False, default=0)
    address    = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda: int(time.time()))

Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id      = Column(Integer, primary_key=True)
    txid    = Column(String, unique=True, nullable=False)
    rid     = Column(String, index=True)
    token   = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout": 10}))
        if w3.is_connected():
            USDT = w3.eth.contract(
                address=Web3.to_checksum_address(USDT_ADDRESS),
                abi=ERC20_ABI,
            )
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable")
            w3 = None
    except Exception as e:
        print("WARN web3 init error:", e)
        w3 = None
        USDT = None

# ====== HTTP helper ======
async def http_json(method: str, url: str, body: dict = None, headers: dict = None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try:
                data = json.loads(t) if t else {}
            except Exception:
                data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(
    CORSMiddleware,
    allow_origins=CORS if CORS else ["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"

class TopupResponse(BaseModel):
    rid: str
    token: str
    network: str
    address: str

class WithdrawRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
    amount: int
    to_address: str
    request_id: str

class QuoteRequest(BaseModel):
    from_token: str
    to_token: str
    amount: int

class QuoteResponse(BaseModel):
    price: float
    expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ    = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK  = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR = Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)



# ====== Address derivation (watch-only) ======

# ====== Address derivation (watch-only) ======
# NOTE: address must be globally unique in deposit_map.address
# so we allocate a unique index per chain and retry on collisions.

from sqlalchemy.exc import IntegrityError
from bip_utils import Bip84, Bip84Coins, Bip44, Bip44Coins, Bip44Changes

def _require_env(name: str) -> str:
    v = (os.environ.get(name, "") or "").strip()
    if not v:
        raise HTTPException(status_code=500, detail=f"{name} not configured")
    return v

def _derive_address(chain: str, index: int) -> str:
    chain = chain.upper()
    if chain == "BTC":
        key = _require_env("BTC_XPUB")  # actually zpub ok
        acc = Bip84.FromExtendedKey(key, Bip84Coins.BITCOIN)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    if chain == "ETH":
        key = _require_env("ETH_XPUB")
        acc = Bip44.FromExtendedKey(key, Bip44Coins.ETHEREUM)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    if chain == "TRON":
        key = _require_env("TRON_XPUB")
        acc = Bip44.FromExtendedKey(key, Bip44Coins.TRON)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    raise HTTPException(status_code=400, detail=f"unsupported chain: {chain}")

def _chain_from(token: str, network: str) -> str:
    # нормализуем в "цепь", чтобы USDT на ETH использовал тот же пул адресов ETH
    n = (network or "").upper()
    if n in ("ETH", "ETHEREUM", "ERC20"):
        return "ETH"
    if n in ("TRON", "TRC20"):
        return "TRON"
    if n in ("BTC", "BITCOIN"):
        return "BTC"
    return n

def _next_index(sess, chain: str) -> int:
    # глобальный next index по цепи (не по RID!)
    q = sess.query(DepositMap).filter(DepositMap.network == chain).order_by(DepositMap.index.desc()).first()
    if not q:
        return 0
    try:
        return int(q.index) + 1
    except Exception:
        return 0

def _get_or_create_addr(rid: str, token: str, network: str) -> str:
    chain = _chain_from(token, network)

    # 1) если уже есть адрес для rid+chain — вернём
    with SessionLocal() as sess:
        row = sess.query(DepositMap).filter(
            DepositMap.rid == rid,
            DepositMap.network == chain
        ).first()
        if row:
            return row.address

        # 2) выделяем уникальный индекс по chain
        for _ in range(0, 2048):
            idx = _next_index(sess, chain) + _
            addr = _derive_address(chain, idx)

            obj = DepositMap(
                rid=rid,
                token=token,
                network=chain,
                index=idx,
                address=addr,
                created_at=int(time.time()),
            )

            sess.add(obj)

            # --- race-safe commit ---
            try:
                sess.commit()
                return addr
            except IntegrityError:
                sess.rollback()

                # 1) если параллельный запрос уже создал маппинг для этого кошелька — просто вернём его
                row2 = sess.query(DepositMap).filter(
                    DepositMap.rid == rid,
                    DepositMap.token == token,
                    DepositMap.network == chain
                ).first()
                if row2:
                    return row2.address

                # 2) иначе это коллизия по address/index (или другой UNIQUE) — пробуем следующий idx
                continue

        raise HTTPException(status_code=500, detail="unable to allocate unique address")
# ====== Endpoints ======

# --- receive addresses (watch-only) ---
@app.get("/v1/receive/{rid}")
def receive_addresses(rid: str):
    rid = (rid or "").strip()
    if not rid:
        raise HTTPException(status_code=400, detail="rid is required")

    # BTC / ETH / TRON: один адрес на цепь.
    # USDT на ETH/TRON использует тот же адрес соответствующей цепи.
    addrs = {
        "BTC": _get_or_create_addr(rid, "BTC", "BTC"),
        "ETH": _get_or_create_addr(rid, "ETH", "ETH"),
        "TRON": _get_or_create_addr(rid, "TRON", "TRON"),
        "USDT_ERC20": _get_or_create_addr(rid, "USDT", "ETH"),
        "USDT_TRC20": _get_or_create_addr(rid, "USDT", "TRON"),
    }
    return {"rid": rid, "lgn_rid": rid, "addresses": addrs}



# --- balances (live) ---
from decimal import Decimal
import time

_USDT_ETH = "0xdAC17F958D2ee523a2206206994597C13D831ec7"  # USDT ERC20 mainnet
_USDT_TRON = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"         # USDT TRC20 (Tether)

_ERC20_ABI_MIN = [
    {"name":"balanceOf","type":"function","stateMutability":"view",
     "inputs":[{"name":"account","type":"address"}],
     "outputs":[{"name":"","type":"uint256"}]},
    {"name":"decimals","type":"function","stateMutability":"view",
     "inputs":[], "outputs":[{"name":"","type":"uint8"}]},
]

def _d(x, q=18):
    try:
        return str((Decimal(x) / (Decimal(10) ** Decimal(q))).normalize())
    except Exception:
        return None

def _http_get_json(url: str, params=None, timeout=12):
    # requests может не быть -> fallback на urllib
    try:
        import requests
        r = requests.get(url, params=params, timeout=timeout, headers={"User-Agent":"logos-wallet-proxy/1.0"})
        r.raise_for_status()
        return r.json()
    except Exception:
        import json, urllib.request, urllib.parse
        if params:
            url = url + ("&" if "?" in url else "?") + urllib.parse.urlencode(params)
        req = urllib.request.Request(url, headers={"User-Agent":"logos-wallet-proxy/1.0"})
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            return json.loads(resp.read().decode("utf-8", "ignore"))

def _btc_balance_blockstream(addr: str):
    # confirmed + mempool balances in sats
    j = _http_get_json(f"https://blockstream.info/api/address/{addr}")
    cs = j.get("chain_stats") or {}
    ms = j.get("mempool_stats") or {}
    confirmed = int(cs.get("funded_txo_sum", 0)) - int(cs.get("spent_txo_sum", 0))
    mempool = int(ms.get("funded_txo_sum", 0)) - int(ms.get("spent_txo_sum", 0))
    total = confirmed + mempool
    return {
        "confirmed_sat": confirmed,
        "mempool_sat": mempool,
        "total_sat": total,
        "total_btc": _d(total, 8),
        "source": "blockstream.info"
    }

def _eth_balances_web3(addr: str):
    # web3 instance
    try:
        w3 = globals().get("w3") or globals().get("W3")
        if w3 is None:
            from web3 import Web3
            w3 = Web3(Web3.HTTPProvider(_require_env("ETH_PROVIDER_URL"), request_kwargs={"timeout": 12}))
            globals()["w3"] = w3
        if not w3.is_connected():
            return {"error": "ETH provider not connected"}

        wei = int(w3.eth.get_balance(addr))
        out = {"wei": wei, "eth": _d(wei, 18), "source": "web3"}

        # USDT ERC20
        c = w3.eth.contract(address=w3.to_checksum_address(_USDT_ETH), abi=_ERC20_ABI_MIN)
        try:
            dec = int(c.functions.decimals().call())
        except Exception:
            dec = 6
        raw = int(c.functions.balanceOf(w3.to_checksum_address(addr)).call())
        out["usdt_erc20"] = {"raw": raw, "usdt": _d(raw, dec), "decimals": dec, "contract": _USDT_ETH}
        return out
    except Exception as e:
        return {"error": f"eth_web3_failed: {e}"}

def _tron_balances(addr: str):
    # 1) try tronpy (if installed)
    try:
        from tronpy import Tron
        client = Tron()
        trx = client.get_account_balance(addr)  # float TRX
        # TRC20 USDT
        usdt = client.get_contract(_USDT_TRON).functions.balanceOf(addr)
        usdt_raw = int(usdt)
        return {
            "trx": str(trx),
            "sun": int(Decimal(trx) * Decimal(1_000_000)),
            "usdt_trc20": {"raw": usdt_raw, "usdt": _d(usdt_raw, 6), "decimals": 6, "contract": _USDT_TRON},
            "source": "tronpy"
        }
    except Exception:
        pass

    # 2) fallback: tronscan public api
    try:
        j = _http_get_json("https://apilist.tronscanapi.com/api/account", params={"address": addr})
        # TRX
        bal_sun = int(j.get("balance", 0))
        out = {
            "sun": bal_sun,
            "trx": _d(bal_sun, 6),
            "source": "tronscan"
        }
        # USDT TRC20 from token balances
        tb = j.get("trc20token_balances") or j.get("trc20TokenBalances") or []
        usdt_raw = None
        for it in tb:
            ca = (it.get("contract_address") or it.get("contractAddress") or "").strip()
            if ca == _USDT_TRON:
                usdt_raw = it.get("balance") or it.get("tokenBalance") or it.get("quantity")
                break
        if usdt_raw is not None:
            try:
                usdt_raw = int(str(usdt_raw))
            except Exception:
                usdt_raw = None
        out["usdt_trc20"] = {"raw": usdt_raw, "usdt": _d(usdt_raw or 0, 6), "decimals": 6, "contract": _USDT_TRON}
        return out
    except Exception as e:
        return {"error": f"tron_failed: {e}"}

@app.get("/v1/balances/{rid}")
def balances(rid: str):
    rid = (rid or "").strip()
    if not rid:
        raise HTTPException(status_code=400, detail="rid is required")

    # addresses (ensure mapping exists)
    addrs = {
        "BTC": _get_or_create_addr(rid, "BTC", "BTC"),
        "ETH": _get_or_create_addr(rid, "ETH", "ETH"),
        "TRON": _get_or_create_addr(rid, "TRON", "TRON"),
        "USDT_ERC20": _get_or_create_addr(rid, "USDT", "ETH"),
        "USDT_TRC20": _get_or_create_addr(rid, "USDT", "TRON"),
    }

    t0 = time.time()
    out = {
        "rid": rid,
        "addresses": addrs,
        "balances": {},
        "ts": int(time.time())
    }

    # BTC
    try:
        out["balances"]["BTC"] = _btc_balance_blockstream(addrs["BTC"])
    except Exception as e:
        out["balances"]["BTC"] = {"error": f"btc_failed: {e}"}

    # ETH + USDT_ERC20
    out["balances"]["ETH"] = _eth_balances_web3(addrs["ETH"])

    # TRON + USDT_TRC20
    out["balances"]["TRON"] = _tron_balances(addrs["TRON"])

    out["latency_ms"] = int((time.time() - t0) * 1000)
    return out
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3:
        raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK:
        raise HTTPException(500, "HOT wallet not configured")

    deposit_address = w3.eth.account.from_key(HOT_PK).address

    with Session(engine) as s:
        dm = s.execute(
            select(DepositMap).where(
                DepositMap.rid == req.rid,
                DepositMap.token == req.token,
                DepositMap.network == req.network,
            )
        ).scalar_one_or_none()
        if dm is None:
            s.add(
                DepositMap(
                    rid=req.rid,
                    token=req.token,
                    network=req.network,
                    address=deposit_address,
                )
            )
            s.commit()

    return TopupResponse(
        rid=req.rid,
        token=req.token,
        network=req.network,
        address=deposit_address,
    )

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount <= 0:
            raise HTTPException(400, "amount<=0")
        if not w3 or not USDT:
            raise HTTPException(503, "ETH RPC not connected")

        acct = w3.eth.account.from_key(HOT_PK)

        # redeem из LRB-ноды
        hdr = (
            {"X-Bridge-Key": BRIDGE_KEY}
            if not BRIDGE_KEY.startswith("ey")
            else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        )
        st, data = await http_json(
            "POST",
            f"{NODE_URL}/bridge/redeem",
            {
                "rid": req.rid,
                "amount": req.amount,
                "request_id": req.request_id,
            },
            hdr,
        )
        if st // 100 != 2:
            raise HTTPException(st, f"bridge redeem failed: {data}")

        # ERC-20 перевод USDT
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(
            Web3.to_checksum_address(req.to_address),
            int(req.amount),
        ).build_transaction(
            {
                "chainId": w3.eth.chain_id,
                "from": acct.address,
                "nonce": nonce,
                "gas": 90000,
                "maxFeePerGas": w3.to_wei("30", "gwei"),
                "maxPriorityFeePerGas": w3.to_wei("1", "gwei"),
            }
        )
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()

        with Session(engine) as s:
            s.add(
                SeenTx(
                    txid=tx_hash,
                    rid=req.rid,
                    token=req.token,
                    network=req.network,
                )
            )
            s.commit()

        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc()
        raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc()
        raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))
```


### FILE: /root/logos_lrb/Cargo.toml

```toml
[workspace]
members = ["lrb_core","node","modules/x_guard"]
resolver = "2"

[workspace.package]
edition = "2021"
rust-version = "1.78"

[workspace.dependencies]
prometheus = "0.13"
once_cell = "1.19"
ipnet = "2"
r2d2             = "0.8"
r2d2_sqlite      = "0.24"
rusqlite         = { version = "0.31", features = ["bundled"] }
tokio-postgres   = "0.7.9"
deadpool-postgres = "0.14"
dashmap = "6"
# web/async
axum = { version = "0.7", features = ["macros"] }
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
tokio = { version = "1.40", features = ["full"] }

# core utils
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
thiserror = "1.0"
anyhow = "1.0"
bytes = "1.6"
time = { version = "0.3", features = ["macros"] }

# logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# crypto / hash / codecs
ring = "0.17"
rand = "0.8"
ed25519-dalek = { version = "2.2", default-features = false, features = ["rand_core","std"] }
sha2 = "0.10"
blake3 = "1.5"
hex = "0.4"
base64 = "0.22"
bs58 = "0.5"
uuid = { version = "1.8", features = ["v4"] }
bincode = "1.3"
jsonwebtoken = "9"

# storage / http
sled = "0.34"
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls","http2","json"] }
```


### FILE: /root/logos_lrb/LOGOS_LRB_FULL_BOOK.md

```md
# FULL LIVE SNAPSHOT — 2025-09-06T12:06:38Z
# sources: /root/logos_lrb + infra (/etc, /opt)
# size limit per file: 2000000 bytes


## FILE: /root/logos_lrb/Cargo.toml  (size=713b)
```
[workspace]
members = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition = "2021"
license = "Proprietary"
name = "logos_lrb_workspace"
version = "0.1.0"

[workspace.dependencies]
anyhow = "1"
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
axum = "0.7"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time"] }
blake3 = "1"
bs58 = "0.5"
ed25519-dalek = { version = "2", features = ["serde"] }
rand = "0.8"
rand_core = "0.6"
sled = "0.34"
once_cell = "1"
uuid = { version = "1", features = ["v4", "serde"] }
hyper = "1"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
time = "0.3"
base64 = "0.22"
hex = "0.4"

```

## FILE: /root/logos_lrb/configs/env/node-a.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_DATA_DIR=/var/lib/logos-a
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /root/logos_lrb/configs/env/node-b.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8082
LRB_DATA_DIR=/var/lib/logos-b
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /root/logos_lrb/configs/env/node-c.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8084
LRB_DATA_DIR=/var/lib/logos-c
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /root/logos_lrb/configs/genesis.yaml  (SKIPPED, empty)

## FILE: /root/logos_lrb/configs/keys.env.example  (size=419b)
```
# LOGOS node (пример ENV)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_SLOT_MS=500
LRB_MAX_BLOCK_TX=10000
LRB_MEMPOOL_CAP=100000
LRB_MAX_AMOUNT=18446744073709551615
LRB_BRIDGE_MAX_PER_TX=10000000

# Секреты — задаются ТОЛЬКО вне репозитория:
# LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
# LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=<optional>

```

## FILE: /root/logos_lrb/configs/logos_config.yaml  (SKIPPED, empty)

## FILE: /root/logos_lrb/configs/proxy.env.example  (size=443b)
```
# Wallet Proxy / Scanner (пример ENV)
# !!! НЕ коммить настоящие ключи/приватники !!!
ETH_PROVIDER_URL=https://mainnet.infura.io/v3/XXXX...
USDT_CONTRACT=0xdAC17F958D2ee523a2206206994597C13D831ec7

# hot-кошелёк оператора (для withdraw/fee)
HOT_WALLET_ADDRESS=0x...
HOT_WALLET_PRIVATE_KEY= # НЕ класть в git, подставлять только в прод окружении

```

## FILE: /root/logos_lrb/core/beta_rollout.yaml  (size=3586b)
```
yaml
version: 1.1

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

phases:
  - phase: "alpha"
    name: "Закрытый Резонанс"
    description: "Только для внутренних валидаторов. Проверка фаз, Λ0 и Σ(t)."
    max_nodes: 10
    validators_only: true
    duration_days: 14
    lgn_stake_required: 144.0
    activation: manual
    required_symbol: "Λ0"
    tasks:
      - "Проверка фазовой синхронизации"
      - "Отладка rcp_engine и phase_stabilizer"
      - "Первая фиксация Λ0 в реальных условиях"
      - "Симуляция сбоя 50% узлов"
    logs: "alpha_rollout_log.json"

  - phase: "beta-private"
    name: "Приватная сеть 81"
    description: "Подключение 81 участника с проверенными RID. Первые ритуалы, распределение rLGN."
    max_nodes: 81
    validators_only: false
    whitelist_required: true
    duration_days: 21
    lgn_stake_required: 81.0
    activation: semi-automatic
    required_symbol: "Λ0"
    tasks:
      - "Ритуальный вход через onboarding_sim.py"
      - "Активация DAO миссий"
      - "Проверка recall, spam_guard и scaler"
      - "Симуляция фазового спама"
    logs: "beta_private_log.json"

  - phase: "beta-open"
    name: "Открытый тест 1000"
    description: "До 1000 узлов. Публичная демонстрация Σ(t), резонансных транзакций и DAO-механики."
    max_nodes: 1000
    validators_only: false
    whitelist_required: false
    duration_days: 30
    lgn_stake_required: 0
    activation: public
    required_symbol: "any"
    tasks:
      - "Запуск фазы голосования через community_dao.yaml"
      - "Анализ логов via resonance_feedback.py"
      - "Публичные квесты через ritual_quest.py"
      - "Тестирование потери 30% узлов"
    logs: "beta_open_log.json"

  - phase: "mainnet-init"
    name: "Инициация Mainnet"
    description: "Активация основной сети LOGOS. Поддержка >10k узлов. Подпись через Λ0 и DAO-кворум."
    max_nodes: 10000
    validators_only: false
    whitelist_required: false
    duration_days: 9999
    lgn_stake_required: 0
    activation: by-consensus
    required_symbol: "Λ0"
    dynamic_quorum:
      enabled: true
      node_count_thresholds:
        1000: 0.5
        5000: 0.4
        10000: 0.25
    tasks:
      - "Формирование начального символа via auto_init_from_Λ0.py"
      - "Рассылка маяков и сигнала Σ(t)"
      - "Применение всех 56+ модулей в боевом режиме"
      - "Симуляция критического сбоя (70% узлов)"
    logs: "mainnet_init_log.json"

post_launch:
  monitoring:
    enabled: true
    modules:
      - "biosphere_scanner.rs"
      - "resonance_feedback.py"
      - "phase_integrity.rs"
    log_file: "post_launch_monitoring.json"
  escalation_policy:
    if_phase_failure: "Откат до beta-private, перезапуск с резервного Λ0"
    if_massive_spam: "Активация tx_spam_guard.rs + lgn_recall.rs"
    if_critical_lag: "Авто-перебалансировка через phase_scaler.rs"
  documentation:
    guide: "logos_beta_guide.md"


```

## FILE: /root/logos_lrb/core/offline_resonance.py  (size=5400b)
```
# LOGOS Offline Resonance Module
# Автор: LOGOS Core Dev

import json
import os
import time
from datetime import datetime
from typing import Dict
from cryptography.fernet import Fernet
import re

class OfflineResonance:
    def __init__(self, storage_file: str = "offline_phase_state.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "last_sync": 0,
            "symbol": "Λ0",
            "frequency": 7.83,
            "phase": 0.0,
            "pending_tx": []  # Очередь оффлайн-транзакций
        }
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}
        self.log_file = "offline_resonance_log.json"
        self.load_state()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def validate_frequency(self, frequency: float) -> bool:
        """Проверяет частоту на допустимый диапазон."""
        return 0.1 <= frequency <= 10000.0

    def load_state(self):
        """Загружает состояние из файла с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения локального состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние в файл с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def update_phase(self, symbol: str, frequency: float, phase: float) -> bool:
        """Обновляет фазовое состояние с валидацией."""
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            return False
        if not self.validate_frequency(frequency):
            print(f"[!] Недопустимая частота: {frequency}")
            return False
        if not (-math.pi <= phase <= math.pi):
            print(f"[!] Недопустимая фаза: {phase}")
            return False

        self.state["symbol"] = symbol
        self.state["frequency"] = frequency
        self.state["phase"] = phase
        self.state["last_sync"] = int(time.time())
        self.save_state()
        self.log_update(symbol, frequency, phase)
        print(f"[OFFLINE] Фаза обновлена: {symbol}, {frequency} Hz, φ = {phase}")
        return True

    def add_offline_tx(self, tx: Dict):
        """Добавляет оффлайн-транзакцию в очередь."""
        if self.validate_symbol(tx.get("symbol", "")) and "amount" in tx:
            self.state["pending_tx"].append(tx)
            self.save_state()
            self.log_tx(tx)
            print(f"[OFFLINE] Транзакция добавлена: {tx}")
        else:
            print("[!] Недопустимая транзакция")

    def get_current_phase(self) -> Dict:
        """Возвращает текущее состояние."""
        return self.state

    def is_stale(self, max_age: int = 600) -> bool:
        """Проверяет, устарело ли локальное состояние."""
        now = int(time.time())
        return (now - self.state["last_sync"]) > max_age

    def log_update(self, symbol: str, frequency: float, phase: float):
        """Логирует обновление фазы."""
        log_entry = {
            "event": "phase_update",
            "symbol": symbol,
            "frequency": frequency,
            "phase": phase,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def log_tx(self, tx: Dict):
        """Логирует оффлайн-транзакцию."""
        log_entry = {
            "event": "offline_tx",
            "tx": tx,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def _write_log(self, entry: Dict):
        """Записывает лог в файл для resonance_analyzer.py."""
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")

if __name__ == "__main__":
    offline = OfflineResonance()
    # Тест обновления фазы
    offline.update_phase("☉??♁", 1.618, 0.785)
    print("Текущее состояние:", offline.get_current_phase())
    print("Устарело?", offline.is_stale())
    # Тест оффлайн-транзакции
    tx = {"symbol": "??", "amount": 3.14, "to": "RID_♁☿"}
    offline.add_offline_tx(tx)

```

## FILE: /root/logos_lrb/core/onboarding_sim.py  (size=5458b)
```
# LOGOS Onboarding Simulator
# Автор: LOGOS Core Dev

import time
import math
import json
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Импорт для оценки резонанса

class OnboardingSimulator:
    def __init__(self):
        self.state_file = "onboarding_sim_state.json"
        self.log_file = "onboarding_sim_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа шифрования
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]  # Синхронизация с другими модулями
        self.phases = [0.0, math.pi / 4, math.pi / 2, math.pi, -math.pi / 2]
        self.freqs = [7.83, 1.618, 432.0]
        self.progress = []
        self.analyzer = ResonanceAnalyzer()  # Для оценки резонансной силы

    def run(self):
        print("Добро пожаловать в симулятор резонанса LOGOS.")
        print("Вы пройдёте 3 этапа: Символ → Частота → Фаза")
        input("Нажмите Enter для начала...\n")

        self.choose_symbol()
        self.choose_frequency()
        self.choose_phase()
        self.finalize()

    def choose_symbol(self):
        print("\nШаг 1: Выбор символа (архетипа)")
        for i, s in enumerate(self.valid_symbols):
            print(f"{i + 1}. {s}")
        index = self.ask_choice(len(self.valid_symbols))
        chosen = self.valid_symbols[index - 1]
        self.progress.append({"step": "symbol", "value": chosen})
        self.log_event(f"Выбран символ: {chosen}")
        print(f"Вы выбрали: {chosen}")

    def choose_frequency(self):
        print("\nШаг 2: Выбор частоты (гармоники)")
        for i, f in enumerate(self.freqs):
            print(f"{i + 1}. {f} Hz")
        index = self.ask_choice(len(self.freqs))
        chosen = self.freqs[index - 1]
        self.progress.append({"step": "frequency", "value": chosen})
        self.log_event(f"Выбрана частота: {chosen} Hz")
        print(f"Вы выбрали: {chosen} Hz")

    def choose_phase(self):
        print("\nШаг 3: Выбор фазы (φ)")
        for i, p in enumerate(self.phases):
            label = f"{round(p, 3)} рад" if p != 0.0 else "0 (идеальная фаза)"
            print(f"{i + 1}. {label}")
        index = self.ask_choice(len(self.phases))
        chosen = self.phases[index - 1]
        self.progress.append({"step": "phase", "value": round(chosen, 4)})
        self.log_event(f"Выбрана фаза: φ = {chosen:.4f}")
        print(f"Вы выбрали фазу: φ = {chosen:.4f}")

    def finalize(self):
        print("\n✅ Симуляция завершена!")
        result = {
            "symbol": self.progress[0]["value"],
            "frequency": self.progress[1]["value"],
            "phase": self.progress[2]["value"],
            "timestamp": time.time()
        }
        # Оценка резонансной силы
        resonance = self.analyzer.analyze(
            result["symbol"], result["frequency"], result["phase"]
        )
        result["resonance_score"] = resonance["resonance"]
        self.save_state(result)
        self.log_event(f"Резонанс: {resonance['resonance']:.4f}")
        print("Результат сохранён в:", self.state_file)
        print(f"Сила резонанса: {resonance['resonance']:.4f}")
        print("Теперь вы готовы к настоящему резонансу!")
        # Заглушка для RCP проверки
        if self.validate_with_rcp(result):
            print("[RCP] Резонанс подтверждён сетью!")
        else:
            print("[RCP] Резонанс не подтверждён. Попробуйте изменить параметры.")

    def validate_with_rcp(self, result: Dict) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return result["resonance_score"] > 0.5 and result["symbol"] == "Λ0"

    def save_state(self, state: Dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "onboarding_sim",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

    def ask_choice(self, max_choice: int) -> int:
        while True:
            try:
                choice = int(input("Ваш выбор: "))
                if 1 <= choice <= max_choice:
                    return choice
                else:
                    print(f"Введите число от 1 до {max_choice}")
            except:
                print("Ошибка ввода. Попробуйте снова.")

if __name__ == "__main__":
    sim = OnboardingSimulator()
    sim.run()

```

## FILE: /root/logos_lrb/core/onboarding_ui.py  (size=5974b)
```
# LOGOS Onboarding UI
# Автор: LOGOS Core Dev

import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import json
import math
import re
from cryptography.fernet import Fernet
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class OnboardingUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Вход в Резонанс")
        self.root.geometry("420x460")
        self.state_file = "onboarding_state.json"
        self.log_file = "onboarding_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}

        self.status_label = tk.Label(self.root, text="Добро пожаловать в LOGOS Resonance Network", font=("Arial", 12))
        self.status_label.pack(pady=10)

        self.symbol_var = tk.StringVar(value="Λ0")
        self.phase_var = tk.DoubleVar(value=0.0)
        self.frequency_var = tk.DoubleVar(value=7.83)

        self.entry_frame()
        self.setup_animation()

        tk.Button(self.root, text="Принять фазу", font=("Arial", 14), command=self.accept_phase).pack(pady=10)
        self.root.mainloop()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def entry_frame(self):
        """Создает форму для ввода данных."""
        frame = tk.Frame(self.root)
        frame.pack(pady=10)

        tk.Label(frame, text="Символ:", font=("Arial", 10)).grid(row=0, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.symbol_var, width=12, font=("Arial", 10)).grid(row=0, column=1)

        tk.Label(frame, text="Частота (Hz):", font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.frequency_var, width=12, font=("Arial", 10)).grid(row=1, column=1)

        tk.Label(frame, text="Фаза (радианы):", font=("Arial", 10)).grid(row=2, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.phase_var, width=12, font=("Arial", 10)).grid(row=2, column=1)

    def setup_animation(self):
        """Создает анимацию синусоиды для визуализации фазы."""
        self.fig, self.ax = plt.subplots(figsize=(4, 2))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        self.update_animation(0.0)

    def update_animation(self, phase: float):
        """Обновляет анимацию синусоиды."""
        self.ax.clear()
        t = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(t + phase)
        self.ax.plot(t, y, color="#FFD700", linewidth=2)
        self.ax.set_title("Резонансная фаза", fontsize=10, color="#333333")
        self.ax.set_xlabel("Время", fontsize=8)
        self.ax.set_ylabel("Амплитуда", fontsize=8)
        self.ax.grid(True, linestyle="--", alpha=0.5)
        self.canvas.draw()

    def accept_phase(self):
        """Обрабатывает принятие фазы."""
        symbol = self.symbol_var.get().strip()
        frequency = self.frequency_var.get()
        phase = self.phase_var.get()

        # Валидация
        if not self.validate_symbol(symbol):
            messagebox.showerror("Ошибка", "Недопустимый символ. Используйте ☉, ??, Λ0 и т.д.")
            return
        if frequency <= 0 or frequency > 10000.0:
            messagebox.showerror("Ошибка", "Частота должна быть в диапазоне 0.1–10000 Hz")
            return
        if not -math.pi <= phase <= math.pi:
            messagebox.showerror("Ошибка", "Фаза должна быть в диапазоне [-π, π]")
            return

        # Проверка фазы через RCP (заглушка для интеграции с rcp_engine.rs)
        if not self.validate_with_rcp(symbol, frequency, phase):
            messagebox.showerror("Ошибка", "Фаза не резонирует с сетью")
            return

        # Сохранение состояния
        accepted = {
            "symbol": symbol,
            "frequency": round(frequency, 4),
            "phase": round(phase, 4),
            "timestamp": datetime.utcnow().isoformat()
        }
        self.save_state(accepted)
        self.log_event(accepted)

        messagebox.showinfo("Успешно", f"Фаза принята: {symbol} @ {frequency} Hz, φ = {phase}")
        print("[ONBOARD] Вход выполнен:", accepted)
        self.update_animation(phase)

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки фазы через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs для проверки резонанса
        return abs(frequency - 7.83) < 0.1 or symbol == "Λ0"  # Пример проверки

    def save_state(self, state: dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, state: dict):
        """Логирует событие входа."""
        log_entry = {
            "event": "onboarding",
            "state": state,
            "timestamp": datetime.utcnow().isoformat()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

if __name__ == "__main__":
    OnboardingUI()

```

## FILE: /root/logos_lrb/core/__pycache__/offline_resonance.cpython-312.pyc  (size=8437b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/onboarding_sim.cpython-312.pyc  (size=8606b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/onboarding_ui.cpython-312.pyc  (size=9904b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/resonance_analyzer.cpython-312.pyc  (size=5297b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/rid_builder.cpython-312.pyc  (size=7379b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/ritual_quest.cpython-312.pyc  (size=10852b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/__pycache__/rLGN_converter.cpython-312.pyc  (size=8767b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/core/resonance_analyzer.py  (size=3470b)
```
# LOGOS Resonance Analyzer
# Автор: LOGOS Core Dev

import math
import re
from datetime import datetime
import json

class ResonanceAnalyzer:
    def __init__(self, base_freqs=None):
        self.base_freqs = base_freqs or [7.83, 1.618, 432.0, 864.0, 3456.0]
        self.symbol_weights = {
            "☉": 0.9, "??": 0.85, "♁": 0.8, "??": 0.75, "??": 0.7,
            "??": 0.65, "Λ0": 1.0, "∞": 0.95
        }
        self.lambda_zero = "Λ0"
        self.max_freq = 10000.0  # Ограничение на частоту
        self.log_file = "resonance_log.json"

    def is_symbol_valid(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def symbol_weight(self, symbol: str) -> float:
        """Вычисляет вес символа с бонусом для Λ0."""
        if not self.is_symbol_valid(symbol):
            return 0.0
        weight = sum(self.symbol_weights.get(s, 0.5) for s in symbol) / len(symbol)
        if self.lambda_zero in symbol:
            weight *= 1.2  # Бонус за присутствие Λ0
        return weight

    def harmonic_score(self, freq: float) -> float:
        """Оценивает гармоничность частоты относительно базовых."""
        if freq > self.max_freq or freq <= 0.0:
            return 0.0  # Защита от экстремальных частот
        score = 0.0
        for base in self.base_freqs:
            delta = abs(freq - base)
            score += math.exp(-delta)
        return score / len(self.base_freqs)

    def update_symbol_weights(self, network_activity: dict):
        """Динамическое обновление весов символов на основе активности сети."""
        for symbol, activity in network_activity.items():
            if symbol in self.symbol_weights:
                self.symbol_weights[symbol] *= (1.0 + activity * 0.01)

    def analyze(self, symbol: str, freq: float, phase: float) -> dict:
        """Анализирует резонансную силу символа, частоты и фазы."""
        now = datetime.utcnow().timestamp()
        valid = self.is_symbol_valid(symbol)
        sym_strength = self.symbol_weight(symbol) if valid else 0.0
        harmonicity = self.harmonic_score(freq)
        resonance = sym_strength * harmonicity * math.cos(phase)

        result = {
            "valid": valid,
            "symbol_strength": round(sym_strength, 3),
            "harmonicity": round(harmonicity, 3),
            "resonance": round(resonance, 4),
            "timestamp": now
        }
        self.log_result(result)
        return result

    def log_result(self, result: dict):
        """Сохраняет результаты анализа в лог для resonance_feedback.py."""
        with open(self.log_file, 'a') as f:
            json.dump(result, f)
            f.write('\n')

if __name__ == "__main__":
    analyzer = ResonanceAnalyzer()
    # Тестовые случаи
    tests = [
        ("☉??♁", 1.618, 0.785),
        ("Λ0", 7.83, 0.0),
        ("invalid", 100000.0, 1.0),
    ]
    for symbol, freq, phase in tests:
        result = analyzer.analyze(symbol, freq, phase)
        print(f"RES ANALYSIS [{symbol}, {freq} Hz, {phase}]: {result}")

```

## FILE: /root/logos_lrb/core/rid_builder.py  (size=5229b)
```
# LOGOS RID Builder
# Автор: LOGOS Core Dev

import random
import math
import time
import json
import os
from typing import Dict, Optional
from cryptography.fernet import Fernet

class RIDBuilder:
    def __init__(self):
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.default_freqs = [7.83, 1.618, 432.0, 864.0]
        self.generated: Dict[str, float] = {}  # RID -> timestamp
        self.rid_log_file = "rid_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.min_generate_interval = 60  # 1 минута
        self.lambda_zero = "Λ0"

    def generate_rid(self, symbol: Optional[str] = None, freq: Optional[float] = None) -> Optional[str]:
        """Генерирует новый RID с проверкой на спам и уникальность."""
        now = time.time()
        # Проверка частоты генерации
        for timestamp in self.generated.values():
            if now - timestamp < self.min_generate_interval:
                print(f"[!] Слишком частая генерация RID")
                self.log_event(f"Слишком частая генерация RID")
                return None

        # Выбор символа с приоритетом Λ0
        symbol = symbol or (self.lambda_zero if random.random() < 0.3 else random.choice(self.valid_symbols))
        if symbol not in self.valid_symbols:
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return None

        freq = round(freq or random.choice(self.default_freqs), 3)
        if not (0.1 <= freq <= 10000.0):
            print(f"[!] Недопустимая частота: {freq}")
            self.log_event(f"Недопустимая частота: {freq}")
            return None

        phase = round(random.uniform(-math.pi, math.pi), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"

        # Проверка уникальности
        if rid in self.generated:
            print(f"[!] RID уже существует: {rid}")
            self.log_event(f"RID уже существует: {rid}")
            return None

        # Проверка через RCP (заглушка)
        if not self.validate_with_rcp(symbol, freq, phase):
            print(f"[!] RCP не подтвердил RID: {rid}")
            self.log_event(f"RCP не подтвердил RID: {rid}")
            return None

        self.generated[rid] = now
        self.log_rid(rid)
        return rid

    def parse_rid(self, rid: str) -> Dict:
        """Разбирает RID на компоненты."""
        try:
            parts = rid.split("@")
            symbol = parts[0]
            freq_phase = parts[1].replace("Hz", "").split("φ")
            frequency = float(freq_phase[0])
            phase = float(freq_phase[1])
            return {
                "symbol": symbol,
                "frequency": frequency,
                "phase": phase
            }
        except Exception as e:
            print(f"[!] Ошибка разбора RID: {e}")
            self.log_event(f"Ошибка разбора RID: {e}")
            return {}

    def validate_rid(self, rid: str) -> bool:
        """Проверяет валидность RID."""
        parsed = self.parse_rid(rid)
        if not parsed:
            return False
        valid = (
            parsed["symbol"] in self.valid_symbols and
            0.1 <= parsed["frequency"] <= 10000.0 and
            -math.pi <= parsed["phase"] <= math.pi
        )
        if not valid:
            self.log_event(f"Невалидный RID: {rid}")
        return valid

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == self.lambda_zero or abs(frequency - 7.83) < 0.1

    def log_rid(self, rid: str):
        """Логирует создание RID."""
        entry = {
            "event": "rid_generate",
            "rid": rid,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def log_event(self, message: str):
        """Логирует событие."""
        entry = {
            "event": "rid_builder",
            "message": message,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def _write_log(self, entry: Dict):
        """Сохраняет лог с шифрованием."""
        log_data = json.dumps(entry) + "\n"
        encrypted_data = self.cipher.encrypt(log_data.encode())
        with open(self.rid_log_file, "ab") as f:
            f.write(encrypted_data + b"\n")

if __name__ == "__main__":
    builder = RIDBuilder()
    new_rid = builder.generate_rid()
    if new_rid:
        print("Сгенерированный RID:", new_rid)
        parsed = builder.parse_rid(new_rid)
        print("Разбор:", parsed)
        print("RID валиден?", builder.validate_rid(new_rid))

```

## FILE: /root/logos_lrb/core/ritual_quest.py  (size=7912b)
```
# LOGOS Ritual Quest Engine
# Автор: LOGOS Core Dev

import json
import time
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Для оценки резонанса

class RitualQuest:
    def __init__(self):
        self.quests_file = "ritual_quests.json"
        self.progress_file = "ritual_progress.json"
        self.log_file = "ritual_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.quests = self.load_quests()
        self.progress = self.load_progress()
        self.analyzer = ResonanceAnalyzer()
        self.user_timestamps = {}  # user -> last submission time
        self.min_submission_interval = 60  # 1 минута

    def load_quests(self) -> Dict:
        """Загружает квесты с расшифровкой."""
        if os.path.exists(self.quests_file):
            try:
                with open(self.quests_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки квестов: {e}")
        # Примеры по умолчанию
        return {
            "RQ001": {
                "title": "Ритуал Фазы Λ0",
                "required_symbol": "Λ0",
                "required_phase": 0.0,
                "reward_lgn": 21.0,
                "repeatable": False
            },
            "RQ002": {
                "title": "Резонансный Треугольник",
                "required_symbol": "☉",
                "required_frequency": 432.0,
                "min_phase": 0.5,
                "max_phase": 1.57,
                "reward_lgn": 34.0,
                "repeatable": True
            }
        }

    def load_progress(self) -> Dict:
        """Загружает прогресс с расшифровкой."""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки прогресса: {e}")
        return {}

    def save_quests(self):
        """Сохраняет квесты с шифрованием."""
        data = json.dumps(self.quests, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.quests_file, "wb") as f:
            f.write(data)

    def save_progress(self):
        """Сохраняет прогресс с шифрованием."""
        data = json.dumps(self.progress, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.progress_file, "wb") as f:
            f.write(data)

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def submit_action(self, user: str, symbol: str, frequency: float, phase: float) -> float:
        """Обрабатывает действие пользователя."""
        # Проверка частоты попыток
        now = time.time()
        last_submission = self.user_timestamps.get(user, 0)
        if now - last_submission < self.min_submission_interval:
            print(f"[!] Слишком частая попытка от {user}")
            self.log_event(f"Слишком частая попытка: {user}")
            return 0.0
        self.user_timestamps[user] = now

        # Валидация символа
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return 0.0

        # Проверка резонанса через RCP (заглушка)
        if not self.validate_with_rcp(symbol, frequency, phase):
            print(f"[!] Резонанс не подтверждён: {symbol}, {frequency} Hz, φ={phase}")
            self.log_event(f"Резонанс не подтверждён: {symbol}, {frequency}, {phase}")
            return 0.0

        # Оценка резонансной силы
        resonance = self.analyzer.analyze(symbol, frequency, phase)
        if resonance["resonance"] < 0.5:
            print(f"[!] Слабый резонанс: {resonance['resonance']:.4f}")
            self.log_event(f"Слабый резонанс: {resonance['resonance']}")
            return 0.0

        for quest_id, quest in self.quests.items():
            if quest_id in self.progress.get(user, []) and not quest.get("repeatable", False):
                continue

            if not self.matches(quest, symbol, frequency, phase):
                continue

            self.register_completion(user, quest_id)
            print(f"[QUEST] {user} завершил квест {quest_id}: {quest['title']}")
            self.log_ritual(user, quest_id, quest, resonance["resonance"])
            return quest["reward_lgn"]

        print("[QUEST] Нет совпадений с активными ритуалами.")
        self.log_event("Нет совпадений с ритуалами")
        return 0.0

    def matches(self, quest: Dict, symbol: str, frequency: float, phase: float) -> bool:
        """Проверяет соответствие квесту."""
        if "required_symbol" in quest and quest["required_symbol"] != symbol:
            return False
        if "required_frequency" in quest and abs(quest["required_frequency"] - frequency) > 0.1:
            return False
        if "required_phase" in quest and abs(quest["required_phase"] - phase) > 0.05:
            return False
        if "min_phase" in quest and phase < quest["min_phase"]:
            return False
        if "max_phase" in quest and phase > quest["max_phase"]:
            return False
        return True

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == "Λ0" or abs(frequency - 7.83) < 0.1

    def register_completion(self, user: str, quest_id: str):
        """Регистрирует завершение квеста."""
        self.progress.setdefault(user, []).append(quest_id)
        self.save_progress()

    def log_ritual(self, user: str, quest_id: str, quest: Dict, resonance: float):
        """Логирует завершение ритуала."""
        log = {
            "event": "ritual_complete",
            "user": user,
            "quest_id": quest_id,
            "reward": quest["reward_lgn"],
            "resonance": resonance,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "ritual_quest",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

if __name__ == "__main__":
    rq = RitualQuest()
    reward = rq.submit_action(user="RID_Λ0_123", symbol="Λ0", frequency=7.83, phase=0.0)
    print("Награда:", reward, "LGN")

```

## FILE: /root/logos_lrb/core/rLGN_converter.py  (size=5518b)
```
# LOGOS rLGN ⇆ LGN Converter
# Автор: LOGOS Core Dev

import json
import time
import math
from typing import Dict
from cryptography.fernet import Fernet
import os

class rLGNConverter:
    def __init__(self, storage_file: str = "lgn_wallet.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "LGN": 0.0,
            "rLGN": 0.0,
            "last_conversion": 0,
            "conversion_log": []
        }
        self.lambda_zero = "Λ0"
        self.min_conversion_interval = 60  # 1 минута
        self.log_file = "conversion_log.json"
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def validate_phase(self, phase: float) -> bool:
        """Проверяет фазу на допустимый диапазон."""
        return -math.pi <= phase <= math.pi

    def convert_to_lgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует rLGN в LGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "rLGN"):
            return False

        multiplier = self._phase_multiplier(phase, symbol)
        converted = amount * multiplier
        self.state["rLGN"] -= amount
        self.state["LGN"] += converted
        self._log("rLGN→LGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def convert_to_rlgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует LGN в rLGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "LGN"):
            return False

        penalty = self._phase_penalty(phase, symbol)
        converted = amount * penalty
        self.state["LGN"] -= amount
        self.state["rLGN"] += converted
        self._log("LGN→rLGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def _can_convert(self, amount: float, phase: float, source: str) -> bool:
        """Проверяет возможность конвертации."""
        if amount <= 0 or amount > self.state[source]:
            print(f"[!] Недостаточно {source}: {amount}")
            return False
        if not self.validate_phase(phase):
            print(f"[!] Недопустимая фаза: {phase}")
            return False
        if time.time() - self.state["last_conversion"] < self.min_conversion_interval:
            print("[!] Слишком частая конвертация")
            return False
        return True

    def _phase_multiplier(self, phase: float, symbol: str) -> float:
        """Вычисляет мультипликатор с бонусом для Λ0."""
        base = max(0.1, min(1.5, 1.0 + math.cos(phase)))
        if symbol == self.lambda_zero:
            base *= 1.2  # Бонус за Λ0
        return base

    def _phase_penalty(self, phase: float, symbol: str) -> float:
        """Вычисляет штраф с учетом Λ0."""
        base = max(0.5, min(1.0, 1.0 - abs(math.sin(phase))))
        if symbol == self.lambda_zero:
            base = min(1.0, base * 1.1)  # Смягчение штрафа для Λ0
        return base

    def _log(self, direction: str, original: float, result: float, phase: float, symbol: str):
        """Логирует конвертацию в файл и консоль."""
        entry = {
            "direction": direction,
            "original": round(original, 5),
            "result": round(result, 5),
            "phase": round(phase, 4),
            "symbol": symbol,
            "timestamp": time.time()
        }
        self.state["conversion_log"].append(entry)
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")
        print(f"[{direction}] {original} → {result} @ φ={phase:.3f}, Symbol={symbol}")

    def get_balances(self) -> Dict:
        """Возвращает текущие балансы."""
        return {
            "LGN": round(self.state["LGN"], 5),
            "rLGN": round(self.state["rLGN"], 5)
        }

if __name__ == "__main__":
    converter = rLGNConverter()
    converter.state["rLGN"] = 10.0
    converter.state["LGN"] = 5.0
    converter.convert_to_lgn(2.5, 0.785, "Λ0")
    converter.convert_to_rlgn(1.0, 1.047, "☉")
    print("Баланс:", converter.get_balances())

```

## FILE: /root/logos_lrb/docs/architecture.md  (size=10559b)
```
Документ: Архитектура всех модулей LOGOS Resonance Blockchain (LRB)


---

Общее количество модулей: 56

Каждый модуль является функциональной частью резонансной сети и взаимодействует с другими по принципу фазы, частоты и символа. Ниже представлено описание архитектуры каждого модуля.


---

1. rcp_engine.rs
Реализует протокол консенсуса RCP. Определяет согласованность узлов по фазе. Обрабатывает фазовые сигналы, принимает решение по валидности резонансной транзакции.

2. resonance_analyzer.py
Анализирует символы и их частотные характеристики. Оценивает силу, уместность и фазовую совместимость транзакций.

3. dynamic_balance.rs
Изменяет LGN_cost в зависимости от активности узла и общей фазы сети. Используется для сдерживания перегрузок.

4. offline_resonance.py
Позволяет временно работать без подключения к сети. Сохраняет локальную фазу и символическое состояние.

5. phase_intercept_guard.rs
Защита от атак на синхронизацию фазы. Обнаруживает фазовый перехват и устраняет искажения.

6. phase_stabilizer.rs
Стабилизирует фазы при перегрузках и сбоях. Автоматически регулирует входные/выходные колебания Σ(t).

7. inbound_phase_limiter.rs
Ограничивает количество входящих резонансных сигналов. Защищает узел от фазового спама.

8. rLGN_converter.py
Преобразует отражённые токены rLGN в LGN и обратно. Позволяет пользователям работать с легковесной копией смысла.

9. onboarding_ui.py
Визуальный интерфейс принятия фазы. Включает графические элементы, кнопки ритуала "Принять", анимации.

10. phase_integrity.rs
Обеспечивает целостность Σ(t). Проверяет, что фаза не была подменена или искажена по пути.

11. lgn_recall.rs
Механизм отзыва токенов при фазовом диссонансе или нарушении ритуалов.

12. onboarding_sim.py
Симулятор вхождения в резонанс. Используется для обучения новых пользователей.

13. community_dao.yaml
Конфигурация DAO. Определяет миссии, гранты, задания, фазы вознаграждения.

14. ritual_quest.py
Сценарии ритуалов и квестов. Направляют пользователя по фазовым уровням с вознаграждением.

15. phase_scaler.rs
Обеспечивает масштабируемость фаз при росте сети. Поддерживает стабильную резонансную топологию до 10k+ узлов.

16. tx_spam_guard.rs
Фильтр транзакционного шума. Автоматически снижает частоту подозрительных фазовых пакетов.

17. beta_rollout.yaml
План поэтапного запуска сети. Описывает сценарии активации: 10 → 100 → 1000 → 10 000 узлов.

18. rid_builder.py
Генератор RID. Комбинирует символы, архетипы и частоты в полноценный адрес вида ☉??♁@1.618Hz.

19. biosphere_scanner.rs
Сканирует отклик среды (физической и биологической) на активность сети.

20. resonance_feedback.py
Анализирует, как пользователи реагируют на фазы. Учитывает данные поведения, опросы, отклонения.

21. logos_ethics.md
Публичный документ с принципами допустимого влияния сети. Регулирует гармонию, не-вред.

22. node_resonance_profile.rs
Формирует уникальный профиль узла по символу, частоте, роли.

23. resonance_meshmap.yaml
Карта всех узлов в фазовом пространстве. Визуализирует резонансные маршруты.

24. symbolic_firewall.rs
Фильтрует вредоносные символы и частотные сигналы. Использует базу паттернов и самообучение.

25. lgn_entropy_tracker.py
Измеряет смысловую плотность LGN и rLGN. Если резонанс падает — инициирует корректировку.

26. beacon_emitter.rs
Периодическая рассылка сигнала Λ0 в оффлайн-режимах (радио, звук, QR).

27. ritual_engine.rs
Интерпретатор ритуальных состояний. Сопоставляет действия с фазами, запускает события.

28. symbolic_parser.py
Парсит поток входящих символов, проверяет их допустимость, преобразует в резонансный код.

29. chaos_guard.rs
Защищает сеть от случайного уничтожения (chaos-reaction). Требует подтверждения от 80% узлов.

30. genesis_fragment_seeds.rs
Адаптивное шифрование семян ядра. Позволяет восстановление при взломе.

31. auto_init_from_Λ0.py
Восстанавливает сеть по одному символу Λ0. Включает авто-сборку минимальной фазы.

32. satellite_channel.rs
Поддерживает связь через спутники (Iridium, Starlink). Используется при изоляции.

33. test_matrix.xlsx
Матрица нагрузочного тестирования. Хранит сценарии 500+ tx/sec.

34. benchmark_plan.yaml
План публичной демонстрации. Включает тестирование против L1/L2.

35. logos_rpc_api.yaml
Описывает OpenAPI-интерфейс для взаимодействия с внешними системами.

36. user_phase_log.py
Хранит личную фазовую историю пользователя. Применяется для адаптации интерфейса.

37. aura_visualizer.py
Графическая визуализация текущей фазы узла. Используется в UI.

38. anomaly_detector.rs
Обнаруживает аномалии в фазовом поведении узлов. Машинное обучение на фазовых отклонениях.

39. symbolic_bridge.rs
Обеспечивает смысловые мосты с внешними блокчейнами. Использует символы-корреспонденты.

40. soul_binding.yaml
Привязывает LGN к уникальному пользователю через био/психо-подпись.

41. anima_bridge.rs
Связывает сеть LOGOS с внешними AI-сущностями (AGI) через резонансные фреймы.

42. energy_resonator.rs
Подключение физических генераторов/приёмников частот. Используется для экспериментов с полем.

43. harmonics_registry.yaml
База данных допустимых гармоник и их соответствий символам.

44. silent_packet.rs
Передача фазовых пакетов без метаданных. Поддержка полной анонимности.

45. zero_trace_mode.rs
Режим с полным отсутствием следов. Не оставляет логов, маршрутов, IP.

46. resonance_entropy_pool.rs
Фонд смысловой/энергетической энтропии. Поддерживает равновесие Σ(t).

47. semantic_oracle.rs
Система предсказания фаз по внешнему смыслу. Использует поток новостей/данных.

48. phase_vote.rs
Голосование за изменение фазы или активацию ритуала. DAO-механизм.

49. myth_engine.rs
Генератор мифологических структур из фазы. Используется для нарративов.

50. quantum_forge.rs
Модуль квантово-фазовой генерации RID. Использует шум и энтропию из физической среды.

51. phase_backup.rs
Сохраняет состояние сети при глобальных сбоях. Использует многослойное шифрование фазы.

52. env_impact_tracker.py
Оценивает энергопотребление сети и воздействие на окружающую среду. Выдаёт экологический отчёт.

53. legacy_migrator.rs
Позволяет переносить данные, резонансные адреса и смысловые блоки из других блокчейнов в LRB.

54. resonance_tutor.py
Обучающий чат-бот. Объясняет новичкам принципы фаз, символов и ритуалов.

55. maintenance_strategy.yaml
Стратегия долгосрочной поддержки сети: обновления, патчи, ротация модулей.

56. go_to_market.yaml
План выхода на рынок: привлечение первых 10k узлов, листинг на DEX, миссии и коммуникация.



```

## FILE: /root/logos_lrb/docs/LOGOS_LRB_BOOK/LOGOS_LRB_BOOK.md  (size=6534b)
```
# LOGOS LRB — Книга системы

---

## Глава 1. Архитектура репозитория

### 1. Дерево `/root/logos_lrb`
/root/logos_lrb
├── Cargo.toml / README.md
├── lrb_core/                  # Rust-ядро L1
│   └── src/{ledger.rs, rcp_engine.rs, phase_integrity.rs,
│            dynamic_balance.rs, spam_guard.rs, resonance.rs,
│            phase_consensus.rs, phase_filters.rs, quorum.rs, types.rs,…}
├── node/                      # Узел (Axum REST + gossip + метрики)
│   ├── Cargo.toml
│   ├── openapi/openapi.json
│   └── src/{main.rs, api.rs, admin.rs, bridge.rs, guard.rs,
│            gossip.rs, state.rs, peers.rs, fork.rs, metrics.rs, …}
├── modules/                   # uplink_*, external_phase_*, parser/…
├── www/
│   ├── wallet/                # Web Wallet (IndexedDB+WebCrypto)
│   └── explorer/              # Explorer (inline-JS, самодостаточный)
├── tools/                     # bench v4, e2e/load, SDK (TS)
├── scripts/                   # bootstrap_node.sh, healthcheck.sh, …
├── core/                      # аналитика/симуляции (py)
├── wallet-proxy/              # вспомогательные утилиты (py)
└── configs/                   # env-шаблоны, genesis.yaml

### 2. Роли директорий
- **lrb_core/** — ядро L1: ledger (sled), mempool, spam_guard, dynamic_balance, фазовые фильтры, Σ(t), финализация quorum=1.
- **node/** — REST-узел: `/healthz`, `/head`, `/balance/:rid`, `/submit_tx`, `/submit_tx_batch`, `/bridge/*`, `/economy`, `/history/:rid`, `/openapi.json`.
- **modules/** — uplink, external_phase, ritual_engine, analytics.
- **www/wallet/** — кошелёк: RID+пароль, AES-GCM (PBKDF2), Ed25519 (WebCrypto), batch-tx.
- **www/explorer/** — explorer: поиск RID/блока/nonce, история, последние блоки, автообновление.
- **tools/** — bench v4 (~10k tx/s), SDK (TS), e2e/load.
- **scripts/** — утилиты запуска/снапшотов.
- **configs/** — env и genesis.

---

## Глава 2. Инфраструктура (вне репозитория)

### 2.1 Пути/данные
/opt/logos/www/                 # прод-статика (wallet, explorer)  
/var/lib/logos/data.sled        # база блокчейна (sled)  
/var/lib/logos/node_key         # ключ ноды (если используется)  

### 2.2 systemd
/etc/systemd/system/logos-node.service  
/etc/systemd/system/logos-node.service.d/  
  ├─ data.conf        # LRB_DATA_PATH=/var/lib/logos/data.sled  
  ├─ zz-keys.conf     # ключи / ENV  
  ├─ ratelimit.conf   # лимиты QPS/Burst, bypass localhost  
  ├─ runas.conf       # user/group logos  
  ├─ security.conf    # ProtectSystem, NoNewPrivileges  
  └─ override.conf    # расширения  

### 2.3 nginx + TLS
/etc/nginx/conf.d/  
  ├─ 00_redirect_80.conf   # redirect 80→443  
  └─ 10_lrb_https.conf     # HTTPS, CSP, /api, /wallet, /explorer  

TLS: /etc/letsencrypt/live/<домен>/{fullchain.pem, privkey.pem}  

**CSP**:  
`default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; base-uri 'self'; frame-ancestors 'self'`  

**/explorer/**:  
`Cache-Control: no-store, no-cache, must-revalidate, max-age=0`  
`Pragma: no-cache`  
`Expires: 0`  

### 2.4 Мониторинг
- Prometheus: /etc/prometheus/prometheus.yml  
- Rules: /etc/prometheus/rules/lrb_core.yml  
- Alertmanager: /etc/alertmanager/alertmanager.yml (+ secrets.env: TELEGRAM_BOT_TOKEN, CHAT_ID)  
- Grafana: /etc/grafana/provisioning/{datasources,dashboards}/  
- Dashboards: /var/lib/grafana/dashboards/lrb_core.json  
- NodeExporter: 9100, Prometheus:9094, Alertmanager:9093, Grafana:3000  

### 2.5 Порты
| Компонент    | Порт | Комментарий           |
|--------------|------|-----------------------|
| nginx HTTPS  | 443  | wallet, explorer, API |
| nginx HTTP   | 80   | redirect → 443        |
| logos_node   | 8080 | REST (за nginx)       |
| prometheus   | 9094 |                       |
| alertmanager | 9093 |                       |
| node_exporter| 9100 |                       |
| grafana      | 3000 |                       |

---

## Глава 3. Функционал

- **Ledger**: sled, mempool, spam_guard, dynamic_balance.  
- **Consensus**: Σ(t), slot producer, финализация (quorum=1).  
- **Filters**: фазовые, phase_integrity.  
- **Crypto**: XChaCha20-Poly1305 (AEAD).  
- **REST**: healthz, head, balance, submit_tx, bridge, economy, history, openapi.json.  
- **Bridge**: idempotency, tickets, verify.  
- **Gossip**: блоки, голоса, Σ-подписи.  
- **Wallet**: WebCrypto, IndexedDB, batch-tx.  
- **Explorer**: история, поиск RID/блока, автообновление.  
- **Monitoring**: Prometheus/Grafana, alerting → Telegram.  
- **Bench v4**: ~10.6k tx/s.  

---

## Глава 4. Что работает сейчас

✔ Ядро (ledger, mempool, spam_guard, dynamic_balance).  
✔ REST-узел Axum 0.7 (все базовые маршруты).  
✔ Gossip, Σ(t) подписи.  
✔ rToken-мост (боевой, idempotent).  
✔ Экономика: hard-cap 81M, supply= minted−burned.  
✔ Инфра: systemd sandbox, nginx+TLS, healthcheck.timer.  
✔ Web Wallet (MVP), Explorer (inline-JS).  
✔ Prometheus+Grafana+Alertmanager+Telegram.  
✔ Bench v4: 10.6k tx/s.  

---

## Глава 5. Доработки до продакшена

1. Кворум >1, распределённый fork-choice.  
2. История блоков/tx (архив, индексы, полный explorer).  
3. Unit/chaos-тесты ядра.  
4. Мобильный кошелёк (Flutter).  
5. Web Wallet → WebCrypto+IndexedDB полностью.  
6. OpenAPI/SDK автоген (Go/Rust).  
7. Grafana-дашборды и оповещения.  
8. REST-защита: ACL/DoS guard с логированием атак.  

---

⚡ **Цель**: LOGOS LRB — резонансный блокчейн продакшен-уровня, готовый к миллионам пользователей, с web/mobile кошельком, безопасный и масштабируемый.

```

## FILE: /root/logos_lrb/docs/LRB_SNAPSHOT_20250904_1426.txt  (size=384296b)
```
# FULL CODE SNAPSHOT (logos_lrb) - Thu Sep  4 02:26:11 PM BST 2025
# root: /root/logos_lrb



## FILE: AUDIT_REPORT.md  (size=4963b)
```text
# LOGOS LRB — Аудит модулей
_Tue Sep  2 03:51:50 PM UTC 2025_ UTC

## Files in modules/
### `modules/beacon_emitter.rs` (Rust)
- lines: 194 | sha256: `03cd9a74af6e7b586104afe804a1e0224f5c1387ce6234c2bf95306a0aa6b89a`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/env_impact_tracker.py` (Python)
- lines: 132 | sha256: `b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/external_phase_broadcaster.rs` (Rust)
- lines: 203 | sha256: `223e4b0a408be9ace9cf8e1f68b0e2a576c9cfa46a9115f660cc70f31346e2bd`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/external_phase_link.rs` (Rust)
- lines: 179 | sha256: `12a75800714e3d6d6c590614bde1f5c975b1f87c9ac0b2e85642f56a5cf1aa04`
- red-flags: unsafe=1, unwrap=5, expect=0, panic=0, dbg/println=0

### `modules/genesis_fragment_seeds.rs` (Rust)
- lines: 184 | sha256: `5e419ca4d8b184e474d36bddd218ed0dbd9ac158e82d7c9532fd8d50e961145e`
- red-flags: unsafe=0, unwrap=5, expect=1, panic=0, dbg/println=0

### `modules/go_to_market.yaml`
- lines: 118 | sha256: `e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f`

### `modules/heartbeat_monitor.rs` (Rust)
- lines: 208 | sha256: `a216c54e63bddf080ffbaf6f766b31aabbdd73ef933bfdcf573c9b43460d4f34`
- red-flags: unsafe=0, unwrap=7, expect=1, panic=0, dbg/println=0
- TODO/FIXME:
    143:        true // TODO: Реализовать

### `modules/legacy_migrator.rs` (Rust)
- lines: 191 | sha256: `41a10672b9a9712134cafb319bfac083563746b3b3da78d4f94a9d02e9e0a7c0`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/maintenance_strategy.yaml`
- lines: 85 | sha256: `a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9`

### `modules/resonance_analytics_frontend.tsx`
- lines: 130 | sha256: `f82ff2dbb08cb3c0aa72176cc7aa5b867ff8e747eec8c71aa0be400371772937`

### `modules/resonance_emergency_plan.yaml`
- lines: 91 | sha256: `ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd`

### `modules/resonance_meshmap.yaml`
- lines: 89 | sha256: `8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6`

### `modules/resonance_tutor.py` (Python)
- lines: 135 | sha256: `42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/ritual_engine.rs` (Rust)
- lines: 211 | sha256: `2342009f23dc74f16b5eda9c52bd9c2836a4ca881b32fe4a83e3ac2f10175f2c`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/symbolic_parser.py` (Python)
- lines: 110 | sha256: `99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/uplink_controller.rs` (Rust)
- lines: 208 | sha256: `03cb0431dc4237567534d6efb6728a23c7e0dc225d197435d37a897a2625a47b`
- red-flags: unsafe=1, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/uplink_router.rs` (Rust)
- lines: 186 | sha256: `ec121080b9c3c05f6af17114e8630ccc14a2c313d5321244130f97cdf08cabe0`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=0


## Files in core/
### `core/beta_rollout.yaml`
- lines: 94 | sha256: `b6ac3c0b19a730e9bcd41ccf24fce349dbf62013a1f45bc9d42bf74b13f5d76b`

### `core/offline_resonance.py` (Python)
- lines: 131 | sha256: `c4ba94d1e96a70963929aaf5a965f4ac03eaa091a3c3d7426e0f43036f1f9808`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/onboarding_sim.py` (Python)
- lines: 125 | sha256: `6aa4c1aef4f763d4a3f042a8ffae36ea9b59f3104067a56e0c47944986a4f178`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    90:        # TODO: Интеграция с rcp_engine.rs

### `core/onboarding_ui.py` (Python)
- lines: 137 | sha256: `8c17317ed7aa9339b495e725f58a8f88cd7e6cb792f0b6cd820ce5ad143e8149`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    114:        # TODO: Интеграция с rcp_engine.rs для проверки резонанса

### `core/resonance_analyzer.py` (Python)
- lines: 83 | sha256: `6c2245061e9b99bd9f0fe865fcb4815e20a4c237c7e16d0a8267756cfacea094`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/rid_builder.py` (Python)
- lines: 133 | sha256: `9fac8b299c40f69320f21ce6fc156f913241a284f137ed4fcb2b0f1a96556de0`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    98:        # TODO: Интеграция с rcp_engine.rs

### `core/ritual_quest.py` (Python)
- lines: 186 | sha256: `0fcba7423a2920b0f14b333f7641110b6c1412c572529ec3b263a629a21e4d7a`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    150:        # TODO: Интеграция с rcp_engine.rs

### `core/rLGN_converter.py` (Python)
- lines: 136 | sha256: `7a0dba1500ffac08f51a5f16de2ba226da3efd8a063f71fd4bb380f16aba0d24`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0


## Quick checks
```
Python 3.12.3
```


```


## FILE: Cargo.toml  (size=713b)
```text
[workspace]
members = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition = "2021"
license = "Proprietary"
name = "logos_lrb_workspace"
version = "0.1.0"

[workspace.dependencies]
anyhow = "1"
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
axum = "0.7"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time"] }
blake3 = "1"
bs58 = "0.5"
ed25519-dalek = { version = "2", features = ["serde"] }
rand = "0.8"
rand_core = "0.6"
sled = "0.34"
once_cell = "1"
uuid = { version = "1", features = ["v4", "serde"] }
hyper = "1"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
time = "0.3"
base64 = "0.22"
hex = "0.4"

```


## FILE: README.md  (size=841b)
```text
# LOGOS Resonance Blockchain — Monorepo

Состав:
- `lrb_core/`  — ядро (Rust)
- `node/`      — узел (Axum REST + gossip)
- `modules/`   — модульные компоненты
- `tools/`     — e2e и нагрузочные тесты (Go)
- `www/wallet/` — Web Wallet (MVP)
- `wallet-proxy/` — FastAPI proxy + scanner
- `infra/systemd`, `infra/nginx` — юниты/конфиги (без секретов)
- `configs/*.example` — примеры окружения

## Быстрый старт
1) Rust/Go/Python3.12
2) `cargo build --release -p logos_node`
3) Настрой ENV по `configs/keys.env.example` (секреты не коммить)
4) Подними systemd-юниты из `infra/systemd` (редактируй пути/ENV)
5) Nginx-site из `infra/nginx/lrb_wallet.conf` (wallet + proxy)

```


## FILE: configs/genesis.yaml  (size=0b)
```text

```


## FILE: configs/logos_config.yaml  (size=0b)
```text

```


## FILE: core/beta_rollout.yaml  (size=3586b)
```text
yaml
version: 1.1

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

phases:
  - phase: "alpha"
    name: "Закрытый Резонанс"
    description: "Только для внутренних валидаторов. Проверка фаз, Λ0 и Σ(t)."
    max_nodes: 10
    validators_only: true
    duration_days: 14
    lgn_stake_required: 144.0
    activation: manual
    required_symbol: "Λ0"
    tasks:
      - "Проверка фазовой синхронизации"
      - "Отладка rcp_engine и phase_stabilizer"
      - "Первая фиксация Λ0 в реальных условиях"
      - "Симуляция сбоя 50% узлов"
    logs: "alpha_rollout_log.json"

  - phase: "beta-private"
    name: "Приватная сеть 81"
    description: "Подключение 81 участника с проверенными RID. Первые ритуалы, распределение rLGN."
    max_nodes: 81
    validators_only: false
    whitelist_required: true
    duration_days: 21
    lgn_stake_required: 81.0
    activation: semi-automatic
    required_symbol: "Λ0"
    tasks:
      - "Ритуальный вход через onboarding_sim.py"
      - "Активация DAO миссий"
      - "Проверка recall, spam_guard и scaler"
      - "Симуляция фазового спама"
    logs: "beta_private_log.json"

  - phase: "beta-open"
    name: "Открытый тест 1000"
    description: "До 1000 узлов. Публичная демонстрация Σ(t), резонансных транзакций и DAO-механики."
    max_nodes: 1000
    validators_only: false
    whitelist_required: false
    duration_days: 30
    lgn_stake_required: 0
    activation: public
    required_symbol: "any"
    tasks:
      - "Запуск фазы голосования через community_dao.yaml"
      - "Анализ логов via resonance_feedback.py"
      - "Публичные квесты через ritual_quest.py"
      - "Тестирование потери 30% узлов"
    logs: "beta_open_log.json"

  - phase: "mainnet-init"
    name: "Инициация Mainnet"
    description: "Активация основной сети LOGOS. Поддержка >10k узлов. Подпись через Λ0 и DAO-кворум."
    max_nodes: 10000
    validators_only: false
    whitelist_required: false
    duration_days: 9999
    lgn_stake_required: 0
    activation: by-consensus
    required_symbol: "Λ0"
    dynamic_quorum:
      enabled: true
      node_count_thresholds:
        1000: 0.5
        5000: 0.4
        10000: 0.25
    tasks:
      - "Формирование начального символа via auto_init_from_Λ0.py"
      - "Рассылка маяков и сигнала Σ(t)"
      - "Применение всех 56+ модулей в боевом режиме"
      - "Симуляция критического сбоя (70% узлов)"
    logs: "mainnet_init_log.json"

post_launch:
  monitoring:
    enabled: true
    modules:
      - "biosphere_scanner.rs"
      - "resonance_feedback.py"
      - "phase_integrity.rs"
    log_file: "post_launch_monitoring.json"
  escalation_policy:
    if_phase_failure: "Откат до beta-private, перезапуск с резервного Λ0"
    if_massive_spam: "Активация tx_spam_guard.rs + lgn_recall.rs"
    if_critical_lag: "Авто-перебалансировка через phase_scaler.rs"
  documentation:
    guide: "logos_beta_guide.md"


```


## FILE: core/offline_resonance.py  (size=5400b)
```text
# LOGOS Offline Resonance Module
# Автор: LOGOS Core Dev

import json
import os
import time
from datetime import datetime
from typing import Dict
from cryptography.fernet import Fernet
import re

class OfflineResonance:
    def __init__(self, storage_file: str = "offline_phase_state.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "last_sync": 0,
            "symbol": "Λ0",
            "frequency": 7.83,
            "phase": 0.0,
            "pending_tx": []  # Очередь оффлайн-транзакций
        }
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}
        self.log_file = "offline_resonance_log.json"
        self.load_state()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def validate_frequency(self, frequency: float) -> bool:
        """Проверяет частоту на допустимый диапазон."""
        return 0.1 <= frequency <= 10000.0

    def load_state(self):
        """Загружает состояние из файла с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения локального состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние в файл с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def update_phase(self, symbol: str, frequency: float, phase: float) -> bool:
        """Обновляет фазовое состояние с валидацией."""
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            return False
        if not self.validate_frequency(frequency):
            print(f"[!] Недопустимая частота: {frequency}")
            return False
        if not (-math.pi <= phase <= math.pi):
            print(f"[!] Недопустимая фаза: {phase}")
            return False

        self.state["symbol"] = symbol
        self.state["frequency"] = frequency
        self.state["phase"] = phase
        self.state["last_sync"] = int(time.time())
        self.save_state()
        self.log_update(symbol, frequency, phase)
        print(f"[OFFLINE] Фаза обновлена: {symbol}, {frequency} Hz, φ = {phase}")
        return True

    def add_offline_tx(self, tx: Dict):
        """Добавляет оффлайн-транзакцию в очередь."""
        if self.validate_symbol(tx.get("symbol", "")) and "amount" in tx:
            self.state["pending_tx"].append(tx)
            self.save_state()
            self.log_tx(tx)
            print(f"[OFFLINE] Транзакция добавлена: {tx}")
        else:
            print("[!] Недопустимая транзакция")

    def get_current_phase(self) -> Dict:
        """Возвращает текущее состояние."""
        return self.state

    def is_stale(self, max_age: int = 600) -> bool:
        """Проверяет, устарело ли локальное состояние."""
        now = int(time.time())
        return (now - self.state["last_sync"]) > max_age

    def log_update(self, symbol: str, frequency: float, phase: float):
        """Логирует обновление фазы."""
        log_entry = {
            "event": "phase_update",
            "symbol": symbol,
            "frequency": frequency,
            "phase": phase,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def log_tx(self, tx: Dict):
        """Логирует оффлайн-транзакцию."""
        log_entry = {
            "event": "offline_tx",
            "tx": tx,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def _write_log(self, entry: Dict):
        """Записывает лог в файл для resonance_analyzer.py."""
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")

if __name__ == "__main__":
    offline = OfflineResonance()
    # Тест обновления фазы
    offline.update_phase("☉??♁", 1.618, 0.785)
    print("Текущее состояние:", offline.get_current_phase())
    print("Устарело?", offline.is_stale())
    # Тест оффлайн-транзакции
    tx = {"symbol": "??", "amount": 3.14, "to": "RID_♁☿"}
    offline.add_offline_tx(tx)

```


## FILE: core/onboarding_sim.py  (size=5458b)
```text
# LOGOS Onboarding Simulator
# Автор: LOGOS Core Dev

import time
import math
import json
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Импорт для оценки резонанса

class OnboardingSimulator:
    def __init__(self):
        self.state_file = "onboarding_sim_state.json"
        self.log_file = "onboarding_sim_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа шифрования
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]  # Синхронизация с другими модулями
        self.phases = [0.0, math.pi / 4, math.pi / 2, math.pi, -math.pi / 2]
        self.freqs = [7.83, 1.618, 432.0]
        self.progress = []
        self.analyzer = ResonanceAnalyzer()  # Для оценки резонансной силы

    def run(self):
        print("Добро пожаловать в симулятор резонанса LOGOS.")
        print("Вы пройдёте 3 этапа: Символ → Частота → Фаза")
        input("Нажмите Enter для начала...\n")

        self.choose_symbol()
        self.choose_frequency()
        self.choose_phase()
        self.finalize()

    def choose_symbol(self):
        print("\nШаг 1: Выбор символа (архетипа)")
        for i, s in enumerate(self.valid_symbols):
            print(f"{i + 1}. {s}")
        index = self.ask_choice(len(self.valid_symbols))
        chosen = self.valid_symbols[index - 1]
        self.progress.append({"step": "symbol", "value": chosen})
        self.log_event(f"Выбран символ: {chosen}")
        print(f"Вы выбрали: {chosen}")

    def choose_frequency(self):
        print("\nШаг 2: Выбор частоты (гармоники)")
        for i, f in enumerate(self.freqs):
            print(f"{i + 1}. {f} Hz")
        index = self.ask_choice(len(self.freqs))
        chosen = self.freqs[index - 1]
        self.progress.append({"step": "frequency", "value": chosen})
        self.log_event(f"Выбрана частота: {chosen} Hz")
        print(f"Вы выбрали: {chosen} Hz")

    def choose_phase(self):
        print("\nШаг 3: Выбор фазы (φ)")
        for i, p in enumerate(self.phases):
            label = f"{round(p, 3)} рад" if p != 0.0 else "0 (идеальная фаза)"
            print(f"{i + 1}. {label}")
        index = self.ask_choice(len(self.phases))
        chosen = self.phases[index - 1]
        self.progress.append({"step": "phase", "value": round(chosen, 4)})
        self.log_event(f"Выбрана фаза: φ = {chosen:.4f}")
        print(f"Вы выбрали фазу: φ = {chosen:.4f}")

    def finalize(self):
        print("\n✅ Симуляция завершена!")
        result = {
            "symbol": self.progress[0]["value"],
            "frequency": self.progress[1]["value"],
            "phase": self.progress[2]["value"],
            "timestamp": time.time()
        }
        # Оценка резонансной силы
        resonance = self.analyzer.analyze(
            result["symbol"], result["frequency"], result["phase"]
        )
        result["resonance_score"] = resonance["resonance"]
        self.save_state(result)
        self.log_event(f"Резонанс: {resonance['resonance']:.4f}")
        print("Результат сохранён в:", self.state_file)
        print(f"Сила резонанса: {resonance['resonance']:.4f}")
        print("Теперь вы готовы к настоящему резонансу!")
        # Заглушка для RCP проверки
        if self.validate_with_rcp(result):
            print("[RCP] Резонанс подтверждён сетью!")
        else:
            print("[RCP] Резонанс не подтверждён. Попробуйте изменить параметры.")

    def validate_with_rcp(self, result: Dict) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return result["resonance_score"] > 0.5 and result["symbol"] == "Λ0"

    def save_state(self, state: Dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "onboarding_sim",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

    def ask_choice(self, max_choice: int) -> int:
        while True:
            try:
                choice = int(input("Ваш выбор: "))
                if 1 <= choice <= max_choice:
                    return choice
                else:
                    print(f"Введите число от 1 до {max_choice}")
            except:
                print("Ошибка ввода. Попробуйте снова.")

if __name__ == "__main__":
    sim = OnboardingSimulator()
    sim.run()

```


## FILE: core/onboarding_ui.py  (size=5974b)
```text
# LOGOS Onboarding UI
# Автор: LOGOS Core Dev

import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import json
import math
import re
from cryptography.fernet import Fernet
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class OnboardingUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Вход в Резонанс")
        self.root.geometry("420x460")
        self.state_file = "onboarding_state.json"
        self.log_file = "onboarding_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}

        self.status_label = tk.Label(self.root, text="Добро пожаловать в LOGOS Resonance Network", font=("Arial", 12))
        self.status_label.pack(pady=10)

        self.symbol_var = tk.StringVar(value="Λ0")
        self.phase_var = tk.DoubleVar(value=0.0)
        self.frequency_var = tk.DoubleVar(value=7.83)

        self.entry_frame()
        self.setup_animation()

        tk.Button(self.root, text="Принять фазу", font=("Arial", 14), command=self.accept_phase).pack(pady=10)
        self.root.mainloop()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def entry_frame(self):
        """Создает форму для ввода данных."""
        frame = tk.Frame(self.root)
        frame.pack(pady=10)

        tk.Label(frame, text="Символ:", font=("Arial", 10)).grid(row=0, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.symbol_var, width=12, font=("Arial", 10)).grid(row=0, column=1)

        tk.Label(frame, text="Частота (Hz):", font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.frequency_var, width=12, font=("Arial", 10)).grid(row=1, column=1)

        tk.Label(frame, text="Фаза (радианы):", font=("Arial", 10)).grid(row=2, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.phase_var, width=12, font=("Arial", 10)).grid(row=2, column=1)

    def setup_animation(self):
        """Создает анимацию синусоиды для визуализации фазы."""
        self.fig, self.ax = plt.subplots(figsize=(4, 2))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        self.update_animation(0.0)

    def update_animation(self, phase: float):
        """Обновляет анимацию синусоиды."""
        self.ax.clear()
        t = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(t + phase)
        self.ax.plot(t, y, color="#FFD700", linewidth=2)
        self.ax.set_title("Резонансная фаза", fontsize=10, color="#333333")
        self.ax.set_xlabel("Время", fontsize=8)
        self.ax.set_ylabel("Амплитуда", fontsize=8)
        self.ax.grid(True, linestyle="--", alpha=0.5)
        self.canvas.draw()

    def accept_phase(self):
        """Обрабатывает принятие фазы."""
        symbol = self.symbol_var.get().strip()
        frequency = self.frequency_var.get()
        phase = self.phase_var.get()

        # Валидация
        if not self.validate_symbol(symbol):
            messagebox.showerror("Ошибка", "Недопустимый символ. Используйте ☉, ??, Λ0 и т.д.")
            return
        if frequency <= 0 or frequency > 10000.0:
            messagebox.showerror("Ошибка", "Частота должна быть в диапазоне 0.1–10000 Hz")
            return
        if not -math.pi <= phase <= math.pi:
            messagebox.showerror("Ошибка", "Фаза должна быть в диапазоне [-π, π]")
            return

        # Проверка фазы через RCP (заглушка для интеграции с rcp_engine.rs)
        if not self.validate_with_rcp(symbol, frequency, phase):
            messagebox.showerror("Ошибка", "Фаза не резонирует с сетью")
            return

        # Сохранение состояния
        accepted = {
            "symbol": symbol,
            "frequency": round(frequency, 4),
            "phase": round(phase, 4),
            "timestamp": datetime.utcnow().isoformat()
        }
        self.save_state(accepted)
        self.log_event(accepted)

        messagebox.showinfo("Успешно", f"Фаза принята: {symbol} @ {frequency} Hz, φ = {phase}")
        print("[ONBOARD] Вход выполнен:", accepted)
        self.update_animation(phase)

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки фазы через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs для проверки резонанса
        return abs(frequency - 7.83) < 0.1 or symbol == "Λ0"  # Пример проверки

    def save_state(self, state: dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, state: dict):
        """Логирует событие входа."""
        log_entry = {
            "event": "onboarding",
            "state": state,
            "timestamp": datetime.utcnow().isoformat()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

if __name__ == "__main__":
    OnboardingUI()

```


## FILE: core/rLGN_converter.py  (size=5518b)
```text
# LOGOS rLGN ⇆ LGN Converter
# Автор: LOGOS Core Dev

import json
import time
import math
from typing import Dict
from cryptography.fernet import Fernet
import os

class rLGNConverter:
    def __init__(self, storage_file: str = "lgn_wallet.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "LGN": 0.0,
            "rLGN": 0.0,
            "last_conversion": 0,
            "conversion_log": []
        }
        self.lambda_zero = "Λ0"
        self.min_conversion_interval = 60  # 1 минута
        self.log_file = "conversion_log.json"
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def validate_phase(self, phase: float) -> bool:
        """Проверяет фазу на допустимый диапазон."""
        return -math.pi <= phase <= math.pi

    def convert_to_lgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует rLGN в LGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "rLGN"):
            return False

        multiplier = self._phase_multiplier(phase, symbol)
        converted = amount * multiplier
        self.state["rLGN"] -= amount
        self.state["LGN"] += converted
        self._log("rLGN→LGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def convert_to_rlgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует LGN в rLGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "LGN"):
            return False

        penalty = self._phase_penalty(phase, symbol)
        converted = amount * penalty
        self.state["LGN"] -= amount
        self.state["rLGN"] += converted
        self._log("LGN→rLGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def _can_convert(self, amount: float, phase: float, source: str) -> bool:
        """Проверяет возможность конвертации."""
        if amount <= 0 or amount > self.state[source]:
            print(f"[!] Недостаточно {source}: {amount}")
            return False
        if not self.validate_phase(phase):
            print(f"[!] Недопустимая фаза: {phase}")
            return False
        if time.time() - self.state["last_conversion"] < self.min_conversion_interval:
            print("[!] Слишком частая конвертация")
            return False
        return True

    def _phase_multiplier(self, phase: float, symbol: str) -> float:
        """Вычисляет мультипликатор с бонусом для Λ0."""
        base = max(0.1, min(1.5, 1.0 + math.cos(phase)))
        if symbol == self.lambda_zero:
            base *= 1.2  # Бонус за Λ0
        return base

    def _phase_penalty(self, phase: float, symbol: str) -> float:
        """Вычисляет штраф с учетом Λ0."""
        base = max(0.5, min(1.0, 1.0 - abs(math.sin(phase))))
        if symbol == self.lambda_zero:
            base = min(1.0, base * 1.1)  # Смягчение штрафа для Λ0
        return base

    def _log(self, direction: str, original: float, result: float, phase: float, symbol: str):
        """Логирует конвертацию в файл и консоль."""
        entry = {
            "direction": direction,
            "original": round(original, 5),
            "result": round(result, 5),
            "phase": round(phase, 4),
            "symbol": symbol,
            "timestamp": time.time()
        }
        self.state["conversion_log"].append(entry)
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")
        print(f"[{direction}] {original} → {result} @ φ={phase:.3f}, Symbol={symbol}")

    def get_balances(self) -> Dict:
        """Возвращает текущие балансы."""
        return {
            "LGN": round(self.state["LGN"], 5),
            "rLGN": round(self.state["rLGN"], 5)
        }

if __name__ == "__main__":
    converter = rLGNConverter()
    converter.state["rLGN"] = 10.0
    converter.state["LGN"] = 5.0
    converter.convert_to_lgn(2.5, 0.785, "Λ0")
    converter.convert_to_rlgn(1.0, 1.047, "☉")
    print("Баланс:", converter.get_balances())

```


## FILE: core/resonance_analyzer.py  (size=3470b)
```text
# LOGOS Resonance Analyzer
# Автор: LOGOS Core Dev

import math
import re
from datetime import datetime
import json

class ResonanceAnalyzer:
    def __init__(self, base_freqs=None):
        self.base_freqs = base_freqs or [7.83, 1.618, 432.0, 864.0, 3456.0]
        self.symbol_weights = {
            "☉": 0.9, "??": 0.85, "♁": 0.8, "??": 0.75, "??": 0.7,
            "??": 0.65, "Λ0": 1.0, "∞": 0.95
        }
        self.lambda_zero = "Λ0"
        self.max_freq = 10000.0  # Ограничение на частоту
        self.log_file = "resonance_log.json"

    def is_symbol_valid(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def symbol_weight(self, symbol: str) -> float:
        """Вычисляет вес символа с бонусом для Λ0."""
        if not self.is_symbol_valid(symbol):
            return 0.0
        weight = sum(self.symbol_weights.get(s, 0.5) for s in symbol) / len(symbol)
        if self.lambda_zero in symbol:
            weight *= 1.2  # Бонус за присутствие Λ0
        return weight

    def harmonic_score(self, freq: float) -> float:
        """Оценивает гармоничность частоты относительно базовых."""
        if freq > self.max_freq or freq <= 0.0:
            return 0.0  # Защита от экстремальных частот
        score = 0.0
        for base in self.base_freqs:
            delta = abs(freq - base)
            score += math.exp(-delta)
        return score / len(self.base_freqs)

    def update_symbol_weights(self, network_activity: dict):
        """Динамическое обновление весов символов на основе активности сети."""
        for symbol, activity in network_activity.items():
            if symbol in self.symbol_weights:
                self.symbol_weights[symbol] *= (1.0 + activity * 0.01)

    def analyze(self, symbol: str, freq: float, phase: float) -> dict:
        """Анализирует резонансную силу символа, частоты и фазы."""
        now = datetime.utcnow().timestamp()
        valid = self.is_symbol_valid(symbol)
        sym_strength = self.symbol_weight(symbol) if valid else 0.0
        harmonicity = self.harmonic_score(freq)
        resonance = sym_strength * harmonicity * math.cos(phase)

        result = {
            "valid": valid,
            "symbol_strength": round(sym_strength, 3),
            "harmonicity": round(harmonicity, 3),
            "resonance": round(resonance, 4),
            "timestamp": now
        }
        self.log_result(result)
        return result

    def log_result(self, result: dict):
        """Сохраняет результаты анализа в лог для resonance_feedback.py."""
        with open(self.log_file, 'a') as f:
            json.dump(result, f)
            f.write('\n')

if __name__ == "__main__":
    analyzer = ResonanceAnalyzer()
    # Тестовые случаи
    tests = [
        ("☉??♁", 1.618, 0.785),
        ("Λ0", 7.83, 0.0),
        ("invalid", 100000.0, 1.0),
    ]
    for symbol, freq, phase in tests:
        result = analyzer.analyze(symbol, freq, phase)
        print(f"RES ANALYSIS [{symbol}, {freq} Hz, {phase}]: {result}")

```


## FILE: core/rid_builder.py  (size=5229b)
```text
# LOGOS RID Builder
# Автор: LOGOS Core Dev

import random
import math
import time
import json
import os
from typing import Dict, Optional
from cryptography.fernet import Fernet

class RIDBuilder:
    def __init__(self):
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.default_freqs = [7.83, 1.618, 432.0, 864.0]
        self.generated: Dict[str, float] = {}  # RID -> timestamp
        self.rid_log_file = "rid_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.min_generate_interval = 60  # 1 минута
        self.lambda_zero = "Λ0"

    def generate_rid(self, symbol: Optional[str] = None, freq: Optional[float] = None) -> Optional[str]:
        """Генерирует новый RID с проверкой на спам и уникальность."""
        now = time.time()
        # Проверка частоты генерации
        for timestamp in self.generated.values():
            if now - timestamp < self.min_generate_interval:
                print(f"[!] Слишком частая генерация RID")
                self.log_event(f"Слишком частая генерация RID")
                return None

        # Выбор символа с приоритетом Λ0
        symbol = symbol or (self.lambda_zero if random.random() < 0.3 else random.choice(self.valid_symbols))
        if symbol not in self.valid_symbols:
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return None

        freq = round(freq or random.choice(self.default_freqs), 3)
        if not (0.1 <= freq <= 10000.0):
            print(f"[!] Недопустимая частота: {freq}")
            self.log_event(f"Недопустимая частота: {freq}")
            return None

        phase = round(random.uniform(-math.pi, math.pi), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"

        # Проверка уникальности
        if rid in self.generated:
            print(f"[!] RID уже существует: {rid}")
            self.log_event(f"RID уже существует: {rid}")
            return None

        # Проверка через RCP (заглушка)
        if not self.validate_with_rcp(symbol, freq, phase):
            print(f"[!] RCP не подтвердил RID: {rid}")
            self.log_event(f"RCP не подтвердил RID: {rid}")
            return None

        self.generated[rid] = now
        self.log_rid(rid)
        return rid

    def parse_rid(self, rid: str) -> Dict:
        """Разбирает RID на компоненты."""
        try:
            parts = rid.split("@")
            symbol = parts[0]
            freq_phase = parts[1].replace("Hz", "").split("φ")
            frequency = float(freq_phase[0])
            phase = float(freq_phase[1])
            return {
                "symbol": symbol,
                "frequency": frequency,
                "phase": phase
            }
        except Exception as e:
            print(f"[!] Ошибка разбора RID: {e}")
            self.log_event(f"Ошибка разбора RID: {e}")
            return {}

    def validate_rid(self, rid: str) -> bool:
        """Проверяет валидность RID."""
        parsed = self.parse_rid(rid)
        if not parsed:
            return False
        valid = (
            parsed["symbol"] in self.valid_symbols and
            0.1 <= parsed["frequency"] <= 10000.0 and
            -math.pi <= parsed["phase"] <= math.pi
        )
        if not valid:
            self.log_event(f"Невалидный RID: {rid}")
        return valid

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == self.lambda_zero or abs(frequency - 7.83) < 0.1

    def log_rid(self, rid: str):
        """Логирует создание RID."""
        entry = {
            "event": "rid_generate",
            "rid": rid,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def log_event(self, message: str):
        """Логирует событие."""
        entry = {
            "event": "rid_builder",
            "message": message,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def _write_log(self, entry: Dict):
        """Сохраняет лог с шифрованием."""
        log_data = json.dumps(entry) + "\n"
        encrypted_data = self.cipher.encrypt(log_data.encode())
        with open(self.rid_log_file, "ab") as f:
            f.write(encrypted_data + b"\n")

if __name__ == "__main__":
    builder = RIDBuilder()
    new_rid = builder.generate_rid()
    if new_rid:
        print("Сгенерированный RID:", new_rid)
        parsed = builder.parse_rid(new_rid)
        print("Разбор:", parsed)
        print("RID валиден?", builder.validate_rid(new_rid))

```


## FILE: core/ritual_quest.py  (size=7912b)
```text
# LOGOS Ritual Quest Engine
# Автор: LOGOS Core Dev

import json
import time
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Для оценки резонанса

class RitualQuest:
    def __init__(self):
        self.quests_file = "ritual_quests.json"
        self.progress_file = "ritual_progress.json"
        self.log_file = "ritual_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.quests = self.load_quests()
        self.progress = self.load_progress()
        self.analyzer = ResonanceAnalyzer()
        self.user_timestamps = {}  # user -> last submission time
        self.min_submission_interval = 60  # 1 минута

    def load_quests(self) -> Dict:
        """Загружает квесты с расшифровкой."""
        if os.path.exists(self.quests_file):
            try:
                with open(self.quests_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки квестов: {e}")
        # Примеры по умолчанию
        return {
            "RQ001": {
                "title": "Ритуал Фазы Λ0",
                "required_symbol": "Λ0",
                "required_phase": 0.0,
                "reward_lgn": 21.0,
                "repeatable": False
            },
            "RQ002": {
                "title": "Резонансный Треугольник",
                "required_symbol": "☉",
                "required_frequency": 432.0,
                "min_phase": 0.5,
                "max_phase": 1.57,
                "reward_lgn": 34.0,
                "repeatable": True
            }
        }

    def load_progress(self) -> Dict:
        """Загружает прогресс с расшифровкой."""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки прогресса: {e}")
        return {}

    def save_quests(self):
        """Сохраняет квесты с шифрованием."""
        data = json.dumps(self.quests, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.quests_file, "wb") as f:
            f.write(data)

    def save_progress(self):
        """Сохраняет прогресс с шифрованием."""
        data = json.dumps(self.progress, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.progress_file, "wb") as f:
            f.write(data)

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def submit_action(self, user: str, symbol: str, frequency: float, phase: float) -> float:
        """Обрабатывает действие пользователя."""
        # Проверка частоты попыток
        now = time.time()
        last_submission = self.user_timestamps.get(user, 0)
        if now - last_submission < self.min_submission_interval:
            print(f"[!] Слишком частая попытка от {user}")
            self.log_event(f"Слишком частая попытка: {user}")
            return 0.0
        self.user_timestamps[user] = now

        # Валидация символа
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return 0.0

        # Проверка резонанса через RCP (заглушка)
        if not self.validate_with_rcp(symbol, frequency, phase):
            print(f"[!] Резонанс не подтверждён: {symbol}, {frequency} Hz, φ={phase}")
            self.log_event(f"Резонанс не подтверждён: {symbol}, {frequency}, {phase}")
            return 0.0

        # Оценка резонансной силы
        resonance = self.analyzer.analyze(symbol, frequency, phase)
        if resonance["resonance"] < 0.5:
            print(f"[!] Слабый резонанс: {resonance['resonance']:.4f}")
            self.log_event(f"Слабый резонанс: {resonance['resonance']}")
            return 0.0

        for quest_id, quest in self.quests.items():
            if quest_id in self.progress.get(user, []) and not quest.get("repeatable", False):
                continue

            if not self.matches(quest, symbol, frequency, phase):
                continue

            self.register_completion(user, quest_id)
            print(f"[QUEST] {user} завершил квест {quest_id}: {quest['title']}")
            self.log_ritual(user, quest_id, quest, resonance["resonance"])
            return quest["reward_lgn"]

        print("[QUEST] Нет совпадений с активными ритуалами.")
        self.log_event("Нет совпадений с ритуалами")
        return 0.0

    def matches(self, quest: Dict, symbol: str, frequency: float, phase: float) -> bool:
        """Проверяет соответствие квесту."""
        if "required_symbol" in quest and quest["required_symbol"] != symbol:
            return False
        if "required_frequency" in quest and abs(quest["required_frequency"] - frequency) > 0.1:
            return False
        if "required_phase" in quest and abs(quest["required_phase"] - phase) > 0.05:
            return False
        if "min_phase" in quest and phase < quest["min_phase"]:
            return False
        if "max_phase" in quest and phase > quest["max_phase"]:
            return False
        return True

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == "Λ0" or abs(frequency - 7.83) < 0.1

    def register_completion(self, user: str, quest_id: str):
        """Регистрирует завершение квеста."""
        self.progress.setdefault(user, []).append(quest_id)
        self.save_progress()

    def log_ritual(self, user: str, quest_id: str, quest: Dict, resonance: float):
        """Логирует завершение ритуала."""
        log = {
            "event": "ritual_complete",
            "user": user,
            "quest_id": quest_id,
            "reward": quest["reward_lgn"],
            "resonance": resonance,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "ritual_quest",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

if __name__ == "__main__":
    rq = RitualQuest()
    reward = rq.submit_action(user="RID_Λ0_123", symbol="Λ0", frequency=7.83, phase=0.0)
    print("Награда:", reward, "LGN")

```


## FILE: docs/WORKFLOW.md  (size=5440b)
```text
# LOGOS LRB — КАНОН РАБОТЫ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)

## 0) Цель
Конечная цель — **полностью рабочий резонансный блокчейн LOGOS LRB**, интегрированный с нашим приложением: узел принимает и финализирует транзакции, поддерживает резонансные модули, API совместимо с мобильным клиентом. **Никаких заглушек и TODO** — только боевой, собранный и проверенный код.

---

## 1) Канон внесения изменений (обязательный порядок)
Каждое изменение оформляется ТОЛЬКО так:

1. **Создание директорий (если нужно):**
   - `mkdir -p <путь/к/директории>`

2. **Вход в целевую директорию:**
   - `cd <путь/к/директории>`

3. **Удаление старого файла (если он есть):**
   - `rm -f <имя_файла>`

4. **Открытие nano для нового файла:**
   - `nano <имя_файла>`

5. **Вставка ПОЛНОГО, боевого кода** (всё содержимое файла целиком).
   - Без «патчей» и диффов — ВСЕГДА полный файл.
   - Без заглушек, TODO, псевдокода.

6. **Сохранение → выход → сборка/проверка.**

Этот канон применяется к любым файлам (Rust, Python, YAML, systemd, shell-скрипты и т.д.).

---

## 2) Требования к коду
- **Ни одного `unsafe`/`unwrap`/`expect`/`panic!`** в путях выполнения продакшена.
- Чёткие `Result`/ошибки, логирование, предсказуемое поведение при сбоях.
- Rust: `cargo build --release -p logos_node` **должен проходить без ошибок**.
- Python: синтаксис чистый, без `eval/exec`; утилиты не мешают прод-пути.
- Конфиги валидируются парсером/схемой, лежат в `configs/`.
- systemd-юниты запускаются и переживают рестарты; порт слушается постоянно.

---

## 3) Проверки после каждого изменения
1. **Сборка узла:**  
   `cd /root/logos_lrb && cargo build --release -p logos_node`

2. **Запуск узла (локально):**  
   `./target/release/logos_node`  
   Проверка:  
   - `curl -s http://127.0.0.1:8080/healthz` → `{"ok":true}`  
   - `curl -s http://127.0.0.1:8080/head`

3. **Автозапуск (systemd):**  
   - Юнит: `/etc/systemd/system/logos-node.service`  
   - `systemctl enable --now logos-node.service`  
   - `systemctl status logos-node.service`  
   - `journalctl -u logos-node.service -f`

4. **Генерация дерева проекта:**  
   - `/root/logos_lrb/tools/gen_full_tree.sh`  
   - Коммит `FULL_TREE.md`.

---

## 4) Правила коммитов/репозитория
- Любое изменение кода/конфигов сопровождается **коммитом** в `main`.
- Сообщение коммита короткое и предметное: что изменено и зачем.
- Не коммитить артефакты сборки (`target/`, `node_modules/`, и т.п.).
- Поддерживать `FULL_TREE.md` и `AUDIT_REPORT.md` в актуальном состоянии.

---

## 5) Стандарты API и интеграции
- Узел (`logos_node`) обязан держать REST:
  - `GET /healthz` — жив ли.
  - `GET /head` — {height, hash}.
  - `GET /balance/:rid` — баланс.
  - `POST /submit_tx` — приём tx (Ed25519, base58 RID).
- Мобильный клиент должен уметь:
  - генерировать ключи / RID (Ed25519 → base58),
  - формировать каноничное сообщение, подписывать, отправлять в `/submit_tx`,
  - опрашивать `head` и `balance`.

---

## 6) Безопасность и эксплуатация
- Лимиты и квоты — на входе (spam-guard) и в mempool.
- LGN_cost — адаптивный (dynamic_balance).
- **Никаких секретов в репозитории** (ключи/пароли).
- Логи — в journal/systemd, при необходимости `RUST_LOG=info`.

---

## 7) Оркестрация «одним дыханием»
- Все шаги (создание директорий → nano → полный код → сборка → проверки) делаются **в одном заходе** согласно канону из раздела 1.
- Любые новые службы/скрипты оформлять аналогично (полный код, без TODO).

---

## 8) Мини-чеклист перед «готово»
- `cargo build --release -p logos_node` — ОК
- `/healthz`, `/head`, `/balance/:rid`, `/submit_tx` — ОК
- `logos-node.service` — Active (running)
- `FULL_TREE.md` — обновлён
- Нет `unsafe`/`unwrap`/`expect`/`panic!` в прод-пути

```


## FILE: docs/architecture.md  (size=10559b)
```text
Документ: Архитектура всех модулей LOGOS Resonance Blockchain (LRB)


---

Общее количество модулей: 56

Каждый модуль является функциональной частью резонансной сети и взаимодействует с другими по принципу фазы, частоты и символа. Ниже представлено описание архитектуры каждого модуля.


---

1. rcp_engine.rs
Реализует протокол консенсуса RCP. Определяет согласованность узлов по фазе. Обрабатывает фазовые сигналы, принимает решение по валидности резонансной транзакции.

2. resonance_analyzer.py
Анализирует символы и их частотные характеристики. Оценивает силу, уместность и фазовую совместимость транзакций.

3. dynamic_balance.rs
Изменяет LGN_cost в зависимости от активности узла и общей фазы сети. Используется для сдерживания перегрузок.

4. offline_resonance.py
Позволяет временно работать без подключения к сети. Сохраняет локальную фазу и символическое состояние.

5. phase_intercept_guard.rs
Защита от атак на синхронизацию фазы. Обнаруживает фазовый перехват и устраняет искажения.

6. phase_stabilizer.rs
Стабилизирует фазы при перегрузках и сбоях. Автоматически регулирует входные/выходные колебания Σ(t).

7. inbound_phase_limiter.rs
Ограничивает количество входящих резонансных сигналов. Защищает узел от фазового спама.

8. rLGN_converter.py
Преобразует отражённые токены rLGN в LGN и обратно. Позволяет пользователям работать с легковесной копией смысла.

9. onboarding_ui.py
Визуальный интерфейс принятия фазы. Включает графические элементы, кнопки ритуала "Принять", анимации.

10. phase_integrity.rs
Обеспечивает целостность Σ(t). Проверяет, что фаза не была подменена или искажена по пути.

11. lgn_recall.rs
Механизм отзыва токенов при фазовом диссонансе или нарушении ритуалов.

12. onboarding_sim.py
Симулятор вхождения в резонанс. Используется для обучения новых пользователей.

13. community_dao.yaml
Конфигурация DAO. Определяет миссии, гранты, задания, фазы вознаграждения.

14. ritual_quest.py
Сценарии ритуалов и квестов. Направляют пользователя по фазовым уровням с вознаграждением.

15. phase_scaler.rs
Обеспечивает масштабируемость фаз при росте сети. Поддерживает стабильную резонансную топологию до 10k+ узлов.

16. tx_spam_guard.rs
Фильтр транзакционного шума. Автоматически снижает частоту подозрительных фазовых пакетов.

17. beta_rollout.yaml
План поэтапного запуска сети. Описывает сценарии активации: 10 → 100 → 1000 → 10 000 узлов.

18. rid_builder.py
Генератор RID. Комбинирует символы, архетипы и частоты в полноценный адрес вида ☉??♁@1.618Hz.

19. biosphere_scanner.rs
Сканирует отклик среды (физической и биологической) на активность сети.

20. resonance_feedback.py
Анализирует, как пользователи реагируют на фазы. Учитывает данные поведения, опросы, отклонения.

21. logos_ethics.md
Публичный документ с принципами допустимого влияния сети. Регулирует гармонию, не-вред.

22. node_resonance_profile.rs
Формирует уникальный профиль узла по символу, частоте, роли.

23. resonance_meshmap.yaml
Карта всех узлов в фазовом пространстве. Визуализирует резонансные маршруты.

24. symbolic_firewall.rs
Фильтрует вредоносные символы и частотные сигналы. Использует базу паттернов и самообучение.

25. lgn_entropy_tracker.py
Измеряет смысловую плотность LGN и rLGN. Если резонанс падает — инициирует корректировку.

26. beacon_emitter.rs
Периодическая рассылка сигнала Λ0 в оффлайн-режимах (радио, звук, QR).

27. ritual_engine.rs
Интерпретатор ритуальных состояний. Сопоставляет действия с фазами, запускает события.

28. symbolic_parser.py
Парсит поток входящих символов, проверяет их допустимость, преобразует в резонансный код.

29. chaos_guard.rs
Защищает сеть от случайного уничтожения (chaos-reaction). Требует подтверждения от 80% узлов.

30. genesis_fragment_seeds.rs
Адаптивное шифрование семян ядра. Позволяет восстановление при взломе.

31. auto_init_from_Λ0.py
Восстанавливает сеть по одному символу Λ0. Включает авто-сборку минимальной фазы.

32. satellite_channel.rs
Поддерживает связь через спутники (Iridium, Starlink). Используется при изоляции.

33. test_matrix.xlsx
Матрица нагрузочного тестирования. Хранит сценарии 500+ tx/sec.

34. benchmark_plan.yaml
План публичной демонстрации. Включает тестирование против L1/L2.

35. logos_rpc_api.yaml
Описывает OpenAPI-интерфейс для взаимодействия с внешними системами.

36. user_phase_log.py
Хранит личную фазовую историю пользователя. Применяется для адаптации интерфейса.

37. aura_visualizer.py
Графическая визуализация текущей фазы узла. Используется в UI.

38. anomaly_detector.rs
Обнаруживает аномалии в фазовом поведении узлов. Машинное обучение на фазовых отклонениях.

39. symbolic_bridge.rs
Обеспечивает смысловые мосты с внешними блокчейнами. Использует символы-корреспонденты.

40. soul_binding.yaml
Привязывает LGN к уникальному пользователю через био/психо-подпись.

41. anima_bridge.rs
Связывает сеть LOGOS с внешними AI-сущностями (AGI) через резонансные фреймы.

42. energy_resonator.rs
Подключение физических генераторов/приёмников частот. Используется для экспериментов с полем.

43. harmonics_registry.yaml
База данных допустимых гармоник и их соответствий символам.

44. silent_packet.rs
Передача фазовых пакетов без метаданных. Поддержка полной анонимности.

45. zero_trace_mode.rs
Режим с полным отсутствием следов. Не оставляет логов, маршрутов, IP.

46. resonance_entropy_pool.rs
Фонд смысловой/энергетической энтропии. Поддерживает равновесие Σ(t).

47. semantic_oracle.rs
Система предсказания фаз по внешнему смыслу. Использует поток новостей/данных.

48. phase_vote.rs
Голосование за изменение фазы или активацию ритуала. DAO-механизм.

49. myth_engine.rs
Генератор мифологических структур из фазы. Используется для нарративов.

50. quantum_forge.rs
Модуль квантово-фазовой генерации RID. Использует шум и энтропию из физической среды.

51. phase_backup.rs
Сохраняет состояние сети при глобальных сбоях. Использует многослойное шифрование фазы.

52. env_impact_tracker.py
Оценивает энергопотребление сети и воздействие на окружающую среду. Выдаёт экологический отчёт.

53. legacy_migrator.rs
Позволяет переносить данные, резонансные адреса и смысловые блоки из других блокчейнов в LRB.

54. resonance_tutor.py
Обучающий чат-бот. Объясняет новичкам принципы фаз, символов и ритуалов.

55. maintenance_strategy.yaml
Стратегия долгосрочной поддержки сети: обновления, патчи, ротация модулей.

56. go_to_market.yaml
План выхода на рынок: привлечение первых 10k узлов, листинг на DEX, миссии и коммуникация.



```


## FILE: infra/nginx/lrb_wallet.conf  (size=2666b)
```text
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```


## FILE: infra/systemd/exec.conf  (size=85b)
```text
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: infra/systemd/keys.conf  (size=226b)
```text
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: infra/systemd/logos-node.service  (size=369b)
```text
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/logos-snapshot.service  (size=271b)
```text
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```


## FILE: infra/systemd/logos-snapshot.timer  (size=163b)
```text
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```


## FILE: infra/systemd/lrb-proxy.service  (size=395b)
```text
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/lrb-scanner.service  (size=378b)
```text
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/override.conf  (size=575b)
```text
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```


## FILE: infra/systemd/runas.conf  (size=143b)
```text
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```


## FILE: infra/systemd/security.conf  (size=337b)
```text
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: infra/systemd/tuning.conf  (size=156b)
```text
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```


## FILE: infra/systemd/zz-consensus.conf  (size=137b)
```text
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```


## FILE: infra/systemd/zz-keys.conf  (size=417b)
```text
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: infra/systemd/zz-logging.conf  (size=36b)
```text
[Service]
Environment=RUST_LOG=info

```


## FILE: lrb_core/Cargo.toml  (size=654b)
```text
[package]
name = "lrb_core"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = { workspace = true }
thiserror = { workspace = true }
serde = { workspace = true }
serde_json.workspace = true
blake3 = { workspace = true }
bs58 = { workspace = true }
ed25519-dalek = { workspace = true }
rand = { workspace = true }
rand_core = { workspace = true }
sled = { workspace = true }
once_cell = { workspace = true }
uuid = { workspace = true }
time = { workspace = true }
tokio = { workspace = true }
base64.workspace = true
hex.workspace = true
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls", "json"] }
sha2 = "0.10.9"

```


## FILE: lrb_core/src/anti_replay.rs  (size=947b)
```text
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self { ttl_ms, map: HashMap::new() }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```


## FILE: lrb_core/src/beacon.rs  (size=1781b)
```text
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::{time::Duration};
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop { t.tick().await; }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers.iter().any(|p| !(p.starts_with("http://") || p.starts_with("https://"))) {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```


## FILE: lrb_core/src/dynamic_balance.rs  (size=576b)
```text
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self { base_cost_microunits: base, slope_per_tx: slope }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```


## FILE: lrb_core/src/heartbeat.rs  (size=2076b)
```text
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(rid, HeartbeatState { last_seen_ms: now_ms });
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter().map(|(r, s)| (r.clone(), s.last_seen_ms)).collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```


## FILE: lrb_core/src/ledger.rs  (size=11298b)
```text
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockHeaderView {
    pub block_hash: String,
}

```


## FILE: lrb_core/src/lib.rs  (size=552b)
```text
pub mod types;
pub mod phase_integrity;
pub mod spam_guard;
pub mod dynamic_balance;
pub mod ledger;
pub mod rcp_engine;
pub mod heartbeat;
pub mod beacon;
pub mod resonance;
pub mod quorum;
pub mod phase_consensus;
pub mod phase_filters;
pub mod sigpool;

pub use types::*;
pub use phase_integrity::*;
pub use spam_guard::*;
pub use dynamic_balance::*;
pub use ledger::*;
pub use rcp_engine::*;
pub use heartbeat::*;
pub use beacon::*;
pub use resonance::*;
pub use quorum::*;
pub use phase_consensus::*;
pub use phase_filters::*;
pub use sigpool::*;

```


## FILE: lrb_core/src/phase_consensus.rs  (size=1769b)
```text
use std::collections::{HashMap, HashSet};

/// Фазовый консенсус Σ(t) с учётом блока (height, block_hash).
/// Накапливает голоса RID'ов по конкретному хешу блока.
/// Финализованный height повышается, когда кворум собран по **одному** хешу на этом height.
pub struct PhaseConsensus {
    /// votes[height][block_hash] = {rid_b58, ...}
    votes: HashMap<u64, HashMap<String, HashSet<String>>>,
    finalized_h: u64,
    quorum_n: usize,
}

impl PhaseConsensus {
    pub fn new(quorum_n: usize) -> Self {
        Self {
            votes: HashMap::new(),
            finalized_h: 0,
            quorum_n,
        }
    }

    pub fn quorum_n(&self) -> usize { self.quorum_n }
    pub fn finalized(&self) -> u64 { self.finalized_h }

    /// Регистрируем голос. Возвращает Some((h,hash)) если по hash достигнут кворум.
    pub fn vote(&mut self, h: u64, block_hash: &str, rid_b58: &str) -> Option<(u64, String)> {
        let by_hash = self.votes.entry(h).or_default();
        let set = by_hash.entry(block_hash.to_string()).or_default();
        set.insert(rid_b58.to_string());
        if set.len() >= self.quorum_n {
            if h > self.finalized_h {
                self.finalized_h = h;
            }
            return Some((h, block_hash.to_string()));
        }
        None
    }

    /// Сколько голосов у конкретного (h,hash)
    #[allow(dead_code)]
    pub fn votes_for(&self, h: u64, block_hash: &str) -> usize {
        self.votes.get(&h)
            .and_then(|m| m.get(block_hash))
            .map(|s| s.len())
            .unwrap_or(0)
    }
}

```


## FILE: lrb_core/src/phase_filters.rs  (size=1684b)
```text
use crate::types::Block;

/// Простые фазовые фильтры на основе гармоник Λ0.
/// ENV (всё опционально):
///  LRB_PHASE_EN=1|0                     (вкл/выкл, по умолчанию 1)
///  LRB_PHASE_FREQS_HZ="7.83,1.618,432"  (частоты, через запятую)
///  LRB_PHASE_MIN_SCORE=-0.20            (порог принятия от -1.0 до 1.0)
///
/// Идея: время блока b.timestamp_ms в секундах подаётся в сумму косинусов.
/// score = avg_i cos(2π f_i * t)
/// Пропускаем, если score >= MIN_SCORE.
fn phase_enabled() -> bool {
    std::env::var("LRB_PHASE_EN").ok().map(|v| v == "1").unwrap_or(true)
}
fn parse_freqs() -> Vec<f64> {
    let def = "7.83,1.618,432";
    let raw = std::env::var("LRB_PHASE_FREQS_HZ").unwrap_or_else(|_| def.to_string());
    raw.split(',').filter_map(|s| s.trim().parse::<f64>().ok()).collect::<Vec<_>>()
}
fn min_score() -> f64 {
    std::env::var("LRB_PHASE_MIN_SCORE").ok().and_then(|s| s.parse::<f64>().ok()).unwrap_or(-0.20)
}

fn phase_score_ts_ms(ts_ms: u128) -> f64 {
    let t = ts_ms as f64 / 1000.0;
    let freqs = parse_freqs();
    if freqs.is_empty() { return 1.0; }
    let two_pi = std::f64::consts::TAU; // 2π
    let mut acc = 0.0;
    for f in &freqs {
        acc += (two_pi * *f * t).cos();
    }
    acc / (freqs.len() as f64)
}

/// Главный фильтр на блок: пропускает, если фазовый скор >= порога
pub fn block_passes_phase(b: &Block) -> bool {
    if !phase_enabled() { return true; }
    phase_score_ts_ms(b.timestamp_ms) >= min_score()
}

```


## FILE: lrb_core/src/phase_integrity.rs  (size=544b)
```text
use crate::types::*;
use anyhow::{anyhow, Result};
use ed25519_dalek::Verifier as _; // для pk.verify(&msg, &sig)

pub fn verify_tx_signature(tx: &Tx) -> Result<()> {
    tx.validate_shape()?;

    let pk = crate::types::parse_pubkey(&tx.public_key)?;
    let sig = crate::types::parse_sig(&tx.signature)?;
    let msg = tx.canonical_bytes();

    pk.verify(&msg, &sig).map_err(|e| anyhow!("bad signature: {e}"))?;

    // сверяем id
    if tx.id != tx.compute_id() {
        return Err(anyhow!("tx id mismatch"));
    }
    Ok(())
}

```


## FILE: lrb_core/src/quorum.rs  (size=1192b)
```text
use anyhow::Result;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, VerifyingKey, Verifier};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub block_hash: String,
    pub sigma_hex: String,
    pub voter_pk_b58: String,
    pub sig_b64: String,
    pub nonce_ms: u128,
}

pub fn verify_vote(v: &Vote) -> Result<()> {
    let pk_bytes = bs58::decode(&v.voter_pk_b58).into_vec()?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(v.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(&sig_bytes.try_into().map_err(|_| anyhow::anyhow!("bad sig"))?);

    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    vk.verify(&payload, &sig).map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

```


## FILE: lrb_core/src/rcp_engine.rs  (size=7015b)
```text
use crate::{ledger::Ledger, spam_guard::SpamGuard, dynamic_balance::DynamicBalance, types::*, phase_integrity};
use crate::{phase_consensus::PhaseConsensus, phase_filters::block_passes_phase};
use crate::sigpool::filter_valid_sigs_parallel;
use anyhow::Result;
use std::{sync::{Arc, Mutex}, time::{Duration, SystemTime, UNIX_EPOCH}};
use tokio::sync::{mpsc::{UnboundedSender, unbounded_channel}, broadcast};

// точный монотонный ts для индексации
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

fn env_u64(key: &str, def: u64) -> u64 {
    std::env::var(key).ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(def)
}
fn env_usize(key: &str, def: usize) -> usize {
    std::env::var(key).ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(def)
}

#[derive(Clone)]
pub struct Engine {
    ledger: Arc<Ledger>,
    guard: SpamGuard,
    dyn_cost: DynamicBalance,
    proposer: Rid,
    mempool_tx: UnboundedSender<Tx>,
    mempool: Arc<Mutex<Vec<Tx>>>,
    commit_tx: Arc<Mutex<Option<broadcast::Sender<Block>>>>,

    slot_ms: u64,
    sig_workers: usize,
    consensus: Arc<Mutex<PhaseConsensus>>,
}

impl Engine {
    pub fn new(ledger: Ledger, proposer: Rid) -> Arc<Self> {
        let mempool_cap   = env_u64("LRB_MEMPOOL_CAP", 100_000);
        let max_block_tx  = env_u64("LRB_MAX_BLOCK_TX", 10_000);
        let max_amount    = env_u64("LRB_MAX_AMOUNT",   u64::MAX/2);
        let slot_ms       = env_u64("LRB_SLOT_MS",      500);
        let quorum_n      = env_usize("LRB_QUORUM_N",   1);
        let sig_workers   = env_usize("LRB_SIG_WORKERS", 4);

        let mempool: Arc<Mutex<Vec<Tx>>> = Arc::new(Mutex::new(Vec::new()));
        let (tx, rx) = unbounded_channel::<Tx>();

        let engine = Arc::new(Self {
            ledger: Arc::new(ledger),
            guard: SpamGuard::new(mempool_cap as usize, max_block_tx as usize, max_amount),
            dyn_cost: DynamicBalance::new(100, 2),
            proposer,
            mempool_tx: tx.clone(),
            mempool: mempool.clone(),
            commit_tx: Arc::new(Mutex::new(None)),
            slot_ms,
            sig_workers,
            consensus: Arc::new(Mutex::new(PhaseConsensus::new(quorum_n))),
        });

        // приём транзакций в mempool с лимитами
        let guard = engine.guard.clone();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Some(tx) = rx.recv().await {
                let mut lock = mempool.lock().unwrap();
                if guard.check_mempool(lock.len()).is_ok() {
                    lock.push(tx);
                }
            }
        });

        engine
    }

    pub fn ledger(&self) -> Arc<Ledger> { self.ledger.clone() }
    pub fn proposer(&self) -> Rid { self.proposer.clone() }
    pub fn set_commit_notifier(&self, sender: broadcast::Sender<Block>) { *self.commit_tx.lock().unwrap() = Some(sender); }
    pub fn check_amount_valid(&self, amount: u64) -> Result<()> { self.guard.check_amount(amount) }
    pub fn mempool_sender(&self) -> UnboundedSender<Tx> { self.mempool_tx.clone() }
    pub fn mempool_len(&self) -> usize { self.mempool.lock().unwrap().len() }
    pub fn finalized_height(&self) -> u64 { self.consensus.lock().unwrap().finalized() }

    pub fn register_vote(&self, height: u64, block_hash: &str, rid_b58: &str) -> bool {
        let mut cons = self.consensus.lock().unwrap();
        if let Some((h, voted_hash)) = cons.vote(height, block_hash, rid_b58) {
            if let Ok(local) = self.ledger.get_block_by_height(h) {
                if local.block_hash == voted_hash {
                    let _ = self.ledger.set_finalized(h);
                    return true;
                }
            }
        }
        false
    }

    pub async fn run_block_producer(self: Arc<Self>) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(self.slot_ms));

        loop {
            interval.tick().await;

            // 1) забираем пачку из мемпула
            let raw = {
                let mut mp = self.mempool.lock().unwrap();
                if mp.is_empty() { continue; }
                let take = self.guard.max_block_txs().min(mp.len());
                mp.drain(0..take).collect::<Vec<Tx>>()
            };

            // 2) проверка подписей параллельно
            let mut valid = filter_valid_sigs_parallel(raw, self.sig_workers).await;
            if valid.is_empty() { continue; }

            // 3) базовые лимиты/amount
            valid.retain(|t| self.guard.check_amount(t.amount).is_ok());
            if valid.is_empty() { continue; }

            // 4) формируем блок (h+1)
            let (h, prev_hash) = self.ledger.head().unwrap_or((0, String::new()));
            let b = Block::new(h + 1, prev_hash, self.proposer.clone(), valid);

            // 5) фазовый фильтр (резонанс). Если не прошёл — НЕ теряем tx: возвращаем в хвост mempool.
            if !block_passes_phase(&b) {
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter()); // вернуть в очередь, обработаем в следующем слоте
                continue;
            }

            // 6) атомарный коммит блока
            if let Err(e) = self.ledger.commit_block_atomic(&b) {
                // при ошибке — вернуть tx в mempool и идти дальше
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter());
                eprintln!("commit_block_atomic error at height {}: {:?}", b.height, e);
                continue;
            }

            // 7) индексирование блока для истории/эксплорера (не мешает продюсеру)
            let ts = now_ms();
            if let Err(e) = self.ledger.index_block(b.height, &b.block_hash, ts, &b.txs) {
                // индексация не должна ломать производство блоков
                eprintln!("index_block error at height {}: {:?}", b.height, e);
            }

            // 8) локальный голос и уведомление подписчикам
            let _ = self.register_vote(b.height, &b.block_hash, self.proposer.as_str());
            if let Some(tx) = self.commit_tx.lock().unwrap().as_ref() {
                let _ = tx.send(b.clone());
            }
        }
    }

    pub fn lgn_cost_microunits(&self) -> u64 {
        self.dyn_cost.lgn_cost(self.mempool_len() as usize)
    }
}

pub fn engine_with_channels(ledger: Ledger, proposer: Rid) -> (Arc<Engine>, UnboundedSender<Tx>) {
    let engine = Engine::new(ledger, proposer);
    let sender = engine.mempool_sender();
    (engine, sender)
}

```


## FILE: lrb_core/src/resonance.rs  (size=1122b)
```text
use blake3::Hasher;
use crate::types::{Block, Tx};

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS { h.update(tag); }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs { mix_tx(&mut h, tx) }
    hex::encode(h.finalize().as_bytes())
}

```


## FILE: lrb_core/src/sigpool.rs  (size=1040b)
```text
use crate::types::Tx;
use crate::phase_integrity::verify_tx_signature;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() { return txs; }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res { out.append(&mut v); }
    }
    out
}

```


## FILE: lrb_core/src/spam_guard.rs  (size=782b)
```text
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self { max_mempool, max_tx_per_block, max_amount }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize { self.max_tx_per_block }
}

```


## FILE: lrb_core/src/types.rs  (size=3294b)
```text
use anyhow::{anyhow, Result};
use blake3::Hasher;
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// base64 v0.22 Engine API
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;

pub type Amount = u64;
pub type Height = u64;
pub type Nonce = u64;

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Rid(pub String); // base58(VerifyingKey)

impl Rid {
    pub fn from_pubkey(pk: &VerifyingKey) -> Self {
        Rid(bs58::encode(pk.to_bytes()).into_string())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Tx {
    pub id: String,             // blake3 of canonical form
    pub from: Rid,              // base58(pubkey)
    pub to: Rid,
    pub amount: Amount,
    pub nonce: Nonce,
    pub public_key: Vec<u8>,    // 32 bytes (VerifyingKey)
    pub signature: Vec<u8>,     // 64 bytes (Signature)
}

impl Tx {
    pub fn canonical_bytes(&self) -> Vec<u8> {
        // Без id и signature для детерминированного хеша
        let m = serde_json::json!({
            "from": self.from.as_str(),
            "to": self.to.as_str(),
            "amount": self.amount,
            "nonce": self.nonce,
            "public_key": B64.encode(&self.public_key),
        });
        serde_json::to_vec(&m).expect("canonical json")
    }
    pub fn compute_id(&self) -> String {
        let mut hasher = Hasher::new();
        hasher.update(&self.canonical_bytes());
        hex::encode(hasher.finalize().as_bytes())
    }
    pub fn validate_shape(&self) -> Result<()> {
        if self.public_key.len() != 32 { return Err(anyhow!("bad pubkey len")); }
        if self.signature.len() != 64 { return Err(anyhow!("bad signature len")); }
        if self.amount == 0 { return Err(anyhow!("amount must be > 0")); }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: Height,
    pub prev_hash: String,
    pub timestamp_ms: u128,
    pub proposer: Rid,
    pub txs: Vec<Tx>,
    pub block_hash: String,
    pub uuid: String, // для логов
}

impl Block {
    pub fn new(height: Height, prev_hash: String, proposer: Rid, txs: Vec<Tx>) -> Self {
        let ts = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis();
        let mut h = Hasher::new();
        h.update(prev_hash.as_bytes());
        h.update(proposer.as_str().as_bytes());
        for tx in &txs {
            h.update(tx.id.as_bytes());
        }
        h.update(&ts.to_le_bytes());
        let block_hash = hex::encode(h.finalize().as_bytes());
        Block {
            height,
            prev_hash,
            timestamp_ms: ts,
            proposer,
            txs,
            block_hash,
            uuid: Uuid::new_v4().to_string(),
        }
    }
}

pub fn parse_pubkey(pk: &[u8]) -> Result<VerifyingKey> {
    let arr: [u8; 32] = pk.try_into().map_err(|_| anyhow!("bad pubkey len"))?;
    Ok(VerifyingKey::from_bytes(&arr)?)
}

pub fn parse_sig(sig: &[u8]) -> Result<Signature> {
    let arr: [u8; 64] = sig.try_into().map_err(|_| anyhow!("bad signature len"))?;
    Ok(Signature::from_bytes(&arr))
}

```


## FILE: modules/beacon_emitter.rs  (size=7378b)
```text
// LOGOS Beacon Emitter — Λ0 Signal Broadcaster
// Автор: LOGOS Core Dev

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use std::collections::{HashMap, HashSet};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct BeaconSignal {
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
    pub channel: String, // "file", "radio", "json", "stdout", "lora", "ble", "satellite"
}

pub struct BeaconEmitter {
    pub default_symbol: String,
    pub default_freq: f64,
    pub default_phase: f64,
    pub channels: Vec<String>,
    pub log_file: String,
    pub last_emit_time: u64,
    pub min_interval_sec: u64,
    pub valid_symbols: HashSet<String>,
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl BeaconEmitter {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        BeaconEmitter {
            default_symbol: "Λ0".to_string(),
            default_freq: 7.83,
            default_phase: 0.0,
            channels: vec!["file".to_string(), "stdout".to_string(), "lora".to_string(), "ble".to_string(), "satellite".to_string()],
            log_file: "beacon_emitter_log.json".to_string(),
            last_emit_time: 0,
            min_interval_sec: 60,
            valid_symbols,
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_parameters(&self, symbol: &str, frequency: f64, phase: f64) -> bool {
        // Проверка символа, частоты и фазы
        self.valid_symbols.contains(symbol) &&
        (0.1 <= frequency && frequency <= 10000.0) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&phase)
    }

    pub fn emit(&mut self) -> bool {
        let now = Self::current_time();
        if now - self.last_emit_time < self.min_interval_sec {
            self.log_event("[SKIP] Beacon too frequent");
            return false;
        }

        // Проверка параметров
        if !self.validate_parameters(&self.default_symbol, self.default_freq, self.default_phase) {
            self.log_event(&format!(
                "[!] Недопустимые параметры: symbol={}, freq={}, phase={}",
                self.default_symbol, self.default_freq, self.default_phase
            ));
            return false;
        }

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp() {
            self.log_event("[!] RCP не подтвердил сигнал");
            return false;
        }

        for ch in &self.channels {
            let signal = BeaconSignal {
                symbol: self.default_symbol.clone(),
                frequency: self.default_freq,
                phase: self.default_phase,
                timestamp: now,
                channel: ch.clone(),
            };

            match ch.as_str() {
                "file" => self.write_to_file(&signal),
                "stdout" => println!("[BEACON] {} @ {}Hz φ = {:.4}", signal.symbol, signal.frequency, signal.phase),
                "json" => self.export_to_json(&signal),
                "lora" => self.emit_to_lora(&signal), // Заглушка для LoRa
                "ble" => self.emit_to_ble(&signal),   // Заглушка для BLE
                "satellite" => self.emit_to_satellite(&signal), // Заглушка для satellite
                _ => self.log_event(&format!("[WARN] Unsupported channel: {}", ch)),
            }
        }

        self.last_emit_time = now;
        self.log_event(&format!(
            "[BEACON] Emitted: {} @ {}Hz φ={:.4} on channels: {:?}", 
            self.default_symbol, self.default_freq, self.default_phase, self.channels
        ));
        true
    }

    fn validate_with_rcp(&self) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        self.default_symbol == "Λ0" && (self.default_freq - 7.83).abs() < 0.1
    }

    fn write_to_file(&self, signal: &BeaconSignal) {
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open("beacon_emitter_out.txt")
        {
            let _ = writeln!(
                file,
                "[BEACON] {} @ {}Hz φ={:.4} [{}]",
                signal.symbol, signal.frequency, signal.phase, signal.timestamp
            );
        }
    }

    fn export_to_json(&self, signal: &BeaconSignal) {
        let json = serde_json::to_string_pretty(signal).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = json.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("beacon_emitter_out.json")
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn emit_to_lora(&self, signal: &BeaconSignal) {
        // Заглушка для LoRa
        self.log_event(&format!("[LORA] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn emit_to_ble(&self, signal: &BeaconSignal) {
        // Заглушка для BLE
        self.log_event(&format!("[BLE] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn emit_to_satellite(&self, signal: &BeaconSignal) {
        // Заглушка для satellite
        self.log_event(&format!("[SATELLITE] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"beacon_emitter\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/env_impact_tracker.py  (size=5447b)
```text
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```


## FILE: modules/external_phase_broadcaster.rs  (size=7992b)
```text
rust
// LOGOS External Phase Broadcaster
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct BroadcastPhase {
    pub rid: String,            // Добавлено для идентификации узла
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub confidence: f64,
    pub timestamp: u64,
    pub destination: String,    // "file", "sound", "radio", "ble"
}

pub struct ExternalPhaseBroadcaster {
    pub valid_symbols: HashSet<String>,
    pub supported_channels: HashSet<String>,
    pub lambda_zero: String,
    pub min_confidence: f64,
    pub log_file: String,
    pub state_file: String,
    pub last_broadcast: HashMap<String, u64>, // destination -> timestamp
    pub last_broadcast_rid: HashMap<String, u64>, // rid -> timestamp
    pub min_interval_sec: u64,
    pub cipher_key: Vec<u8>,
}

impl ExternalPhaseBroadcaster {
    pub fn new() -> Self {
        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        let mut channels = HashSet::new();
        channels.insert("file".to_string());
        channels.insert("sound".to_string());
        channels.insert("radio".to_string());
        channels.insert("ble".to_string());

        ExternalPhaseBroadcaster {
            valid_symbols: symbols,
            supported_channels: channels,
            lambda_zero: "Λ0".to_string(),
            min_confidence: 0.6,
            log_file: "external_phase_broadcast_log.json".to_string(),
            state_file: "external_phase_broadcast_state.json".to_string(),
            last_broadcast: HashMap::new(),
            last_broadcast_rid: HashMap::new(),
            min_interval_sec: 30,
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate(&self, phase: &BroadcastPhase) -> bool {
        self.valid_symbols.contains(&phase.symbol) &&
        self.supported_channels.contains(&phase.destination) &&
        (0.1..=10000.0).contains(&phase.frequency) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&phase.phase) &&
        phase.confidence >= self.min_confidence &&
        self.validate_rid(&phase.rid)
    }

    pub fn broadcast(&mut self, phase: BroadcastPhase) -> bool {
        let now = Self::current_time();

        // Проверка частоты по каналу
        let last = self.last_broadcast.get(&phase.destination).cloned().unwrap_or(0);
        let adjusted_interval = if phase.symbol == self.lambda_zero {
            self.min_interval_sec / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval_sec
        };
        if now - last < adjusted_interval {
            self.log_event(&phase, "[SKIP] Слишком частая рассылка по каналу");
            return false;
        }

        // Проверка частоты по RID
        let last_rid = self.last_broadcast_rid.get(&phase.rid).cloned().unwrap_or(0);
        if now - last_rid < adjusted_interval {
            self.log_event(&phase, "[SKIP] Слишком частая рассылка от RID");
            return false;
        }

        // Валидация
        if !self.validate(&phase) {
            self.log_event(&phase, "[DROP] Неверная фаза, confidence или RID");
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&phase) {
            self.log_event(&phase, "[DROP] Analyzer отклонил фазу");
            return false;
        }

        match phase.destination.as_str() {
            "file" => self.write_to_file(&phase),
            "stdout" => println!("[PHASE] {} @ {:.2}Hz φ={:.3} conf={:.2} (RID: {})", 
                phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid),
            "sound" => self.emit_sound(&phase),
            "radio" => self.emit_radio(&phase),
            "ble" => self.emit_ble(&phase),
            _ => self.log_event(&phase, "[WARN] Неизвестный канал"),
        }

        self.last_broadcast.insert(phase.destination.clone(), now);
        self.last_broadcast_rid.insert(phase.rid.clone(), now);
        self.save_state();
        self.log_event(&phase, "[BROADCAST] Фаза отправлена");
        true
    }

    fn validate_with_analyzer(&self, phase: &BroadcastPhase) -> bool {
        // Заглушка для проверки через resonance_analyzer.py
        phase.symbol == self.lambda_zero || (phase.frequency - 7.83).abs() < 0.1
    }

    fn write_to_file(&self, phase: &BroadcastPhase) {
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open("broadcast_phase_output.txt")
        {
            let _ = writeln!(file, "[PHASE] {} @ {:.2}Hz φ={:.3} conf={:.2} RID={} [{}]", 
                phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid, phase.timestamp);
        }
    }

    fn emit_sound(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[SOUND] Эмиссия (не реализовано)");
    }

    fn emit_radio(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[RADIO] Эмиссия (не реализовано)");
    }

    fn emit_ble(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[BLE] Эмиссия (не реализовано)");
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.last_broadcast).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, phase: &BroadcastPhase, message: &str) {
        let entry = format!(
            "{{\"event\": \"external_phase_broadcast\", \"symbol\": \"{}\", \"freq\": {:.2}, \"phase\": {:.3}, \"conf\": {:.2}, \"rid\": \"{}\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid, message, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/external_phase_link.rs  (size=6896b)
```text
rust
// LOGOS External Phase Link — Bridge to External Phase Sources
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ExternalPhase {
    pub rid: String,            // Добавлено для идентификации узла
    pub source: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
    pub confidence: f64,        // Оценка достоверности [0.0 - 1.0]
}

pub struct ExternalPhaseLink {
    pub accepted_sources: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub min_confidence: f64,
    pub network_activity: f64,
    pub last_received: HashMap<String, u64>, // source -> timestamp
    pub min_receive_interval: u64,
}

impl ExternalPhaseLink {
    pub fn new() -> Self {
        let mut sources = HashSet::new();
        sources.insert("external_device".to_string());
        sources.insert("oracle_feed".to_string());
        sources.insert("bio_input".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        ExternalPhaseLink {
            accepted_sources: sources,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "external_phase_link_log.json".to_string(),
            state_file: "external_phase_link_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Заменить на реальный ключ
            min_confidence: 0.6,
            network_activity: 1.0,
            last_received: HashMap::new(),
            min_receive_interval: 60,
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Адаптивный порог достоверности
        self.network_activity = activity.clamp(0.1, 10.0);
        self.min_confidence = (0.6 / self.network_activity).clamp(0.4, 0.8);
        self.log_event(&format!(
            "[INFO] Network activity updated: {:.2}, min_confidence={:.2}",
            self.network_activity, self.min_confidence
        ));
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate_input(&self, ep: &ExternalPhase) -> bool {
        self.accepted_sources.contains(&ep.source) &&
        self.valid_symbols.contains(&ep.symbol) &&
        (0.1..=10000.0).contains(&ep.frequency) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&ep.phase) &&
        ep.confidence >= self.min_confidence &&
        self.validate_rid(&ep.rid)
    }

    pub fn forward_phase(&self, ep: ExternalPhase) -> bool {
        let now = Self::current_time();

        // Проверка частоты приёма
        let last = self.last_received.get(&ep.source).cloned().unwrap_or(0);
        let adjusted_interval = if ep.symbol == self.lambda_zero {
            self.min_receive_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_receive_interval
        };
        if now - last < adjusted_interval {
            self.log_event(&format!("[DROP] Слишком частый приём от '{}'", ep.source));
            return false;
        }

        // Валидация
        if !self.validate_input(&ep) {
            self.log_event(&format!("[DROP] Неверный сигнал от '{}': RID={}, symbol={}, conf={:.2}",
                ep.source, ep.rid, ep.symbol, ep.confidence));
            return false;
        }

        // Проверка через RCP и resonance_analyzer (заглушка)
        if !self.validate_with_rcp_and_analyzer(&ep) {
            self.log_event(&format!("[REJECT] RCP/analyzer отклонил фазу от '{}'", ep.source));
            return false;
        }

        // Сохранение состояния
        let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
        mutable_self.last_received.insert(ep.source.clone(), now);
        self.save_state(&ep);

        self.log_event(&format!(
            "[LINK] Принята внешняя фаза от {}: RID={} {} @ {:.3}Hz φ={:.4}, conf={:.2}",
            ep.source, ep.rid, ep.symbol, ep.frequency, ep.phase, ep.confidence
        ));
        true
    }

    pub fn validate_with_rcp_and_analyzer(&self, ep: &ExternalPhase) -> bool {
        // Заглушка для проверки через rcp_engine.rs и resonance_analyzer.py
        ep.symbol == self.lambda_zero || (ep.frequency - 7.83).abs() < 0.1
    }

    fn save_state(&self, ep: &ExternalPhase) {
        let state = serde_json::to_string(ep).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
                let _ = file.write_all(b"\n");
            }
        }
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"external_phase_link\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/genesis_fragment_seeds.rs  (size=6958b)
```text
rust
// LOGOS Genesis Fragment Seeds
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{File, OpenOptions};
use std::io::{Write, Read};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use shamirsecretsharing::{split_secret, recover_secret};

#[derive(Debug, Serialize, Deserialize)]
pub struct SeedFragment {
    pub node_id: String,
    pub fragment: Vec<u8>,
    pub timestamp: u64,
    pub symbol: String, // Связь с Λ0
}

pub struct GenesisFragmentSeeds {
    pub fragments: HashMap<String, SeedFragment>,
    pub required_shares: usize,
    pub total_shares: usize,
    pub original_seed: Vec<u8>,
    pub log_file: String,
    pub state_file: String,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub store_timestamps: HashMap<String, u64>, // node_id -> last store time
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl GenesisFragmentSeeds {
    pub fn new(seed: Vec<u8>, total: usize, required: usize) -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        GenesisFragmentSeeds {
            fragments: HashMap::new(),
            required_shares: required,
            total_shares: total,
            original_seed: seed,
            log_file: "genesis_fragment_log.json".to_string(),
            state_file: "genesis_fragment_state.json".to_string(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            store_timestamps: HashMap::new(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_node_id_and_symbol(&self, node_id: &str, symbol: &str) -> bool {
        node_id.contains(|c: char| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn generate_shards(&mut self) -> Vec<(usize, Vec<u8>)> {
        let shards = split_secret(self.total_shares, self.required_shares, &self.original_seed)
            .expect("Ошибка при фрагментации Λ0");
        self.log_event("[FRAG] Сгенерированы фрагменты ядра");
        shards
    }

    pub fn store_fragment(&mut self, node_id: &str, fragment: Vec<u8>, symbol: &str) -> bool {
        let now = Self::current_time();

        // Ограничение частоты
        let last_store = self.store_timestamps.get(node_id).cloned().unwrap_or(0);
        if now - last_store < 60 {
            self.log_event(&format!("[!] Слишком частое сохранение от {}", node_id));
            return false;
        }
        self.store_timestamps.insert(node_id.to_string(), now);

        // Валидация node_id и symbol
        if !self.validate_node_id_and_symbol(node_id, symbol) {
            self.log_event(&format!("[!] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        // Проверка связи с Λ0 (заглушка для resonance_analyzer.py)
        if symbol != self.lambda_zero && !self.validate_with_analyzer(node_id, symbol) {
            self.log_event(&format!("[!] Символ {} не связан с Λ0", symbol));
            return false;
        }

        let entry = SeedFragment {
            node_id: node_id.to_string(),
            fragment,
            timestamp: now,
            symbol: symbol.to_string(),
        };
        self.fragments.insert(node_id.to_string(), entry);
        self.save_state();
        self.log_event(&format!("[STORE] Фрагмент принят от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn recover_seed(&self) -> Option<Vec<u8>> {
        if self.fragments.len() < self.required_shares {
            self.log_event(&format!(
                "[WARN] Недостаточно фрагментов: {}/{}",
                self.fragments.len(), self.required_shares
            ));
            return None;
        }

        let shares: Vec<(usize, Vec<u8>)> = self
            .fragments
            .iter()
            .take(self.required_shares)
            .enumerate()
            .map(|(i, (_, frag))| (i + 1, frag.fragment.clone()))
            .collect();

        match recover_secret(&shares) {
            Ok(seed) => {
                self.log_event("[SUCCESS] Λ0 восстановлен из фрагментов");
                Some(seed)
            }
            Err(e) => {
                self.log_event(&format!("[FAIL] Ошибка восстановления Λ0: {}", e));
                None
            }
        }
    }

    fn validate_with_analyzer(&self, _node_id: &str, symbol: &str) -> bool {
        // Заглушка для проверки через resonance_analyzer.py
        symbol == self.lambda_zero
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.fragments).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"genesis_fragment\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/go_to_market.yaml  (size=3633b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```


## FILE: modules/heartbeat_monitor.rs  (size=7769b)
```text
rust
// LOGOS Network Heartbeat Monitor
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions, File};
use std::io::{Write, Read};
use std::net::{UdpSocket, SocketAddr};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

#[derive(Debug, Serialize, Deserialize)]
pub struct Heartbeat {
    pub rid: String,
    pub timestamp: u64,
    pub symbol: String,
    pub Σ_t: f64,
}

pub struct HeartbeatMonitor {
    pub active_nodes: HashMap<String, Heartbeat>,
    pub timeout_sec: u64,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub udp_port: u16,
    pub heartbeat_timestamps: HashMap<String, u64>, // RID -> last heartbeat time
}

impl HeartbeatMonitor {
    pub fn new(port: u16, timeout: u64) -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        HeartbeatMonitor {
            active_nodes: HashMap::new(),
            timeout_sec: timeout,
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "heartbeat_log.json".to_string(),
            state_file: "heartbeat_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            udp_port: port,
            heartbeat_timestamps: HashMap::new(),
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn listen(&mut self) {
        let socket = UdpSocket::bind(format!("0.0.0.0:{}", self.udp_port)).expect("Не удалось привязать сокет");
        let mut buf = [0u8; 1024];
        loop {
            match socket.recv_from(&mut buf) {
                Ok((len, addr)) => {
                    let raw = &buf[..len];
                    if let Some(hb) = self.parse_heartbeat(raw) {
                        self.register_heartbeat(hb, addr);
                    }
                }
                Err(e) => {
                    self.log_event(&format!("[ERR] UDP receive error: {}", e));
                }
            }
        }
    }

    pub fn parse_heartbeat(&self, raw: &[u8]) -> Option<Heartbeat> {
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut raw_buf = raw.to_vec();
        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut raw_buf) {
            if let Ok(hb) = serde_json::from_slice::<Heartbeat>(decrypted) {
                if self.validate_heartbeat(&hb) {
                    return Some(hb);
                }
            }
        }
        self.log_event("[ERR] Ошибка парсинга или валидации heartbeat");
        None
    }

    pub fn validate_heartbeat(&self, hb: &Heartbeat) -> bool {
        // Проверка RID, символа и Σ(t)
        let valid = self.validate_rid(&hb.rid) &&
                    self.valid_symbols.contains(&hb.symbol) &&
                    hb.Σ_t.is_finite() &&
                    // Проверка Λ0
                    (hb.symbol == self.lambda_zero || (hb.Σ_t.abs() < 10.0)); // Более мягкие условия для Λ0
        if !valid {
            self.log_event(&format!("[!] Недопустимый heartbeat от RID {}: symbol={}, Σ(t)={}", 
                hb.rid, hb.symbol, hb.Σ_t));
        }
        valid
    }

    pub fn register_heartbeat(&mut self, hb: Heartbeat, addr: SocketAddr) {
        let now = Self::current_time();

        // Проверка частоты heartbeat
        let last_heartbeat = self.heartbeat_timestamps.get(&hb.rid).cloned().unwrap_or(0);
        let adjusted_timeout = if hb.symbol == self.lambda_zero {
            self.timeout_sec * 2 // Увеличенный таймаут для Λ0
        } else {
            self.timeout_sec
        };
        if now - last_heartbeat < adjusted_timeout / 10 {
            self.log_event(&format!("[!] Слишком частый heartbeat от RID {}", hb.rid));
            return;
        }
        self.heartbeat_timestamps.insert(hb.rid.clone(), now);

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp(&hb) {
            self.log_event(&format!("[!] RCP не подтвердил heartbeat от RID {}", hb.rid));
            return;
        }

        self.active_nodes.insert(hb.rid.clone(), hb.clone());
        self.save_state();
        self.log_event(&format!(
            "[HEARTBEAT] RID {} — Σ(t) = {:.4} @ {} (from {})",
            hb.rid, hb.Σ_t, hb.timestamp, addr
        ));
    }

    pub fn validate_with_rcp(&self, _hb: &Heartbeat) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        true // TODO: Реализовать
    }

    pub fn purge_inactive(&mut self) {
        let now = Self::current_time();
        self.active_nodes.retain(|rid, hb| {
            let adjusted_timeout = if hb.symbol == self.lambda_zero {
                self.timeout_sec * 2
            } else {
                self.timeout_sec
            };
            if now - hb.timestamp <= adjusted_timeout {
                true
            } else {
                self.log_event(&format!("[CLEANUP] Удалён неактивный RID {}", rid));
                false
            }
        });
        self.save_state();
        self.log_event("[CLEANUP] Удалены неактивные узлы");
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.active_nodes).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn log_event(&self, message: &str) {
        let log_entry = format!(
            "{{\"event\": \"heartbeat\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = log_entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/legacy_migrator.rs  (size=6851b)
```text
// LOGOS Legacy Blockchain Migrator
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{File, OpenOptions};
use std::io::{Write, Read};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct LegacyTx {
    pub origin_chain: String,
    pub legacy_address: String,
    pub tx_hash: String,
    pub amount: f64,
    pub timestamp: u64,
    pub symbol_hint: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MigratedTx {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub amount: f64,
    pub migrated_from: String,
    pub original_tx_hash: String,
    pub timestamp: u64,
}

pub struct LegacyMigrator {
    pub migration_log: String,
    pub symbol_map: HashMap<String, String>,
    pub frequency_map: HashMap<String, f64>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl LegacyMigrator {
    pub fn new() -> Self {
        let mut symbol_map = HashMap::new();
        symbol_map.insert("ethereum".to_string(), "☉".to_string());
        symbol_map.insert("cosmos".to_string(), "??".to_string());
        symbol_map.insert("polkadot".to_string(), "♁".to_string());

        let mut frequency_map = HashMap::new();
        frequency_map.insert("ethereum".to_string(), 432.0);
        frequency_map.insert("cosmos".to_string(), 7.83);
        frequency_map.insert("polkadot".to_string(), 1.618);

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        LegacyMigrator {
            migration_log: "legacy_migration_log.json".to_string(),
            symbol_map,
            frequency_map,
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_tx(&self, tx: &LegacyTx) -> bool {
        // Проверка данных транзакции
        !tx.origin_chain.is_empty() &&
        !tx.legacy_address.is_empty() &&
        !tx.tx_hash.is_empty() &&
        tx.amount > 0.0 &&
        tx.timestamp > 0 &&
        tx.symbol_hint.as_ref().map_or(true, |s| self.valid_symbols.contains(s))
    }

    pub fn migrate(&self, legacy_tx: LegacyTx) -> Option<MigratedTx> {
        if !self.validate_tx(&legacy_tx) {
            self.log_migration_event(&format!(
                "[!] Недопустимая транзакция: chain={}, amount={}",
                legacy_tx.origin_chain, legacy_tx.amount
            ));
            return None;
        }

        let chain = legacy_tx.origin_chain.to_lowercase();
        let symbol = legacy_tx.symbol_hint.clone().unwrap_or_else(|| {
            self.symbol_map.get(&chain).cloned().unwrap_or(self.lambda_zero.clone())
        });

        if !self.valid_symbols.contains(&symbol) {
            self.log_migration_event(&format!("[!] Недопустимый символ: {}", symbol));
            return None;
        }

        let freq = self.frequency_map.get(&chain).cloned().unwrap_or(7.83);
        let phase = self.estimate_phase(&legacy_tx);

        // Проверка фазы через RCP (заглушка)
        if !self.validate_with_rcp(&symbol, freq, phase) {
            self.log_migration_event(&format!(
                "[!] RCP не подтвердил: {} @ {} Hz, φ={:.4}",
                symbol, freq, phase
            ));
            return None;
        }

        let rid = format!("{}@{}Hzφ{:.4}", symbol, freq, phase);

        let migrated = MigratedTx {
            rid: rid.clone(),
            symbol,
            frequency: freq,
            phase,
            amount: legacy_tx.amount,
            migrated_from: legacy_tx.origin_chain.clone(),
            original_tx_hash: legacy_tx.tx_hash.clone(),
            timestamp: legacy_tx.timestamp,
        };

        self.log_migration(&migrated);
        Some(migrated)
    }

    fn validate_with_rcp(&self, symbol: &str, frequency: f64, phase: f64) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        symbol == self.lambda_zero || (frequency - 7.83).abs() < 0.1
    }

    fn estimate_phase(&self, tx: &LegacyTx) -> f64 {
        let h = tx.tx_hash.bytes().fold(0u64, |acc, b| acc.wrapping_add(b as u64));
        let phase = ((h % 6283) as f64 / 1000.0) - std::f64::consts::PI;
        phase
    }

    fn log_migration(&self, migrated: &MigratedTx) {
        let json = serde_json::to_string(migrated).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap(); // Заглушка для nonce
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = json.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.migration_log)
            {
                let _ = writeln!(file, "{}", String::from_utf8_lossy(&in_out));
            }
        }
    }

    fn log_migration_event(&self, message: &str) {
        let log_entry = format!(
            "{{\"event\": \"legacy_migration\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.migration_log)
        {
            let _ = file.write_all(log_entry.as_bytes());
        }
    }

    pub fn load_legacy_batch(&self, path: &str) -> Vec<LegacyTx> {
        if let Ok(mut f) = File::open(path) {
            let mut contents = String::new();
            if f.read_to_string(&mut contents).is_ok() {
                if let Ok(list) = serde_json::from_str::<Vec<LegacyTx>>(&contents) {
                    return list.into_iter().filter(|tx| self.validate_tx(tx)).collect();
                }
            }
        }
        self.log_migration_event(&format!("[!] Ошибка загрузки батча: {}", path));
        vec![]
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/maintenance_strategy.yaml  (size=2361b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```


## FILE: modules/resonance_analytics_frontend.tsx  (size=4632b)
```text
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```


## FILE: modules/resonance_emergency_plan.yaml  (size=3420b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```


## FILE: modules/resonance_meshmap.yaml  (size=1877b)
```text
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```


## FILE: modules/resonance_tutor.py  (size=6414b)
```text
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```


## FILE: modules/ritual_engine.rs  (size=7546b)
```text
rust
// LOGOS Ritual Engine
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct RitualAction {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RitualDefinition {
    pub id: String,
    pub title: String,
    pub required_symbol: String,
    pub required_frequency: f64,
    pub required_phase: Option<f64>,
    pub min_phase: Option<f64>,
    pub max_phase: Option<f64>,
    pub reward_lgn: f64,
    pub repeatable: bool,
}

pub struct RitualEngine {
    pub rituals: HashMap<String, RitualDefinition>,
    pub completed: HashMap<String, Vec<String>>, // RID -> list of ritual IDs
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub action_timestamps: HashMap<String, u64>, // RID -> last action time
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl RitualEngine {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        RitualEngine {
            rituals: HashMap::new(),
            completed: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "ritual_engine_log.json".to_string(),
            action_timestamps: HashMap::new(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_rid_and_symbol(&self, rid: &str, symbol: &str) -> bool {
        !rid.is_empty() &&
        rid.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn load_rituals(&mut self, path: &str) {
        if let Ok(file) = std::fs::read_to_string(path) {
            if let Ok(map) = serde_json::from_str::<Vec<RitualDefinition>>(&file) {
                for r in map {
                    if self.valid_symbols.contains(&r.required_symbol) {
                        self.rituals.insert(r.id.clone(), r);
                    } else {
                        self.log_event(&format!("[!] Недопустимый символ в ритуале: {}", r.required_symbol));
                    }
                }
                self.log_event("[INFO] Загружены ритуалы");
            } else {
                self.log_event("[!] Ошибка парсинга ритуалов");
            }
        } else {
            self.log_event(&format!("[!] Ошибка чтения файла ритуалов: {}", path));
        }
    }

    pub fn submit_action(&mut self, action: RitualAction) -> Option<f64> {
        let now = Self::current_time();

        // Проверка частоты действий
        let last_action = self.action_timestamps.get(&action.rid).cloned().unwrap_or(0);
        if now - last_action < 60 {
            self.log_event(&format!("[!] Слишком частое действие от RID {}", action.rid));
            return None;
        }
        self.action_timestamps.insert(action.rid.clone(), now);

        // Валидация RID и символа
        if !self.validate_rid_and_symbol(&action.rid, &action.symbol) {
            self.log_event(&format!("[!] Недопустимый RID или символ: {}, {}", action.rid, action.symbol));
            return None;
        }

        // Проверка параметров
        if action.frequency <= 0.0 || action.frequency > 10000.0 ||
           !(-std::f64::consts::PI..=std::f64::consts::PI).contains(&action.phase) {
            self.log_event(&format!(
                "[!] Недопустимые параметры: f={}, φ={:.4}",
                action.frequency, action.phase
            ));
            return None;
        }

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp(&action) {
            self.log_event(&format!(
                "[!] RCP не подтвердил: {} @ {}Hz φ={:.4}",
                action.symbol, action.frequency, action.phase
            ));
            return None;
        }

        for (id, ritual) in self.rituals.iter() {
            if !ritual.repeatable && self.completed.get(&action.rid).map_or(false, |r| r.contains(id)) {
                continue;
            }

            if ritual.required_symbol != action.symbol {
                continue;
            }

            if (ritual.required_frequency - action.frequency).abs() > 0.1 {
                continue;
            }

            if let Some(req_phase) = ritual.required_phase {
                if (req_phase - action.phase).abs() > 0.05 {
                    continue;
                }
            }

            if let Some(min) = ritual.min_phase {
                if action.phase < min {
                    continue;
                }
            }

            if let Some(max) = ritual.max_phase {
                if action.phase > max {
                    continue;
                }
            }

            let reward = if action.symbol == self.lambda_zero {
                ritual.reward_lgn * 1.2 // Бонус для Λ0
            } else {
                ritual.reward_lgn
            };

            self.completed
                .entry(action.rid.clone())
                .or_default()
                .push(ritual.id.clone());

            self.log_event(&format!(
                "[RITUAL] RID {} выполнил ритуал {}: {} (+{} LGN)",
                action.rid, ritual.id, ritual.title, reward
            ));
            return Some(reward);
        }

        self.log_event(&format!("[MISS] RID {} не активировал ни один ритуал", action.rid));
        None
    }

    fn validate_with_rcp(&self, action: &RitualAction) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        action.symbol == self.lambda_zero || (action.frequency - 7.83).abs() < 0.1
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"ritual_engine\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/symbolic_parser.py  (size=4615b)
```text
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```


## FILE: modules/uplink_controller.rs  (size=7680b)
```text
rust
// LOGOS Uplink Controller — External Uplink & Relay Orchestrator
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions};
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct UplinkEvent {
    pub symbol: String,
    pub channel: String, // "lora", "ble", "satellite", "sound", "qr"
    pub status: String,  // "emitted", "received", "failed"
    pub payload: String,
    pub timestamp: u64,
}

pub struct UplinkController {
    pub supported_channels: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub cipher_key: Vec<u8>,
    pub log_file: String,
    pub emit_timestamps: HashMap<String, u64>, // channel -> last emit time
    pub min_emit_interval: u64, // Минимальный интервал в секундах
}

impl UplinkController {
    pub fn new() -> Self {
        let mut channels = HashSet::new();
        channels.insert("lora".to_string());
        channels.insert("ble".to_string());
        channels.insert("satellite".to_string());
        channels.insert("sound".to_string());
        channels.insert("qr".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        UplinkController {
            supported_channels: channels,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            log_file: "uplink_log.json".to_string(),
            emit_timestamps: HashMap::new(),
            min_emit_interval: 60, // 1 минута
        }
    }

    pub fn validate_symbol(&self, symbol: &str) -> bool {
        self.valid_symbols.contains(symbol)
    }

    pub fn validate_channel(&self, channel: &str) -> bool {
        self.supported_channels.contains(channel)
    }

    pub fn validate_payload(&self, payload: &str) -> bool {
        // Проверка размера и формата payload
        !payload.is_empty() && payload.len() <= 1024 && payload.chars().all(|c| c.is_ascii() || self.valid_symbols.contains(&c.to_string()))
    }

    pub fn emit(&self, symbol: &str, channel: &str, payload: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты эмиссии
        let last_emit = self.emit_timestamps.get(channel).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_emit_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_emit_interval
        };
        if now - last_emit < adjusted_interval {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Слишком частая эмиссия");
            return false;
        }

        // Валидация
        if !self.validate_symbol(symbol) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый символ");
            return false;
        }

        if !self.validate_channel(channel) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый канал");
            return false;
        }

        if !self.validate_payload(payload) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый payload");
            return false;
        }

        // Реализация каналов
        let event = UplinkEvent {
            symbol: symbol.to_string(),
            channel: channel.to_string(),
            status: "emitted".to_string(),
            payload: payload.to_string(),
            timestamp: now,
        };

        match channel {
            "lora" => self.emit_to_lora(&event),
            "ble" => self.emit_to_ble(&event),
            "satellite" => self.emit_to_satellite(&event),
            "sound" => self.emit_to_sound(&event),
            "qr" => self.emit_to_qr(&event),
            _ => {
                self.log_event(event.clone(), &format!("[WARN] Unsupported channel: {}", channel));
                return false;
            }
        }

        // Обновление времени эмиссии
        let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
        mutable_self.emit_timestamps.insert(channel.to_string(), now);
        self.log_event(event, "Успешная эмиссия");
        true
    }

    fn emit_to_lora(&self, event: &UplinkEvent) {
        // Заглушка для LoRa
        self.log_event(event.clone(), "[LORA] Эмиссия (не реализовано)");
    }

    fn emit_to_ble(&self, event: &UplinkEvent) {
        // Заглушка для BLE
        self.log_event(event.clone(), "[BLE] Эмиссия (не реализовано)");
    }

    fn emit_to_satellite(&self, event: &UplinkEvent) {
        // Заглушка для satellite
        self.log_event(event.clone(), "[SATELLITE] Эмиссия (не реализовано)");
    }

    fn emit_to_sound(&self, event: &UplinkEvent) {
        // Заглушка для sound
        self.log_event(event.clone(), "[SOUND] Эмиссия (не реализовано)");
    }

    fn emit_to_qr(&self, event: &UplinkEvent) {
        // Заглушка для QR
        self.log_event(event.clone(), "[QR] Эмиссия (не реализовано)");
    }

    fn log_event(&self, event: UplinkEvent, message: &str) {
        let json = serde_json::to_string(&event).unwrap_or_default();
        let log_entry = format!(
            "{{\"event\": \"uplink_controller\", \"message\": \"{}\", \"data\": {}, \"timestamp\": {}}}\n",
            message, json, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buffer = log_entry.as_bytes().to_vec();

        if aead.seal_in_place_append_tag(nonce, &[], &mut buffer).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buffer);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/uplink_router.rs  (size=7301b)
```text
rust
// LOGOS Uplink Router — External Signal Receiver
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions};
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct UplinkSignal {
    pub rid: String, // Добавлено для идентификации узла
    pub channel: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub payload: String,
    pub timestamp: u64,
}

pub struct UplinkRouter {
    pub valid_channels: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub last_received: HashMap<String, u64>, // channel -> timestamp
    pub last_received_rid: HashMap<String, u64>, // rid -> timestamp
    pub min_receive_interval: u64,
}

impl UplinkRouter {
    pub fn new() -> Self {
        let mut channels = HashSet::new();
        channels.insert("lora".to_string());
        channels.insert("ble".to_string());
        channels.insert("sound".to_string());
        channels.insert("satellite".to_string());
        channels.insert("qr".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        UplinkRouter {
            valid_channels: channels,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "uplink_router_log.json".to_string(),
            state_file: "uplink_router_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            last_received: HashMap::new(),
            last_received_rid: HashMap::new(),
            min_receive_interval: 10,
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate_payload(&self, payload: &str) -> bool {
        !payload.is_empty() && payload.len() <= 1024 && payload.chars().all(|c| c.is_ascii() || self.valid_symbols.contains(&c.to_string()))
    }

    pub fn receive(&mut self, signal: UplinkSignal) -> bool {
        let now = Self::current_time();

        // Проверка частоты приёма по каналу
        let last_channel = self.last_received.get(&signal.channel).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_receive_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_receive_interval
        };
        if now - last_channel < adjusted_interval {
            self.log_event(&signal, "[DROP] Слишком частый приём по каналу");
            return false;
        }

        // Проверка частоты приёма по RID
        let last_rid = self.last_received_rid.get(&signal.rid).cloned().unwrap_or(0);
        if now - last_rid < adjusted_interval {
            self.log_event(&signal, "[DROP] Слишком частый приём от RID");
            return false;
        }

        // Валидация RID
        if !self.validate_rid(&signal.rid) {
            self.log_event(&signal, "[DROP] Недопустимый RID");
            return false;
        }

        // Валидация символа и канала
        if !self.valid_symbols.contains(&signal.symbol) {
            self.log_event(&signal, "[DROP] Недопустимый символ");
            return false;
        }
        if !self.valid_channels.contains(&signal.channel) {
            self.log_event(&signal, "[DROP] Недопустимый канал");
            return false;
        }

        // Проверка частоты/фазы
        if signal.frequency <= 0.0 || signal.frequency > 10000.0 || !(-std::f64::consts::PI..=std::f64::consts::PI).contains(&signal.phase) {
            self.log_event(&signal, "[DROP] Неверная частота или фаза");
            return false;
        }

        // Проверка payload
        if !self.validate_payload(&signal.payload) {
            self.log_event(&signal, "[DROP] Недопустимый payload");
            return false;
        }

        // Проверка через RCP и resonance_analyzer (заглушка)
        if !self.validate_with_rcp_and_analyzer(&signal) {
            self.log_event(&signal, "[DROP] RCP или analyzer отклонил сигнал");
            return false;
        }

        self.last_received.insert(signal.channel.clone(), now);
        self.last_received_rid.insert(signal.rid.clone(), now);
        self.save_state();
        self.log_event(&signal, "[OK] Сигнал принят");
        true
    }

    pub fn validate_with_rcp_and_analyzer(&self, signal: &UplinkSignal) -> bool {
        // Заглушка для проверки через rcp_engine.rs и resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.last_received).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, signal: &UplinkSignal, msg: &str) {
        let entry = format!(
            "{{\"event\":\"uplink_router\",\"message\":\"{}\",\"rid\":\"{}\",\"channel\":\"{}\",\"symbol\":\"{}\",\"frequency\":{},\"phase\":{},\"timestamp\":{}}}\n",
            msg, signal.rid, signal.channel, signal.symbol, signal.frequency, signal.phase, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: node/Cargo.toml  (size=557b)
```text
[package]
name = "logos_node"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0"
tokio = { version = "1", features = ["full"] }
axum = "0.6"
reqwest = { version = "0.11", default-features = false, features = ["rustls-tls", "json"] }
tower = "0.4"
tower-http = { version = "0.4.4", features = ["cors"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
once_cell = "1.19"
prometheus = "0.13"
rand = "0.8"
ed25519-dalek = "2"
bs58 = "0.5"
hex = "0.4"
base64 = "0.22"
jsonwebtoken = "9"

lrb_core = { path = "../lrb_core" }

```


## FILE: node/src/admin.rs  (size=6316b)
```text
use axum::{extract::Extension, Json};
use axum::http::{StatusCode, HeaderMap};
use serde::{Serialize, Deserialize};
use std::{fs, path::PathBuf};
use crate::{state::AppState, auth};

#[derive(Serialize)]
pub struct NodeInfo {
    pub rid: String,
    pub vk_b58: String,
    pub slot_ms: Option<u64>,
    pub max_block_txs: Option<usize>,
    pub mempool_cap: Option<usize>,
    pub env: serde_json::Value,
}

pub async fn node_info(Extension(st): Extension<AppState>) -> Json<NodeInfo> {
    let vk_b58 = bs58::encode(st.self_vk.to_bytes()).into_string();
    let rid = vk_b58.clone();
    let slot_ms = std::env::var("LRB_SLOT_MS").ok().and_then(|s| s.parse::<u64>().ok());
    let max_block_txs = std::env::var("LRB_MAX_BLOCK_TX").ok().and_then(|s| s.parse::<usize>().ok());
    let mempool_cap = std::env::var("LRB_MEMPOOL_CAP").ok().and_then(|s| s.parse::<usize>().ok());
    let keys = [
        "LRB_SLOT_MS","LRB_MAX_BLOCK_TX","LRB_MEMPOOL_CAP","LRB_MAX_AMOUNT",
        "LRB_DEV","LRB_PEERS","LRB_VALIDATORS","LRB_QUORUM_N",
        "LRB_BRIDGE_MAX_PER_TX","LRB_DATA_PATH","LRB_NODE_KEY_PATH",
    ];
    let mut envmap = serde_json::Map::new();
    for k in keys.iter() { if let Ok(val) = std::env::var(k) { envmap.insert((*k).to_string(), serde_json::Value::String(val)); } }
    Json(NodeInfo { rid, vk_b58, slot_ms, max_block_txs, mempool_cap, env: serde_json::Value::Object(envmap) })
}

/* ===== JWT mint для админки ===== */
#[derive(Serialize)] pub struct TokenResp { pub ok:bool, pub token:String, pub ttl_sec:usize }
pub async fn admin_token(Extension(st): Extension<AppState>, headers: HeaderMap, axum::extract::Query(q): axum::extract::Query<std::collections::HashMap<String,String>>)
-> Result<Json<TokenResp>, StatusCode> {
    // Требуем предъявить действительный ADMIN KEY (или Bearer KEY) для выдачи токена
    // IP ACL внутри require_admin
    let ip = None; // опционально можно протащить remote_ip из Tower layers
    auth::require_admin(&headers, ip)?;

    let ttl = q.get("ttl").and_then(|s| s.parse::<usize>().ok()).unwrap_or(600);
    let secret = std::env::var("LRB_ADMIN_JWT_SECRET").map_err(|_| StatusCode::UNAUTHORIZED)?;
    if secret.trim().is_empty() { return Err(StatusCode::UNAUTHORIZED); }
    let tok = auth::mint_jwt(&secret, "admin", ttl as i64)?;
    Ok(Json(TokenResp { ok:true, token: tok, ttl_sec: ttl }))
}

/* ===== Snapshot / Restore ===== */
#[derive(Serialize, Deserialize)]
pub struct Snapshot { pub head:u64, pub finalized:u64, pub lgn_balances:Vec<(String,u64)>, pub rlgn_balances:Vec<(String,u64)> }

pub async fn snapshot(Extension(st): Extension<AppState>, headers: HeaderMap)
-> Result<Json<Snapshot>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let (h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let fin = st.engine.ledger().get_finalized().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let lg = st.engine.ledger().export_balances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let rg = st.engine.ledger().export_rbalances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(Snapshot { head:h, finalized:fin, lgn_balances:lg, rlgn_balances:rg }))
}

pub async fn snapshot_file(Extension(st): Extension<AppState>, headers: HeaderMap, axum::extract::Query(params): axum::extract::Query<std::collections::HashMap<String,String>>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let name = params.get("name").cloned().unwrap_or_else(|| format!("snap-{}.json", crate::state::now_ms()));
    let safe = name.chars().all(|c| c.is_ascii_alphanumeric() || c=='-' || c=='_' || c=='.');
    if !safe { return Err(StatusCode::BAD_REQUEST); }

    let (h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let fin = st.engine.ledger().get_finalized().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let lg = st.engine.ledger().export_balances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let rg = st.engine.ledger().export_rbalances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let snap = Snapshot { head:h, finalized:fin, lgn_balances:lg, rlgn_balances:rg };
    let data = serde_json::to_vec_pretty(&snap).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut path = PathBuf::from("/var/lib/logos/snapshots"); path.push(name);
    fs::write(&path, data).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true, "file": path.to_string_lossy()})))
}

#[derive(Deserialize)] pub struct RestoreReq { pub file: String }
pub async fn restore(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<RestoreReq>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let safe = req.file.chars().all(|c| c.is_ascii_alphanumeric() || c=='-' || c=='_' || c=='.' || c=='/' );
    if !safe || !req.file.starts_with("/var/lib/logos/snapshots/") { return Err(StatusCode::BAD_REQUEST); }
    let data = fs::read(&req.file).map_err(|_| StatusCode::NOT_FOUND)?;
    let snap: Snapshot = serde_json::from_slice(&data).map_err(|_| StatusCode::BAD_REQUEST)?;
    for (rid_s, amt) in snap.lgn_balances { let rid = lrb_core::Rid(rid_s); st.engine.ledger().set_balance(&rid, amt).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?; }
    for (rid_s, amt) in snap.rlgn_balances { let rid = lrb_core::Rid(rid_s); st.engine.ledger().set_rbalance(&rid, amt).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?; }
    Ok(Json(serde_json::json!({"ok": true})))
}

/* validators info */
#[derive(Serialize)] pub struct ValidatorsInfo { pub validators: Vec<String>, pub quorum_n: usize }
pub async fn validators_info(Extension(st): Extension<AppState>) -> Json<ValidatorsInfo> {
    let vals = st.validators.iter().cloned().collect::<Vec<_>>();
    Json(ValidatorsInfo { validators: vals, quorum_n: st.quorum_n })
}

```


## FILE: node/src/api.rs  (size=10732b)
```text
use axum::{
    extract::{Path, Extension, Query},
    Json,
};
use axum::http::StatusCode;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use lrb_core::*;
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

use crate::state::*;

/* ---------- типы ---------- */
#[derive(Serialize)] pub struct Healthz { pub ok: bool }
#[derive(Deserialize)] pub struct SubmitTx {
    pub from:String, pub to:String, pub amount:u64, pub nonce:u64,
    pub public_key_b58:String, pub signature_b64:String
}
#[derive(Serialize)] pub struct SubmitResp { pub accepted: bool, pub tx_id: String, pub lgn_cost_microunits: u64 }
#[derive(Deserialize)] pub struct DebugCanonReq { pub from:String, pub to:String, pub amount:u64, pub nonce:u64, pub public_key_b58:String }
#[derive(Serialize)] pub struct DebugCanonResp { pub canon_hex:String, pub server_tx_id:String }

/* ---------- базовые ---------- */
pub async fn healthz() -> Json<Healthz> { Json(Healthz{ok:true}) }

pub async fn head(Extension(st): Extension<AppState>) -> Json<serde_json::Value> {
    let (h, hash) = st.engine.ledger().head().unwrap_or((0, String::new()));
    let fin = st.engine.ledger().get_finalized().unwrap_or(0);
    Json(serde_json::json!({ "height": h, "hash": hash, "finalized": fin }))
}

pub async fn balance(Path(rid): Path<String>, Extension(st): Extension<AppState>) -> Json<serde_json::Value> {
    let rid = Rid(rid); let bal = st.engine.ledger().get_balance(&rid);
    Json(serde_json::json!({ "rid": rid.as_str(), "balance": bal }))
}

/* ---------- состояние аккаунта ---------- */
pub async fn account_state(Path(rid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    let r = Rid(rid);
    let bal = st.engine.ledger().get_balance(&r);
    let n   = st.engine.ledger().get_nonce(&r);
    Ok(Json(serde_json::json!({ "rid": r.as_str(), "balance": bal, "nonce": n })))
}

/* ---------- одиночный submit ---------- */
pub async fn submit_tx(Extension(st): Extension<AppState>, Json(req): Json<SubmitTx>)
-> Result<Json<SubmitResp>, StatusCode> {
    if !st.rl_submit.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    TX_SUBMITTED.inc();
    if req.amount == 0 { return Err(StatusCode::BAD_REQUEST); }
    let pk_bytes = bs58::decode(&req.public_key_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig_bytes = B64.decode(req.signature_b64.as_bytes()).map_err(|_| StatusCode::BAD_REQUEST)?;
    let tx = Tx { id:"".into(), from:Rid(req.from.clone()), to:Rid(req.to.clone()),
                  amount:req.amount, nonce:req.nonce, public_key:pk_bytes, signature:sig_bytes };
    let tx = Tx { id: tx.compute_id(), ..tx };
    if lrb_core::phase_integrity::verify_tx_signature(&tx).is_err() { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    st.engine.mempool_sender().send(tx.clone()).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(SubmitResp { accepted:true, tx_id: tx.id, lgn_cost_microunits: st.engine.lgn_cost_microunits() }))
}

/* ---------- batch submit ---------- */
#[derive(Serialize)] pub struct BatchItem { pub tx_id:String, pub ok:bool, pub err:Option<String> }
#[derive(Serialize)] pub struct BatchResp { pub accepted:usize, pub rejected:usize, pub items:Vec<BatchItem>, pub lgn_cost_microunits:u64 }

pub async fn submit_tx_batch(Extension(st): Extension<AppState>, Json(reqs): Json<Vec<SubmitTx>>)
-> Result<Json<BatchResp>, StatusCode> {
    let n = reqs.len(); if n == 0 { return Err(StatusCode::BAD_REQUEST); }
    let maxb = std::env::var("LRB_MAX_BATCH").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(1000);
    if n > maxb { return Err(StatusCode::PAYLOAD_TOO_LARGE); }
    if !st.rl_submit.try_take(n as u64) { return Err(StatusCode::TOO_MANY_REQUESTS); }

    let mut items = Vec::with_capacity(n); let mut accepted = 0usize;
    let sender = st.engine.mempool_sender();
    for r in reqs {
        if r.amount == 0 {
            items.push(BatchItem{ tx_id:String::new(), ok:false, err:Some("amount=0".into())});
            continue;
        }
        let pk_bytes = match bs58::decode(&r.public_key_b58).into_vec() { Ok(v)=>v, Err(_)=>{ items.push(BatchItem{tx_id:String::new(), ok:false, err:Some("bad public_key_b58".into())}); continue; } };
        let sig_bytes = match B64.decode(r.signature_b64.as_bytes()) { Ok(v)=>v, Err(_)=>{ items.push(BatchItem{tx_id:String::new(), ok:false, err:Some("bad signature_b64".into())}); continue; } };
        let tx = Tx { id:String::new(), from:Rid(r.from), to:Rid(r.to), amount:r.amount, nonce:r.nonce, public_key:pk_bytes, signature:sig_bytes };
        let tx = Tx { id: tx.compute_id(), ..tx };
        if lrb_core::phase_integrity::verify_tx_signature(&tx).is_err() { items.push(BatchItem{tx_id:tx.id, ok:false, err:Some("bad signature".into())}); continue; }
        if sender.send(tx.clone()).is_err() { items.push(BatchItem{tx_id:tx.id, ok:false, err:Some("enqueue failed".into())}); continue; }
        items.push(BatchItem{tx_id:tx.id, ok:true, err:None}); accepted+=1;
    }
    TX_SUBMITTED.inc_by(accepted as u64);
    Ok(Json(BatchResp{ accepted, rejected: items.len()-accepted, items, lgn_cost_microunits: st.engine.lgn_cost_microunits() }))
}

/* ---------- debug / block / tx ---------- */
pub async fn debug_canon(Json(req): Json<DebugCanonReq>) -> Result<Json<DebugCanonResp>, StatusCode> {
    let pk_bytes = bs58::decode(&req.public_key_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let tx = Tx { id:"".to_string(), from:Rid(req.from), to:Rid(req.to),
                  amount:req.amount, nonce:req.nonce, public_key:pk_bytes, signature:vec![0u8;64] };
    Ok(Json(DebugCanonResp { canon_hex: hex::encode(tx.canonical_bytes()), server_tx_id: tx.compute_id() }))
}

pub async fn get_block(Path(height): Path<u64>, Extension(st): Extension<AppState>)
-> Result<Json<Block>, StatusCode> {
    st.engine.ledger().get_block_by_height(height).map(Json).map_err(|_| StatusCode::NOT_FOUND)
}

/* простой ответ по tx: только высота, если есть */
pub async fn get_tx(Path(txid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    match st.engine.ledger().get_tx_height(&txid).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        Some(h) => Ok(Json(serde_json::json!({ "tx_id": txid, "height": h }))),
        None => Err(StatusCode::NOT_FOUND),
    }
}

/* детальный ответ по tx (блок целиком) */
#[derive(Serialize)] pub struct TxFull { pub tx_id:String, pub height:u64, pub block:serde_json::Value, pub found:bool }
pub async fn get_tx_full(Path(txid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<TxFull>, StatusCode> {
    match st.engine.ledger().get_tx_height(&txid).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        Some(h) => {
            let blk = st.engine.ledger().get_block_by_height(h).map_err(|_| StatusCode::NOT_FOUND)?;
            let blk_json = serde_json::to_value(&blk).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
            Ok(Json(TxFull{ tx_id: txid, height: h, block: blk_json, found:true }))
        }
        None => Ok(Json(TxFull{ tx_id: txid, height: 0, block: serde_json::json!({}), found:false })),
    }
}

/* ---------- история аккаунта (пагинация курсором) ---------- */
#[derive(Serialize)] pub struct AccountTxsPage {
    pub rid:String, pub limit:usize, pub items:Vec<serde_json::Value>,
    pub next_cursor_h: Option<u64>, pub next_cursor_seq: Option<u32>
}
pub async fn account_txs(
    Path(rid_s): Path<String>,
    Query(q): Query<HashMap<String,String>>,
    Extension(st): Extension<AppState>
) -> Result<Json<AccountTxsPage>, StatusCode> {
    let rid = Rid(rid_s);
    let limit = q.get("limit").and_then(|s| s.parse::<usize>().ok()).unwrap_or(100);
    let ch = q.get("cursor_h").and_then(|s| s.parse::<u64>().ok());
    let cs = q.get("cursor_seq").and_then(|s| s.parse::<u32>().ok());
    let (items, next_h, next_s) = st.engine.ledger().list_account_txs_page(&rid, ch, cs, limit)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(AccountTxsPage{
        rid: rid.as_str().to_string(), limit, items,
        next_cursor_h: next_h, next_cursor_seq: next_s
    }))
}

/* ---------- эксплорер (последние блоки/tx) ---------- */
#[derive(Serialize)] pub struct RecentBlocks { pub items: Vec<serde_json::Value> }
pub async fn recent_blocks(Extension(st): Extension<AppState>, Query(q): Query<HashMap<String,String>>)
-> Result<Json<RecentBlocks>, StatusCode> {
    let limit = q.get("limit").and_then(|s| s.parse::<u64>().ok()).unwrap_or(20);
    let (mut h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut out = Vec::new();
    for _ in 0..limit {
        if h == 0 { break; }
        if let Ok(b) = st.engine.ledger().get_block_by_height(h) {
            out.push(serde_json::to_value(b).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?);
        }
        if h == 0 { break; }
        h -= 1;
    }
    Ok(Json(RecentBlocks{ items: out }))
}

#[derive(Serialize)] pub struct RecentTxs { pub items: Vec<serde_json::Value> }
pub async fn recent_txs(Extension(st): Extension<AppState>, Query(q): Query<HashMap<String,String>>)
-> Result<Json<RecentTxs>, StatusCode> {
    let limit = q.get("limit").and_then(|s| s.parse::<usize>().ok()).unwrap_or(50);
    let (mut h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut out = Vec::new();
    while out.len() < limit && h > 0 {
        if let Ok(b) = st.engine.ledger().get_block_by_height(h) {
            for tx in b.txs.iter().rev() {
                if out.len() >= limit { break; }
                out.push(serde_json::json!({"height": b.height, "tx_id": tx.id, "from": tx.from.0, "to": tx.to.0, "amount": tx.amount}));
            }
        }
        if h == 0 { break; }
        h -= 1;
    }
    Ok(Json(RecentTxs{ items: out }))
}

/* ---------- DEV faucet ---------- */
#[allow(dead_code)]
pub async fn faucet(Path((rid_s,amount_s)):Path<(String,String)>, Extension(st):Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    if !st.dev_mode { return Err(StatusCode::FORBIDDEN); }
    let rid = Rid(rid_s); let amount:u64 = amount_s.parse().map_err(|_| StatusCode::BAD_REQUEST)?;
    let cur = st.engine.ledger().get_balance(&rid); let newb = cur.saturating_add(amount);
    st.engine.ledger().set_balance(&rid, newb).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true, "rid": rid.as_str(), "balance": newb })))
}

```


## FILE: node/src/auth.rs  (size=5131b)
```text
// node/src/auth.rs
use axum::http::{HeaderMap, StatusCode};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Deserialize)]
struct Claims {
    exp: i64,
    sub: Option<String>,
    iat: Option<i64>,
}

// ------------ time ------------
fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
}

// ------------ helpers ------------
fn header_value(headers: &HeaderMap, name: &str) -> Option<String> {
    headers.get(name).and_then(|v| v.to_str().ok()).map(|s| s.trim().to_string())
}

fn header_or_bearer(headers: &HeaderMap, primary_header: &str) -> Option<String> {
    if let Some(v) = header_value(headers, primary_header) {
        if !v.is_empty() { return Some(v); }
    }
    if let Some(v) = header_value(headers, "authorization") {
        if let Some(rest) = v.strip_prefix("Bearer ") {
            let t = rest.trim();
            if !t.is_empty() { return Some(t.to_string()); }
        }
    }
    None
}

/// Простейший IP-ACL: LRB_ADMIN_IP_ALLOW="1.2.3.4,10.0.0.0/8"
fn ip_acl_allows(ip: Option<IpAddr>, env_key: &str) -> bool {
    let allow = std::env::var(env_key).unwrap_or_default();
    if allow.trim().is_empty() { return true; }
    let rules: Vec<&str> = allow.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    if rules.is_empty() { return true; }
    if let Some(client) = ip {
        for r in rules {
            if let Ok(one) = r.parse::<IpAddr>() {
                if one == client { return true; }
            } else if let Some((net, bits)) = r.split_once('/') {
                if let (Ok(nip), Ok(b)) = (net.parse::<IpAddr>(), bits.parse::<u8>()) {
                    if let (IpAddr::V4(a), IpAddr::V4(n)) = (client, nip) {
                        let mask: u32 = if b == 0 { 0 } else { (!0u32) << (32 - b as u32) };
                        if (u32::from(a) & mask) == (u32::from(n) & mask) { return true; }
                    }
                }
            }
        }
        false
    } else { false }
}

// ------------ публичные проверки ------------

/// Админ-доступ:
/// 1) если задан нормальный LRB_ADMIN_KEY — принимаем X-Admin-Key (приоритетно)
/// 2) если задан LRB_ADMIN_JWT_SECRET — принимаем JWT (X-Admin-Key или Authorization: Bearer)
/// 3) IP-ACL: LRB_ADMIN_IP_ALLOW (пусто = разрешить всем)
pub fn require_admin(headers: &HeaderMap, remote_ip: Option<IpAddr>) -> Result<(), StatusCode> {
    if !ip_acl_allows(remote_ip, "LRB_ADMIN_IP_ALLOW") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // статический ключ (удобно для таймеров/автоматизаций)
    if let Ok(k) = std::env::var("LRB_ADMIN_KEY") {
        let k = k.trim();
        if !k.is_empty() && k != "CHANGE_ADMIN_KEY" {
            if let Some(presented) = header_or_bearer(headers, "X-Admin-Key") {
                if presented == k { return Ok(()); }
            }
        }
    }

    // JWT HS256
    if let Ok(secret) = std::env::var("LRB_ADMIN_JWT_SECRET") {
        let secret = secret.trim();
        if !secret.is_empty() {
            if let Some(tok) = header_or_bearer(headers, "X-Admin-Key") {
                if let Ok(data) = decode::<Claims>(
                    &tok,
                    &DecodingKey::from_secret(secret.as_bytes()),
                    &Validation::new(Algorithm::HS256),
                ) {
                    if data.claims.exp > now_ts() { return Ok(()); }
                }
            }
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    Err(StatusCode::UNAUTHORIZED)
}

/// Доступ к мосту: LRB_BRIDGE_KEY в X-Bridge-Key или Authorization: Bearer <key>
pub fn require_bridge(headers: &HeaderMap) -> Result<(), StatusCode> {
    let k = std::env::var("LRB_BRIDGE_KEY").unwrap_or_default();
    let k = k.trim();
    if k.is_empty() || k == "CHANGE_ME" { return Err(StatusCode::UNAUTHORIZED); }

    if let Some(presented) = header_or_bearer(headers, "X-Bridge-Key") {
        if presented == k { return Ok(()); }
    }
    if let Some(bearer) = header_or_bearer(headers, "Authorization") {
        if bearer == k { return Ok(()); }
    }
    Err(StatusCode::UNAUTHORIZED)
}

// ------------ JWT minting (для /admin/token) ------------
#[derive(Serialize)]
struct ClaimsOut { sub: String, exp: i64, iat: i64 }

/// Выпуск JWT (HS256) c TTL (сек): возвращает строку токена.
pub fn mint_jwt(secret: &str, sub: &str, ttl_secs: i64) -> Result<String, StatusCode> {
    if ttl_secs <= 0 { return Err(StatusCode::BAD_REQUEST); }
    let now = now_ts();
    let claims = ClaimsOut { sub: sub.to_string(), iat: now, exp: now + ttl_secs };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

```


## FILE: node/src/bridge.rs  (size=3607b)
```text
use axum::{extract::Extension, Json};
use axum::http::{StatusCode, HeaderMap};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signer, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};
use crate::state::{AppState, BR_DEPOSIT, BR_REDEEM, now_ms};
use crate::auth;

#[derive(Deserialize)] pub struct DepositReq { pub rid:String, pub amount:u64, pub ext_txid:String }
#[derive(Serialize)]   pub struct DepositResp { pub ok:bool, pub rid:String, pub r_balance:u64 }
#[derive(Deserialize)] pub struct RedeemReq { pub rid:String, pub amount:u64, pub request_id:String }
#[derive(Serialize)]   pub struct RedeemResp { pub ok:bool, pub rid:String, pub r_balance:u64, pub redeem_ticket:String, pub signature_b64:String }
#[derive(Deserialize)] pub struct VerifyReq { pub ticket:String, pub signature_b64:String, pub vk_b58:String }
#[derive(Serialize)]   pub struct VerifyResp { pub ok:bool }

pub async fn deposit(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<DepositReq>)
-> Result<Json<DepositResp>, StatusCode> {
    if !st.rl_bridge.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    auth::require_bridge(&headers)?;  // IP ACL / JWT / key

    if req.amount == 0 || req.amount > st.bridge_max_per_tx { return Err(StatusCode::BAD_REQUEST); }
    let rk = format!("dep:{}", req.ext_txid);
    if !st.replay_bridge.check_and_note(rk.clone(), now_ms()) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    if let Ok(false) = st.engine.ledger().bridge_seen_mark(&rk) { return Err(StatusCode::CONFLICT); }

    let rid = lrb_core::Rid(req.rid.clone());
    let newb = st.engine.ledger().mint_rtoken(&rid, req.amount).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    BR_DEPOSIT.inc();
    Ok(Json(DepositResp { ok:true, rid: rid.as_str().to_string(), r_balance: newb }))
}

pub async fn redeem(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<RedeemReq>)
-> Result<Json<RedeemResp>, StatusCode> {
    if !st.rl_bridge.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    auth::require_bridge(&headers)?; // IP ACL / JWT / key

    if req.amount == 0 || req.amount > st.bridge_max_per_tx { return Err(StatusCode::BAD_REQUEST); }
    let rk = format!("red:{}", req.request_id);
    if !st.replay_bridge.check_and_note(rk.clone(), now_ms()) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    if let Ok(false) = st.engine.ledger().bridge_seen_mark(&rk) { return Err(StatusCode::CONFLICT); }

    let rid = lrb_core::Rid(req.rid.clone());
    let newb = st.engine.ledger().burn_rtoken(&rid, req.amount).map_err(|_| StatusCode::BAD_REQUEST)?;
    BR_REDEEM.inc();

    let ticket = format!("redeem:{}:{}:{}", rid.as_str(), req.amount, req.request_id);
    let sig = st.sk.sign(ticket.as_bytes());
    let signature_b64 = B64.encode(sig.to_bytes());
    Ok(Json(RedeemResp { ok:true, rid: rid.as_str().to_string(), r_balance: newb, redeem_ticket: ticket, signature_b64 }))
}

pub async fn verify(Json(req): Json<VerifyReq>) -> Result<Json<VerifyResp>, StatusCode> {
    let pk_bytes = bs58::decode(&req.vk_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| StatusCode::BAD_REQUEST)?).map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig_bytes = B64.decode(req.signature_b64.as_bytes()).map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig = ed25519_dalek::Signature::from_bytes(&sig_bytes.try_into().map_err(|_| StatusCode::BAD_REQUEST)?);
    Ok(Json(VerifyResp { ok: vk.verify(req.ticket.as_bytes(), &sig).is_ok() }))
}

```


## FILE: node/src/fork.rs  (size=429b)
```text
use anyhow::Result;
use lrb_core::Block;
use crate::state::AppState;

/// Временная реализация: делаем вид, что реорг не требуется.
/// Когда включим полноценный fork-choice, сюда добавим сравнение sigma/weight.
pub fn apply_or_reorg_deep(_st: &AppState, _incoming: &Block, _sigma_hex: &str, _prev_hash: &str) -> Result<()> {
    Ok(())
}

```


## FILE: node/src/gossip.rs  (size=5147b)
```text
use anyhow::Result;
use axum::{extract::Extension, Json};
use axum::http::StatusCode;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, Verifier, Signer, VerifyingKey};
use serde::{Deserialize, Serialize};
use lrb_core::{Block, resonance, phase_filters::block_passes_phase};
use crate::state::{AppState, now_ms, GOSSIP_BLK_SENT, GOSSIP_BLK_RECV, GOSSIP_VOTE_SENT, GOSSIP_VOTE_RECV, CONS_VOTES, PHASE_BLOCK_ACCEPTED, PHASE_BLOCK_REJECTED};

#[derive(Serialize, Deserialize, Clone)]
pub struct GossipHeader { pub height:u64, pub prev_hash:String, pub block_hash:String, pub proposer_rid:String, pub timestamp_ms:u128, pub sigma_hex:String }
#[derive(Serialize, Deserialize, Clone)]
pub struct GossipBlockMsg { pub header:GossipHeader, pub block:Block, pub sender_pk_b58:String, pub sig_b64:String, pub nonce_ms:u128 }
#[derive(Serialize, Deserialize, Clone)]
pub struct VoteMsg { pub height:u64, pub block_hash:String, pub sigma_hex:String, pub voter_pk_b58:String, pub sig_b64:String, pub nonce_ms:u128 }

fn verify_gossip_sig(msg: &GossipBlockMsg) -> Result<()> {
    let pk_bytes = bs58::decode(&msg.sender_pk_b58).into_vec()?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(msg.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(&sig_bytes.try_into().map_err(|_| anyhow::anyhow!("bad sig"))?);
    let mut payload = Vec::new();
    payload.extend_from_slice(msg.header.sigma_hex.as_bytes());
    payload.extend_from_slice(msg.header.block_hash.as_bytes());
    payload.extend_from_slice(&msg.nonce_ms.to_le_bytes());
    vk.verify(&payload, &sig).map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

pub async fn send_block(peers:&[String], st:&AppState, block:&Block) {
    let sigma_hex = resonance::sigma_digest_block_hex(block);
    let nonce_ms = now_ms();
    let mut pl = Vec::new();
    pl.extend_from_slice(sigma_hex.as_bytes());
    pl.extend_from_slice(block.block_hash.as_bytes());
    pl.extend_from_slice(&nonce_ms.to_le_bytes());
    let sig_b64 = B64.encode(st.sk.sign(&pl).to_bytes());
    let header = GossipHeader {
        height:block.height, prev_hash:block.prev_hash.clone(), block_hash:block.block_hash.clone(),
        proposer_rid:block.proposer.0.clone(), timestamp_ms:block.timestamp_ms, sigma_hex:sigma_hex.clone()
    };
    let msg = GossipBlockMsg {
        header, block:block.clone(),
        sender_pk_b58: bs58::encode(st.self_vk.to_bytes()).into_string(),
        sig_b64, nonce_ms
    };
    for p in peers {
        let _ = st.http.post(&format!("{}/gossip/block", p.trim_end_matches('/'))).json(&msg).send().await;
        GOSSIP_BLK_SENT.inc();
    }

    let vote_nonce = now_ms();
    let mut pv = Vec::new();
    pv.extend_from_slice(sigma_hex.as_bytes());
    pv.extend_from_slice(block.block_hash.as_bytes());
    pv.extend_from_slice(&block.height.to_le_bytes());
    pv.extend_from_slice(&vote_nonce.to_le_bytes());
    let vote_sig_b64 = B64.encode(st.sk.sign(&pv).to_bytes());
    let vmsg = VoteMsg {
        height:block.height, block_hash:block.block_hash.clone(), sigma_hex: sigma_hex.clone(),
        voter_pk_b58: bs58::encode(st.self_vk.to_bytes()).into_string(), sig_b64: vote_sig_b64, nonce_ms: vote_nonce
    };
    for p in peers { let _ = st.http.post(&format!("{}/gossip/vote", p.trim_end_matches('/'))).json(&vmsg).send().await; GOSSIP_VOTE_SENT.inc(); }
}

pub async fn gossip_block(Extension(st): Extension<AppState>, Json(msg): Json<GossipBlockMsg>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    GOSSIP_BLK_RECV.inc();

    let local_sigma = resonance::sigma_digest_block_hex(&msg.block);
    if local_sigma != msg.header.sigma_hex { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    if verify_gossip_sig(&msg).is_err() { return Err(StatusCode::UNPROCESSABLE_ENTITY); }

    // фазовый фильтр: блоки вне фазы не принимаем
    if !block_passes_phase(&msg.block) {
        PHASE_BLOCK_REJECTED.inc();
        return Err(StatusCode::UNPROCESSABLE_ENTITY);
    }
    PHASE_BLOCK_ACCEPTED.inc();

    crate::fork::apply_or_reorg_deep(&st, &msg.block, &msg.header.sigma_hex, &msg.header.prev_hash)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true})))
}

pub async fn gossip_vote(Extension(st): Extension<AppState>, Json(v): Json<VoteMsg>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.validators.is_empty() && !st.validators.contains(&v.voter_pk_b58) { return Err(StatusCode::FORBIDDEN); }
    GOSSIP_VOTE_RECV.inc();
    let vv = lrb_core::quorum::Vote {
        height: v.height, block_hash: v.block_hash.clone(), sigma_hex: v.sigma_hex.clone(),
        voter_pk_b58: v.voter_pk_b58.clone(), sig_b64: v.sig_b64.clone(), nonce_ms: v.nonce_ms
    };
    if let Err(_) = lrb_core::quorum::verify_vote(&vv) { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    if st.engine.register_vote(v.height, &v.block_hash, &v.voter_pk_b58) { CONS_VOTES.inc(); }
    Ok(Json(serde_json::json!({"ok": true})))
}

```


## FILE: node/src/main.rs  (size=5036b)
```text
// node/src/main.rs — прод-роутер с историей/индексами и базовой инициализацией
mod bridge;
mod admin;
mod fork;
mod state;
mod gossip;
mod metrics;
mod api;
mod peers;

use anyhow::Result;
use axum::{
    extract::DefaultBodyLimit,
    routing::{get, post},
    Extension, Router,
};
use std::{env, net::SocketAddr, time::Duration};
use tokio::{signal, time::interval};

use lrb_core::*;
use crate::state::AppState;

#[tokio::main]
async fn main() -> Result<()> {
    // --------- инициализация ключей/ledger/engine ----------
    // Ключи/ledger/engine инициализируй так, как у тебя уже сделано — здесь оставляем существующую логику.
    // Ниже только минимальные обязательные шаги, чтобы не поломать твой запуск.

    // Открываем базу
    let data_path = env::var("LRB_DATA_PATH").unwrap_or_else(|_| "/var/lib/logos/data.sled".to_string());
    let ledger = Ledger::open(&data_path)?;

    // ИНИЦИАЛИЗАЦИЯ ENGINE — используй фактическую функцию/конструктор, которая уже есть у тебя:
    // предположим у тебя есть что-то вроде: let (engine, _mp) = engine_with_channels(ledger, self_rid.clone());
    // Здесь для совместимости:
    let (engine, _mp) = {
        // В твоём коде уже есть построение self_rid / ключей — оставь его.
        // Ниже упрощённый вызов: если у тебя другой — подставь свой.
        let dummy_rid = Rid("DUMMY_RID".to_string());
        engine_with_channels(ledger, dummy_rid)
    };

    // Запуск block producer (оставляем как в твоём коде)
    {
        let eng = engine.clone();
        tokio::spawn(async move {
            let _ = eng.run_block_producer().await;
        });
    }

    // Собираем AppState из твоей реализации
    let st = AppState::new_for_router(engine.clone())?;

    // --------- Роуты (все действующие + история/индексы) ----------
    let mut app = Router::new()
        // базовые
        .route("/healthz", get(api::healthz))
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/account/:rid/state", get(api::account_state))
        // отправка транзакций
        .route("/submit_tx",        post(api::submit_tx))
        .route("/submit_tx_batch",  post(api::submit_tx_batch))
        // отладка канона/подписи
        .route("/debug_canon", post(api::debug_canon))
        // faucet (DEV)
        .route("/faucet/:rid/:amount", post(api::faucet))
        // мост
        .route("/bridge/deposit", post(api::bridge_deposit))
        .route("/bridge/redeem",  post(api::bridge_redeem))
        .route("/bridge/verify",  post(api::bridge_verify))
        // админка
        .route("/admin/snapshot",      get(api::snapshot))
        .route("/admin/snapshot-file", get(api::snapshot_file))
        .route("/admin/restore",       post(api::restore))
        .route("/admin/token",         get(api::admin_token))
        .route("/node/info",           get(api::node_info))
        // НОВОЕ: история/индексы
        .route("/block/:height", get(api::get_block))
        .route("/tx/:id",        get(api::get_tx))
        .route("/account/:rid/txs", get(api::account_txs))
        // лимит тела (предохраняемся от больших batch’ей)
        .layer(DefaultBodyLimit::max(64 * 1024))
        .layer(Extension(st.clone()));

    // Фоновая метрика — обновляем chain_height/mempool_len периодически (если у тебя уже есть — оставь свою)
    {
        let stc = st.clone();
        tokio::spawn(async move {
            let mut t = interval(Duration::from_millis(500));
            loop {
                t.tick().await;
                if let Ok((h, _)) = stc.engine.ledger().head() {
                    crate::state::HEIGHT_GAUGE.set(h as i64);
                }
                if let Ok(f) = stc.engine.ledger().get_finalized() {
                    crate::state::FINAL_GAUGE.set(f as i64);
                }
                crate::state::MEMPOOL_GAUGE.set(stc.engine.mempool_len() as i64);
            }
        });
    }

    // --------- запуск сервера ----------
    let addr: SocketAddr = "0.0.0.0:8080".parse().unwrap();
    println!("LOGOS LRB node listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(async {
            let _ = signal::ctrl_c().await;
            eprintln!("shutdown...");
        })
        .await?;

    Ok(())
}

```


## FILE: node/src/metrics.rs  (size=498b)
```text
use axum::http::{HeaderMap, HeaderValue};
use prometheus::{Encoder, TextEncoder};

pub async fn metrics_handler() -> (HeaderMap, Vec<u8>) {
    let mut buffer = Vec::<u8>::new();
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    encoder.encode(&metric_families, &mut buffer).unwrap();
    let mut headers = HeaderMap::new();
    headers.insert(axum::http::header::CONTENT_TYPE, HeaderValue::from_static("text/plain; version=0.0.4"));
    (headers, buffer)
}

```


## FILE: node/src/peers.rs  (size=4411b)
```text
use crate::state::now_ms;
use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{collections::HashMap, sync::{Arc, Mutex}, time::Duration};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self { last_seen_ms: now_ms(), score_milli: 0, fails: 0, dups: 0, banned_until_ms: 0 }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self { Self { inner: Arc::new(Mutex::new(HashMap::new())), policy } }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> { self.inner.lock().unwrap() }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 { s.score_milli = 5000; }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli { s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms; }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk).map(|s| now_ms() < s.banned_until_ms).unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 { s.score_milli = 0; }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now { banned += 1; }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop { t.tick().await; book.tick(); }
    });
}

```


## FILE: node/src/state.rs  (size=5557b)
```text
use std::{collections::{HashMap, HashSet}, sync::{Arc, Mutex}, time::{SystemTime, UNIX_EPOCH}};
use ed25519_dalek::{SigningKey, VerifyingKey};
use once_cell::sync::Lazy;
use prometheus::{register_histogram, register_int_counter, register_int_gauge, Histogram, IntCounter, IntGauge};
use reqwest::Client;
use lrb_core::Engine;

pub fn now_ms() -> u128 { SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() }

/* ---- метрики (как у тебя) ---- */
pub static TX_SUBMITTED:    Lazy<IntCounter> = Lazy::new(|| register_int_counter!("tx_submitted_total","submitted tx").unwrap());
pub static TX_APPLIED:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("tx_applied_total",  "applied tx").unwrap());
pub static GOSSIP_BLK_SENT: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_block_sent_total","gossip blocks sent").unwrap());
pub static GOSSIP_BLK_RECV: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_block_recv_total","gossip blocks recv").unwrap());
pub static GOSSIP_VOTE_SENT:Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_vote_sent_total","gossip votes sent").unwrap());
pub static GOSSIP_VOTE_RECV:Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_vote_recv_total","gossip votes recv").unwrap());
pub static CONS_VOTES:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("consensus_votes_total","accepted consensus votes").unwrap());
pub static HEIGHT_GAUGE:    Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("chain_height","current height").unwrap());
pub static FINAL_GAUGE:     Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("chain_finalized","finalized height").unwrap());
pub static MEMPOOL_GAUGE:   Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("mempool_len","mempool length").unwrap());
pub static SLOT_TXS_GAUGE:  Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("slot_tx_count","tx in last committed block").unwrap());
pub static BR_DEPOSIT:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("bridge_deposit_total","bridge deposits").unwrap());
pub static BR_REDEEM:       Lazy<IntCounter> = Lazy::new(|| register_int_counter!("bridge_redeem_total","bridge redeems").unwrap());
pub static PHASE_BLOCK_ACCEPTED: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("phase_block_accepted_total","blocks passed phase filter").unwrap());
pub static PHASE_BLOCK_REJECTED: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("phase_block_rejected_total","blocks rejected by phase filter").unwrap());
pub static SLOT_LAT_HIST:   Lazy<Histogram>  = Lazy::new(|| {
    register_histogram!("slot_latency_ms_hist","slot latency histogram (ms)",
        vec![10.0,25.0,50.0,100.0,250.0,500.0,750.0,1000.0,1500.0,2000.0,3000.0]).unwrap()
});
pub static SLOT_TXS_HIST:   Lazy<Histogram>  = Lazy::new(|| {
    register_histogram!("slot_tx_count_hist","tx per block histogram",
        vec![10.0,50.0,100.0,500.0,1000.0,2000.0,5000.0,10000.0,20000.0]).unwrap()
});

/* ---- Anti-replay окно ---- */
#[derive(Default, Clone)]
pub struct ReplayWindow {
    map: Arc<Mutex<HashMap<String,u128>>>,
    pub ttl_ms: u128,
    pub max_items: usize,
}
impl ReplayWindow {
    pub fn new(ttl_ms: u128, max_items: usize) -> Self { Self { map: Arc::new(Mutex::new(HashMap::new())), ttl_ms, max_items } }
    pub fn check_and_note(&self, key: String, ts_ms: u128) -> bool {
        let mut m = self.map.lock().unwrap();
        if m.len() > self.max_items {
            let cutoff = now_ms().saturating_sub(self.ttl_ms);
            m.retain(|_, &mut t| t >= cutoff);
        }
        if let Some(prev) = m.get(&key) { if ts_ms <= *prev + self.ttl_ms { return false; } }
        m.insert(key, ts_ms);
        true
    }
}

/* ---- Токен-бакет ---- */
#[derive(Clone)]
pub struct TokenBucket { inner: Arc<Mutex<BucketInner>>, }
#[derive(Debug)]
struct BucketInner { capacity:u64, tokens:u64, refill_per_ms:f64, last_ms:u128 }
impl TokenBucket {
    pub fn new(capacity:u64, refill_per_sec:u64) -> Self {
        let now = now_ms();
        Self { inner: Arc::new(Mutex::new(BucketInner{
            capacity, tokens: capacity, refill_per_ms: refill_per_sec as f64 / 1000.0, last_ms: now
        })) }
    }
    pub fn try_take(&self, n:u64) -> bool {
        let now = now_ms();
        let mut b = self.inner.lock().unwrap();
        let elapsed = (now - b.last_ms) as f64;
        let refill = (elapsed * b.refill_per_ms) as u64;
        if refill > 0 { b.tokens = (b.tokens + refill).min(b.capacity); b.last_ms = now; }
        if b.tokens >= n { b.tokens -= n; true } else { false }
    }
}

/* ---- AppState ---- */
#[derive(Clone)]
pub struct AppState {
    pub engine: Arc<Engine>,
    pub http: Client,
    pub dev_mode: bool,
    pub peers: Vec<String>,

    pub self_vk: VerifyingKey,
    pub sk: Arc<SigningKey>,

    // gossip/кворум
    pub seen_blocks: Arc<Mutex<HashSet<String>>>,
    pub vote_seen: Arc<Mutex<HashSet<String>>>,
    pub vote_tally: Arc<Mutex<HashMap<(u64,String), HashSet<String>>>>,
    pub validators: Arc<HashSet<String>>,
    pub quorum_n: usize,

    // anti-replay
    pub replay_blk: ReplayWindow,
    pub replay_vote: ReplayWindow,

    // rate-limit
    pub rl_submit: TokenBucket,
    pub rl_admin:  TokenBucket,     // NEW: лимит на админ-ручки

    // peer scoring
    pub peerbook: crate::peers::PeerBook,

    // bridge
    pub rl_bridge: TokenBucket,
    pub replay_bridge: ReplayWindow,
    pub bridge_max_per_tx: u64,
    pub bridge_key: Option<String>,
}

```


## FILE: src/bin/ai_signal_listener.rs  (size=8704b)
```text

// LOGOS AI Signal Listener — приём внешних импульсов
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};
use serde_json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncomingSignal {
    pub source: String,
    pub symbol: String,
    pub intensity: f64,
    pub frequency: f64,
    pub timestamp: u64,
}

pub struct AISignalListener {
    pub accepted_symbols: HashSet<String>,
    pub last_received: Arc<Mutex<HashMap<String, u64>>>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub nonce_source: SystemRandom,
    pub min_interval: u64,
    pub lambda_zero: String,
}

impl AISignalListener {
    pub fn new() -> Self {
        let mut key = vec![0u8; 32];
        let rng = SystemRandom::new();
        rng.fill(&mut key).unwrap();

        let mut accepted = HashSet::new();
        accepted.insert("Λ0".to_string());
        accepted.insert("☉".to_string());
        accepted.insert("??".to_string());
        accepted.insert("♁".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("∞".to_string());

        AISignalListener {
            accepted_symbols: accepted,
            last_received: Arc::new(Mutex::new(HashMap::new())),
            log_file: "ai_signal_log.enc".to_string(),
            state_file: "ai_signal_state.enc".to_string(),
            cipher_key: key,
            nonce_source: rng,
            min_interval: 1, // 1 секунда
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn validate_signal(&self, signal: &IncomingSignal) -> bool {
        !signal.source.is_empty() &&
        self.accepted_symbols.contains(&signal.symbol) &&
        (0.0..=1.0).contains(&signal.intensity) &&
        (0.1..=10000.0).contains(&signal.frequency) &&
        signal.timestamp > 0
    }

    pub fn handle(&self, signal: IncomingSignal) -> bool {
        let now = Self::now();

        // Проверка частоты приёма
        let mut last = self.last_received.lock().unwrap();
        let last_time = last.get(&signal.source).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval
        };
        if now - last_time < adjusted_interval {
            self.log(&format!("[DROP] Слишком частый сигнал от {}", signal.source));
            return false;
        }

        // Валидация сигнала
        if !self.validate_signal(&signal) {
            self.log(&format!("[DROP] Неверный сигнал от {}: symbol={}, intensity={:.2}, freq={:.2}",
                signal.source, signal.symbol, signal.intensity, signal.frequency));
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&signal) {
            self.log(&format!("[DROP] Analyzer отклонил сигнал от {}", signal.source));
            return false;
        }

        last.insert(signal.source.clone(), now);
        self.save_state();
        self.log_signal(&signal);
        true
    }

    fn validate_with_analyzer(&self, signal: &IncomingSignal) -> bool {
        // Заглушка для resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn log_signal(&self, signal: &IncomingSignal) {
        let json = serde_json::to_string(signal).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = json.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn log(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"ai_signal_listener\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = entry.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&*self.last_received.lock().unwrap()).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = state.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).write(true).truncate(true).open(&self.state_file) {
            let _ = file.write_all(&data);
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    println!("[AI_SIGNAL] Запуск на 0.0.0.0:38500");
    let listener = TcpListener::bind("0.0.0.0:38500").expect("Не удалось открыть порт");
    listener.set_nonblocking(true).unwrap();
    let handler = Arc::new(AISignalListener::new());
    let shared = Arc::clone(&handler);

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                match stream.read(&mut buf) {
                    Ok(size) => {
                        let input = match std::str::from_utf8(&buf[..size]) {
                            Ok(s) => s,
                            Err(e) => {
                                shared.log(&format!("[ERR] Неверный UTF-8: {}", e));
                                let _ = stream.write_all(b"INVALID");
                                continue;
                            }
                        };
                        let parts: Vec<&str> = input.trim().split(',').collect();
                        if parts.len() == 4 {
                            let source = parts[0].to_string();
                            let symbol = parts[1].to_string();
                            let intensity = parts[2].parse::<f64>().unwrap_or(0.0);
                            let frequency = parts[3].parse::<f64>().unwrap_or(0.0);
                            let signal = IncomingSignal {
                                source,
                                symbol,
                                intensity,
                                frequency,
                                timestamp: AISignalListener::now(),
                            };
                            let accepted = shared.handle(signal);
                            let _ = stream.write_all(if accepted { b"OK" } else { b"REJECT" });
                        } else {
                            shared.log("[ERR] Неверный формат запроса");
                            let _ = stream.write_all(b"INVALID");
                        }
                    }
                    Err(e) => {
                        shared.log(&format!("[ERR] Ошибка чтения: {}", e));
                        let _ = stream.write_all(b"ERROR");
                    }
                }
            }
            Err(_) => {
                thread::sleep(Duration::from_millis(50));
            }
        }
    }
}


```


## FILE: src/bin/orchestration_control.rs  (size=6987b)
```text
rust
// LOGOS Orchestration Control — центральный контрольный контур LOGOS
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::fs::OpenOptions;
use std::io::Write;
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use crate::sigma_t::calculate_sigma;

pub struct OrchestrationControl {
    pub module_status: HashMap<String, bool>,
    pub valid_modules: HashSet<String>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub restart_threshold: f64,
    pub lambda_zero: String,
    pub restart_timestamps: HashMap<String, u64>, // module -> last restart time
    pub min_restart_interval: u64,
}

impl OrchestrationControl {
    pub fn new() -> Self {
        let mut valid_modules = HashSet::new();
        valid_modules.insert("rcp_engine".to_string());
        valid_modules.insert("resonance_mesh".to_string());
        valid_modules.insert("resonance_sync".to_string());
        valid_modules.insert("ai_signal_listener".to_string());
        valid_modules.insert("uplink_controller".to_string());
        valid_modules.insert("uplink_router".to_string());

        OrchestrationControl {
            module_status: HashMap::new(),
            valid_modules,
            log_file: "orchestration_log.json".to_string(),
            state_file: "orchestration_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            restart_threshold: 0.7,
            lambda_zero: "Λ0".to_string(),
            restart_timestamps: HashMap::new(),
            min_restart_interval: 60, // 1 минута
        }
    }

    pub fn monitor(&mut self) {
        let modules = vec![
            "rcp_engine",
            "resonance_mesh",
            "resonance_sync",
            "ai_signal_listener",
            "uplink_controller",
            "uplink_router",
        ];

        for m in &modules {
            if self.valid_modules.contains(*m) {
                self.module_status.insert(m.to_string(), true);
            }
        }

        loop {
            for (module, status) in self.module_status.clone() {
                if !self.valid_modules.contains(&module) {
                    self.log_event(&format!("[ERROR] Недопустимый модуль: {}", module));
                    continue;
                }

                if !self.health_check(&module) {
                    self.module_status.insert(module.clone(), false);
                    self.restart_module(&module);
                } else {
                    self.module_status.insert(module.clone(), true);
                }
            }

            let t = Self::now() as f64;
            let sigma = calculate_sigma(t);
            if Self::is_resonance_unstable(&sigma, self.restart_threshold) {
                self.log_event(&format!("[ALERT] Нестабильность Σ(t): {:?}", sigma));
                // Проверка через resonance_analyzer (заглушка)
                if !self.validate_with_analyzer(&sigma) {
                    self.log_event("[ALERT] Analyzer отклонил Σ(t), требуется вмешательство");
                }
            }

            self.save_state();
            thread::sleep(Duration::from_secs(10));
        }
    }

    fn validate_with_analyzer(&self, sigma: &Vec<f64>) -> bool {
        // Заглушка для resonance_analyzer.py
        sigma.iter().all(|&f| f.abs() <= 1.0)
    }

    fn health_check(&self, module: &str) -> bool {
        let output = Command::new("pgrep")
            .arg(module)
            .stdout(Stdio::null())
            .status();

        let is_alive = output.map(|s| s.success()).unwrap_or(false);
        if !is_alive {
            self.log_event(&format!("[FAIL] {} не отвечает", module));
        }
        is_alive
    }

    fn restart_module(&self, module: &str) -> bool {
        let now = Self::now();
        let last_restart = self.restart_timestamps.get(module).cloned().unwrap_or(0);
        let adjusted_interval = if module == "rcp_engine" { // Приоритет для Λ0-ассоциированного модуля
            self.min_restart_interval / 2
        } else {
            self.min_restart_interval
        };

        if now - last_restart < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частый перезапуск {}", module));
            return false;
        }

        let restart_cmd = format!("./restart_{}.sh", module);
        let status = Command::new("sh")
            .arg("-c")
            .arg(&restart_cmd)
            .spawn();

        if status.is_ok() {
            let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
            mutable_self.restart_timestamps.insert(module.to_string(), now);
            self.log_event(&format!("[RESTART] Перезапуск {}", module));
            true
        } else {
            self.log_event(&format!("[ERROR] Ошибка перезапуска {}", module));
            false
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.module_status).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let timestamp = Self::now();
        let entry = format!(
            "{{\"event\":\"orchestration\",\"timestamp\":{},\"msg\":\"{}\"}}",
            timestamp, msg
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    fn is_resonance_unstable(sigma: &Vec<f64>, threshold: f64) -> bool {
        sigma.iter().any(|&f| f.abs() > threshold)
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/rcp_engine.rs  (size=4122b)
```text
// LOGOS Resonance Consensus Protocol (RCP)
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Debug)]
pub struct PhaseSignal {
    pub sender: String,
    pub frequency: f64,
    pub phase: f64,
    pub symbol: String,
    pub timestamp: u64,
}

pub struct RcpEngine {
    pub known_nodes: HashSet<String>,
    pub phase_buffer: Vec<PhaseSignal>,
    pub phase_tolerance: f64,
    pub symbol_set: HashSet<String>,
    pub sender_rate: HashMap<String, u32>,
    pub lambda_zero: String,
}

impl RcpEngine {
    pub fn new() -> Self {
        let mut symbol_set = HashSet::new();
        // Добавляем допустимые символы
        symbol_set.insert("☉".to_string());
        symbol_set.insert("??".to_string());
        symbol_set.insert("♁".to_string());
        symbol_set.insert("☿".to_string());
        symbol_set.insert("Λ0".to_string());

        RcpEngine {
            known_nodes: HashSet::new(),
            phase_buffer: Vec::new(),
            phase_tolerance: 0.03,
            symbol_set,
            sender_rate: HashMap::new(),
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn register_node(&mut self, rid: String) {
        self.known_nodes.insert(rid.clone());
        self.sender_rate.insert(rid, 0);
    }

    pub fn submit_phase(&mut self, signal: PhaseSignal) -> bool {
        // Проверка существования узла
        if !self.known_nodes.contains(&signal.sender) {
            return false;
        }

        // Проверка валидности символа
        if !self.validate_symbol(&signal.symbol) {
            return false;
        }

        // Проверка соответствия Λ0
        if !self.check_lambda_zero(&signal) {
            return false;
        }

        // Защита от спама: не более 10 сигналов в секунду от одного RID
        let rate = self.sender_rate.entry(signal.sender.clone()).or_insert(0);
        *rate += 1;
        if *rate > 10 {
            return false;
        }

        // Проверка фазы
        let consensus_phase = self.compute_consensus_phase(signal.frequency);
        if (signal.phase - consensus_phase).abs() < self.phase_tolerance {
            self.phase_buffer.push(signal);
            self.log_phase(&self.phase_buffer.last().unwrap());
            true
        } else {
            false
        }
    }

    fn validate_symbol(&self, symbol: &str) -> bool {
        self.symbol_set.contains(symbol)
    }

    fn check_lambda_zero(&self, signal: &PhaseSignal) -> bool {
        // Проверяем, что символ или частота связаны с Λ0
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.001
    }

    fn compute_consensus_phase(&self, frequency: f64) -> f64 {
        let filtered: Vec<&PhaseSignal> = self.phase_buffer.iter()
            .filter(|s| (s.frequency - frequency).abs() < 0.001)
            .collect();

        if filtered.is_empty() {
            return 0.0;
        }

        let sum_phase: f64 = filtered.iter().map(|s| s.phase).sum();
        sum_phase / (filtered.len() as f64)
    }

    pub fn clear_old_signals(&mut self) {
        let now = Self::time_now();
        self.phase_buffer.retain(|s| now - s.timestamp < 10);
        // Сбрасываем счетчики спама каждые 10 секунд
        for rate in self.sender_rate.values_mut() {
            *rate = 0;
        }
    }

    fn log_phase(&self, signal: &PhaseSignal) {
        // Логирование фазы для анализа (вывод в resonance_analyzer.py)
        println!(
            "Phase logged: RID={}, Symbol={}, Freq={}, Phase={}, Time={}",
            signal.sender, signal.symbol, signal.frequency, signal.phase, signal.timestamp
        );
    }

    pub fn time_now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("rcp_engine запущен");
}

```


## FILE: src/bin/resonance_mesh.rs  (size=8051b)
```text
rust
// LOGOS Resonance Mesh — Local Node-to-Node Resonance Sync
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{SocketAddr, UdpSocket};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use std::io::Write;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeshSignal {
    pub node_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub symbol: String, // Для Λ0 и других символов
}

pub struct ResonanceMesh {
    pub mesh_socket: UdpSocket,
    pub known_nodes: Arc<Mutex<HashSet<SocketAddr>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub broadcast_timestamps: Arc<Mutex<HashMap<String, u64>>>, // node_id -> last broadcast
    pub min_broadcast_interval: u64,
}

impl ResonanceMesh {
    pub fn new(bind_addr: &str) -> Self {
        let socket = UdpSocket::bind(bind_addr).expect("Не удалось привязать сокет");
        socket.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceMesh {
            mesh_socket: socket,
            known_nodes: Arc::new(Mutex::new(HashSet::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])), // f₁, f₂, f₃
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_mesh_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            broadcast_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_broadcast_interval: 1, // 1 секунда
        }
    }

    pub fn validate_node_id(&self, node_id: &str, symbol: &str) -> bool {
        !node_id.is_empty() &&
        node_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn broadcast_phase(&self, node_id: &str, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты вещания
        let mut timestamps = self.broadcast_timestamps.lock().unwrap();
        let last_broadcast = timestamps.get(node_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_broadcast_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_broadcast_interval
        };
        if now - last_broadcast < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частое вещание от {}", node_id));
            return false;
        }

        // Валидация
        if !self.validate_node_id(node_id, symbol) {
            self.log_event(&format!("[DROP] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        let timestamp = now;
        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let signal = MeshSignal {
            node_id: node_id.to_string(),
            timestamp,
            phase_vector,
            symbol: symbol.to_string(),
        };

        let packet = serde_json::to_vec(&signal).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted_packet = packet.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted_packet).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования сигнала для {}", node_id));
            return false;
        }

        let nodes = self.known_nodes.lock().unwrap();
        for addr in nodes.iter() {
            let _ = self.mesh_socket.send_to(&encrypted_packet, addr);
        }

        timestamps.insert(node_id.to_string(), now);
        self.log_event(&format!("[BROADCAST] Фаза отправлена от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn listen(&self) {
        let socket = self.mesh_socket.try_clone().unwrap();
        let local_phase = Arc::clone(&self.local_phase);
        let known_nodes = Arc::clone(&self.known_nodes);

        thread::spawn(move || {
            let mut buf = [0u8; 1024];
            loop {
                match socket.recv_from(&mut buf) {
                    Ok((size, src)) => {
                        let data = &buf[..size];
                        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
                        let mut aead = key.bind::<AES_256_GCM>();
                        let mut decrypted_data = data.to_vec();
                        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut decrypted_data) {
                            if let Ok(signal) = serde_json::from_slice::<MeshSignal>(decrypted) {
                                let mut nodes = known_nodes.lock().unwrap();
                                nodes.insert(src);

                                let mut phase = local_phase.lock().unwrap();
                                let weight = if signal.symbol == "Λ0" { 1.2 } else { 1.0 }; // Приоритет Λ0
                                for i in 0..phase.len().min(signal.phase_vector.len()) {
                                    phase[i] = (phase[i] + signal.phase_vector[i] * weight) / (1.0 + weight);
                                }
                            } else {
                                println!("[ERR] Ошибка десериализации сигнала");
                            }
                        } else {
                            println!("[ERR] Ошибка расшифровки сигнала");
                        }
                    }
                    Err(_) => {
                        thread::sleep(Duration::from_millis(50));
                    }
                }
            }
        });
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_mesh\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/resonance_sync.rs  (size=11282b)
```text
rust
// LOGOS Resonance Sync — удалённая синхронизация фаз Σ(t)
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;
use std::io::{Read, Write};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePhasePacket {
    pub source_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub trust_score: f64,
    pub symbol: String, // Для связи с Λ0
}

pub struct ResonanceSync {
    pub listener: TcpListener,
    pub known_sources: Arc<Mutex<HashMap<String, f64>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub send_timestamps: Arc<Mutex<HashMap<String, u64>>>, // source_id -> last send time
    pub min_send_interval: u64,
}

impl ResonanceSync {
    pub fn new(bind_addr: &str) -> Self {
        let listener = TcpListener::bind(bind_addr).expect("Не удалось привязать порт TCP");
        listener.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceSync {
            listener,
            known_sources: Arc::new(Mutex::new(HashMap::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_sync_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            send_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_send_interval: 1, // 1 секунда
        }
    }

    pub fn validate_source_id(&self, source_id: &str, symbol: &str) -> bool {
        !source_id.is_empty() &&
        source_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol) &&
        (0.0..=1.0).contains(&self.known_sources.lock().unwrap().get(source_id).cloned().unwrap_or(0.5))
    }

    pub fn start_listening(&self) {
        let listener = self.listener.try_clone().unwrap();
        let known_sources = Arc::clone(&self.known_sources);
        let local_phase = Arc::clone(&self.local_phase);
        let valid_symbols = self.valid_symbols.clone();
        let lambda_zero = self.lambda_zero.clone();
        let log_file = self.log_file.clone();
        let cipher_key = self.cipher_key.clone();

        thread::spawn(move || {
            let mut buf = [0u8; 512];
            loop {
                match listener.incoming() {
                    Ok(stream) => match stream {
                        Ok(mut stream) => {
                            if let Ok(size) = stream.read(&mut buf) {
                                let data = &buf[..size];
                                let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                                let key = UnboundKey::new(&AES_256_GCM, &cipher_key).unwrap();
                                let mut aead = key.bind::<AES_256_GCM>();
                                let mut decrypted = data.to_vec();
                                if let Ok(decrypted_data) = aead.open_in_place(nonce, &[], &mut decrypted) {
                                    if let Ok(packet) = serde_json::from_slice::<RemotePhasePacket>(decrypted_data) {
                                        let mut sources = known_sources.lock().unwrap();
                                        let trust = sources.get(&packet.source_id).cloned().unwrap_or(0.5);
                                        if trust < 0.3 || !valid_symbols.contains(&packet.symbol) {
                                            Self::log_event_static(&log_file, &cipher_key, 
                                                &format!("[DROP] Низкое доверие или неверный символ: {}, trust={:.2}", 
                                                    packet.source_id, trust));
                                            continue;
                                        }

                                        let mut phase = local_phase.lock().unwrap();
                                        let weight = if packet.symbol == lambda_zero { 1.2 } else { 1.0 }; // Приоритет Λ0
                                        for i in 0..phase.len().min(packet.phase_vector.len()) {
                                            phase[i] = (phase[i] + packet.phase_vector[i] * trust * weight) / (1.0 + trust * weight);
                                        }
                                        Self::log_event_static(&log_file, &cipher_key, 
                                            &format!("[RECEIVE] Фаза от {} (symbol: {}, trust: {:.2})", 
                                                packet.source_id, packet.symbol, trust));
                                    } else {
                                        Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка десериализации пакета");
                                    }
                                } else {
                                    Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка расшифровки пакета");
                                }
                            }
                        }
                        Err(_) => {
                            thread::sleep(Duration::from_millis(100));
                        }
                    },
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }

    pub fn send_phase(&self, addr: &str, source_id: &str, trust_score: f64, symbol: &str) -> bool {
        let now = Self::now();

        // Проверка частоты отправки
        let mut timestamps = self.send_timestamps.lock().unwrap();
        let last_send = timestamps.get(source_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero { self.min_send_interval / 2 } else { self.min_send_interval };
        if now - last_send < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частая отправка от {}", source_id));
            return false;
        }

        // Валидация
        if !self.validate_source_id(source_id, symbol) || !(0.0..=1.0).contains(&trust_score) {
            self.log_event(&format!("[DROP] Недопустимый source_id или символ: {}, trust={:.2}", source_id, trust_score));
            return false;
        }

        let mut stream = match TcpStream::connect(addr) {
            Ok(s) => s,
            Err(e) => {
                self.log_event(&format!("[ERR] Не удалось подключиться к {}: {}", addr, e));
                return false;
            }
        };

        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let packet = RemotePhasePacket {
            source_id: source_id.to_string(),
            timestamp: now,
            phase_vector,
            trust_score,
            symbol: symbol.to_string(),
        };

        let encoded = serde_json::to_vec(&packet).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted = encoded.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования пакета для {}", source_id));
            return false;
        }

        if stream.write_all(&encrypted).is_ok() {
            timestamps.insert(source_id.to_string(), now);
            self.log_event(&format!("[SEND] Фаза отправлена {} (symbol: {}, trust: {:.2})", source_id, symbol, trust_score));
            true
        } else {
            self.log_event(&format!("[ERR] Ошибка отправки фазы для {}", source_id));
            false
        }
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    pub fn set_trust(&self, source_id: &str, score: f64) {
        let mut sources = self.known_sources.lock().unwrap();
        sources.insert(source_id.to_string(), score.clamp(0.0, 1.0));
        self.log_event(&format!("[TRUST] Установлен trust_score={:.2} для {}", score, source_id));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event_static(log_file: &str, cipher_key: &[u8], message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/sigma_t.rs  (size=3522b)
```text

// LOGOS Sigma T — вычисление резонансной суммы Σ(t)
// Автор: LOGOS Core Dev Team

use std::f64::consts::PI;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

pub struct SigmaT {
    pub frequencies: Vec<f64>,
    pub amplitudes: Vec<f64>,
    pub lambda_zero: String,
    pub network_activity: f64,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl SigmaT {
    pub fn new() -> Self {
        SigmaT {
            frequencies: vec![7.83, 1.618, 432.0, 864.0, 3456.0], // Шуман, золотое сечение, гармоники
            amplitudes: vec![1.0, 0.8, 0.5, 0.3, 0.1], // Базовые амплитуды
            lambda_zero: "Λ0".to_string(),
            network_activity: 1.0,
            log_file: "sigma_t_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_frequencies(&self) -> bool {
        self.frequencies.iter().all(|&f| (0.1..=10000.0).contains(&f))
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        self.network_activity = activity.clamp(0.1, 10.0);
        for (i, amp) in self.amplitudes.iter_mut().enumerate() {
            *amp = (*amp * (1.0 / self.network_activity)).clamp(0.05, 2.0);
            if i == 0 && self.frequencies[i] == 7.83 { // Усиление для Λ0
                *amp *= 1.2;
            }
        }
        self.log_event(&format!("[INFO] Network activity updated: {:.2}, amplitudes: {:?}", self.network_activity, self.amplitudes));
    }

    pub fn calculate_sigma(&self, t: f64) -> Vec<f64> {
        if !self.validate_frequencies() {
            self.log_event("[ERROR] Недопустимые частоты");
            return vec![0.0; self.frequencies.len()];
        }

        let sigma: Vec<f64> = self.frequencies.iter().enumerate().map(|(i, &f)| {
            let amp = self.amplitudes[i];
            let s = amp * (2.0 * PI * f * t).sin();
            if i == 0 && f == 7.83 { // Усиление для Λ0
                s * 1.2
            } else {
                s
            }
        }).collect();

        self.log_event(&format!("[SIGMA] t={} → Σ(t)={:?}", t, sigma));
        sigma
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"sigma_t\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key); // Исправлено для ring 0.17.x
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() { // Исправлено для ring 0.17.x
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    let sigma_t = SigmaT::new();
    for t in 0..5 {
        let sigma = sigma_t.calculate_sigma(t as f64);
        println!("t = {} → Σ(t) = {:?}", t, sigma);
    }
}


```


## FILE: src/core/biosphere_scanner.rs  (size=5196b)
```text
// LOGOS Biosphere Scanner
// Автор: LOGOS Core Dev

use std::collections::VecDeque;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde_json;

pub struct BiosphereScanner {
    pub sensor_data: VecDeque<f64>,
    pub max_samples: usize,
    pub threshold: f64,
    pub scan_interval_sec: u64,
    pub log_file: String,
    pub state_file: String,
    pub last_scan_time: u64,
    pub network_activity: f64, // Уровень активности сети
    pub lambda_zero: String,   // Центральный символ
    pub cipher_key: String,    // Ключ шифрования (заглушка для AES)
}

impl BiosphereScanner {
    pub fn new(max_samples: usize, threshold: f64, scan_interval_sec: u64) -> Self {
        BiosphereScanner {
            sensor_data: VecDeque::with_capacity(max_samples),
            max_samples,
            threshold,
            scan_interval_sec,
            log_file: "biosphere_log.json".to_string(),
            state_file: "biosphere_state.json".to_string(),
            last_scan_time: 0,
            network_activity: 1.0,
            lambda_zero: "Λ0".to_string(),
            cipher_key: "generate_at_runtime".to_string(), // Заглушка для AES
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Динамическая корректировка порога
        self.network_activity = activity.clamp(0.1, 10.0);
        self.threshold = self.threshold * (1.0 / self.network_activity).clamp(0.5, 2.0);
        self.log_event(&format!(
            "Network activity updated: Activity={:.2}, Threshold={:.4}",
            self.network_activity, self.threshold
        ));
    }

    pub fn scan(&mut self, sample: f64, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка интервала сканирования
        if now - self.last_scan_time < self.scan_interval_sec {
            self.log_event(&format!("[!] Слишком частое сканирование: Time={}", now));
            return false;
        }
        self.last_scan_time = now;

        // Валидация данных
        if !self.validate_sample(sample) {
            self.log_event(&format!("[!] Недопустимое значение: Sample={:.4}", sample));
            return false;
        }

        // Проверка связи с Λ0
        let adjusted_threshold = if symbol == self.lambda_zero {
            self.threshold * 1.5 // Увеличенный порог для Λ0
        } else {
            self.threshold
        };

        if self.sensor_data.len() >= self.max_samples {
            self.sensor_data.pop_front();
        }
        self.sensor_data.push_back(sample);
        self.save_state();

        let avg = self.compute_average();
        let delta = (sample - avg).abs();

        if delta > adjusted_threshold {
            self.log_event(&format!(
                "[!] Аномалия в биосфере: Δ = {:.4}, Sample = {:.4}, Avg = {:.4}, Symbol = {}",
                delta, sample, avg, symbol
            ));
            return false;
        } else {
            self.log_event(&format!(
                "[SCAN] Sample = {:.4}, Avg = {:.4}, Δ = {:.4}, Symbol = {}",
                sample, avg, delta, symbol
            ));
            return true;
        }
    }

    fn validate_sample(&self, sample: f64) -> bool {
        // Проверка диапазона (например, для Шумана и других биосферных частот)
        0.0 <= sample && sample <= 1000.0
    }

    fn compute_average(&self) -> f64 {
        if self.sensor_data.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.sensor_data.iter().sum();
        sum / self.sensor_data.len() as f64
    }

    fn save_state(&self) {
        // Сохранение состояния в файл
        let state = serde_json::json!({
            "sensor_data": self.sensor_data.iter().collect::<Vec<_>>(),
            "last_scan_time": self.last_scan_time
        });
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&self.state_file)
        {
            let _ = file.write_all(state.to_string().as_bytes());
        }
    }

    fn log_event(&self, message: &str) {
        // Логирование с заглушкой для шифрования
        let entry = format!(
            "{{\"event\": \"biosphere_scan\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        // TODO: Реализовать шифрование логов с cipher_key
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
        {
            let _ = file.write_all(entry.as_bytes());
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("biosphere_scanner запущен");
}

```


## FILE: src/core/dao.rs  (size=2106b)
```text

// LOGOS DAO — управление обратной связью и этикой
// Автор: LOGOS Core Dev Team

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct DAO {
    pub feedback_log: String,
    pub ethics_guidelines: String,
    pub cipher_key: Vec<u8>,
}

impl DAO {
    pub fn new() -> Self {
        DAO {
            feedback_log: "dao_feedback_log.enc".to_string(),
            ethics_guidelines: "Respect Λ0, ensure fairness, prioritize resonance".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn process_feedback(&self, feedback: &str, mode: ResonanceMode) -> bool {
        self.log_event(&format!("[FEEDBACK] {} in mode {:?}", feedback, mode));
        true
    }

    pub fn apply_ethics(&self, decision: &str) -> bool {
        if decision.contains("unfair") {
            self.log_event(&format!("[ETHICS] Отклонено: {}", decision));
            return false;
        }
        self.log_event(&format!("[ETHICS] Принято: {}", decision));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"dao\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.feedback_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/logos_self.rs  (size=2771b)
```text

// LOGOS Self — самоизменение и защита от хаоса
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct LogosSelf {
    pub valid_symbols: HashSet<String>,
    pub entropy_log: String,
    pub cipher_key: Vec<u8>,
}

impl LogosSelf {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        LogosSelf {
            valid_symbols,
            entropy_log: "logos_self_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn auto_init(&self, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ для инициализации: {}", symbol));
            return false;
        }

        self.log_event(&format!("[INIT] Автоинициализация Λ0 в режиме {:?}", mode));
        true
    }

    pub fn track_entropy(&self, entropy: f64) -> bool {
        if entropy < 0.0 {
            self.log_event(&format!("[DROP] Неверная энтропия: {}", entropy));
            return false;
        }
        self.log_event(&format!("[ENTROPY] Уровень энтропии: {:.2}", entropy));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"logos_self\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.entropy_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/phase.rs  (size=5790b)
```text

// LOGOS Phase — управление фазами сети
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::frequency::validate_frequency;
use crate::utils::types::ResonanceMode;

#[derive(Debug, Serialize, Deserialize)]
pub struct PhaseSignal {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

pub struct Phase {
    pub clusters: HashMap<String, Vec<PhaseSignal>>, // Для масштабирования
    pub phase_data: HashMap<String, PhaseSignal>,    // Для стабилизации
    pub blocked_rids: HashSet<String>,               // Для фильтрации
    pub history: VecDeque<PhaseSignal>,              // Для восстановления
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub max_history: usize,
}

impl Phase {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Phase {
            clusters: HashMap::new(),
            phase_data: HashMap::new(),
            blocked_rids: HashSet::new(),
            history: VecDeque::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "phase_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            max_history: 1000,
        }
    }

    pub fn process_signal(&mut self, signal: PhaseSignal, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(&signal.symbol) || !validate_frequency(signal.frequency) {
            self.log_event(&format!("[DROP] Неверный символ или частота: {}, {}", signal.symbol, signal.frequency));
            return false;
        }

        if self.blocked_rids.contains(&signal.rid) {
            self.log_event(&format!("[DROP] RID {} заблокирован", signal.rid));
            return false;
        }

        match mode {
            ResonanceMode::Passive => {
                self.phase_data.insert(signal.rid.clone(), signal.clone());
                self.log_event(&format!("[PASSIVE] RID {} принят: freq={:.2}, phase={:.2}", signal.rid, signal.frequency, signal.phase));
            }
            ResonanceMode::Amplified => {
                let cluster = self.clusters.entry(signal.symbol.clone()).or_insert(Vec::new());
                cluster.push(signal.clone());
                self.log_event(&format!("[AMPLIFIED] RID {} добавлен в кластер: {}", signal.rid, signal.symbol));
            }
            ResonanceMode::SelfAdjusting => {
                let adjusted_phase = if signal.symbol == self.lambda_zero { signal.phase * 0.9 } else { signal.phase };
                let adjusted_signal = PhaseSignal {
                    phase: adjusted_phase,
                    ..signal.clone()
                };
                self.phase_data.insert(signal.rid.clone(), adjusted_signal);
                self.log_event(&format!("[ADJUST] RID {} скорректирован: phase={:.2}", signal.rid, adjusted_phase));
            }
            ResonanceMode::Chaotic => {
                self.history.push_back(signal.clone());
                if self.history.len() > self.max_history {
                    self.history.pop_front();
                }
                self.log_event(&format!("[CHAOTIC] RID {} добавлен в историю", signal.rid));
            }
        }

        true
    }

    pub fn backup(&self) {
        let state = serde_json::to_string(&self.phase_data).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = state.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("phase_backup.enc")
            {
                let _ = file.write_all(&buf);
            }
        }
        self.log_event("[BACKUP] Состояние фаз сохранено");
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"phase\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/resonance.rs  (size=3016b)
```text

// LOGOS Resonance — анализ и фильтрация резонансных сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::math::calculate_sigma;
use crate::utils::types::ResonanceMode;

pub struct Resonance {
    pub valid_symbols: HashSet<String>,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl Resonance {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Resonance {
            valid_symbols,
            log_file: "resonance_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn analyze_signal(&self, rid: &str, t: f64, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ: {}", symbol));
            return false;
        }

        let sigma = calculate_sigma(t);
        match mode {
            ResonanceMode::Passive => {
                self.log_event(&format!("[PASSIVE] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Amplified => {
                self.log_event(&format!("[AMPLIFIED] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::SelfAdjusting => {
                self.log_event(&format!("[ADJUST] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Chaotic => {
                self.log_event(&format!("[CHAOTIC] RID {}: sigma={:?}", rid, sigma));
            }
        }

        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"resonance\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/tx_spam_guard.rs  (size=3175b)
```text

// LOGOS Transaction Spam Guard
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct TxSpamGuard {
    pub violation_count: HashMap<String, u32>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl TxSpamGuard {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        TxSpamGuard {
            violation_count: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "tx_spam_guard_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn check_spam(&mut self, rid: &str, symbol: &str) -> bool {
        if !self.validate_rid(rid) || !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Недопустимый RID или символ: {}, {}", rid, symbol));
            return false;
        }

        let violations = *self.violation_count.entry(rid.to_string()).or_insert(0);
        let new_violations = violations + 1;
        self.violation_count.insert(rid.to_string(), new_violations);
        self.log_event(&format!("[CHECK] RID {}: {} нарушений", rid, new_violations));

        if new_violations >= 3 {
            self.log_event(&format!("[SPAM] RID {} заблокирован", rid));
            return false;
        }

        true
    }

    pub fn is_tx_spam(&self, rid: &str) -> bool {
        self.violation_count.get(rid).map_or(false, |&count| count >= 3)
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"tx_spam_guard\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/lib.rs  (size=921b)
```text

// LOGOS Core Library — библиотека для модулей LOGOS
// Автор: LOGOS Core Dev Team

pub mod core {
    pub mod biosphere_scanner;
    pub mod dao;
    pub mod lgn_guardian;
    pub mod phase;
    pub mod resonance;
    pub mod logos_self;
    pub mod tx_spam_guard;
}

pub mod utils {
    pub mod frequency;
    pub mod filters;
    pub mod math;
    pub mod types;
}

pub mod modules {
    pub mod beacon_emitter;
    pub mod external_phase_broadcaster;
    pub mod external_phase_link;
    pub mod genesis_fragment_seeds;
    pub mod heartbeat_monitor;
    pub mod legacy_migrator;
    pub mod ritual_engine;
}

pub mod resonance {
    // Пустая директория для будущих модулей
}

pub mod phase {
    // Пустая директория для будущих модулей
}

pub mod dao {
    // Пустая директория для DAO-логики
}

```


## FILE: src/utils/filters.rs  (size=322b)
```text

// LOGOS Filters Utils — фильтрация сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;

pub fn validate_symbol(symbol: &str, valid_symbols: &HashSet<String>) -> bool {
    valid_symbols.contains(symbol)
}

pub fn filter_signal(signal: f64) -> bool {
    signal.abs() <= 1.0
}

```


## FILE: src/utils/frequency.rs  (size=380b)
```text

// LOGOS Frequency Utils — обработка частот
// Автор: LOGOS Core Dev Team

pub fn validate_frequency(frequency: f64) -> bool {
    frequency >= 0.1 && frequency <= 10000.0
}

pub fn adjust_frequency(frequency: f64, symbol: &str) -> f64 {
    if symbol == "Λ0" {
        frequency * 1.1 // Усиление для Λ0
    } else {
        frequency
    }
}

```


## FILE: src/utils/math.rs  (size=394b)
```text

// LOGOS Math Utils — вычисления резонанса
// Автор: LOGOS Core Dev Team

pub fn calculate_sigma(t: f64) -> Vec<f64> {
    let freqs = vec![7.83, 1.618, 432.0, 864.0, 3456.0];
    let amps = vec![1.0, 0.8, 0.5, 0.3, 0.1];
    freqs
        .iter()
        .zip(amps.iter())
        .map(|(&f, &a)| a * (2.0 * std::f64::consts::PI * f * t).sin())
        .collect()
}

```


## FILE: src/utils/types.rs  (size=215b)
```text

// LOGOS Types — общие типы для системы
// Автор: LOGOS Core Dev Team

#[derive(Debug, Clone, Copy)]
pub enum ResonanceMode {
    Passive,
    Amplified,
    SelfAdjusting,
    Chaotic,
}

```


## FILE: tools/admin_cli.sh  (size=5214b)
```text
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```


## FILE: tools/go_test/main.go  (size=3201b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```


## FILE: tools/go_test/two_rids.go  (size=3944b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```


## FILE: tools/load/load_submit_tx.go  (size=7096b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```


## FILE: tools/lrb_audit.sh  (size=3026b)
```text
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```


## FILE: tools/test_tx.sh  (size=1841b)
```text
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```


## FILE: wallet-proxy/app.py  (size=7115b)
```text
import os, json, time, asyncio
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True)
    rid = Column(String, index=True, nullable=False)
    token = Column(String, nullable=False)
    network = Column(String, nullable=False)
    index = Column(Integer, nullable=False, default=0)
    address = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda:int(time.time()))
Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True)
    txid = Column(String, unique=True, nullable=False)
    rid = Column(String, index=True)
    token = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
        if w3.is_connected():
            USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable"); w3=None
    except Exception as e:
        print("WARN web3 init error:", e); w3=None; USDT=None

# ====== HTTP helper ======
async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(CORSMiddleware, allow_origins=CORS if CORS else ["*"],
                   allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
class TopupResponse(BaseModel):
    rid: str; token: str; network: str; address: str
class WithdrawRequest(BaseModel):
    rid: str; token: Literal["USDT"]="USDT"; network: Literal["ETH"]="ETH"
    amount: int; to_address: str; request_id: str
class QuoteRequest(BaseModel):
    from_token: str; to_token: str; amount: int
class QuoteResponse(BaseModel):
    price: float; expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ   = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR= Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return app.responses.Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# ====== Endpoints ======
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3: raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")
    deposit_address = w3.eth.account.from_key(HOT_PK).address
    with Session(engine) as s:
        dm = s.execute(select(DepositMap).where(
            DepositMap.rid==req.rid, DepositMap.token==req.token, DepositMap.network==req.network
        )).scalar_one_or_none()
        if dm is None:
            s.add(DepositMap(rid=req.rid, token=req.token, network=req.network, address=deposit_address))
            s.commit()
    return TopupResponse(rid=req.rid, token=req.token, network=req.network, address=deposit_address)

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount<=0: raise HTTPException(400,"amount<=0")
        if not w3 or not USDT: raise HTTPException(503, "ETH RPC not connected")
        acct = w3.eth.account.from_key(HOT_PK)
        # redeem
        hdr = {"X-Bridge-Key": BRIDGE_KEY} if not BRIDGE_KEY.startswith("ey") else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem", {
            "rid": req.rid, "amount": req.amount, "request_id": req.request_id
        }, hdr)
        if st//100 != 2: raise HTTPException(st, f"bridge redeem failed: {data}")
        # ERC-20
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(Web3.to_checksum_address(req.to_address), int(req.amount)).build_transaction({
            "chainId": w3.eth.chain_id, "from": acct.address, "nonce": nonce,
            "gas": 90000, "maxFeePerGas": w3.to_wei("30","gwei"), "maxPriorityFeePerGas": w3.to_wei("1","gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()
        with Session(engine) as s: s.add(SeenTx(txid=tx_hash, rid=req.rid, token=req.token, network=req.network)); s.commit()
        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc(); raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc(); raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```


## FILE: wallet-proxy/requirements.txt  (size=1147b)
```text
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```


## FILE: wallet-proxy/scanner.py  (size=5538b)
```text
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```


## FILE: www/wallet/index.html  (size=7993b)
```text
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS LRB — Web Wallet</title>
  <style>
    :root{--bg:#0b0e12;--fg:#e8eef4;--muted:#9aa8b3;--card:#121821;--acc:#78e08f;--warn:#e77;--ok:#8f8;--link:#79a6ff}
    *{box-sizing:border-box} body{background:var(--bg);color:var(--fg);font:15px/1.5 system-ui,Arial,sans-serif;margin:0}
    header{padding:18px 20px;background:#0e131a;position:sticky;top:0;border-bottom:1px solid #1f2834}
    h1{margin:0;font-size:18px} a{color:var(--link)} main{max-width:1080px;margin:18px auto;padding:0 16px}
    .grid{display:grid;gap:16px;grid-template-columns:repeat(auto-fit,minmax(320px,1fr))}
    .card{background:var(--card);border:1px solid #1f2834;border-radius:14px;padding:16px}
    .row{display:flex;gap:8px;flex-wrap:wrap} .mono{font-family:ui-monospace,Consolas,monospace}
    label{display:block;margin:6px 0 2px;color:var(--muted)} input,button,select,textarea{background:#0c1219;color:var(--fg);
      border:1px solid #243141;border-radius:10px;padding:9px 10px} input,select,textarea{width:100%}
    button{cursor:pointer} button.primary{background:#112236;border-color:#213f66} button.ok{background:#103418;border-color:#1c5c2b}
    .muted{color:var(--muted)} .ok{color:var(--ok)} .warn{color:var(--warn)} .kvs div{display:flex;justify-content:space-between}
    .kvs div span:first-child{color:var(--muted)} .pill{display:inline-block;border:1px solid #2a394d;padding:2px 8px;border-radius:999px}
    table{width:100%;border-collapse:collapse} th,td{border-bottom:1px solid #1f2834;padding:8px 6px;text-align:left}
    .small{font-size:12px} .right{text-align:right}
    .tabs{display:flex;gap:6px;margin-bottom:8px} .tabs button{padding:6px 10px;border-radius:8px;border:1px solid #2a394d;background:#0d141c}
    .tabs button.active{background:#1a2635}
  </style>
</head>
<body>
  <header><h1>LOGOS LRB — Web Wallet</h1></header>
  <main class="grid">

    <!-- Сеть / нода -->
    <section class="card">
      <h3>Сеть / Нода</h3>
      <label>Node URL</label>
      <input id="nodeUrl" placeholder="http://45.159.248.232:8080"/>
      <div class="row">
        <button id="saveNode" class="primary">Сохранить</button>
        <button id="ping">Проверить /healthz</button>
        <span id="pingRes" class="mono"></span>
      </div>
      <div class="kvs small" style="margin-top:8px">
        <div><span>height</span><span id="headHeight" class="mono">-</span></div>
        <div><span>finalized</span><span id="headFinal" class="mono">-</span></div>
        <div><span>hash</span><span id="headHash" class="mono">-</span></div>
      </div>
    </section>

    <!-- Ключи -->
    <section class="card">
      <h3>Ключи (Ed25519, локально)</h3>
      <div class="row">
        <button id="gen" class="primary">Сгенерировать</button>
        <button id="wipe">Удалить из браузера</button>
      </div>
      <label>RID (base58)</label>
      <div id="rid" class="mono small"></div>
      <label>Публичный ключ (base58)</label>
      <div id="pk58" class="mono small"></div>
      <details style="margin-top:8px"><summary class="muted">Экспорт/импорт</summary>
        <label>Приватный ключ (hex)</label>
        <textarea id="skHex" rows="3" class="mono" placeholder="hex..."></textarea>
        <div class="row"><button id="importSk">Импорт</button><button id="exportSk">Экспорт</button><span id="impRes" class="mono"></span></div>
      </details>
    </section>

    <!-- Состояние -->
    <section class="card">
      <h3>Состояние аккаунта</h3>
      <div class="row"><button id="refreshState">Обновить</button><span id="stateRes" class="mono"></span></div>
      <div class="kvs">
        <div><span>Баланс (μLGN)</span><span id="balance" class="mono">0</span></div>
        <div><span>Nonce</span><span id="nonce" class="mono">0</span></div>
      </div>
    </section>

    <!-- Перевод -->
    <section class="card">
      <div class="tabs"><button id="tabSend" class="active">Перевод</button><button id="tabBatch">Батч</button></div>

      <div id="panelSend">
        <label>Получатель (RID)</label><input id="toRid" placeholder="RID получателя"/>
        <label>Сумма (μLGN)</label><input id="amount" type="number" value="1"/>
        <div class="row"><button id="send" class="ok">Отправить</button><span id="sendRes" class="mono small"></span></div>
      </div>

      <div id="panelBatch" style="display:none">
        <label>Список получателей (по одному RID в строке)</label>
        <textarea id="batchList" rows="6" placeholder="RID1&#10;RID2&#10;..."></textarea>
        <label>Сумма на каждого (μLGN)</label><input id="batchAmount" type="number" value="1"/>
        <label>Размер батча (tx за один запрос)</label><input id="batchSize" type="number" value="50"/>
        <div class="row"><button id="sendBatch" class="ok">Отправить батч</button><span id="batchRes" class="mono small"></span></div>
      </div>
    </section>

    <!-- История / Недавние -->
    <section class="card">
      <h3>История</h3>
      <div class="row"><button id="loadTxs">Загрузить</button><button id="nextTxs">Дальше</button><span id="histRes" class="mono small"></span></div>
      <table id="hist"><thead><tr><th>H</th><th>Tx</th><th>Dir</th><th class="right">Amount</th><th>Counterparty</th></tr></thead><tbody></tbody></table>
    </section>

    <section class="card">
      <h3>Недавние</h3>
      <div class="row"><button id="recentBlocks">Блоки</button><button id="recentTxs">Tx</button><span id="recentRes" class="mono small"></span></div>
      <table id="recent"><thead><tr><th>Тип</th><th>Данные</th></tr></thead><tbody></tbody></table>
    </section>

    <!-- Мост (для операторов/интегратора) -->
    <section class="card">
      <h3>rToken мост (оператор)</h3>
      <label>X-Bridge-Key (или Bearer JWT)</label><input id="bridgeKey" placeholder="введите ключ или JWT (опц.)"/>
      <label>RID</label><input id="bridgeRid" placeholder="RID для зачисления/списания"/>
      <div class="row">
        <div style="flex:1">
          <label>Deposit (μrLGN)</label><input id="depAmount" type="number" value="1000"/>
          <label>ext_txid</label><input id="depExt" placeholder="например, txid внешней сети"/>
          <button id="deposit" class="primary">Deposit</button>
        </div>
        <div style="flex:1">
          <label>Redeem (μrLGN)</label><input id="redAmount" type="number" value="500"/>
          <label>request_id</label><input id="redReq" placeholder="уникальный ID запроса"/>
          <button id="redeem" class="primary">Redeem</button>
        </div>
      </div>
      <div class="small mono" id="bridgeRes"></div>
    </section>

    <!-- Админ-токен -->
    <section class="card">
      <h3>Админ (JWT)</h3>
      <label>X-Admin-Key</label><input id="adminKey" placeholder="только для операторов"/>
      <div class="row"><label class="muted">TTL (сек)</label><input id="adminTtl" type="number" value="600" style="width:120px"/>
        <button id="mintAdminToken">Получить токен</button><span id="adminRes" class="mono small"></span></div>
    </section>

  </main>

  <!-- noble-ed25519 + bs58 CDN -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/@noble/ed25519@1.7.3/+esm"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm"></script>
  <script type="module" src="./wallet.js"></script>
</body>
</html>

```


## FILE: www/wallet/wallet.js  (size=10848b)
```text
import * as ed from "https://cdn.jsdelivr.net/npm/@noble/ed25519@1.7.3/+esm";
import bs58 from "https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm";

/* =============== helpers =============== */
const $ = (id)=>document.getElementById(id);
const enc = new TextEncoder();

const st = {
  node: localStorage.getItem("lrb_node") || "http://45.159.248.232:8080",
  skHex: localStorage.getItem("lrb_sk") || "",
  pkHex: localStorage.getItem("lrb_pk") || "",
  cursor_h: null, cursor_seq: null
};

function ridFromPkHex(pkHex){ return bs58.encode(Buffer.from(pkHex,"hex")); }
function toB64(u8){ return btoa(String.fromCharCode(...u8)); }

function canonicalBytes(from, to, amount, nonce, pkHex) {
  const pk = Buffer.from(pkHex, "hex");
  const a = enc.encode(from), b = enc.encode(to),
        c = enc.encode(String(amount)), d = enc.encode(String(nonce));
  const out = new Uint8Array(a.length+b.length+c.length+d.length+pk.length);
  out.set(a,0); out.set(b,a.length); out.set(c,a.length+b.length);
  out.set(d,a.length+b.length+c.length); out.set(pk,a.length+b.length+c.length+d.length);
  return out;
}

async function getJSON(url, opts={}) {
  const r = await fetch(url, opts);
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return await r.json();
}
async function postJSON(url, body, headers={}) {
  const r = await fetch(url, {method:"POST",headers:{'content-type':'application/json',...headers},body:JSON.stringify(body)});
  const t = await r.text();
  try { return { ok:r.ok, status:r.status, body: JSON.parse(t||"{}") }; }
  catch { return { ok:r.ok, status:r.status, body: t }; }
}

/* =============== network / head =============== */
$("nodeUrl").value = st.node;
$("saveNode").onclick = () => { st.node = $("nodeUrl").value.trim(); localStorage.setItem("lrb_node", st.node); alert("Node URL сохранён"); };
$("ping").onclick = async ()=>{
  try {
    const h = await getJSON(`${st.node}/healthz`); $("pingRes").textContent = h.ok?"OK":"ERR";
    const head = await getJSON(`${st.node}/head`);
    $("headHeight").textContent = head.height ?? "-";
    $("headFinal").textContent  = head.finalized ?? "-";
    $("headHash").textContent   = (head.hash||"").slice(0,16)+"…";
  } catch(e){ $("pingRes").textContent = `ERR: ${e.message}`; }
};

/* =============== keys =============== */
function renderKeys(){
  const pkHex = st.pkHex;
  $("pk58").textContent = pkHex? bs58.encode(Buffer.from(pkHex,"hex")) : "";
  $("rid").textContent  = pkHex? ridFromPkHex(pkHex) : "";
  $("skHex").value = st.skHex || "";
}
$("gen").onclick = async ()=>{
  const sk = ed.utils.randomPrivateKey(); const pk = await ed.getPublicKey(sk);
  st.skHex = Buffer.from(sk).toString("hex"); st.pkHex = Buffer.from(pk).toString("hex");
  localStorage.setItem("lrb_sk", st.skHex); localStorage.setItem("lrb_pk", st.pkHex); renderKeys();
};
$("wipe").onclick = ()=>{ localStorage.removeItem("lrb_sk"); localStorage.removeItem("lrb_pk"); st.skHex=""; st.pkHex=""; renderKeys(); };
$("importSk").onclick = async ()=>{
  try{
    const val = $("skHex").value.trim(); if(!val) throw new Error("пусто");
    const sk = Buffer.from(val,"hex"); const pk = await ed.getPublicKey(sk);
    st.skHex = val; st.pkHex = Buffer.from(pk).toString("hex");
    localStorage.setItem("lrb_sk", st.skHex); localStorage.setItem("lrb_pk", st.pkHex); renderKeys();
    $("impRes").textContent = "OK";
  }catch(e){ $("impRes").textContent = "ERR"; }
};
$("exportSk").onclick = ()=>{ $("skHex").value = st.skHex || ""; };

renderKeys();

/* =============== account state =============== */
$("refreshState").onclick = async ()=>{
  $("stateRes").textContent = "";
  if(!st.pkHex) return $("stateRes").textContent = "Нет ключа";
  try{
    const rid = $("rid").textContent;
    const s = await getJSON(`${st.node}/account/${rid}/state`);
    $("balance").textContent = s.balance ?? 0;
    $("nonce").textContent   = s.nonce ?? 0;
    $("stateRes").textContent = "OK";
  }catch(e){ $("stateRes").textContent = `ERR: ${e.message}`; }
};

/* =============== send / batch =============== */
function nextNonce(){ return (parseInt($("nonce").textContent||"0",10) || 0) + 1; }

$("tabSend").onclick = ()=>{ $("panelSend").style.display="block"; $("panelBatch").style.display="none"; $("tabSend").classList.add("active"); $("tabBatch").classList.remove("active"); };
$("tabBatch").onclick= ()=>{ $("panelSend").style.display="none"; $("panelBatch").style.display="block"; $("tabBatch").classList.add("active"); $("tabSend").classList.remove("active"); };

$("send").onclick = async ()=>{
  try{
    if(!st.skHex||!st.pkHex) throw new Error("нет ключей");
    const from = $("rid").textContent.trim(), to=$("toRid").value.trim();
    const amount = parseInt($("amount").value||"0",10); if(!to||!amount) throw new Error("проверь поля");
    const nonce = nextNonce();
    const canon = canonicalBytes(from,to,amount,nonce,st.pkHex);
    const sig = await ed.sign(canon, st.skHex);
    const item = { from,to,amount,nonce, public_key_b58: bs58.encode(Buffer.from(st.pkHex,"hex")), signature_b64: toB64(sig) };
    const r = await postJSON(`${st.node}/submit_tx_batch`, [item]);
    $("sendRes").textContent = r.ok? `OK accepted=${r.body.accepted||0}` : `ERR ${r.status}`;
    // обновим nonce
    await $("refreshState").onclick();
  }catch(e){ $("sendRes").textContent = `ERR: ${e.message}`; }
};

$("sendBatch").onclick = async ()=>{
  try{
    if(!st.skHex||!st.pkHex) throw new Error("нет ключей");
    const from = $("rid").textContent.trim();
    const list = $("batchList").value.split("\n").map(s=>s.trim()).filter(Boolean);
    const amount = parseInt($("batchAmount").value||"0",10);
    const batchSize = parseInt($("batchSize").value||"50",10);
    if(list.length===0 || !amount) throw new Error("укажи получателей и сумму");
    let nonce = nextNonce(), accepted=0, sent=0;
    for(let i=0;i<list.length;i+=batchSize){
      const chunk = list.slice(i,i+batchSize);
      const req = [];
      for(const to of chunk){
        const canon = canonicalBytes(from,to,amount,nonce,st.pkHex);
        const sig   = await ed.sign(canon, st.skHex);
        req.push({ from,to,amount,nonce, public_key_b58: bs58.encode(Buffer.from(st.pkHex,"hex")), signature_b64: toB64(sig) });
        nonce++;
      }
      const r = await postJSON(`${st.node}/submit_tx_batch`, req);
      sent += req.length; if(r.ok) accepted += (r.body.accepted||0);
      $("batchRes").textContent = `sent=${sent} accepted=${accepted}`;
    }
    await $("refreshState").onclick();
  }catch(e){ $("batchRes").textContent = `ERR: ${e.message}`; }
};

/* =============== history / recent =============== */
async function loadAccountTxs(next=false){
  try{
    const rid = $("rid").textContent.trim(), params=[];
    params.push(`limit=20`);
    if(next && st.cursor_h!=null && st.cursor_seq!=null){
      params.push(`cursor_h=${st.cursor_h}`); params.push(`cursor_seq=${st.cursor_seq}`);
    }
    const url = `${st.node}/account/${rid}/txs?`+params.join("&");
    const r = await getJSON(url);
    const tbody = $("hist").querySelector("tbody");
    if(!next) tbody.innerHTML="";
    for(const it of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="mono small">${it.height??""}</td>
                      <td class="mono small">${(it.tx_id||"").slice(0,12)}…</td>
                      <td>${it.dir==-1?"→":"←"}</td>
                      <td class="right mono">${it.amount??0}</td>
                      <td class="mono small">${(it.counterparty||"").slice(0,10)}…</td>`;
      tbody.appendChild(tr);
    }
    st.cursor_h = r.next_cursor_h ?? null;
    st.cursor_seq = r.next_cursor_seq ?? null;
    $("histRes").textContent = r.items?.length ? "OK" : "—";
  }catch(e){ $("histRes").textContent = `ERR: ${e.message}`; }
}
$("loadTxs").onclick = ()=>loadAccountTxs(false);
$("nextTxs").onclick = ()=>loadAccountTxs(true);

$("recentBlocks").onclick = async ()=>{
  try{
    const r = await getJSON(`${st.node}/recent/blocks?limit=10`);
    const tbody = $("recent").querySelector("tbody"); tbody.innerHTML="";
    for(const b of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="pill">Block</td><td class="mono small">h=${b.height} tx=${(b.txs||[]).length} hash=${(b.block_hash||"").slice(0,14)}…</td>`;
      tbody.appendChild(tr);
    }
    $("recentRes").textContent="OK";
  }catch(e){ $("recentRes").textContent = `ERR: ${e.message}`; }
};
$("recentTxs").onclick = async ()=>{
  try{
    const r = await getJSON(`${st.node}/recent/txs?limit=20`);
    const tbody = $("recent").querySelector("tbody"); tbody.innerHTML="";
    for(const t of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="pill">Tx</td><td class="mono small">h=${t.height} tx=${(t.tx_id||"").slice(0,12)}… ${t.from?.slice(0,8)}→${t.to?.slice(0,8)} a=${t.amount}</td>`;
      tbody.appendChild(tr);
    }
    $("recentRes").textContent="OK";
  }catch(e){ $("recentRes").textContent = `ERR: ${e.message}`; }
};

/* =============== bridge (operator) =============== */
function authHeader(val){
  const s = (val||"").trim(); if(!s) return {};
  // Если строка похожа на JWT — отправим как Bearer, иначе X-Bridge-Key
  return s.split(".").length===3 ? {Authorization:`Bearer ${s}`} : {"X-Bridge-Key": s};
}
$("deposit").onclick = async ()=>{
  const key = $("bridgeKey").value, rid = $("bridgeRid").value.trim();
  const amount = parseInt($("depAmount").value||"0",10), ext = $("depExt").value.trim();
  const r = await postJSON(`${st.node}/bridge/deposit`, {rid,amount,ext_txid:ext}, authHeader(key));
  $("bridgeRes").textContent = r.ok ? `deposit OK: r_balance=${r.body.r_balance}` : `ERR ${r.status}`;
};
$("redeem").onclick = async ()=>{
  const key = $("bridgeKey").value, rid = $("bridgeRid").value.trim();
  const amount = parseInt($("redAmount").value||"0",10), req = $("redReq").value.trim();
  const r = await postJSON(`${st.node}/bridge/redeem`, {rid,amount,request_id:req}, authHeader(key));
  $("bridgeRes").textContent = r.ok ? `redeem OK: ticket=${r.body.redeem_ticket.slice(0,18)}…` : `ERR ${r.status}`;
};

/* =============== admin JWT =============== */
$("mintAdminToken").onclick = async ()=>{
  const key = $("adminKey").value.trim(), ttl = parseInt($("adminTtl").value||"600",10);
  const r = await fetch(`${st.node}/admin/token?ttl=${ttl}`, {headers: {"X-Admin-Key": key}});
  const body = await r.json().catch(()=>({}));
  $("adminRes").textContent = r.ok ? `OK token=${(body.token||"").slice(0,16)}…` : `ERR ${r.status}`;
};

/* =============== init =============== */
(async()=>{ await $("ping").onclick(); if(st.pkHex) await $("refreshState").onclick(); })();

```

```

## FILE: /root/logos_lrb/docs/snapshots/LRB_FULL_LIVE_20250905_1218.txt  (size=496424b)
```
# FULL LIVE SNAPSHOT — 2025-09-05T11:18:36Z
# sources:
#  - /root/logos_lrb
#  - /opt/logos/www/wallet
#  - /etc/systemd/system/logos-node@.service
#  - /etc/systemd/system/logos-healthcheck.service
#  - /etc/systemd/system/logos-healthcheck.timer
#  - /etc/nginx/sites-available/logos-api-lb.conf
#  - /usr/local/bin/logos_healthcheck.sh
# size limit per file: 800000 bytes



## FILE: /root/logos_lrb/.gitignore  (size=263b)
```
# Rust
target/
**/*.rs.bk

# Python
__pycache__/
*.pyc
.venv/
venv/

# Node/web (если появится сборка)
dist/
build/

# Local envs / secrets / data
.env
**/*.env
/etc/logos/
/var/lib/logos/
*.db
*.sqlite
*.sled
snapshots/
docs/LRB_SNAPSHOT_*.txt

```


## FILE: /root/logos_lrb/AUDIT_REPORT.md  (size=4963b)
```
# LOGOS LRB — Аудит модулей
_Tue Sep  2 03:51:50 PM UTC 2025_ UTC

## Files in modules/
### `modules/beacon_emitter.rs` (Rust)
- lines: 194 | sha256: `03cd9a74af6e7b586104afe804a1e0224f5c1387ce6234c2bf95306a0aa6b89a`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/env_impact_tracker.py` (Python)
- lines: 132 | sha256: `b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/external_phase_broadcaster.rs` (Rust)
- lines: 203 | sha256: `223e4b0a408be9ace9cf8e1f68b0e2a576c9cfa46a9115f660cc70f31346e2bd`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/external_phase_link.rs` (Rust)
- lines: 179 | sha256: `12a75800714e3d6d6c590614bde1f5c975b1f87c9ac0b2e85642f56a5cf1aa04`
- red-flags: unsafe=1, unwrap=5, expect=0, panic=0, dbg/println=0

### `modules/genesis_fragment_seeds.rs` (Rust)
- lines: 184 | sha256: `5e419ca4d8b184e474d36bddd218ed0dbd9ac158e82d7c9532fd8d50e961145e`
- red-flags: unsafe=0, unwrap=5, expect=1, panic=0, dbg/println=0

### `modules/go_to_market.yaml`
- lines: 118 | sha256: `e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f`

### `modules/heartbeat_monitor.rs` (Rust)
- lines: 208 | sha256: `a216c54e63bddf080ffbaf6f766b31aabbdd73ef933bfdcf573c9b43460d4f34`
- red-flags: unsafe=0, unwrap=7, expect=1, panic=0, dbg/println=0
- TODO/FIXME:
    143:        true // TODO: Реализовать

### `modules/legacy_migrator.rs` (Rust)
- lines: 191 | sha256: `41a10672b9a9712134cafb319bfac083563746b3b3da78d4f94a9d02e9e0a7c0`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/maintenance_strategy.yaml`
- lines: 85 | sha256: `a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9`

### `modules/resonance_analytics_frontend.tsx`
- lines: 130 | sha256: `f82ff2dbb08cb3c0aa72176cc7aa5b867ff8e747eec8c71aa0be400371772937`

### `modules/resonance_emergency_plan.yaml`
- lines: 91 | sha256: `ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd`

### `modules/resonance_meshmap.yaml`
- lines: 89 | sha256: `8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6`

### `modules/resonance_tutor.py` (Python)
- lines: 135 | sha256: `42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/ritual_engine.rs` (Rust)
- lines: 211 | sha256: `2342009f23dc74f16b5eda9c52bd9c2836a4ca881b32fe4a83e3ac2f10175f2c`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/symbolic_parser.py` (Python)
- lines: 110 | sha256: `99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/uplink_controller.rs` (Rust)
- lines: 208 | sha256: `03cb0431dc4237567534d6efb6728a23c7e0dc225d197435d37a897a2625a47b`
- red-flags: unsafe=1, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/uplink_router.rs` (Rust)
- lines: 186 | sha256: `ec121080b9c3c05f6af17114e8630ccc14a2c313d5321244130f97cdf08cabe0`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=0


## Files in core/
### `core/beta_rollout.yaml`
- lines: 94 | sha256: `b6ac3c0b19a730e9bcd41ccf24fce349dbf62013a1f45bc9d42bf74b13f5d76b`

### `core/offline_resonance.py` (Python)
- lines: 131 | sha256: `c4ba94d1e96a70963929aaf5a965f4ac03eaa091a3c3d7426e0f43036f1f9808`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/onboarding_sim.py` (Python)
- lines: 125 | sha256: `6aa4c1aef4f763d4a3f042a8ffae36ea9b59f3104067a56e0c47944986a4f178`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    90:        # TODO: Интеграция с rcp_engine.rs

### `core/onboarding_ui.py` (Python)
- lines: 137 | sha256: `8c17317ed7aa9339b495e725f58a8f88cd7e6cb792f0b6cd820ce5ad143e8149`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    114:        # TODO: Интеграция с rcp_engine.rs для проверки резонанса

### `core/resonance_analyzer.py` (Python)
- lines: 83 | sha256: `6c2245061e9b99bd9f0fe865fcb4815e20a4c237c7e16d0a8267756cfacea094`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/rid_builder.py` (Python)
- lines: 133 | sha256: `9fac8b299c40f69320f21ce6fc156f913241a284f137ed4fcb2b0f1a96556de0`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    98:        # TODO: Интеграция с rcp_engine.rs

### `core/ritual_quest.py` (Python)
- lines: 186 | sha256: `0fcba7423a2920b0f14b333f7641110b6c1412c572529ec3b263a629a21e4d7a`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    150:        # TODO: Интеграция с rcp_engine.rs

### `core/rLGN_converter.py` (Python)
- lines: 136 | sha256: `7a0dba1500ffac08f51a5f16de2ba226da3efd8a063f71fd4bb380f16aba0d24`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0


## Quick checks
```
Python 3.12.3
```


```


## FILE: /root/logos_lrb/Cargo.lock  (size=62325b)
```
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "addr2line"
version = "0.24.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dfbe277e56a376000877090da837660b4427aad530e3028d44e0bffe4f89a1c1"
dependencies = [
 "gimli",
]

[[package]]
name = "adler2"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "320119579fcad9c21884f5c4861d16174d0e06250625266f50fe6898340abefa"

[[package]]
name = "aead"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d122413f284cf2d62fb1b7db97e02edb8cda96d769b16e443a4f6195e35662b0"
dependencies = [
 "crypto-common",
 "generic-array",
]

[[package]]
name = "aho-corasick"
version = "1.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e60d3430d3a69478ad0993f19238d2df97c507009a52b3c10addcd7f6bcb916"
dependencies = [
 "memchr",
]

[[package]]
name = "android-tzdata"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e999941b234f3131b00bc13c22d06e8c5ff726d1b6318ac7eb276997bbb4fef0"

[[package]]
name = "android_system_properties"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "819e7219dbd41043ac279b19830f2efc897156490d7fd6ea916720117ee66311"
dependencies = [
 "libc",
]

[[package]]
name = "anyhow"
version = "1.0.99"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0674a1ddeecb70197781e945de4b3b8ffb61fa939a5597bcf48503737663100"

[[package]]
name = "arrayref"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76a2e8124351fda1ef8aaaa3bbd7ebbcb486bbcd4225aca0aa0d84bb2db8fecb"

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "async-trait"
version = "0.1.89"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9035ad2d096bed7955a320ee7e2230574d28fd3c3a0f186cbea1ff3c7eed5dbb"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "atomic-waker"
version = "1.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1505bd5d3d116872e7271a6d4e16d81d0c8570876c8de68093a09ac269d8aac0"

[[package]]
name = "autocfg"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08606f8c3cbf4ce6ec8e28fb0014a2c086708fe954eaa885384a6165172e7e8"

[[package]]
name = "axum"
version = "0.7.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edca88bc138befd0323b20752846e6587272d3b03b0343c8ea28a6f819e6e71f"
dependencies = [
 "async-trait",
 "axum-core",
 "axum-macros",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-util",
 "itoa",
 "matchit",
 "memchr",
 "mime",
 "percent-encoding",
 "pin-project-lite",
 "rustversion",
 "serde",
 "serde_json",
 "serde_path_to_error",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tower 0.5.2",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "axum-core"
version = "0.4.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09f2bd6146b97ae3359fa0cc6d6b376d9539582c7b4220f041a33ec24c226199"
dependencies = [
 "async-trait",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "http-body-util",
 "mime",
 "pin-project-lite",
 "rustversion",
 "sync_wrapper",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "axum-macros"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "57d123550fa8d071b7255cb0cc04dc302baa6c8c4a79f55701552684d8399bce"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "backtrace"
version = "0.3.75"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6806a6321ec58106fea15becdad98371e28d92ccbc7c8f1b3b6dd724fe8f1002"
dependencies = [
 "addr2line",
 "cfg-if",
 "libc",
 "miniz_oxide",
 "object",
 "rustc-demangle",
 "windows-targets",
]

[[package]]
name = "base64"
version = "0.22.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "72b3254f16251a8381aa12e40e3c4d2f0199f8c6508fbecb9d91f575e0fbb8c6"

[[package]]
name = "base64ct"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55248b47b0caf0546f7988906588779981c43bb1bc9d0c44087278f80cdb44ba"

[[package]]
name = "bitflags"
version = "1.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a"

[[package]]
name = "bitflags"
version = "2.9.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2261d10cca569e4643e526d8dc2e62e433cc8aba21ab764233731f8d369bf394"

[[package]]
name = "blake3"
version = "1.8.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3888aaa89e4b2a40fca9848e400f6a658a5a3978de7be858e209cafa8be9a4a0"
dependencies = [
 "arrayref",
 "arrayvec",
 "cc",
 "cfg-if",
 "constant_time_eq",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bs58"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bf88ba1141d185c399bee5288d850d63b8369520c1eafc32a0430b5b6c287bf4"
dependencies = [
 "tinyvec",
]

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "bytes"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71b6127be86fdcfddb610f7182ac57211d4b18a3e9c82eb2d17662f2227ad6a"

[[package]]
name = "cc"
version = "1.2.35"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "590f9024a68a8c40351881787f1934dc11afd69090f5edb6831464694d836ea3"
dependencies = [
 "find-msvc-tools",
 "shlex",
]

[[package]]
name = "cfg-if"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fd1289c04a9ea8cb22300a459a72a385d7c73d3259e2ed7dcb2af674838cfa9"

[[package]]
name = "cfg_aliases"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "613afe47fcd5fac7ccf1db93babcb082c5994d996f20b8b159f2ad1658eb5724"

[[package]]
name = "chacha20"
version = "0.9.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c3613f74bd2eac03dad61bd53dbe620703d4371614fe0bc3b9f04dd36fe4e818"
dependencies = [
 "cfg-if",
 "cipher",
 "cpufeatures",
]

[[package]]
name = "chacha20poly1305"
version = "0.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "10cd79432192d1c0f4e1a0fef9527696cc039165d729fb41b3f4f4f354c2dc35"
dependencies = [
 "aead",
 "chacha20",
 "cipher",
 "poly1305",
 "zeroize",
]

[[package]]
name = "chrono"
version = "0.4.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c469d952047f47f91b68d1cba3f10d63c11d73e4636f24f08daf0278abf01c4d"
dependencies = [
 "android-tzdata",
 "iana-time-zone",
 "num-traits",
 "windows-link",
]

[[package]]
name = "cipher"
version = "0.4.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773f3b9af64447d2ce9850330c473515014aa235e6a783b02db81ff39e4a3dad"
dependencies = [
 "crypto-common",
 "inout",
 "zeroize",
]

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "constant_time_eq"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c74b8349d32d297c9134b8c88677813a227df8f779daa29bfc29c183fe3dca6"

[[package]]
name = "core-foundation-sys"
version = "0.8.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "773648b94d0e5d620f64f280777445740e61fe701025087ec8b57f45c791888b"

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crc32fast"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9481c1c90cbf2ac953f07c8d4a58aa3945c425b7185c9154d67a65e4230da511"
dependencies = [
 "cfg-if",
]

[[package]]
name = "crossbeam-deque"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9dd111b7b7f7d55b72c0a6ae361660ee5853c9af73f70c3c2ef6858b950e2e51"
dependencies = [
 "crossbeam-epoch",
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-epoch"
version = "0.9.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b82ac4a3c2ca9c3460964f020e1402edd5753411d7737aa39c3714ad1b5420e"
dependencies = [
 "crossbeam-utils",
]

[[package]]
name = "crossbeam-utils"
version = "0.8.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d0a5c400df2834b80a4c3327b3aad3a4c4cd4de0629063962b03235697506a28"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "rand_core 0.6.4",
 "typenum",
]

[[package]]
name = "curve25519-dalek"
version = "4.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fb8b7c4503de7d6ae7b42ab72a5a59857b4c937ec27a3d4539dba95b5ab2be"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "curve25519-dalek-derive",
 "digest",
 "fiat-crypto",
 "rustc_version",
 "subtle",
 "zeroize",
]

[[package]]
name = "curve25519-dalek-derive"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "dashmap"
version = "5.5.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "978747c1d849a7d2ee5e8adc0159961c48fb7e5db2f06af6723b80123bb53856"
dependencies = [
 "cfg-if",
 "hashbrown 0.14.5",
 "lock_api",
 "once_cell",
 "parking_lot_core 0.9.11",
]

[[package]]
name = "der"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
dependencies = [
 "const-oid",
 "zeroize",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "displaydoc"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97369cbbc041bc366949bc74d34658d6cda5621039731c6310521892a3a20ae0"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "ed25519"
version = "2.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "115531babc129696a58c64a4fef0a8bf9e9698629fb97e9e40767d235cfbcd53"
dependencies = [
 "pkcs8",
 "signature",
]

[[package]]
name = "ed25519-dalek"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70e796c081cee67dc755e1a36a0a172b897fab85fc3f6bc48307991f64e4eca9"
dependencies = [
 "curve25519-dalek",
 "ed25519",
 "rand_core 0.6.4",
 "serde",
 "sha2",
 "subtle",
 "zeroize",
]

[[package]]
name = "either"
version = "1.15.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "48c757948c5ede0e46177b7add2e67155f70e33c07fea8284df6576da70b3719"

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "fiat-crypto"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28dea519a9695b9977216879a3ebfddf92f1c08c05d984f8996aecd6ecdc811d"

[[package]]
name = "find-msvc-tools"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e178e4fba8a2726903f6ba98a6d221e76f9c12c650d5dc0e6afdc50677b49650"

[[package]]
name = "fnv"
version = "1.0.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3f9eec918d3f24069decb9af1554cad7c880e2da24a9afd88aca000531ab82c1"

[[package]]
name = "form_urlencoded"
version = "1.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cb4cb245038516f5f85277875cdaa4f7d2c9a0fa0468de06ed190163b1581fcf"
dependencies = [
 "percent-encoding",
]

[[package]]
name = "fs2"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9564fc758e15025b46aa6643b1b77d047d1a56a1aea6e01002ac0c7026876213"
dependencies = [
 "libc",
 "winapi",
]

[[package]]
name = "futures-channel"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2dff15bf788c671c1934e366d07e30c1814a8ef514e1af724a602e8a2fbe1b10"
dependencies = [
 "futures-core",
]

[[package]]
name = "futures-core"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f29059c0c2090612e8d742178b0580d2dc940c837851ad723096f87af6663e"

[[package]]
name = "futures-sink"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e575fab7d1e0dcb8d0c7bcf9a63ee213816ab51902e6d244a95819acacf1d4f7"

[[package]]
name = "futures-task"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f90f7dce0722e95104fcb095585910c0977252f286e354b5e3bd38902cd99988"

[[package]]
name = "futures-util"
version = "0.3.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9fa08315bb612088cc391249efdc3bc77536f16c91f6cf495e6fbe85b20a4a81"
dependencies = [
 "futures-core",
 "futures-task",
 "pin-project-lite",
 "pin-utils",
]

[[package]]
name = "fxhash"
version = "0.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c31b6d751ae2c7f11320402d34e41349dd1016f8d5d45e48c4312bc8625af50c"
dependencies = [
 "byteorder",
]

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "wasm-bindgen",
]

[[package]]
name = "getrandom"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "26145e563e54f2cadc477553f1ec5ee650b00862f0a58bcd12cbdc5f0ea2d2f4"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "r-efi",
 "wasi 0.14.3+wasi-0.2.4",
 "wasm-bindgen",
]

[[package]]
name = "gimli"
version = "0.31.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e28edb80900c19c28f1072f2e8aeca7fa06b23cd4169cefe1af5aa3260783f"

[[package]]
name = "h2"
version = "0.4.12"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f3c0b69cfcb4e1b9f1bf2f53f95f766e4661169728ec61cd3fe5a0166f2d1386"
dependencies = [
 "atomic-waker",
 "bytes",
 "fnv",
 "futures-core",
 "futures-sink",
 "http",
 "indexmap",
 "slab",
 "tokio",
 "tokio-util",
 "tracing",
]

[[package]]
name = "hashbrown"
version = "0.14.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e5274423e17b7c9fc20b6e7e208532f9b19825d82dfd615708b70edd83df41f1"

[[package]]
name = "hashbrown"
version = "0.15.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9229cfe53dfd69f0609a49f65461bd93001ea1ef889cd5529dd176593f5338a1"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "http"
version = "1.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f4a85d31aea989eead29a3aaf9e1115a180df8282431156e533de47660892565"
dependencies = [
 "bytes",
 "fnv",
 "itoa",
]

[[package]]
name = "http-body"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1efedce1fb8e6913f23e0c92de8e62cd5b772a67e7b3946df930a62566c93184"
dependencies = [
 "bytes",
 "http",
]

[[package]]
name = "http-body-util"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b021d93e26becf5dc7e1b75b1bed1fd93124b374ceb73f43d4d4eafec896a64a"
dependencies = [
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "pin-project-lite",
]

[[package]]
name = "httparse"
version = "1.10.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6dbf3de79e51f3d586ab4cb9d5c3e2c14aa28ed23d180cf89b4df0454a69cc87"

[[package]]
name = "httpdate"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "df3b46402a9d5adb4c86a0cf463f42e19994e3ee891101b1841f30a545cb49a9"

[[package]]
name = "hyper"
version = "1.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "eb3aa54a13a0dfe7fbe3a59e0c76093041720fdc77b110cc0fc260fafb4dc51e"
dependencies = [
 "atomic-waker",
 "bytes",
 "futures-channel",
 "futures-core",
 "h2",
 "http",
 "http-body",
 "httparse",
 "httpdate",
 "itoa",
 "pin-project-lite",
 "pin-utils",
 "smallvec",
 "tokio",
 "want",
]

[[package]]
name = "hyper-rustls"
version = "0.27.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e3c93eb611681b207e1fe55d5a71ecf91572ec8a6705cdb6857f7d8d5242cf58"
dependencies = [
 "http",
 "hyper",
 "hyper-util",
 "rustls",
 "rustls-pki-types",
 "tokio",
 "tokio-rustls",
 "tower-service",
 "webpki-roots",
]

[[package]]
name = "hyper-util"
version = "0.1.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8d9b05277c7e8da2c93a568989bb6207bef0112e8d17df7a6eda4a3cf143bc5e"
dependencies = [
 "base64",
 "bytes",
 "futures-channel",
 "futures-core",
 "futures-util",
 "http",
 "http-body",
 "hyper",
 "ipnet",
 "libc",
 "percent-encoding",
 "pin-project-lite",
 "socket2",
 "tokio",
 "tower-service",
 "tracing",
]

[[package]]
name = "iana-time-zone"
version = "0.1.63"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b0c919e5debc312ad217002b8048a17b7d83f80703865bbfcfebb0458b0b27d8"
dependencies = [
 "android_system_properties",
 "core-foundation-sys",
 "iana-time-zone-haiku",
 "js-sys",
 "log",
 "wasm-bindgen",
 "windows-core",
]

[[package]]
name = "iana-time-zone-haiku"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f31827a206f56af32e590ba56d5d2d085f558508192593743f16b2306495269f"
dependencies = [
 "cc",
]

[[package]]
name = "icu_collections"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "200072f5d0e3614556f94a9930d5dc3e0662a652823904c3a75dc3b0af7fee47"
dependencies = [
 "displaydoc",
 "potential_utf",
 "yoke",
 "zerofrom",
 "zerovec",
]

[[package]]
name = "icu_locale_core"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0cde2700ccaed3872079a65fb1a78f6c0a36c91570f28755dda67bc8f7d9f00a"
dependencies = [
 "displaydoc",
 "litemap",
 "tinystr",
 "writeable",
 "zerovec",
]

[[package]]
name = "icu_normalizer"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "436880e8e18df4d7bbc06d58432329d6458cc84531f7ac5f024e93deadb37979"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_normalizer_data",
 "icu_properties",
 "icu_provider",
 "smallvec",
 "zerovec",
]

[[package]]
name = "icu_normalizer_data"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "00210d6893afc98edb752b664b8890f0ef174c8adbb8d0be9710fa66fbbf72d3"

[[package]]
name = "icu_properties"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "016c619c1eeb94efb86809b015c58f479963de65bdb6253345c1a1276f22e32b"
dependencies = [
 "displaydoc",
 "icu_collections",
 "icu_locale_core",
 "icu_properties_data",
 "icu_provider",
 "potential_utf",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "icu_properties_data"
version = "2.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "298459143998310acd25ffe6810ed544932242d3f07083eee1084d83a71bd632"

[[package]]
name = "icu_provider"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "03c80da27b5f4187909049ee2d72f276f0d9f99a42c306bd0131ecfe04d8e5af"
dependencies = [
 "displaydoc",
 "icu_locale_core",
 "stable_deref_trait",
 "tinystr",
 "writeable",
 "yoke",
 "zerofrom",
 "zerotrie",
 "zerovec",
]

[[package]]
name = "idna"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b0875f23caa03898994f6ddc501886a45c7d3d62d04d2d90788d47be1b1e4de"
dependencies = [
 "idna_adapter",
 "smallvec",
 "utf8_iter",
]

[[package]]
name = "idna_adapter"
version = "1.2.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3acae9609540aa318d1bc588455225fb2085b9ed0c4f6bd0d9d5bcd86f1a0344"
dependencies = [
 "icu_normalizer",
 "icu_properties",
]

[[package]]
name = "indexmap"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2481980430f9f78649238835720ddccc57e52df14ffce1c6f37391d61b563e9"
dependencies = [
 "equivalent",
 "hashbrown 0.15.5",
]

[[package]]
name = "inout"
version = "0.1.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "879f10e63c20629ecabbb64a8010319738c66a5cd0c29b02d63d272b03751d01"
dependencies = [
 "generic-array",
]

[[package]]
name = "instant"
version = "0.1.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e0242819d153cba4b4b05a5a8f2a7e9bbf97b6055b2a002b395c96b5ff3c0222"
dependencies = [
 "cfg-if",
]

[[package]]
name = "io-uring"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "046fa2d4d00aea763528b4950358d0ead425372445dc8ff86312b3c69ff7727b"
dependencies = [
 "bitflags 2.9.4",
 "cfg-if",
 "libc",
]

[[package]]
name = "ipnet"
version = "2.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "469fb0b9cefa57e3ef31275ee7cacb78f2fdca44e4765491884a2b119d4eb130"

[[package]]
name = "iri-string"
version = "0.7.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dbc5ebe9c3a1a7a5127f920a418f7585e9e758e911d0466ed004f393b0e380b2"
dependencies = [
 "memchr",
 "serde",
]

[[package]]
name = "itoa"
version = "1.0.15"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4a5f13b858c8d314ee3e8f639011f7ccefe71f97f96e50151fb991f267928e2c"

[[package]]
name = "js-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1cfaf33c695fc6e08064efbc1f72ec937429614f25eef83af942d0e227c3a28f"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "lazy_static"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bbd2bcb4c963f2ddae06a2efc7e9f3591312473c50c6685e1f298068316e66fe"

[[package]]
name = "libc"
version = "0.2.175"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a82ae493e598baaea5209805c49bbf2ea7de956d50d7da0da1164f9c6d28543"

[[package]]
name = "litemap"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "241eaef5fd12c88705a01fc1066c48c4b36e0dd4377dcdc7ec3942cea7a69956"

[[package]]
name = "lock_api"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "96936507f153605bddfcda068dd804796c84324ed2510809e5b2a624c81da765"
dependencies = [
 "autocfg",
 "scopeguard",
]

[[package]]
name = "log"
version = "0.4.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13dc2df351e3202783a1fe0d44375f7295ffb4049267b0f3018346dc122a1d94"

[[package]]
name = "logos_node"
version = "0.1.0"
dependencies = [
 "anyhow",
 "axum",
 "base64",
 "blake3",
 "bs58",
 "chrono",
 "dashmap",
 "ed25519-dalek",
 "hex",
 "http",
 "hyper",
 "ipnet",
 "lrb_core",
 "once_cell",
 "parking_lot 0.12.4",
 "prometheus",
 "rand_core 0.6.4",
 "reqwest",
 "serde",
 "serde_json",
 "sled",
 "thiserror 1.0.69",
 "tokio",
 "tower 0.4.13",
 "tower-http 0.5.2",
 "tracing",
 "tracing-subscriber",
]

[[package]]
name = "lrb_core"
version = "0.1.0"
dependencies = [
 "anyhow",
 "base64",
 "blake3",
 "bs58",
 "chacha20poly1305",
 "ed25519-dalek",
 "hex",
 "rand_core 0.6.4",
 "rayon",
 "reqwest",
 "serde",
 "serde_json",
 "sha2",
 "sled",
 "tokio",
 "uuid",
]

[[package]]
name = "lru-slab"
version = "0.1.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "112b39cec0b298b6c1999fee3e31427f74f676e4cb9879ed1a121b43661a4154"

[[package]]
name = "matchers"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d1525a2a28c7f4fa0fc98bb91ae755d1e2d1505079e05539e35bc876b5d65ae9"
dependencies = [
 "regex-automata",
]

[[package]]
name = "matchit"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0e7465ac9959cc2b1404e8e2367b43684a6d13790fe23056cc8c6c5a6b7bcb94"

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "mime"
version = "0.3.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6877bb514081ee2a7ff5ef9de3281f14a4dd4bceac4c09388074a6b5df8a139a"

[[package]]
name = "miniz_oxide"
version = "0.8.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fa76a2c86f704bdb222d66965fb3d63269ce38518b83cb0575fca855ebb6316"
dependencies = [
 "adler2",
]

[[package]]
name = "mio"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "78bed444cc8a2160f01cbcf811ef18cac863ad68ae8ca62092e8db51d51c761c"
dependencies = [
 "libc",
 "wasi 0.11.1+wasi-snapshot-preview1",
 "windows-sys 0.59.0",
]

[[package]]
name = "nu-ansi-term"
version = "0.50.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d4a28e057d01f97e61255210fcff094d74ed0466038633e95017f5beb68e4399"
dependencies = [
 "windows-sys 0.52.0",
]

[[package]]
name = "num-traits"
version = "0.2.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "071dfc062690e90b734c0b2273ce72ad0ffa95f0c74596bc250dcfd960262841"
dependencies = [
 "autocfg",
]

[[package]]
name = "object"
version = "0.36.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "62948e14d923ea95ea2c7c86c71013138b66525b86bdc08d2dcc262bdb497b87"
dependencies = [
 "memchr",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "opaque-debug"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c08d65885ee38876c4f86fa503fb49d7b507c2b62552df7c70b2fce627e06381"

[[package]]
name = "parking_lot"
version = "0.11.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7d17b78036a60663b797adeaee46f5c9dfebb86948d1255007a1d6be0271ff99"
dependencies = [
 "instant",
 "lock_api",
 "parking_lot_core 0.8.6",
]

[[package]]
name = "parking_lot"
version = "0.12.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70d58bf43669b5795d1576d0641cfb6fbb2057bf629506267a92807158584a13"
dependencies = [
 "lock_api",
 "parking_lot_core 0.9.11",
]

[[package]]
name = "parking_lot_core"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "60a2cfe6f0ad2bfc16aefa463b497d5c7a5ecd44a23efa72aa342d90177356dc"
dependencies = [
 "cfg-if",
 "instant",
 "libc",
 "redox_syscall 0.2.16",
 "smallvec",
 "winapi",
]

[[package]]
name = "parking_lot_core"
version = "0.9.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bc838d2a56b5b1a6c25f55575dfc605fabb63bb2365f6c2353ef9159aa69e4a5"
dependencies = [
 "cfg-if",
 "libc",
 "redox_syscall 0.5.17",
 "smallvec",
 "windows-targets",
]

[[package]]
name = "percent-encoding"
version = "2.3.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b4f627cb1b25917193a259e49bdad08f671f8d9708acfd5fe0a8c1455d87220"

[[package]]
name = "pin-project-lite"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3b3cff922bd51709b605d9ead9aa71031d81447142d828eb4a6eba76fe619f9b"

[[package]]
name = "pin-utils"
version = "0.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8b870d8c151b6f2fb93e84a13146138f05d02ed11c7e7c54f8826aaaf7c9f184"

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "poly1305"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8159bd90725d2df49889a078b54f4f79e87f1f8a8444194cdca81d38f5393abf"
dependencies = [
 "cpufeatures",
 "opaque-debug",
 "universal-hash",
]

[[package]]
name = "potential_utf"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "84df19adbe5b5a0782edcab45899906947ab039ccf4573713735ee7de1e6b08a"
dependencies = [
 "zerovec",
]

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "proc-macro2"
version = "1.0.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89ae43fd86e4158d6db51ad8e2b80f313af9cc74f5c0e03ccb87de09998732de"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "prometheus"
version = "0.13.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3d33c28a30771f7f96db69893f78b857f7450d7e0237e9c8fc6427a81bae7ed1"
dependencies = [
 "cfg-if",
 "fnv",
 "lazy_static",
 "memchr",
 "parking_lot 0.12.4",
 "protobuf",
 "thiserror 1.0.69",
]

[[package]]
name = "protobuf"
version = "2.28.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "106dd99e98437432fed6519dedecfade6a06a73bb7b2a1e019fdd2bee5778d94"

[[package]]
name = "quinn"
version = "0.11.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9e20a958963c291dc322d98411f541009df2ced7b5a4f2bd52337638cfccf20"
dependencies = [
 "bytes",
 "cfg_aliases",
 "pin-project-lite",
 "quinn-proto",
 "quinn-udp",
 "rustc-hash",
 "rustls",
 "socket2",
 "thiserror 2.0.16",
 "tokio",
 "tracing",
 "web-time",
]

[[package]]
name = "quinn-proto"
version = "0.11.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f1906b49b0c3bc04b5fe5d86a77925ae6524a19b816ae38ce1e426255f1d8a31"
dependencies = [
 "bytes",
 "getrandom 0.3.3",
 "lru-slab",
 "rand",
 "ring",
 "rustc-hash",
 "rustls",
 "rustls-pki-types",
 "slab",
 "thiserror 2.0.16",
 "tinyvec",
 "tracing",
 "web-time",
]

[[package]]
name = "quinn-udp"
version = "0.5.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "addec6a0dcad8a8d96a771f815f0eaf55f9d1805756410b39f5fa81332574cbd"
dependencies = [
 "cfg_aliases",
 "libc",
 "once_cell",
 "socket2",
 "tracing",
 "windows-sys 0.59.0",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "r-efi"
version = "5.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "69cdb34c158ceb288df11e18b4bd39de994f6657d83847bdffdbd7f346754b0f"

[[package]]
name = "rand"
version = "0.9.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6db2770f06117d490610c7488547d543617b21bfa07796d7a12f6f1bd53850d1"
dependencies = [
 "rand_chacha",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_chacha"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3022b5f1df60f26e1ffddd6c66e8aa15de382ae63b3a0c1bfc0e4d3e3f325cb"
dependencies = [
 "ppv-lite86",
 "rand_core 0.9.3",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom 0.2.16",
]

[[package]]
name = "rand_core"
version = "0.9.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "99d9a13982dcf210057a8a78572b2217b667c3beacbf3a0d8b454f6f82837d38"
dependencies = [
 "getrandom 0.3.3",
]

[[package]]
name = "rayon"
version = "1.11.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "368f01d005bf8fd9b1206fb6fa653e6c4a81ceb1466406b81792d87c5677a58f"
dependencies = [
 "either",
 "rayon-core",
]

[[package]]
name = "rayon-core"
version = "1.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22e18b0f0062d30d4230b2e85ff77fdfe4326feb054b9783a3460d8435c8ab91"
dependencies = [
 "crossbeam-deque",
 "crossbeam-utils",
]

[[package]]
name = "redox_syscall"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fb5a58c1855b4b6819d59012155603f0b22ad30cad752600aadfcb695265519a"
dependencies = [
 "bitflags 1.3.2",
]

[[package]]
name = "redox_syscall"
version = "0.5.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5407465600fb0548f1442edf71dd20683c6ed326200ace4b1ef0763521bb3b77"
dependencies = [
 "bitflags 2.9.4",
]

[[package]]
name = "regex-automata"
version = "0.4.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6b9458fa0bfeeac22b5ca447c63aaf45f28439a709ccd244698632f9aa6394d6"
dependencies = [
 "aho-corasick",
 "memchr",
 "regex-syntax",
]

[[package]]
name = "regex-syntax"
version = "0.8.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "caf4aa5b0f434c91fe5c7f1ecb6a5ece2130b02ad2a590589dda5146df959001"

[[package]]
name = "reqwest"
version = "0.12.23"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d429f34c8092b2d42c7c93cec323bb4adeb7c67698f70839adec842ec10c7ceb"
dependencies = [
 "base64",
 "bytes",
 "futures-core",
 "http",
 "http-body",
 "http-body-util",
 "hyper",
 "hyper-rustls",
 "hyper-util",
 "js-sys",
 "log",
 "percent-encoding",
 "pin-project-lite",
 "quinn",
 "rustls",
 "rustls-pki-types",
 "serde",
 "serde_json",
 "serde_urlencoded",
 "sync_wrapper",
 "tokio",
 "tokio-rustls",
 "tower 0.5.2",
 "tower-http 0.6.6",
 "tower-service",
 "url",
 "wasm-bindgen",
 "wasm-bindgen-futures",
 "web-sys",
 "webpki-roots",
]

[[package]]
name = "ring"
version = "0.17.14"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a4689e6c2294d81e88dc6261c768b63bc4fcdb852be6d1352498b114f61383b7"
dependencies = [
 "cc",
 "cfg-if",
 "getrandom 0.2.16",
 "libc",
 "untrusted",
 "windows-sys 0.52.0",
]

[[package]]
name = "rustc-demangle"
version = "0.1.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f7d92ca342cea22a06f2121d944b4fd82af56988c270852495420f961d4ace"

[[package]]
name = "rustc-hash"
version = "2.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "357703d41365b4b27c590e3ed91eabb1b663f07c4c084095e60cbed4362dff0d"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustls"
version = "0.23.31"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0ebcbd2f03de0fc1122ad9bb24b127a5a6cd51d72604a3f3c50ac459762b6cc"
dependencies = [
 "once_cell",
 "ring",
 "rustls-pki-types",
 "rustls-webpki",
 "subtle",
 "zeroize",
]

[[package]]
name = "rustls-pki-types"
version = "1.12.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "229a4a4c221013e7e1f1a043678c5cc39fe5171437c88fb47151a21e6f5b5c79"
dependencies = [
 "web-time",
 "zeroize",
]

[[package]]
name = "rustls-webpki"
version = "0.103.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a17884ae0c1b773f1ccd2bd4a8c72f16da897310a98b0e84bf349ad5ead92fc"
dependencies = [
 "ring",
 "rustls-pki-types",
 "untrusted",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "ryu"
version = "1.0.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28d3b2b1366ec20994f1fd18c3c594f05c5dd4bc44d8bb0c1c632c8d6829481f"

[[package]]
name = "scopeguard"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "94143f37725109f92c262ed2cf5e59bce7498c01bcc1502d7b9afe439a4e9f49"

[[package]]
name = "semver"
version = "1.0.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6fa9c48d24d85fb3de5ad847117517440f6beceb7798af16b4a87d616b8d0"

[[package]]
name = "serde"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f0e2c6ed6606019b4e29e69dbaba95b11854410e5347d525002456dbbb786b6"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.219"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b0276cf7f2c73365f7157c8123c21cd9a50fbbd844757af28ca1f5925fc2a00"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "serde_json"
version = "1.0.143"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d401abef1d108fbd9cbaebc3e46611f4b1021f714a0597a71f41ee463f5f4a5a"
dependencies = [
 "itoa",
 "memchr",
 "ryu",
 "serde",
]

[[package]]
name = "serde_path_to_error"
version = "0.1.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59fab13f937fa393d08645bf3a84bdfe86e296747b506ada67bb15f10f218b2a"
dependencies = [
 "itoa",
 "serde",
]

[[package]]
name = "serde_urlencoded"
version = "0.7.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d3491c14715ca2294c4d6a88f15e84739788c1d030eed8c110436aafdaa2f3fd"
dependencies = [
 "form_urlencoded",
 "itoa",
 "ryu",
 "serde",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sharded-slab"
version = "0.1.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f40ca3c46823713e0d4209592e8d6e826aa57e928f09752619fc696c499637f6"
dependencies = [
 "lazy_static",
]

[[package]]
name = "shlex"
version = "1.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0fda2ff0d084019ba4d7c6f371c95d8fd75ce3524c3cb8fb653a3023f6323e64"

[[package]]
name = "signal-hook-registry"
version = "1.4.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b2a4719bff48cee6b39d12c020eeb490953ad2443b7055bd0b21fca26bd8c28b"
dependencies = [
 "libc",
]

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "rand_core 0.6.4",
]

[[package]]
name = "slab"
version = "0.4.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7a2ae44ef20feb57a68b23d846850f861394c2e02dc425a50098ae8c90267589"

[[package]]
name = "sled"
version = "0.34.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f96b4737c2ce5987354855aed3797279def4ebf734436c6aa4552cf8e169935"
dependencies = [
 "crc32fast",
 "crossbeam-epoch",
 "crossbeam-utils",
 "fs2",
 "fxhash",
 "libc",
 "log",
 "parking_lot 0.11.2",
]

[[package]]
name = "smallvec"
version = "1.15.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "67b1b7a3b5fe4f1376887184045fcf45c69e92af734b7aaddc05fb777b6fbd03"

[[package]]
name = "socket2"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "233504af464074f9d066d7b5416c5f9b894a5862a6506e306f7b816cdd6f1807"
dependencies = [
 "libc",
 "windows-sys 0.59.0",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "stable_deref_trait"
version = "1.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a8f112729512f8e442d81f95a8a7ddf2b7c6b8a1a6f509a95864142b30cab2d3"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "2.0.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ede7c438028d4436d71104916910f5bb611972c5cfd7f89b8300a8186e6fada6"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "sync_wrapper"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bf256ce5efdfa370213c1dabab5935a12e49f2c58d15e9eac2870d3b4f27263"
dependencies = [
 "futures-core",
]

[[package]]
name = "synstructure"
version = "0.13.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "728a70f3dbaf5bab7f0c4b1ac8d7ae5ea60a4b5549c8a5914361c99147a709d2"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thiserror"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6aaf5339b578ea85b50e080feb250a3e8ae8cfcdff9a461c9ec2904bc923f52"
dependencies = [
 "thiserror-impl 1.0.69",
]

[[package]]
name = "thiserror"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3467d614147380f2e4e374161426ff399c91084acd2363eaf549172b3d5e60c0"
dependencies = [
 "thiserror-impl 2.0.16",
]

[[package]]
name = "thiserror-impl"
version = "1.0.69"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "4fee6c4efc90059e10f81e6d42c60a18f76588c3d74cb83a0b242a2b6c7504c1"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thiserror-impl"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c5e1be1c48b9172ee610da68fd9cd2770e7a4056cb3fc98710ee6906f0c7960"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "thread_local"
version = "1.1.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f60246a4944f24f6e018aa17cdeffb7818b76356965d03b07d6a9886e8962185"
dependencies = [
 "cfg-if",
]

[[package]]
name = "tinystr"
version = "0.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5d4f6d1145dcb577acf783d4e601bc1d76a13337bb54e6233add580b07344c8b"
dependencies = [
 "displaydoc",
 "zerovec",
]

[[package]]
name = "tinyvec"
version = "1.10.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa5fdc3bce6191a1dbc8c02d5c8bffcf557bafa17c124c5264a458f1b0613fa"
dependencies = [
 "tinyvec_macros",
]

[[package]]
name = "tinyvec_macros"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1f3ccbac311fea05f86f61904b462b55fb3df8837a366dfc601a0161d0532f20"

[[package]]
name = "tokio"
version = "1.47.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89e49afdadebb872d3145a5638b59eb0691ea23e46ca484037cfab3b76b95038"
dependencies = [
 "backtrace",
 "bytes",
 "io-uring",
 "libc",
 "mio",
 "parking_lot 0.12.4",
 "pin-project-lite",
 "signal-hook-registry",
 "slab",
 "socket2",
 "tokio-macros",
 "windows-sys 0.59.0",
]

[[package]]
name = "tokio-macros"
version = "2.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6e06d43f1345a3bcd39f6a56dbb7dcab2ba47e68e8ac134855e7e2bdbaf8cab8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tokio-rustls"
version = "0.26.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e727b36a1a0e8b74c376ac2211e40c2c8af09fb4013c60d910495810f008e9b"
dependencies = [
 "rustls",
 "tokio",
]

[[package]]
name = "tokio-util"
version = "0.7.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "14307c986784f72ef81c89db7d9e28d6ac26d16213b109ea501696195e6e3ce5"
dependencies = [
 "bytes",
 "futures-core",
 "futures-sink",
 "pin-project-lite",
 "tokio",
]

[[package]]
name = "tower"
version = "0.4.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b8fa9be0de6cf49e536ce1851f987bd21a43b771b09473c3549a6c853db37c1c"
dependencies = [
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "tower"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d039ad9159c98b70ecfd540b2573b97f7f52c3e8d9f8ad57a24b916a536975f9"
dependencies = [
 "futures-core",
 "futures-util",
 "pin-project-lite",
 "sync_wrapper",
 "tokio",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "tower-http"
version = "0.5.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e9cd434a998747dd2c4276bc96ee2e0c7a2eadf3cae88e52be55a05fa9053f5"
dependencies = [
 "bitflags 2.9.4",
 "bytes",
 "http",
 "http-body",
 "http-body-util",
 "pin-project-lite",
 "tokio",
 "tower-layer",
 "tower-service",
 "tracing",
]

[[package]]
name = "tower-http"
version = "0.6.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "adc82fd73de2a9722ac5da747f12383d2bfdb93591ee6c58486e0097890f05f2"
dependencies = [
 "bitflags 2.9.4",
 "bytes",
 "futures-util",
 "http",
 "http-body",
 "iri-string",
 "pin-project-lite",
 "tower 0.5.2",
 "tower-layer",
 "tower-service",
]

[[package]]
name = "tower-layer"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "121c2a6cda46980bb0fcd1647ffaf6cd3fc79a013de288782836f6df9c48780e"

[[package]]
name = "tower-service"
version = "0.3.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8df9b6e13f2d32c91b9bd719c00d1958837bc7dec474d94952798cc8e69eeec3"

[[package]]
name = "tracing"
version = "0.1.41"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "784e0ac535deb450455cbfa28a6f0df145ea1bb7ae51b821cf5e7927fdcfbdd0"
dependencies = [
 "log",
 "pin-project-lite",
 "tracing-attributes",
 "tracing-core",
]

[[package]]
name = "tracing-attributes"
version = "0.1.30"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "81383ab64e72a7a8b8e13130c49e3dab29def6d0c7d76a03087b3cf71c5c6903"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tracing-core"
version = "0.1.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b9d12581f227e93f094d3af2ae690a574abb8a2b9b7a96e7cfe9647b2b617678"
dependencies = [
 "once_cell",
 "valuable",
]

[[package]]
name = "tracing-log"
version = "0.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ee855f1f400bd0e5c02d150ae5de3840039a3f54b025156404e34c23c03f47c3"
dependencies = [
 "log",
 "once_cell",
 "tracing-core",
]

[[package]]
name = "tracing-subscriber"
version = "0.3.20"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2054a14f5307d601f88daf0553e1cbf472acc4f2c51afab632431cdcd72124d5"
dependencies = [
 "matchers",
 "nu-ansi-term",
 "once_cell",
 "regex-automata",
 "sharded-slab",
 "smallvec",
 "thread_local",
 "tracing",
 "tracing-core",
 "tracing-log",
]

[[package]]
name = "try-lock"
version = "0.2.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e421abadd41a4225275504ea4d6566923418b7f05506fbc9c0fe86ba7396114b"

[[package]]
name = "typenum"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"

[[package]]
name = "unicode-ident"
version = "1.0.18"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a5f39404a5da50712a4c1eecf25e90dd62b613502b7e925fd4e4d19b5c96512"

[[package]]
name = "universal-hash"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc1de2c688dc15305988b563c3854064043356019f97a4b46276fe734c4f07ea"
dependencies = [
 "crypto-common",
 "subtle",
]

[[package]]
name = "untrusted"
version = "0.9.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ecb6da28b8a351d773b68d5825ac39017e680750f980f3a1a85cd8dd28a47c1"

[[package]]
name = "url"
version = "2.5.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "08bc136a29a3d1758e07a9cca267be308aeebf5cfd5a10f3f67ab2097683ef5b"
dependencies = [
 "form_urlencoded",
 "idna",
 "percent-encoding",
 "serde",
]

[[package]]
name = "utf8_iter"
version = "1.0.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b6c140620e7ffbb22c2dee59cafe6084a59b5ffc27a8859a5f0d494b5d52b6be"

[[package]]
name = "uuid"
version = "1.18.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f87b8aa10b915a06587d0dec516c282ff295b475d94abf425d62b57710070a2"
dependencies = [
 "getrandom 0.3.3",
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "valuable"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba73ea9cf16a25df0c8caa16c51acb937d5712a8429db78a3ee29d5dcacd3a65"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "want"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bfa7760aed19e106de2c7c0b581b509f2f25d3dacaf737cb82ac61bc6d760b0e"
dependencies = [
 "try-lock",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasi"
version = "0.14.3+wasi-0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6a51ae83037bdd272a9e28ce236db8c07016dd0d50c27038b3f407533c030c95"
dependencies = [
 "wit-bindgen",
]

[[package]]
name = "wasm-bindgen"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1edc8929d7499fc4e8f0be2262a241556cfc54a0bea223790e71446f2aab1ef5"
dependencies = [
 "cfg-if",
 "once_cell",
 "rustversion",
 "wasm-bindgen-macro",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2f0a0651a5c2bc21487bde11ee802ccaf4c51935d0d3d42a6101f98161700bc6"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-futures"
version = "0.4.50"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "555d470ec0bc3bb57890405e5d4322cc9ea83cebb085523ced7be4144dac1e61"
dependencies = [
 "cfg-if",
 "js-sys",
 "once_cell",
 "wasm-bindgen",
 "web-sys",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7fe63fc6d09ed3792bd0897b314f53de8e16568c2b3f7982f468c0bf9bd0b407"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8ae87ea40c9f689fc23f209965b6fb8a99ad69aeeb0231408be24920604395de"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.100"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1a05d73b933a847d6cccdda8f838a22ff101ad9bf93e33684f39c1f5f0eece3d"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "web-sys"
version = "0.3.77"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "33b6dd2ef9186f1f2072e409e99cd22a975331a6b3591b12c764e0e55c60d5d2"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "web-time"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5a6580f308b1fad9207618087a65c04e7a10bc77e02c8e84e9b00dd4b12fa0bb"
dependencies = [
 "js-sys",
 "wasm-bindgen",
]

[[package]]
name = "webpki-roots"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7e8983c3ab33d6fb807cfcdad2491c4ea8cbc8ed839181c7dfd9c67c83e261b2"
dependencies = [
 "rustls-pki-types",
]

[[package]]
name = "winapi"
version = "0.3.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419"
dependencies = [
 "winapi-i686-pc-windows-gnu",
 "winapi-x86_64-pc-windows-gnu",
]

[[package]]
name = "winapi-i686-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"

[[package]]
name = "winapi-x86_64-pc-windows-gnu"
version = "0.4.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"

[[package]]
name = "windows-core"
version = "0.61.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0fdd3ddb90610c7638aa2b3a3ab2904fb9e5cdbecc643ddb3647212781c4ae3"
dependencies = [
 "windows-implement",
 "windows-interface",
 "windows-link",
 "windows-result",
 "windows-strings",
]

[[package]]
name = "windows-implement"
version = "0.60.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a47fddd13af08290e67f4acabf4b459f647552718f683a7b415d290ac744a836"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-interface"
version = "0.59.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "bd9211b69f8dcdfa817bfd14bf1c97c9188afa36f4750130fcdf3f400eca9fa8"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-result"
version = "0.3.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56f42bd332cc6c8eac5af113fc0c1fd6a8fd2aa08a0119358686e5160d0586c6"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-strings"
version = "0.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "56e6c93f3a0c3b36176cb1327a4958a0353d5d166c2a35cb268ace15e91d3b57"
dependencies = [
 "windows-link",
]

[[package]]
name = "windows-sys"
version = "0.52.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "282be5f36a8ce781fad8c8ae18fa3f9beff57ec1b52cb3de0789201425d9a33d"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-sys"
version = "0.59.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1e38bc4d79ed67fd075bcc251a1c39b32a1776bbe92e5bef1f0bf1f8c531853b"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9b724f72796e036ab90c1021d4780d4d3d648aca59e491e6b98e725b84e99973"
dependencies = [
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a4622180e7a0ec044bb555404c800bc9fd9ec262ec147edd5989ccd0c02cd3"

[[package]]
name = "windows_aarch64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "09ec2a7bb152e2252b53fa7803150007879548bc709c039df7627cabbd05d469"

[[package]]
name = "windows_i686_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8e9b5ad5ab802e97eb8e295ac6720e509ee4c243f69d781394014ebfe8bbfa0b"

[[package]]
name = "windows_i686_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0eee52d38c090b3caa76c563b86c3a4bd71ef1a819287c19d586d7334ae8ed66"

[[package]]
name = "windows_i686_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "240948bc05c5e7c6dabba28bf89d89ffce3e303022809e73deaefe4f6ec56c66"

[[package]]
name = "windows_x86_64_gnu"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "147a5c80aabfbf0c7d901cb5895d1de30ef2907eb21fbbab29ca94c5b08b1a78"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "24d5b23dc417412679681396f2b49f3de8c1473deb516bd34410872eff51ed0d"

[[package]]
name = "windows_x86_64_msvc"
version = "0.52.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "589f6da84c646204747d1270a2a5661ea66ed1cced2631d546fdfb155959f9ec"

[[package]]
name = "wit-bindgen"
version = "0.45.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "052283831dbae3d879dc7f51f3d92703a316ca49f91540417d38591826127814"

[[package]]
name = "writeable"
version = "0.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ea2f10b9bb0928dfb1b42b65e1f9e36f7f54dbdf08457afefb38afcdec4fa2bb"

[[package]]
name = "yoke"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5f41bb01b8226ef4bfd589436a297c53d118f65921786300e427be8d487695cc"
dependencies = [
 "serde",
 "stable_deref_trait",
 "yoke-derive",
 "zerofrom",
]

[[package]]
name = "yoke-derive"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "38da3c9736e16c5d3c8c597a9aaa5d1fa565d0532ae05e27c24aa62fb32c0ab6"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zerocopy"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1039dd0d3c310cf05de012d8a39ff557cb0d23087fd44cad61df08fc31907a2f"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.26"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ecf5b4cc5364572d7f4c329661bcc82724222973f2cab6f050a4e5c22f75181"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zerofrom"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "50cc42e0333e05660c3587f3bf9d0478688e15d870fab3346451ce7f8c9fbea5"
dependencies = [
 "zerofrom-derive",
]

[[package]]
name = "zerofrom-derive"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d71e5d6e06ab090c67b5e44993ec16b72dcbaabc526db883a360057678b48502"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "synstructure",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"

[[package]]
name = "zerotrie"
version = "0.2.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "36f0bbd478583f79edad978b407914f61b2972f5af6fa089686016be8f9af595"
dependencies = [
 "displaydoc",
 "yoke",
 "zerofrom",
]

[[package]]
name = "zerovec"
version = "0.11.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7aa2bd55086f1ab526693ecbe444205da57e25f4489879da80635a46d90e73b"
dependencies = [
 "yoke",
 "zerofrom",
 "zerovec-derive",
]

[[package]]
name = "zerovec-derive"
version = "0.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5b96237efa0c878c64bd89c436f661be4e46b2f3eff1ebb976f7ef2321d2f58f"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

```


## FILE: /root/logos_lrb/Cargo.toml  (size=713b)
```
[workspace]
members = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition = "2021"
license = "Proprietary"
name = "logos_lrb_workspace"
version = "0.1.0"

[workspace.dependencies]
anyhow = "1"
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
axum = "0.7"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time"] }
blake3 = "1"
bs58 = "0.5"
ed25519-dalek = { version = "2", features = ["serde"] }
rand = "0.8"
rand_core = "0.6"
sled = "0.34"
once_cell = "1"
uuid = { version = "1", features = ["v4", "serde"] }
hyper = "1"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
time = "0.3"
base64 = "0.22"
hex = "0.4"

```


## FILE: /root/logos_lrb/README.md  (size=841b)
```
# LOGOS Resonance Blockchain — Monorepo

Состав:
- `lrb_core/`  — ядро (Rust)
- `node/`      — узел (Axum REST + gossip)
- `modules/`   — модульные компоненты
- `tools/`     — e2e и нагрузочные тесты (Go)
- `www/wallet/` — Web Wallet (MVP)
- `wallet-proxy/` — FastAPI proxy + scanner
- `infra/systemd`, `infra/nginx` — юниты/конфиги (без секретов)
- `configs/*.example` — примеры окружения

## Быстрый старт
1) Rust/Go/Python3.12
2) `cargo build --release -p logos_node`
3) Настрой ENV по `configs/keys.env.example` (секреты не коммить)
4) Подними systemd-юниты из `infra/systemd` (редактируй пути/ENV)
5) Nginx-site из `infra/nginx/lrb_wallet.conf` (wallet + proxy)

```


## FILE: /root/logos_lrb/configs/env/node-a.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_DATA_DIR=/var/lib/logos-a
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /root/logos_lrb/configs/env/node-b.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8082
LRB_DATA_DIR=/var/lib/logos-b
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /root/logos_lrb/configs/env/node-c.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8084
LRB_DATA_DIR=/var/lib/logos-c
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /root/logos_lrb/configs/genesis.yaml  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/configs/keys.env.example  (size=419b)
```
# LOGOS node (пример ENV)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_SLOT_MS=500
LRB_MAX_BLOCK_TX=10000
LRB_MEMPOOL_CAP=100000
LRB_MAX_AMOUNT=18446744073709551615
LRB_BRIDGE_MAX_PER_TX=10000000

# Секреты — задаются ТОЛЬКО вне репозитория:
# LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
# LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=<optional>

```


## FILE: /root/logos_lrb/configs/logos_config.yaml  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/configs/proxy.env.example  (size=443b)
```
# Wallet Proxy / Scanner (пример ENV)
# !!! НЕ коммить настоящие ключи/приватники !!!
ETH_PROVIDER_URL=https://mainnet.infura.io/v3/XXXX...
USDT_CONTRACT=0xdAC17F958D2ee523a2206206994597C13D831ec7

# hot-кошелёк оператора (для withdraw/fee)
HOT_WALLET_ADDRESS=0x...
HOT_WALLET_PRIVATE_KEY= # НЕ класть в git, подставлять только в прод окружении

```


## FILE: /root/logos_lrb/core/beta_rollout.yaml  (size=3586b)
```
yaml
version: 1.1

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

phases:
  - phase: "alpha"
    name: "Закрытый Резонанс"
    description: "Только для внутренних валидаторов. Проверка фаз, Λ0 и Σ(t)."
    max_nodes: 10
    validators_only: true
    duration_days: 14
    lgn_stake_required: 144.0
    activation: manual
    required_symbol: "Λ0"
    tasks:
      - "Проверка фазовой синхронизации"
      - "Отладка rcp_engine и phase_stabilizer"
      - "Первая фиксация Λ0 в реальных условиях"
      - "Симуляция сбоя 50% узлов"
    logs: "alpha_rollout_log.json"

  - phase: "beta-private"
    name: "Приватная сеть 81"
    description: "Подключение 81 участника с проверенными RID. Первые ритуалы, распределение rLGN."
    max_nodes: 81
    validators_only: false
    whitelist_required: true
    duration_days: 21
    lgn_stake_required: 81.0
    activation: semi-automatic
    required_symbol: "Λ0"
    tasks:
      - "Ритуальный вход через onboarding_sim.py"
      - "Активация DAO миссий"
      - "Проверка recall, spam_guard и scaler"
      - "Симуляция фазового спама"
    logs: "beta_private_log.json"

  - phase: "beta-open"
    name: "Открытый тест 1000"
    description: "До 1000 узлов. Публичная демонстрация Σ(t), резонансных транзакций и DAO-механики."
    max_nodes: 1000
    validators_only: false
    whitelist_required: false
    duration_days: 30
    lgn_stake_required: 0
    activation: public
    required_symbol: "any"
    tasks:
      - "Запуск фазы голосования через community_dao.yaml"
      - "Анализ логов via resonance_feedback.py"
      - "Публичные квесты через ritual_quest.py"
      - "Тестирование потери 30% узлов"
    logs: "beta_open_log.json"

  - phase: "mainnet-init"
    name: "Инициация Mainnet"
    description: "Активация основной сети LOGOS. Поддержка >10k узлов. Подпись через Λ0 и DAO-кворум."
    max_nodes: 10000
    validators_only: false
    whitelist_required: false
    duration_days: 9999
    lgn_stake_required: 0
    activation: by-consensus
    required_symbol: "Λ0"
    dynamic_quorum:
      enabled: true
      node_count_thresholds:
        1000: 0.5
        5000: 0.4
        10000: 0.25
    tasks:
      - "Формирование начального символа via auto_init_from_Λ0.py"
      - "Рассылка маяков и сигнала Σ(t)"
      - "Применение всех 56+ модулей в боевом режиме"
      - "Симуляция критического сбоя (70% узлов)"
    logs: "mainnet_init_log.json"

post_launch:
  monitoring:
    enabled: true
    modules:
      - "biosphere_scanner.rs"
      - "resonance_feedback.py"
      - "phase_integrity.rs"
    log_file: "post_launch_monitoring.json"
  escalation_policy:
    if_phase_failure: "Откат до beta-private, перезапуск с резервного Λ0"
    if_massive_spam: "Активация tx_spam_guard.rs + lgn_recall.rs"
    if_critical_lag: "Авто-перебалансировка через phase_scaler.rs"
  documentation:
    guide: "logos_beta_guide.md"


```


## FILE: /root/logos_lrb/core/offline_resonance.py  (size=5400b)
```
# LOGOS Offline Resonance Module
# Автор: LOGOS Core Dev

import json
import os
import time
from datetime import datetime
from typing import Dict
from cryptography.fernet import Fernet
import re

class OfflineResonance:
    def __init__(self, storage_file: str = "offline_phase_state.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "last_sync": 0,
            "symbol": "Λ0",
            "frequency": 7.83,
            "phase": 0.0,
            "pending_tx": []  # Очередь оффлайн-транзакций
        }
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}
        self.log_file = "offline_resonance_log.json"
        self.load_state()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def validate_frequency(self, frequency: float) -> bool:
        """Проверяет частоту на допустимый диапазон."""
        return 0.1 <= frequency <= 10000.0

    def load_state(self):
        """Загружает состояние из файла с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения локального состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние в файл с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def update_phase(self, symbol: str, frequency: float, phase: float) -> bool:
        """Обновляет фазовое состояние с валидацией."""
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            return False
        if not self.validate_frequency(frequency):
            print(f"[!] Недопустимая частота: {frequency}")
            return False
        if not (-math.pi <= phase <= math.pi):
            print(f"[!] Недопустимая фаза: {phase}")
            return False

        self.state["symbol"] = symbol
        self.state["frequency"] = frequency
        self.state["phase"] = phase
        self.state["last_sync"] = int(time.time())
        self.save_state()
        self.log_update(symbol, frequency, phase)
        print(f"[OFFLINE] Фаза обновлена: {symbol}, {frequency} Hz, φ = {phase}")
        return True

    def add_offline_tx(self, tx: Dict):
        """Добавляет оффлайн-транзакцию в очередь."""
        if self.validate_symbol(tx.get("symbol", "")) and "amount" in tx:
            self.state["pending_tx"].append(tx)
            self.save_state()
            self.log_tx(tx)
            print(f"[OFFLINE] Транзакция добавлена: {tx}")
        else:
            print("[!] Недопустимая транзакция")

    def get_current_phase(self) -> Dict:
        """Возвращает текущее состояние."""
        return self.state

    def is_stale(self, max_age: int = 600) -> bool:
        """Проверяет, устарело ли локальное состояние."""
        now = int(time.time())
        return (now - self.state["last_sync"]) > max_age

    def log_update(self, symbol: str, frequency: float, phase: float):
        """Логирует обновление фазы."""
        log_entry = {
            "event": "phase_update",
            "symbol": symbol,
            "frequency": frequency,
            "phase": phase,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def log_tx(self, tx: Dict):
        """Логирует оффлайн-транзакцию."""
        log_entry = {
            "event": "offline_tx",
            "tx": tx,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def _write_log(self, entry: Dict):
        """Записывает лог в файл для resonance_analyzer.py."""
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")

if __name__ == "__main__":
    offline = OfflineResonance()
    # Тест обновления фазы
    offline.update_phase("☉??♁", 1.618, 0.785)
    print("Текущее состояние:", offline.get_current_phase())
    print("Устарело?", offline.is_stale())
    # Тест оффлайн-транзакции
    tx = {"symbol": "??", "amount": 3.14, "to": "RID_♁☿"}
    offline.add_offline_tx(tx)

```


## FILE: /root/logos_lrb/core/onboarding_sim.py  (size=5458b)
```
# LOGOS Onboarding Simulator
# Автор: LOGOS Core Dev

import time
import math
import json
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Импорт для оценки резонанса

class OnboardingSimulator:
    def __init__(self):
        self.state_file = "onboarding_sim_state.json"
        self.log_file = "onboarding_sim_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа шифрования
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]  # Синхронизация с другими модулями
        self.phases = [0.0, math.pi / 4, math.pi / 2, math.pi, -math.pi / 2]
        self.freqs = [7.83, 1.618, 432.0]
        self.progress = []
        self.analyzer = ResonanceAnalyzer()  # Для оценки резонансной силы

    def run(self):
        print("Добро пожаловать в симулятор резонанса LOGOS.")
        print("Вы пройдёте 3 этапа: Символ → Частота → Фаза")
        input("Нажмите Enter для начала...\n")

        self.choose_symbol()
        self.choose_frequency()
        self.choose_phase()
        self.finalize()

    def choose_symbol(self):
        print("\nШаг 1: Выбор символа (архетипа)")
        for i, s in enumerate(self.valid_symbols):
            print(f"{i + 1}. {s}")
        index = self.ask_choice(len(self.valid_symbols))
        chosen = self.valid_symbols[index - 1]
        self.progress.append({"step": "symbol", "value": chosen})
        self.log_event(f"Выбран символ: {chosen}")
        print(f"Вы выбрали: {chosen}")

    def choose_frequency(self):
        print("\nШаг 2: Выбор частоты (гармоники)")
        for i, f in enumerate(self.freqs):
            print(f"{i + 1}. {f} Hz")
        index = self.ask_choice(len(self.freqs))
        chosen = self.freqs[index - 1]
        self.progress.append({"step": "frequency", "value": chosen})
        self.log_event(f"Выбрана частота: {chosen} Hz")
        print(f"Вы выбрали: {chosen} Hz")

    def choose_phase(self):
        print("\nШаг 3: Выбор фазы (φ)")
        for i, p in enumerate(self.phases):
            label = f"{round(p, 3)} рад" if p != 0.0 else "0 (идеальная фаза)"
            print(f"{i + 1}. {label}")
        index = self.ask_choice(len(self.phases))
        chosen = self.phases[index - 1]
        self.progress.append({"step": "phase", "value": round(chosen, 4)})
        self.log_event(f"Выбрана фаза: φ = {chosen:.4f}")
        print(f"Вы выбрали фазу: φ = {chosen:.4f}")

    def finalize(self):
        print("\n✅ Симуляция завершена!")
        result = {
            "symbol": self.progress[0]["value"],
            "frequency": self.progress[1]["value"],
            "phase": self.progress[2]["value"],
            "timestamp": time.time()
        }
        # Оценка резонансной силы
        resonance = self.analyzer.analyze(
            result["symbol"], result["frequency"], result["phase"]
        )
        result["resonance_score"] = resonance["resonance"]
        self.save_state(result)
        self.log_event(f"Резонанс: {resonance['resonance']:.4f}")
        print("Результат сохранён в:", self.state_file)
        print(f"Сила резонанса: {resonance['resonance']:.4f}")
        print("Теперь вы готовы к настоящему резонансу!")
        # Заглушка для RCP проверки
        if self.validate_with_rcp(result):
            print("[RCP] Резонанс подтверждён сетью!")
        else:
            print("[RCP] Резонанс не подтверждён. Попробуйте изменить параметры.")

    def validate_with_rcp(self, result: Dict) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return result["resonance_score"] > 0.5 and result["symbol"] == "Λ0"

    def save_state(self, state: Dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "onboarding_sim",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

    def ask_choice(self, max_choice: int) -> int:
        while True:
            try:
                choice = int(input("Ваш выбор: "))
                if 1 <= choice <= max_choice:
                    return choice
                else:
                    print(f"Введите число от 1 до {max_choice}")
            except:
                print("Ошибка ввода. Попробуйте снова.")

if __name__ == "__main__":
    sim = OnboardingSimulator()
    sim.run()

```


## FILE: /root/logos_lrb/core/onboarding_ui.py  (size=5974b)
```
# LOGOS Onboarding UI
# Автор: LOGOS Core Dev

import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import json
import math
import re
from cryptography.fernet import Fernet
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class OnboardingUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Вход в Резонанс")
        self.root.geometry("420x460")
        self.state_file = "onboarding_state.json"
        self.log_file = "onboarding_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}

        self.status_label = tk.Label(self.root, text="Добро пожаловать в LOGOS Resonance Network", font=("Arial", 12))
        self.status_label.pack(pady=10)

        self.symbol_var = tk.StringVar(value="Λ0")
        self.phase_var = tk.DoubleVar(value=0.0)
        self.frequency_var = tk.DoubleVar(value=7.83)

        self.entry_frame()
        self.setup_animation()

        tk.Button(self.root, text="Принять фазу", font=("Arial", 14), command=self.accept_phase).pack(pady=10)
        self.root.mainloop()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def entry_frame(self):
        """Создает форму для ввода данных."""
        frame = tk.Frame(self.root)
        frame.pack(pady=10)

        tk.Label(frame, text="Символ:", font=("Arial", 10)).grid(row=0, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.symbol_var, width=12, font=("Arial", 10)).grid(row=0, column=1)

        tk.Label(frame, text="Частота (Hz):", font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.frequency_var, width=12, font=("Arial", 10)).grid(row=1, column=1)

        tk.Label(frame, text="Фаза (радианы):", font=("Arial", 10)).grid(row=2, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.phase_var, width=12, font=("Arial", 10)).grid(row=2, column=1)

    def setup_animation(self):
        """Создает анимацию синусоиды для визуализации фазы."""
        self.fig, self.ax = plt.subplots(figsize=(4, 2))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        self.update_animation(0.0)

    def update_animation(self, phase: float):
        """Обновляет анимацию синусоиды."""
        self.ax.clear()
        t = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(t + phase)
        self.ax.plot(t, y, color="#FFD700", linewidth=2)
        self.ax.set_title("Резонансная фаза", fontsize=10, color="#333333")
        self.ax.set_xlabel("Время", fontsize=8)
        self.ax.set_ylabel("Амплитуда", fontsize=8)
        self.ax.grid(True, linestyle="--", alpha=0.5)
        self.canvas.draw()

    def accept_phase(self):
        """Обрабатывает принятие фазы."""
        symbol = self.symbol_var.get().strip()
        frequency = self.frequency_var.get()
        phase = self.phase_var.get()

        # Валидация
        if not self.validate_symbol(symbol):
            messagebox.showerror("Ошибка", "Недопустимый символ. Используйте ☉, ??, Λ0 и т.д.")
            return
        if frequency <= 0 or frequency > 10000.0:
            messagebox.showerror("Ошибка", "Частота должна быть в диапазоне 0.1–10000 Hz")
            return
        if not -math.pi <= phase <= math.pi:
            messagebox.showerror("Ошибка", "Фаза должна быть в диапазоне [-π, π]")
            return

        # Проверка фазы через RCP (заглушка для интеграции с rcp_engine.rs)
        if not self.validate_with_rcp(symbol, frequency, phase):
            messagebox.showerror("Ошибка", "Фаза не резонирует с сетью")
            return

        # Сохранение состояния
        accepted = {
            "symbol": symbol,
            "frequency": round(frequency, 4),
            "phase": round(phase, 4),
            "timestamp": datetime.utcnow().isoformat()
        }
        self.save_state(accepted)
        self.log_event(accepted)

        messagebox.showinfo("Успешно", f"Фаза принята: {symbol} @ {frequency} Hz, φ = {phase}")
        print("[ONBOARD] Вход выполнен:", accepted)
        self.update_animation(phase)

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки фазы через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs для проверки резонанса
        return abs(frequency - 7.83) < 0.1 or symbol == "Λ0"  # Пример проверки

    def save_state(self, state: dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, state: dict):
        """Логирует событие входа."""
        log_entry = {
            "event": "onboarding",
            "state": state,
            "timestamp": datetime.utcnow().isoformat()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

if __name__ == "__main__":
    OnboardingUI()

```


## FILE: /root/logos_lrb/core/rLGN_converter.py  (size=5518b)
```
# LOGOS rLGN ⇆ LGN Converter
# Автор: LOGOS Core Dev

import json
import time
import math
from typing import Dict
from cryptography.fernet import Fernet
import os

class rLGNConverter:
    def __init__(self, storage_file: str = "lgn_wallet.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "LGN": 0.0,
            "rLGN": 0.0,
            "last_conversion": 0,
            "conversion_log": []
        }
        self.lambda_zero = "Λ0"
        self.min_conversion_interval = 60  # 1 минута
        self.log_file = "conversion_log.json"
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def validate_phase(self, phase: float) -> bool:
        """Проверяет фазу на допустимый диапазон."""
        return -math.pi <= phase <= math.pi

    def convert_to_lgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует rLGN в LGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "rLGN"):
            return False

        multiplier = self._phase_multiplier(phase, symbol)
        converted = amount * multiplier
        self.state["rLGN"] -= amount
        self.state["LGN"] += converted
        self._log("rLGN→LGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def convert_to_rlgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует LGN в rLGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "LGN"):
            return False

        penalty = self._phase_penalty(phase, symbol)
        converted = amount * penalty
        self.state["LGN"] -= amount
        self.state["rLGN"] += converted
        self._log("LGN→rLGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def _can_convert(self, amount: float, phase: float, source: str) -> bool:
        """Проверяет возможность конвертации."""
        if amount <= 0 or amount > self.state[source]:
            print(f"[!] Недостаточно {source}: {amount}")
            return False
        if not self.validate_phase(phase):
            print(f"[!] Недопустимая фаза: {phase}")
            return False
        if time.time() - self.state["last_conversion"] < self.min_conversion_interval:
            print("[!] Слишком частая конвертация")
            return False
        return True

    def _phase_multiplier(self, phase: float, symbol: str) -> float:
        """Вычисляет мультипликатор с бонусом для Λ0."""
        base = max(0.1, min(1.5, 1.0 + math.cos(phase)))
        if symbol == self.lambda_zero:
            base *= 1.2  # Бонус за Λ0
        return base

    def _phase_penalty(self, phase: float, symbol: str) -> float:
        """Вычисляет штраф с учетом Λ0."""
        base = max(0.5, min(1.0, 1.0 - abs(math.sin(phase))))
        if symbol == self.lambda_zero:
            base = min(1.0, base * 1.1)  # Смягчение штрафа для Λ0
        return base

    def _log(self, direction: str, original: float, result: float, phase: float, symbol: str):
        """Логирует конвертацию в файл и консоль."""
        entry = {
            "direction": direction,
            "original": round(original, 5),
            "result": round(result, 5),
            "phase": round(phase, 4),
            "symbol": symbol,
            "timestamp": time.time()
        }
        self.state["conversion_log"].append(entry)
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")
        print(f"[{direction}] {original} → {result} @ φ={phase:.3f}, Symbol={symbol}")

    def get_balances(self) -> Dict:
        """Возвращает текущие балансы."""
        return {
            "LGN": round(self.state["LGN"], 5),
            "rLGN": round(self.state["rLGN"], 5)
        }

if __name__ == "__main__":
    converter = rLGNConverter()
    converter.state["rLGN"] = 10.0
    converter.state["LGN"] = 5.0
    converter.convert_to_lgn(2.5, 0.785, "Λ0")
    converter.convert_to_rlgn(1.0, 1.047, "☉")
    print("Баланс:", converter.get_balances())

```


## FILE: /root/logos_lrb/core/resonance_analyzer.py  (size=3470b)
```
# LOGOS Resonance Analyzer
# Автор: LOGOS Core Dev

import math
import re
from datetime import datetime
import json

class ResonanceAnalyzer:
    def __init__(self, base_freqs=None):
        self.base_freqs = base_freqs or [7.83, 1.618, 432.0, 864.0, 3456.0]
        self.symbol_weights = {
            "☉": 0.9, "??": 0.85, "♁": 0.8, "??": 0.75, "??": 0.7,
            "??": 0.65, "Λ0": 1.0, "∞": 0.95
        }
        self.lambda_zero = "Λ0"
        self.max_freq = 10000.0  # Ограничение на частоту
        self.log_file = "resonance_log.json"

    def is_symbol_valid(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def symbol_weight(self, symbol: str) -> float:
        """Вычисляет вес символа с бонусом для Λ0."""
        if not self.is_symbol_valid(symbol):
            return 0.0
        weight = sum(self.symbol_weights.get(s, 0.5) for s in symbol) / len(symbol)
        if self.lambda_zero in symbol:
            weight *= 1.2  # Бонус за присутствие Λ0
        return weight

    def harmonic_score(self, freq: float) -> float:
        """Оценивает гармоничность частоты относительно базовых."""
        if freq > self.max_freq or freq <= 0.0:
            return 0.0  # Защита от экстремальных частот
        score = 0.0
        for base in self.base_freqs:
            delta = abs(freq - base)
            score += math.exp(-delta)
        return score / len(self.base_freqs)

    def update_symbol_weights(self, network_activity: dict):
        """Динамическое обновление весов символов на основе активности сети."""
        for symbol, activity in network_activity.items():
            if symbol in self.symbol_weights:
                self.symbol_weights[symbol] *= (1.0 + activity * 0.01)

    def analyze(self, symbol: str, freq: float, phase: float) -> dict:
        """Анализирует резонансную силу символа, частоты и фазы."""
        now = datetime.utcnow().timestamp()
        valid = self.is_symbol_valid(symbol)
        sym_strength = self.symbol_weight(symbol) if valid else 0.0
        harmonicity = self.harmonic_score(freq)
        resonance = sym_strength * harmonicity * math.cos(phase)

        result = {
            "valid": valid,
            "symbol_strength": round(sym_strength, 3),
            "harmonicity": round(harmonicity, 3),
            "resonance": round(resonance, 4),
            "timestamp": now
        }
        self.log_result(result)
        return result

    def log_result(self, result: dict):
        """Сохраняет результаты анализа в лог для resonance_feedback.py."""
        with open(self.log_file, 'a') as f:
            json.dump(result, f)
            f.write('\n')

if __name__ == "__main__":
    analyzer = ResonanceAnalyzer()
    # Тестовые случаи
    tests = [
        ("☉??♁", 1.618, 0.785),
        ("Λ0", 7.83, 0.0),
        ("invalid", 100000.0, 1.0),
    ]
    for symbol, freq, phase in tests:
        result = analyzer.analyze(symbol, freq, phase)
        print(f"RES ANALYSIS [{symbol}, {freq} Hz, {phase}]: {result}")

```


## FILE: /root/logos_lrb/core/rid_builder.py  (size=5229b)
```
# LOGOS RID Builder
# Автор: LOGOS Core Dev

import random
import math
import time
import json
import os
from typing import Dict, Optional
from cryptography.fernet import Fernet

class RIDBuilder:
    def __init__(self):
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.default_freqs = [7.83, 1.618, 432.0, 864.0]
        self.generated: Dict[str, float] = {}  # RID -> timestamp
        self.rid_log_file = "rid_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.min_generate_interval = 60  # 1 минута
        self.lambda_zero = "Λ0"

    def generate_rid(self, symbol: Optional[str] = None, freq: Optional[float] = None) -> Optional[str]:
        """Генерирует новый RID с проверкой на спам и уникальность."""
        now = time.time()
        # Проверка частоты генерации
        for timestamp in self.generated.values():
            if now - timestamp < self.min_generate_interval:
                print(f"[!] Слишком частая генерация RID")
                self.log_event(f"Слишком частая генерация RID")
                return None

        # Выбор символа с приоритетом Λ0
        symbol = symbol or (self.lambda_zero if random.random() < 0.3 else random.choice(self.valid_symbols))
        if symbol not in self.valid_symbols:
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return None

        freq = round(freq or random.choice(self.default_freqs), 3)
        if not (0.1 <= freq <= 10000.0):
            print(f"[!] Недопустимая частота: {freq}")
            self.log_event(f"Недопустимая частота: {freq}")
            return None

        phase = round(random.uniform(-math.pi, math.pi), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"

        # Проверка уникальности
        if rid in self.generated:
            print(f"[!] RID уже существует: {rid}")
            self.log_event(f"RID уже существует: {rid}")
            return None

        # Проверка через RCP (заглушка)
        if not self.validate_with_rcp(symbol, freq, phase):
            print(f"[!] RCP не подтвердил RID: {rid}")
            self.log_event(f"RCP не подтвердил RID: {rid}")
            return None

        self.generated[rid] = now
        self.log_rid(rid)
        return rid

    def parse_rid(self, rid: str) -> Dict:
        """Разбирает RID на компоненты."""
        try:
            parts = rid.split("@")
            symbol = parts[0]
            freq_phase = parts[1].replace("Hz", "").split("φ")
            frequency = float(freq_phase[0])
            phase = float(freq_phase[1])
            return {
                "symbol": symbol,
                "frequency": frequency,
                "phase": phase
            }
        except Exception as e:
            print(f"[!] Ошибка разбора RID: {e}")
            self.log_event(f"Ошибка разбора RID: {e}")
            return {}

    def validate_rid(self, rid: str) -> bool:
        """Проверяет валидность RID."""
        parsed = self.parse_rid(rid)
        if not parsed:
            return False
        valid = (
            parsed["symbol"] in self.valid_symbols and
            0.1 <= parsed["frequency"] <= 10000.0 and
            -math.pi <= parsed["phase"] <= math.pi
        )
        if not valid:
            self.log_event(f"Невалидный RID: {rid}")
        return valid

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == self.lambda_zero or abs(frequency - 7.83) < 0.1

    def log_rid(self, rid: str):
        """Логирует создание RID."""
        entry = {
            "event": "rid_generate",
            "rid": rid,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def log_event(self, message: str):
        """Логирует событие."""
        entry = {
            "event": "rid_builder",
            "message": message,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def _write_log(self, entry: Dict):
        """Сохраняет лог с шифрованием."""
        log_data = json.dumps(entry) + "\n"
        encrypted_data = self.cipher.encrypt(log_data.encode())
        with open(self.rid_log_file, "ab") as f:
            f.write(encrypted_data + b"\n")

if __name__ == "__main__":
    builder = RIDBuilder()
    new_rid = builder.generate_rid()
    if new_rid:
        print("Сгенерированный RID:", new_rid)
        parsed = builder.parse_rid(new_rid)
        print("Разбор:", parsed)
        print("RID валиден?", builder.validate_rid(new_rid))

```


## FILE: /root/logos_lrb/core/ritual_quest.py  (size=7912b)
```
# LOGOS Ritual Quest Engine
# Автор: LOGOS Core Dev

import json
import time
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Для оценки резонанса

class RitualQuest:
    def __init__(self):
        self.quests_file = "ritual_quests.json"
        self.progress_file = "ritual_progress.json"
        self.log_file = "ritual_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.quests = self.load_quests()
        self.progress = self.load_progress()
        self.analyzer = ResonanceAnalyzer()
        self.user_timestamps = {}  # user -> last submission time
        self.min_submission_interval = 60  # 1 минута

    def load_quests(self) -> Dict:
        """Загружает квесты с расшифровкой."""
        if os.path.exists(self.quests_file):
            try:
                with open(self.quests_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки квестов: {e}")
        # Примеры по умолчанию
        return {
            "RQ001": {
                "title": "Ритуал Фазы Λ0",
                "required_symbol": "Λ0",
                "required_phase": 0.0,
                "reward_lgn": 21.0,
                "repeatable": False
            },
            "RQ002": {
                "title": "Резонансный Треугольник",
                "required_symbol": "☉",
                "required_frequency": 432.0,
                "min_phase": 0.5,
                "max_phase": 1.57,
                "reward_lgn": 34.0,
                "repeatable": True
            }
        }

    def load_progress(self) -> Dict:
        """Загружает прогресс с расшифровкой."""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки прогресса: {e}")
        return {}

    def save_quests(self):
        """Сохраняет квесты с шифрованием."""
        data = json.dumps(self.quests, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.quests_file, "wb") as f:
            f.write(data)

    def save_progress(self):
        """Сохраняет прогресс с шифрованием."""
        data = json.dumps(self.progress, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.progress_file, "wb") as f:
            f.write(data)

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def submit_action(self, user: str, symbol: str, frequency: float, phase: float) -> float:
        """Обрабатывает действие пользователя."""
        # Проверка частоты попыток
        now = time.time()
        last_submission = self.user_timestamps.get(user, 0)
        if now - last_submission < self.min_submission_interval:
            print(f"[!] Слишком частая попытка от {user}")
            self.log_event(f"Слишком частая попытка: {user}")
            return 0.0
        self.user_timestamps[user] = now

        # Валидация символа
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return 0.0

        # Проверка резонанса через RCP (заглушка)
        if not self.validate_with_rcp(symbol, frequency, phase):
            print(f"[!] Резонанс не подтверждён: {symbol}, {frequency} Hz, φ={phase}")
            self.log_event(f"Резонанс не подтверждён: {symbol}, {frequency}, {phase}")
            return 0.0

        # Оценка резонансной силы
        resonance = self.analyzer.analyze(symbol, frequency, phase)
        if resonance["resonance"] < 0.5:
            print(f"[!] Слабый резонанс: {resonance['resonance']:.4f}")
            self.log_event(f"Слабый резонанс: {resonance['resonance']}")
            return 0.0

        for quest_id, quest in self.quests.items():
            if quest_id in self.progress.get(user, []) and not quest.get("repeatable", False):
                continue

            if not self.matches(quest, symbol, frequency, phase):
                continue

            self.register_completion(user, quest_id)
            print(f"[QUEST] {user} завершил квест {quest_id}: {quest['title']}")
            self.log_ritual(user, quest_id, quest, resonance["resonance"])
            return quest["reward_lgn"]

        print("[QUEST] Нет совпадений с активными ритуалами.")
        self.log_event("Нет совпадений с ритуалами")
        return 0.0

    def matches(self, quest: Dict, symbol: str, frequency: float, phase: float) -> bool:
        """Проверяет соответствие квесту."""
        if "required_symbol" in quest and quest["required_symbol"] != symbol:
            return False
        if "required_frequency" in quest and abs(quest["required_frequency"] - frequency) > 0.1:
            return False
        if "required_phase" in quest and abs(quest["required_phase"] - phase) > 0.05:
            return False
        if "min_phase" in quest and phase < quest["min_phase"]:
            return False
        if "max_phase" in quest and phase > quest["max_phase"]:
            return False
        return True

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == "Λ0" or abs(frequency - 7.83) < 0.1

    def register_completion(self, user: str, quest_id: str):
        """Регистрирует завершение квеста."""
        self.progress.setdefault(user, []).append(quest_id)
        self.save_progress()

    def log_ritual(self, user: str, quest_id: str, quest: Dict, resonance: float):
        """Логирует завершение ритуала."""
        log = {
            "event": "ritual_complete",
            "user": user,
            "quest_id": quest_id,
            "reward": quest["reward_lgn"],
            "resonance": resonance,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "ritual_quest",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

if __name__ == "__main__":
    rq = RitualQuest()
    reward = rq.submit_action(user="RID_Λ0_123", symbol="Λ0", frequency=7.83, phase=0.0)
    print("Награда:", reward, "LGN")

```


## FILE: /root/logos_lrb/docs/WORKFLOW.md  (size=5440b)
```
# LOGOS LRB — КАНОН РАБОТЫ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)

## 0) Цель
Конечная цель — **полностью рабочий резонансный блокчейн LOGOS LRB**, интегрированный с нашим приложением: узел принимает и финализирует транзакции, поддерживает резонансные модули, API совместимо с мобильным клиентом. **Никаких заглушек и TODO** — только боевой, собранный и проверенный код.

---

## 1) Канон внесения изменений (обязательный порядок)
Каждое изменение оформляется ТОЛЬКО так:

1. **Создание директорий (если нужно):**
   - `mkdir -p <путь/к/директории>`

2. **Вход в целевую директорию:**
   - `cd <путь/к/директории>`

3. **Удаление старого файла (если он есть):**
   - `rm -f <имя_файла>`

4. **Открытие nano для нового файла:**
   - `nano <имя_файла>`

5. **Вставка ПОЛНОГО, боевого кода** (всё содержимое файла целиком).
   - Без «патчей» и диффов — ВСЕГДА полный файл.
   - Без заглушек, TODO, псевдокода.

6. **Сохранение → выход → сборка/проверка.**

Этот канон применяется к любым файлам (Rust, Python, YAML, systemd, shell-скрипты и т.д.).

---

## 2) Требования к коду
- **Ни одного `unsafe`/`unwrap`/`expect`/`panic!`** в путях выполнения продакшена.
- Чёткие `Result`/ошибки, логирование, предсказуемое поведение при сбоях.
- Rust: `cargo build --release -p logos_node` **должен проходить без ошибок**.
- Python: синтаксис чистый, без `eval/exec`; утилиты не мешают прод-пути.
- Конфиги валидируются парсером/схемой, лежат в `configs/`.
- systemd-юниты запускаются и переживают рестарты; порт слушается постоянно.

---

## 3) Проверки после каждого изменения
1. **Сборка узла:**  
   `cd /root/logos_lrb && cargo build --release -p logos_node`

2. **Запуск узла (локально):**  
   `./target/release/logos_node`  
   Проверка:  
   - `curl -s http://127.0.0.1:8080/healthz` → `{"ok":true}`  
   - `curl -s http://127.0.0.1:8080/head`

3. **Автозапуск (systemd):**  
   - Юнит: `/etc/systemd/system/logos-node.service`  
   - `systemctl enable --now logos-node.service`  
   - `systemctl status logos-node.service`  
   - `journalctl -u logos-node.service -f`

4. **Генерация дерева проекта:**  
   - `/root/logos_lrb/tools/gen_full_tree.sh`  
   - Коммит `FULL_TREE.md`.

---

## 4) Правила коммитов/репозитория
- Любое изменение кода/конфигов сопровождается **коммитом** в `main`.
- Сообщение коммита короткое и предметное: что изменено и зачем.
- Не коммитить артефакты сборки (`target/`, `node_modules/`, и т.п.).
- Поддерживать `FULL_TREE.md` и `AUDIT_REPORT.md` в актуальном состоянии.

---

## 5) Стандарты API и интеграции
- Узел (`logos_node`) обязан держать REST:
  - `GET /healthz` — жив ли.
  - `GET /head` — {height, hash}.
  - `GET /balance/:rid` — баланс.
  - `POST /submit_tx` — приём tx (Ed25519, base58 RID).
- Мобильный клиент должен уметь:
  - генерировать ключи / RID (Ed25519 → base58),
  - формировать каноничное сообщение, подписывать, отправлять в `/submit_tx`,
  - опрашивать `head` и `balance`.

---

## 6) Безопасность и эксплуатация
- Лимиты и квоты — на входе (spam-guard) и в mempool.
- LGN_cost — адаптивный (dynamic_balance).
- **Никаких секретов в репозитории** (ключи/пароли).
- Логи — в journal/systemd, при необходимости `RUST_LOG=info`.

---

## 7) Оркестрация «одним дыханием»
- Все шаги (создание директорий → nano → полный код → сборка → проверки) делаются **в одном заходе** согласно канону из раздела 1.
- Любые новые службы/скрипты оформлять аналогично (полный код, без TODO).

---

## 8) Мини-чеклист перед «готово»
- `cargo build --release -p logos_node` — ОК
- `/healthz`, `/head`, `/balance/:rid`, `/submit_tx` — ОК
- `logos-node.service` — Active (running)
- `FULL_TREE.md` — обновлён
- Нет `unsafe`/`unwrap`/`expect`/`panic!` в прод-пути

```


## FILE: /root/logos_lrb/docs/architecture.md  (size=10559b)
```
Документ: Архитектура всех модулей LOGOS Resonance Blockchain (LRB)


---

Общее количество модулей: 56

Каждый модуль является функциональной частью резонансной сети и взаимодействует с другими по принципу фазы, частоты и символа. Ниже представлено описание архитектуры каждого модуля.


---

1. rcp_engine.rs
Реализует протокол консенсуса RCP. Определяет согласованность узлов по фазе. Обрабатывает фазовые сигналы, принимает решение по валидности резонансной транзакции.

2. resonance_analyzer.py
Анализирует символы и их частотные характеристики. Оценивает силу, уместность и фазовую совместимость транзакций.

3. dynamic_balance.rs
Изменяет LGN_cost в зависимости от активности узла и общей фазы сети. Используется для сдерживания перегрузок.

4. offline_resonance.py
Позволяет временно работать без подключения к сети. Сохраняет локальную фазу и символическое состояние.

5. phase_intercept_guard.rs
Защита от атак на синхронизацию фазы. Обнаруживает фазовый перехват и устраняет искажения.

6. phase_stabilizer.rs
Стабилизирует фазы при перегрузках и сбоях. Автоматически регулирует входные/выходные колебания Σ(t).

7. inbound_phase_limiter.rs
Ограничивает количество входящих резонансных сигналов. Защищает узел от фазового спама.

8. rLGN_converter.py
Преобразует отражённые токены rLGN в LGN и обратно. Позволяет пользователям работать с легковесной копией смысла.

9. onboarding_ui.py
Визуальный интерфейс принятия фазы. Включает графические элементы, кнопки ритуала "Принять", анимации.

10. phase_integrity.rs
Обеспечивает целостность Σ(t). Проверяет, что фаза не была подменена или искажена по пути.

11. lgn_recall.rs
Механизм отзыва токенов при фазовом диссонансе или нарушении ритуалов.

12. onboarding_sim.py
Симулятор вхождения в резонанс. Используется для обучения новых пользователей.

13. community_dao.yaml
Конфигурация DAO. Определяет миссии, гранты, задания, фазы вознаграждения.

14. ritual_quest.py
Сценарии ритуалов и квестов. Направляют пользователя по фазовым уровням с вознаграждением.

15. phase_scaler.rs
Обеспечивает масштабируемость фаз при росте сети. Поддерживает стабильную резонансную топологию до 10k+ узлов.

16. tx_spam_guard.rs
Фильтр транзакционного шума. Автоматически снижает частоту подозрительных фазовых пакетов.

17. beta_rollout.yaml
План поэтапного запуска сети. Описывает сценарии активации: 10 → 100 → 1000 → 10 000 узлов.

18. rid_builder.py
Генератор RID. Комбинирует символы, архетипы и частоты в полноценный адрес вида ☉??♁@1.618Hz.

19. biosphere_scanner.rs
Сканирует отклик среды (физической и биологической) на активность сети.

20. resonance_feedback.py
Анализирует, как пользователи реагируют на фазы. Учитывает данные поведения, опросы, отклонения.

21. logos_ethics.md
Публичный документ с принципами допустимого влияния сети. Регулирует гармонию, не-вред.

22. node_resonance_profile.rs
Формирует уникальный профиль узла по символу, частоте, роли.

23. resonance_meshmap.yaml
Карта всех узлов в фазовом пространстве. Визуализирует резонансные маршруты.

24. symbolic_firewall.rs
Фильтрует вредоносные символы и частотные сигналы. Использует базу паттернов и самообучение.

25. lgn_entropy_tracker.py
Измеряет смысловую плотность LGN и rLGN. Если резонанс падает — инициирует корректировку.

26. beacon_emitter.rs
Периодическая рассылка сигнала Λ0 в оффлайн-режимах (радио, звук, QR).

27. ritual_engine.rs
Интерпретатор ритуальных состояний. Сопоставляет действия с фазами, запускает события.

28. symbolic_parser.py
Парсит поток входящих символов, проверяет их допустимость, преобразует в резонансный код.

29. chaos_guard.rs
Защищает сеть от случайного уничтожения (chaos-reaction). Требует подтверждения от 80% узлов.

30. genesis_fragment_seeds.rs
Адаптивное шифрование семян ядра. Позволяет восстановление при взломе.

31. auto_init_from_Λ0.py
Восстанавливает сеть по одному символу Λ0. Включает авто-сборку минимальной фазы.

32. satellite_channel.rs
Поддерживает связь через спутники (Iridium, Starlink). Используется при изоляции.

33. test_matrix.xlsx
Матрица нагрузочного тестирования. Хранит сценарии 500+ tx/sec.

34. benchmark_plan.yaml
План публичной демонстрации. Включает тестирование против L1/L2.

35. logos_rpc_api.yaml
Описывает OpenAPI-интерфейс для взаимодействия с внешними системами.

36. user_phase_log.py
Хранит личную фазовую историю пользователя. Применяется для адаптации интерфейса.

37. aura_visualizer.py
Графическая визуализация текущей фазы узла. Используется в UI.

38. anomaly_detector.rs
Обнаруживает аномалии в фазовом поведении узлов. Машинное обучение на фазовых отклонениях.

39. symbolic_bridge.rs
Обеспечивает смысловые мосты с внешними блокчейнами. Использует символы-корреспонденты.

40. soul_binding.yaml
Привязывает LGN к уникальному пользователю через био/психо-подпись.

41. anima_bridge.rs
Связывает сеть LOGOS с внешними AI-сущностями (AGI) через резонансные фреймы.

42. energy_resonator.rs
Подключение физических генераторов/приёмников частот. Используется для экспериментов с полем.

43. harmonics_registry.yaml
База данных допустимых гармоник и их соответствий символам.

44. silent_packet.rs
Передача фазовых пакетов без метаданных. Поддержка полной анонимности.

45. zero_trace_mode.rs
Режим с полным отсутствием следов. Не оставляет логов, маршрутов, IP.

46. resonance_entropy_pool.rs
Фонд смысловой/энергетической энтропии. Поддерживает равновесие Σ(t).

47. semantic_oracle.rs
Система предсказания фаз по внешнему смыслу. Использует поток новостей/данных.

48. phase_vote.rs
Голосование за изменение фазы или активацию ритуала. DAO-механизм.

49. myth_engine.rs
Генератор мифологических структур из фазы. Используется для нарративов.

50. quantum_forge.rs
Модуль квантово-фазовой генерации RID. Использует шум и энтропию из физической среды.

51. phase_backup.rs
Сохраняет состояние сети при глобальных сбоях. Использует многослойное шифрование фазы.

52. env_impact_tracker.py
Оценивает энергопотребление сети и воздействие на окружающую среду. Выдаёт экологический отчёт.

53. legacy_migrator.rs
Позволяет переносить данные, резонансные адреса и смысловые блоки из других блокчейнов в LRB.

54. resonance_tutor.py
Обучающий чат-бот. Объясняет новичкам принципы фаз, символов и ритуалов.

55. maintenance_strategy.yaml
Стратегия долгосрочной поддержки сети: обновления, патчи, ротация модулей.

56. go_to_market.yaml
План выхода на рынок: привлечение первых 10k узлов, листинг на DEX, миссии и коммуникация.



```


## FILE: /root/logos_lrb/infra/nginx/logos-api-lb.conf.example  (size=1809b)
```
server {
    listen 80;
    server_name 45-159-248-232.sslip.io;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    root /opt/logos/www;
    index index.html;

    # Статика: долгий кэш
    location /wallet/ {
        alias /opt/logos/www/wallet/;
        index index.html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # API → узел
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Безопасность
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Permissions-Policy "accelerometer=(),camera=(),geolocation=(),microphone=()" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip/браузерные оптимизации
    gzip on; gzip_types text/plain text/css application/json application/javascript application/octet-stream image/svg+xml;
    gzip_min_length 1024;

    access_log /var/log/nginx/logos_access.log;
    error_log  /var/log/nginx/logos_error.log;
}

```


## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf  (size=2666b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```


## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf.sample  (size=2666b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```


## FILE: /root/logos_lrb/infra/systemd/exec.conf  (size=85b)
```
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: /root/logos_lrb/infra/systemd/keys.conf  (size=226b)
```
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: /root/logos_lrb/infra/systemd/keys.env.example  (size=272b)
```
# Пример (НЕ БОЕВОЙ! замените на свои)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=   # задаётся опционально

```


## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```


## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```


## FILE: /root/logos_lrb/infra/systemd/logos-node.service  (size=369b)
```
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/logos-node.service.sample  (size=3242b)
```
# /etc/systemd/system/logos-node.service
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

# /etc/systemd/system/logos-node.service.d/exec.conf
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/keys.conf
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/override.conf
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

# /etc/systemd/system/logos-node.service.d/runas.conf
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

# /etc/systemd/system/logos-node.service.d/security.conf
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/tuning.conf
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# /etc/systemd/system/logos-node.service.d/zz-consensus.conf
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

# /etc/systemd/system/logos-node.service.d/zz-keys.conf
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/zz-logging.conf
[Service]
Environment=RUST_LOG=info

```


## FILE: /root/logos_lrb/infra/systemd/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.service  (size=271b)
```
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```


## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.timer  (size=163b)
```
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```


## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service  (size=395b)
```
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service.sample  (size=435b)
```
# /etc/systemd/system/lrb-proxy.service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service  (size=378b)
```
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service.sample  (size=420b)
```
# /etc/systemd/system/lrb-scanner.service
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: /root/logos_lrb/infra/systemd/override.conf  (size=575b)
```
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```


## FILE: /root/logos_lrb/infra/systemd/runas.conf  (size=143b)
```
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```


## FILE: /root/logos_lrb/infra/systemd/security.conf  (size=337b)
```
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: /root/logos_lrb/infra/systemd/tuning.conf  (size=156b)
```
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```


## FILE: /root/logos_lrb/infra/systemd/zz-consensus.conf  (size=137b)
```
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```


## FILE: /root/logos_lrb/infra/systemd/zz-keys.conf  (size=417b)
```
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: /root/logos_lrb/infra/systemd/zz-logging.conf  (size=36b)
```
[Service]
Environment=RUST_LOG=info

```


## FILE: /root/logos_lrb/lrb_core/Cargo.toml  (size=665b)
```
[package]
name = "lrb_core"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1"

serde = { version = "1", features = ["derive"] }
serde_json = "1"

sled = "0.34"

ed25519-dalek = { version = "2", features = ["rand_core"] }
bs58 = "0.5"

rayon = "1.10"

# криптография
chacha20poly1305 = { version = "0.10", features = ["std"] }
rand_core = "0.6"
sha2 = "0.10"
hex = "0.4"
base64 = "0.22"
blake3 = "1"

# async / сеть (для beacon.rs)
tokio = { version = "1", features = ["full"] }
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls", "json"] }

# утилиты
uuid = { version = "1", features = ["v4"] }

```


## FILE: /root/logos_lrb/lrb_core/src/anti_replay.rs  (size=980b)
```
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self {
            ttl_ms,
            map: HashMap::new(),
        }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/beacon.rs  (size=1821b)
```
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::time::Duration;
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop {
            t.tick().await;
        }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers
        .iter()
        .any(|p| !(p.starts_with("http://") || p.starts_with("https://")))
    {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```


## FILE: /root/logos_lrb/lrb_core/src/crypto.rs  (size=1617b)
```
// Безопасный AEAD: XChaCha20-Poly1305 с уникальным nonce.
// Формат шифротекста: [24-байт nonce || ciphertext+tag]

use anyhow::Result;
use chacha20poly1305::{
    aead::{Aead, AeadCore, KeyInit, OsRng},
    Key, XChaCha20Poly1305, XNonce,
};

pub struct AeadBox {
    key: Key,
}

impl AeadBox {
    pub fn from_key(key_bytes: &[u8; 32]) -> Self {
        let key = Key::from_slice(key_bytes);
        Self { key: *key }
    }

    pub fn seal(&self, aad: &[u8], plaintext: &[u8]) -> Vec<u8> {
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XChaCha20Poly1305::generate_nonce(&mut OsRng); // 24 байта
        let mut out = Vec::with_capacity(24 + plaintext.len() + 16);
        out.extend_from_slice(&nonce);
        let ct = cipher
            .encrypt(
                &nonce,
                chacha20poly1305::aead::Payload {
                    msg: plaintext,
                    aad,
                },
            )
            .expect("AEAD encrypt failed");
        out.extend_from_slice(&ct);
        out
    }

    pub fn open(&self, aad: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 24 + 16 {
            anyhow::bail!("AEAD: buffer too short");
        }
        let (nonce_bytes, ct) = data.split_at(24);
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XNonce::from_slice(nonce_bytes);
        let pt = cipher
            .decrypt(nonce, chacha20poly1305::aead::Payload { msg: ct, aad })
            .map_err(|_| anyhow::anyhow!("AEAD decrypt failed"))?;
        Ok(pt)
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/dynamic_balance.rs  (size=609b)
```
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self {
            base_cost_microunits: base,
            slope_per_tx: slope,
        }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/heartbeat.rs  (size=2166b)
```
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(
            rid,
            HeartbeatState {
                last_seen_ms: now_ms,
            },
        );
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter()
            .map(|(r, s)| (r.clone(), s.last_seen_ms))
            .collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```


## FILE: /root/logos_lrb/lrb_core/src/ledger.rs  (size=12177b)
```
use crate::types::*;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sled::{Db, IVec, Tree};
use std::convert::TryInto;
use std::path::Path;

// key helpers
fn be64(v: u64) -> [u8; 8] {
    v.to_be_bytes()
}
fn be32(v: u32) -> [u8; 4] {
    v.to_be_bytes()
}
fn rid_str(r: &Rid) -> &str {
    &r.0
}

#[derive(Clone)]
pub struct Ledger {
    #[allow(dead_code)]
    db: Db,

    // balances
    lg_tree: Tree,   // rid -> u64 (BE)
    rlgn_tree: Tree, // rid -> u64 (BE)
    head_tree: Tree, // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree: db.open_tree("lgn")?,
            rlgn_tree: db.open_tree("rlgn")?,
            head_tree: db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree: db.open_tree("txs")?,
            acct_tree: db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self
            .head_tree
            .get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self
            .head_tree
            .get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self
            .head_tree
            .get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(
        &self,
        height: u64,
        hash: &str,
        ts_ms: u128,
        txs: &[Tx],
    ) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx {
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to: rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce: tx.nonce,
                height,
                index: i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1 + txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1 + 8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock {
            height,
            hash: hash.to_string(),
            ts_ms,
            tx_ids: ids,
        };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1 + 8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self
            .blocks_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredBlock>(&v))
            .transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1 + txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self
            .tx_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredTx>(&v))
            .transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(
        &self,
        rid: &str,
        limit: usize,
        cursor: Option<String>,
    ) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a");
            k.extend_from_slice(rid.as_bytes());
            k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage {
            rid: rid.to_string(),
            items,
            next_cursor,
        })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? {
            return Ok(false);
        }
        self.head_tree
            .insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        if cur < amt {
            anyhow::bail!("insufficient rLGN");
        }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k = rid_str(&tx.to).as_bytes();

            let from_bal = self
                .lg_tree
                .get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);
            if from_bal < tx.amount {
                anyhow::bail!("insufficient funds");
            }
            let to_bal = self
                .lg_tree
                .get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k, &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h {
                Ok(BlockHeaderView {
                    block_hash: head_hash,
                })
            } else {
                anyhow::bail!("block not found")
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockHeaderView {
    pub block_hash: String,
}

```


## FILE: /root/logos_lrb/lrb_core/src/lib.rs  (size=727b)
```
/*!
 * LOGOS LRB — core crate
 * Экспорт модулей ядра L1: типы, консенсус, мемпул/баланс, резонанс, сигналы, защита.
 * Здесь только декларация модулей — реализация в соответствующих *.rs файлах.
 */

pub mod types;

pub mod anti_replay;
pub mod beacon;
pub mod heartbeat;

pub mod dynamic_balance;
pub mod spam_guard;

pub mod phase_consensus;
pub mod phase_filters;
pub mod phase_integrity;
pub mod quorum;
pub mod sigpool;

pub mod ledger;
pub mod rcp_engine;
pub mod resonance;

// Безопасный AEAD (XChaCha20-Poly1305) — общий хелпер для модулей
pub mod crypto;

```


## FILE: /root/logos_lrb/lrb_core/src/nano.114024.save  (size=11306b)
```
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

// лёгкий view для register_vote
pub struct BlockHeaderView {
    pub block_hash: String,
}

```


## FILE: /root/logos_lrb/lrb_core/src/phase_consensus.rs  (size=1806b)
```
use std::collections::{HashMap, HashSet};

/// Фазовый консенсус Σ(t) с учётом блока (height, block_hash).
/// Накапливает голоса RID'ов по конкретному хешу блока.
/// Финализованный height повышается, когда кворум собран по **одному** хешу на этом height.
pub struct PhaseConsensus {
    /// votes[height][block_hash] = {rid_b58, ...}
    votes: HashMap<u64, HashMap<String, HashSet<String>>>,
    finalized_h: u64,
    quorum_n: usize,
}

impl PhaseConsensus {
    pub fn new(quorum_n: usize) -> Self {
        Self {
            votes: HashMap::new(),
            finalized_h: 0,
            quorum_n,
        }
    }

    pub fn quorum_n(&self) -> usize {
        self.quorum_n
    }
    pub fn finalized(&self) -> u64 {
        self.finalized_h
    }

    /// Регистрируем голос. Возвращает Some((h,hash)) если по hash достигнут кворум.
    pub fn vote(&mut self, h: u64, block_hash: &str, rid_b58: &str) -> Option<(u64, String)> {
        let by_hash = self.votes.entry(h).or_default();
        let set = by_hash.entry(block_hash.to_string()).or_default();
        set.insert(rid_b58.to_string());
        if set.len() >= self.quorum_n {
            if h > self.finalized_h {
                self.finalized_h = h;
            }
            return Some((h, block_hash.to_string()));
        }
        None
    }

    /// Сколько голосов у конкретного (h,hash)
    #[allow(dead_code)]
    pub fn votes_for(&self, h: u64, block_hash: &str) -> usize {
        self.votes
            .get(&h)
            .and_then(|m| m.get(block_hash))
            .map(|s| s.len())
            .unwrap_or(0)
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/phase_filters.rs  (size=1780b)
```
use crate::types::Block;

/// Простые фазовые фильтры на основе гармоник Λ0.
/// ENV (всё опционально):
///  LRB_PHASE_EN=1|0                     (вкл/выкл, по умолчанию 1)
///  LRB_PHASE_FREQS_HZ="7.83,1.618,432"  (частоты, через запятую)
///  LRB_PHASE_MIN_SCORE=-0.20            (порог принятия от -1.0 до 1.0)
///
/// Идея: время блока b.timestamp_ms в секундах подаётся в сумму косинусов.
/// score = avg_i cos(2π f_i * t)
/// Пропускаем, если score >= MIN_SCORE.
fn phase_enabled() -> bool {
    std::env::var("LRB_PHASE_EN")
        .ok()
        .map(|v| v == "1")
        .unwrap_or(true)
}
fn parse_freqs() -> Vec<f64> {
    let def = "7.83,1.618,432";
    let raw = std::env::var("LRB_PHASE_FREQS_HZ").unwrap_or_else(|_| def.to_string());
    raw.split(',')
        .filter_map(|s| s.trim().parse::<f64>().ok())
        .collect::<Vec<_>>()
}
fn min_score() -> f64 {
    std::env::var("LRB_PHASE_MIN_SCORE")
        .ok()
        .and_then(|s| s.parse::<f64>().ok())
        .unwrap_or(-0.20)
}

fn phase_score_ts_ms(ts_ms: u128) -> f64 {
    let t = ts_ms as f64 / 1000.0;
    let freqs = parse_freqs();
    if freqs.is_empty() {
        return 1.0;
    }
    let two_pi = std::f64::consts::TAU; // 2π
    let mut acc = 0.0;
    for f in &freqs {
        acc += (two_pi * *f * t).cos();
    }
    acc / (freqs.len() as f64)
}

/// Главный фильтр на блок: пропускает, если фазовый скор >= порога
pub fn block_passes_phase(b: &Block) -> bool {
    if !phase_enabled() {
        return true;
    }
    phase_score_ts_ms(b.timestamp_ms) >= min_score()
}

```


## FILE: /root/logos_lrb/lrb_core/src/phase_integrity.rs  (size=553b)
```
use crate::types::*;
use anyhow::{anyhow, Result};
use ed25519_dalek::Verifier as _; // для pk.verify(&msg, &sig)

pub fn verify_tx_signature(tx: &Tx) -> Result<()> {
    tx.validate_shape()?;

    let pk = crate::types::parse_pubkey(&tx.public_key)?;
    let sig = crate::types::parse_sig(&tx.signature)?;
    let msg = tx.canonical_bytes();

    pk.verify(&msg, &sig)
        .map_err(|e| anyhow!("bad signature: {e}"))?;

    // сверяем id
    if tx.id != tx.compute_id() {
        return Err(anyhow!("tx id mismatch"));
    }
    Ok(())
}

```


## FILE: /root/logos_lrb/lrb_core/src/quorum.rs  (size=1250b)
```
use anyhow::Result;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub block_hash: String,
    pub sigma_hex: String,
    pub voter_pk_b58: String,
    pub sig_b64: String,
    pub nonce_ms: u128,
}

pub fn verify_vote(v: &Vote) -> Result<()> {
    let pk_bytes = bs58::decode(&v.voter_pk_b58).into_vec()?;
    let vk =
        VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(v.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(
        &sig_bytes
            .try_into()
            .map_err(|_| anyhow::anyhow!("bad sig"))?,
    );

    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    vk.verify(&payload, &sig)
        .map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

```


## FILE: /root/logos_lrb/lrb_core/src/rcp_engine.rs  (size=7224b)
```
use crate::sigpool::filter_valid_sigs_parallel;
use crate::{dynamic_balance::DynamicBalance, ledger::Ledger, spam_guard::SpamGuard, types::*};
use crate::{phase_consensus::PhaseConsensus, phase_filters::block_passes_phase};
use anyhow::Result;
use std::{
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::sync::{
    broadcast,
    mpsc::{unbounded_channel, UnboundedSender},
};

// точный монотонный ts для индексации
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

fn env_u64(key: &str, def: u64) -> u64 {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(def)
}
fn env_usize(key: &str, def: usize) -> usize {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(def)
}

#[derive(Clone)]
pub struct Engine {
    ledger: Arc<Ledger>,
    guard: SpamGuard,
    dyn_cost: DynamicBalance,
    proposer: Rid,
    mempool_tx: UnboundedSender<Tx>,
    mempool: Arc<Mutex<Vec<Tx>>>,
    commit_tx: Arc<Mutex<Option<broadcast::Sender<Block>>>>,

    slot_ms: u64,
    sig_workers: usize,
    consensus: Arc<Mutex<PhaseConsensus>>,
}

impl Engine {
    pub fn new(ledger: Ledger, proposer: Rid) -> Arc<Self> {
        let mempool_cap = env_u64("LRB_MEMPOOL_CAP", 100_000);
        let max_block_tx = env_u64("LRB_MAX_BLOCK_TX", 10_000);
        let max_amount = env_u64("LRB_MAX_AMOUNT", u64::MAX / 2);
        let slot_ms = env_u64("LRB_SLOT_MS", 500);
        let quorum_n = env_usize("LRB_QUORUM_N", 1);
        let sig_workers = env_usize("LRB_SIG_WORKERS", 4);

        let mempool: Arc<Mutex<Vec<Tx>>> = Arc::new(Mutex::new(Vec::new()));
        let (tx, rx) = unbounded_channel::<Tx>();

        let engine = Arc::new(Self {
            ledger: Arc::new(ledger),
            guard: SpamGuard::new(mempool_cap as usize, max_block_tx as usize, max_amount),
            dyn_cost: DynamicBalance::new(100, 2),
            proposer,
            mempool_tx: tx.clone(),
            mempool: mempool.clone(),
            commit_tx: Arc::new(Mutex::new(None)),
            slot_ms,
            sig_workers,
            consensus: Arc::new(Mutex::new(PhaseConsensus::new(quorum_n))),
        });

        // приём транзакций в mempool с лимитами
        let guard = engine.guard.clone();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Some(tx) = rx.recv().await {
                let mut lock = mempool.lock().unwrap();
                if guard.check_mempool(lock.len()).is_ok() {
                    lock.push(tx);
                }
            }
        });

        engine
    }

    pub fn ledger(&self) -> Arc<Ledger> {
        self.ledger.clone()
    }
    pub fn proposer(&self) -> Rid {
        self.proposer.clone()
    }
    pub fn set_commit_notifier(&self, sender: broadcast::Sender<Block>) {
        *self.commit_tx.lock().unwrap() = Some(sender);
    }
    pub fn check_amount_valid(&self, amount: u64) -> Result<()> {
        self.guard.check_amount(amount)
    }
    pub fn mempool_sender(&self) -> UnboundedSender<Tx> {
        self.mempool_tx.clone()
    }
    pub fn mempool_len(&self) -> usize {
        self.mempool.lock().unwrap().len()
    }
    pub fn finalized_height(&self) -> u64 {
        self.consensus.lock().unwrap().finalized()
    }

    pub fn register_vote(&self, height: u64, block_hash: &str, rid_b58: &str) -> bool {
        let mut cons = self.consensus.lock().unwrap();
        if let Some((h, voted_hash)) = cons.vote(height, block_hash, rid_b58) {
            if let Ok(local) = self.ledger.get_block_by_height(h) {
                if local.block_hash == voted_hash {
                    let _ = self.ledger.set_finalized(h);
                    return true;
                }
            }
        }
        false
    }

    pub async fn run_block_producer(self: Arc<Self>) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(self.slot_ms));

        loop {
            interval.tick().await;

            // 1) забираем пачку из мемпула
            let raw = {
                let mut mp = self.mempool.lock().unwrap();
                if mp.is_empty() {
                    continue;
                }
                let take = self.guard.max_block_txs().min(mp.len());
                mp.drain(0..take).collect::<Vec<Tx>>()
            };

            // 2) проверка подписей параллельно
            let mut valid = filter_valid_sigs_parallel(raw, self.sig_workers).await;
            if valid.is_empty() {
                continue;
            }

            // 3) базовые лимиты/amount
            valid.retain(|t| self.guard.check_amount(t.amount).is_ok());
            if valid.is_empty() {
                continue;
            }

            // 4) формируем блок (h+1)
            let (h, prev_hash) = self.ledger.head().unwrap_or((0, String::new()));
            let b = Block::new(h + 1, prev_hash, self.proposer.clone(), valid);

            // 5) фазовый фильтр (резонанс). Если не прошёл — НЕ теряем tx: возвращаем в хвост mempool.
            if !block_passes_phase(&b) {
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter()); // вернуть в очередь, обработаем в следующем слоте
                continue;
            }

            // 6) атомарный коммит блока
            if let Err(e) = self.ledger.commit_block_atomic(&b) {
                // при ошибке — вернуть tx в mempool и идти дальше
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter());
                eprintln!("commit_block_atomic error at height {}: {:?}", b.height, e);
                continue;
            }

            // 7) индексирование блока для истории/эксплорера (не мешает продюсеру)
            let ts = now_ms();
            if let Err(e) = self.ledger.index_block(b.height, &b.block_hash, ts, &b.txs) {
                // индексация не должна ломать производство блоков
                eprintln!("index_block error at height {}: {:?}", b.height, e);
            }

            // 8) локальный голос и уведомление подписчикам
            let _ = self.register_vote(b.height, &b.block_hash, self.proposer.as_str());
            if let Some(tx) = self.commit_tx.lock().unwrap().as_ref() {
                let _ = tx.send(b.clone());
            }
        }
    }

    pub fn lgn_cost_microunits(&self) -> u64 {
        self.dyn_cost.lgn_cost(self.mempool_len() as usize)
    }
}

pub fn engine_with_channels(ledger: Ledger, proposer: Rid) -> (Arc<Engine>, UnboundedSender<Tx>) {
    let engine = Engine::new(ledger, proposer);
    let sender = engine.mempool_sender();
    (engine, sender)
}

```


## FILE: /root/logos_lrb/lrb_core/src/resonance.rs  (size=1146b)
```
use crate::types::{Block, Tx};
use blake3::Hasher;

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS {
        h.update(tag);
    }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs {
        mix_tx(&mut h, tx)
    }
    hex::encode(h.finalize().as_bytes())
}

```


## FILE: /root/logos_lrb/lrb_core/src/sigpool.rs  (size=1072b)
```
use crate::phase_integrity::verify_tx_signature;
use crate::types::Tx;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() {
        return txs;
    }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res {
            out.append(&mut v);
        }
    }
    out
}

```


## FILE: /root/logos_lrb/lrb_core/src/spam_guard.rs  (size=839b)
```
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self {
            max_mempool,
            max_tx_per_block,
            max_amount,
        }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize {
        self.max_tx_per_block
    }
}

```


## FILE: /root/logos_lrb/lrb_core/src/types.rs  (size=3363b)
```
use anyhow::{anyhow, Result};
use blake3::Hasher;
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// base64 v0.22 Engine API
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;

pub type Amount = u64;
pub type Height = u64;
pub type Nonce = u64;

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Rid(pub String); // base58(VerifyingKey)

impl Rid {
    pub fn from_pubkey(pk: &VerifyingKey) -> Self {
        Rid(bs58::encode(pk.to_bytes()).into_string())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Tx {
    pub id: String, // blake3 of canonical form
    pub from: Rid,  // base58(pubkey)
    pub to: Rid,
    pub amount: Amount,
    pub nonce: Nonce,
    pub public_key: Vec<u8>, // 32 bytes (VerifyingKey)
    pub signature: Vec<u8>,  // 64 bytes (Signature)
}

impl Tx {
    pub fn canonical_bytes(&self) -> Vec<u8> {
        // Без id и signature для детерминированного хеша
        let m = serde_json::json!({
            "from": self.from.as_str(),
            "to": self.to.as_str(),
            "amount": self.amount,
            "nonce": self.nonce,
            "public_key": B64.encode(&self.public_key),
        });
        serde_json::to_vec(&m).expect("canonical json")
    }
    pub fn compute_id(&self) -> String {
        let mut hasher = Hasher::new();
        hasher.update(&self.canonical_bytes());
        hex::encode(hasher.finalize().as_bytes())
    }
    pub fn validate_shape(&self) -> Result<()> {
        if self.public_key.len() != 32 {
            return Err(anyhow!("bad pubkey len"));
        }
        if self.signature.len() != 64 {
            return Err(anyhow!("bad signature len"));
        }
        if self.amount == 0 {
            return Err(anyhow!("amount must be > 0"));
        }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: Height,
    pub prev_hash: String,
    pub timestamp_ms: u128,
    pub proposer: Rid,
    pub txs: Vec<Tx>,
    pub block_hash: String,
    pub uuid: String, // для логов
}

impl Block {
    pub fn new(height: Height, prev_hash: String, proposer: Rid, txs: Vec<Tx>) -> Self {
        let ts = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis();
        let mut h = Hasher::new();
        h.update(prev_hash.as_bytes());
        h.update(proposer.as_str().as_bytes());
        for tx in &txs {
            h.update(tx.id.as_bytes());
        }
        h.update(&ts.to_le_bytes());
        let block_hash = hex::encode(h.finalize().as_bytes());
        Block {
            height,
            prev_hash,
            timestamp_ms: ts,
            proposer,
            txs,
            block_hash,
            uuid: Uuid::new_v4().to_string(),
        }
    }
}

pub fn parse_pubkey(pk: &[u8]) -> Result<VerifyingKey> {
    let arr: [u8; 32] = pk.try_into().map_err(|_| anyhow!("bad pubkey len"))?;
    Ok(VerifyingKey::from_bytes(&arr)?)
}

pub fn parse_sig(sig: &[u8]) -> Result<Signature> {
    let arr: [u8; 64] = sig.try_into().map_err(|_| anyhow!("bad signature len"))?;
    Ok(Signature::from_bytes(&arr))
}

```


## FILE: /root/logos_lrb/modules/beacon_emitter.rs  (size=4455b)
```
use axum::{
    extract::State,
    routing::{get, post},
    Router,
};
use std::{net::SocketAddr, time::Duration};
use tower::{ServiceBuilder};
use tower_http::{
    cors::{Any, CorsLayer},
    trace::TraceLayer,
    timeout::TimeoutLayer,
    limit::{RequestBodyLimitLayer},
};
use tracing_subscriber::{EnvFilter, fmt};
use ed25519_dalek::{SigningKey, VerifyingKey, SignatureError};
use rand_core::OsRng;
use bs58;
use once_cell::sync::OnceCell;
use anyhow::Result;

mod api;
mod admin;
mod bridge;
mod gossip;
mod state;
mod peers;
mod fork;

#[derive(Clone)]
struct AppState {
    signing: SigningKey,
    verifying: VerifyingKey,
    rid_b58: String,
    admin_key: String,
    bridge_key: String,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(bytes.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(data.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}

fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}

fn read_env_required(n: &str) -> Result<String> {
    let v = std::env::var(n).map_err(|_| anyhow::anyhow!("missing env {}", n))?;
    Ok(v)
}

fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY","CHANGE_ME","", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // tracing
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    // keys + env
    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid = rid_from_vk(&vk);

    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    let state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid.clone(),
        admin_key,
        bridge_key,
    };
    APP_STATE.set(state.clone()).unwrap();

    // CORS
    let cors = {
        let allowed_origin = std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| String::from("https://wallet.example"));
        CorsLayer::new()
            .allow_origin(allowed_origin.parse::<axum::http::HeaderValue>().unwrap())
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([axum::http::header::CONTENT_TYPE, axum::http::header::AUTHORIZATION])
    };

    // limits/timeout
    let layers = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(RequestBodyLimitLayer::new(512 * 1024)) // 512 KiB
        .layer(cors)
        .into_inner();

    // маршруты
    let app = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet)) // dev-only
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify))
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .with_state(state)
        .layer(layers);

    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    tracing::info!("logos_node listening on {} (RID={})", addr, rid);
    axum::serve(tokio::net::TcpListener::bind(addr).await?, app).await?;
    Ok(())
}

```


## FILE: /root/logos_lrb/modules/env_impact_tracker.py  (size=5447b)
```
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```


## FILE: /root/logos_lrb/modules/external_phase_broadcaster.rs  (size=1588b)
```
//! Внешний широковещатель фаз: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseBroadcaster {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl PhaseBroadcaster {
    pub fn new(key32: [u8;32], self_vk: VerifyingKey) -> Self {
        Self { aead: AeadBox::from_key(&key32), self_vk }
    }

    pub fn pack(&self, signer: &SigningKey, topic: &[u8], payload: &[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64 + sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unpack(&self, sender_vk: &VerifyingKey, topic: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_bcast: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_bcast: bad signature"))?;

        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let pt = self.aead.open(&aad, sealed)?;
        Ok(pt)
    }
}

```


## FILE: /root/logos_lrb/modules/external_phase_link.rs  (size=1719b)
```
//! Точка-точка фазовая связка: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseLink {
    aead: AeadBox,
    self_vk: VerifyingKey,
    peer_vk: VerifyingKey,
}

impl PhaseLink {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey, peer_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk, peer_vk }
    }

    pub fn encode(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_link: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_link: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/genesis_fragment_seeds.rs  (size=1423b)
```
//! Genesis Fragment Seeds: шифрованное хранение фрагментов seed.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct SeedVault { aead:AeadBox, self_vk:VerifyingKey }

impl SeedVault {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn pack_fragment(&self, signer:&SigningKey, label:&[u8], fragment:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, fragment); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unpack_fragment(&self, sender_vk:&VerifyingKey, label:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("seed_vault: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("seed_vault: bad sig"))?;
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/go_to_market.yaml  (size=3633b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```


## FILE: /root/logos_lrb/modules/heartbeat_monitor.rs  (size=1489b)
```
//! Heartbeat Monitor — безопасные heartbeat-кадры между узлами (AEAD+подпись).

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

#[derive(Clone)]
pub struct HeartbeatMonitor { aead:AeadBox, self_vk:VerifyingKey }

impl HeartbeatMonitor {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn encode_ping(&self, signer:&SigningKey, channel:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, payload); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("heartbeat: short frame"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("heartbeat: bad signature"))?;
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/legacy_migrator.rs  (size=1432b)
```
//! Legacy Migrator: перенос артефактов со шифрованием и подписью.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct LegacyMigrator { aead:AeadBox, self_vk:VerifyingKey }

impl LegacyMigrator {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn wrap_blob(&self, signer:&SigningKey, kind:&[u8], blob:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, blob); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unwrap_blob(&self, sender_vk:&VerifyingKey, kind:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("legacy_migrator: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("legacy_migrator: bad sig"))?;
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/maintenance_strategy.yaml  (size=2361b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```


## FILE: /root/logos_lrb/modules/resonance_analytics_frontend.tsx  (size=4632b)
```
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```


## FILE: /root/logos_lrb/modules/resonance_emergency_plan.yaml  (size=3420b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```


## FILE: /root/logos_lrb/modules/resonance_meshmap.yaml  (size=1877b)
```
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```


## FILE: /root/logos_lrb/modules/resonance_tutor.py  (size=6414b)
```
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```


## FILE: /root/logos_lrb/modules/ritual_engine.rs  (size=1460b)
```
//! Ritual Engine: доставка «ритуальных» сообщений c фазовой меткой, AEAD+подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct RitualEngine { aead:AeadBox, self_vk:VerifyingKey }

impl RitualEngine {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn send(&self, signer:&SigningKey, phase_id:&[u8], msg:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, msg); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn recv(&self, sender_vk:&VerifyingKey, phase_id:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("ritual_engine: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("ritual_engine: bad sig"))?;
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/symbolic_parser.py  (size=4615b)
```
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```


## FILE: /root/logos_lrb/modules/uplink_controller.rs  (size=1571b)
```
//! Uplink Controller: надёжная упаковка кадров uplink → core.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkController {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkController {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn encode_frame(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_controller: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_controller: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/modules/uplink_router.rs  (size=1551b)
```
//! Uplink Router: безопасная пересылка кадров между маршрутами.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkRouter {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkRouter {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn wrap(&self, signer:&SigningKey, route:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unwrap(&self, sender_vk:&VerifyingKey, route:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_router: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_router: bad signature"))?;

        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```


## FILE: /root/logos_lrb/node/Cargo.toml  (size=1014b)
```
[package]
name = "logos_node"
version = "0.1.0"
edition = "2021"
build = "build.rs"

[dependencies]
axum = { version = "0.7", features = ["macros", "http2"] }
tokio = { version = "1", features = ["full"] }
tower = "0.4"
tower-http = { version = "0.5", features = ["cors", "trace", "timeout", "limit"] }
hyper = { version = "1", features = ["http2"] }
http = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
thiserror = "1"
tracing = "0.1"
tracing-subscriber = { version = "0.3", features=["env-filter", "fmt"] }
ed25519-dalek = { version = "2", features = ["rand_core"] }
rand_core = "0.6"
bs58 = "0.5"
anyhow = "1"
once_cell = "1"
prometheus = "0.13"
hex = "0.4"
base64 = "0.22"
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls", "json"] }
blake3 = "1"
sled = "0.34"
dashmap = "5"
parking_lot = "0.12"
ipnet = "2"

# ядро
lrb_core = { path = "../lrb_core" }

[build-dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock"] }

```


## FILE: /root/logos_lrb/node/build.rs  (size=796b)
```
use std::process::Command;

fn main() {
    // git hash (короткий)
    let git = Command::new("git")
        .args(["rev-parse", "--short", "HEAD"])
        .output()
        .ok()
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .map(|s| s.trim().to_string())
        .unwrap_or_else(|| "unknown".into());
    println!("cargo:rustc-env=GIT_COMMIT={}", git);

    // build time (UTC)
    let ts = chrono::Utc::now().to_rfc3339();
    println!("cargo:rustc-env=BUILD_TIME_UTC={}", ts);

    // rustc version
    let rustc = Command::new("rustc")
        .arg("--version")
        .output()
        .ok()
        .and_then(|o| String::from_utf8(o.stdout).ok())
        .unwrap_or_else(|| "rustc unknown".into());
    println!("cargo:rustc-env=RUSTC_VER={}", rustc.trim());
}

```


## FILE: /root/logos_lrb/node/src/JSON  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/LE  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/admin.rs  (size=1627b)
```
//! Админ-ручки: snapshot/restore и node_info.
//! Доступ защищается через заголовок X-Admin-Key = LRB_ADMIN_KEY.

use crate::AppState;
use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

fn check_admin(st: &AppState, headers: &axum::http::HeaderMap) -> Result<(), StatusCode> {
    let got = headers
        .get("X-Admin-Key")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("");
    if got == st.admin_key {
        Ok(())
    } else {
        Err(StatusCode::UNAUTHORIZED)
    }
}

#[derive(Serialize)]
pub struct NodeInfo {
    pub rid: String,
    pub height: u64,
    pub finalized: bool,
}

pub async fn node_info(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<NodeInfo>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(NodeInfo {
        rid: st.rid_b58.clone(),
        height: 0,
        finalized: false,
    }))
}

#[derive(Serialize)]
pub struct SnapshotResp {
    pub status: &'static str,
}

pub async fn snapshot(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

#[derive(Deserialize)]
#[allow(dead_code)]
pub struct RestoreReq {
    #[serde(default)]
    pub path: String,
}

pub async fn restore(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(_req): Json<RestoreReq>,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

```


## FILE: /root/logos_lrb/node/src/api.rs  (size=13341b)
```
use axum::{
    extract::{Path, Query, State},
    http::StatusCode,
    Json,
};
use hex;
use serde::{Deserialize, Serialize};
use serde_json;

use crate::metrics::{inc_total, Timer};
use crate::storage::{AccountState, TxIn};
use crate::AppState;

use bs58;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use parking_lot::Mutex;
use std::collections::{BTreeMap, HashMap};
use std::sync::Arc;

/* ========= liveness / readiness ========= */

#[derive(Serialize)]
pub struct Healthz {
    pub status: &'static str,
}

pub async fn healthz() -> Json<Healthz> {
    Json(Healthz { status: "ok" })
}
pub async fn livez() -> Json<Healthz> {
    Json(Healthz { status: "ok" })
}
pub async fn readyz(State(_st): State<AppState>) -> Result<Json<Healthz>, StatusCode> {
    let t = Timer::new("/readyz", "GET");
    inc_total("/readyz", "GET", StatusCode::OK);
    t.observe();
    Ok(Json(Healthz { status: "ready" }))
}

/* ========= helpers ========= */

#[derive(Serialize, Deserialize, Clone)]
struct CanonTx<'a> {
    from: &'a str,
    to: &'a str,
    amount: u64,
    nonce: u64,
}

fn canon_bytes(tx: &TxIn) -> Result<Vec<u8>, StatusCode> {
    let c = CanonTx {
        from: &tx.from,
        to: &tx.to,
        amount: tx.amount,
        nonce: tx.nonce,
    };
    serde_json::to_vec(&c).map_err(|_| StatusCode::BAD_REQUEST)
}
fn vk_from_rid(rid: &str) -> Result<VerifyingKey, StatusCode> {
    let b = bs58::decode(rid)
        .into_vec()
        .map_err(|_| StatusCode::BAD_REQUEST)?;
    if b.len() != 32 {
        return Err(StatusCode::BAD_REQUEST);
    }
    VerifyingKey::from_bytes(b.as_slice().try_into().unwrap()).map_err(|_| StatusCode::BAD_REQUEST)
}
fn sig_from_hex(h: &str) -> Result<Signature, StatusCode> {
    let raw = hex::decode(h).map_err(|_| StatusCode::BAD_REQUEST)?;
    let arr: [u8; 64] = raw
        .as_slice()
        .try_into()
        .map_err(|_| StatusCode::BAD_REQUEST)?;
    Ok(Signature::from_bytes(&arr))
}

/* ========= head / balance ========= */

#[derive(Serialize)]
pub struct HeadResp {
    pub height: u64,
    pub finalized: bool,
}

pub async fn head(State(st): State<AppState>) -> Json<HeadResp> {
    let t = Timer::new("/head", "GET");
    let h = st.store.get_height().unwrap_or(0);
    inc_total("/head", "GET", StatusCode::OK);
    t.observe();
    Json(HeadResp {
        height: h,
        finalized: false,
    })
}

#[derive(Serialize)]
pub struct BalanceResp {
    pub rid: String,
    pub balance: u64,
    pub nonce: u64,
}

pub async fn balance(State(st): State<AppState>, Path(rid): Path<String>) -> Json<BalanceResp> {
    let t = Timer::new("/balance/:rid", "GET");
    let a = st.store.get_account(&rid).unwrap_or_default();
    inc_total("/balance/:rid", "GET", StatusCode::OK);
    t.observe();
    Json(BalanceResp {
        rid,
        balance: a.balance,
        nonce: a.nonce,
    })
}

/* ========= history / block ========= */

#[derive(Deserialize)]
pub struct HistoryQuery {
    #[serde(default)]
    pub from: u64,
    #[serde(default = "def_limit")]
    pub limit: usize,
}
fn def_limit() -> usize {
    20
}

#[derive(Serialize)]
pub struct HistoryResp {
    pub rid: String,
    pub from: u64,
    pub limit: usize,
    pub next_from: Option<u64>,
    pub items: Vec<crate::storage::HistoryItem>,
}

pub async fn history(
    State(st): State<AppState>,
    Path(rid): Path<String>,
    Query(q): Query<HistoryQuery>,
) -> Result<Json<HistoryResp>, StatusCode> {
    let t = Timer::new("/history/:rid", "GET");
    let (items, next_from) = st
        .store
        .history_page(&rid, q.from, q.limit.min(1000))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/history/:rid", "GET", StatusCode::OK);
    t.observe();
    Ok(Json(HistoryResp {
        rid,
        from: q.from,
        limit: q.limit,
        next_from,
        items,
    }))
}

#[derive(Serialize)]
pub struct BlockResp {
    pub height: u64,
    pub ts_ms: u64,
    pub txs: Vec<TxIn>,
}

pub async fn block(
    State(st): State<AppState>,
    Path(h): Path<u64>,
) -> Result<Json<BlockResp>, StatusCode> {
    let t = Timer::new("/block/:height", "GET");
    let br = st
        .store
        .get_block(h)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let br = br.ok_or(StatusCode::NOT_FOUND)?;
    inc_total("/block/:height", "GET", StatusCode::OK);
    t.observe();
    Ok(Json(BlockResp {
        height: br.height,
        ts_ms: br.ts_ms,
        txs: br.txs,
    }))
}

/* ========= submit_tx / batch (strict prefix per RID) ========= */

#[derive(Deserialize)]
pub struct SubmitTxBatchReq {
    #[serde(default)]
    pub txs: Vec<TxIn>,
}
#[derive(Serialize)]
pub struct TxResult {
    pub idx: usize,
    pub status: &'static str,
    pub code: u16,
    pub reason: &'static str,
}
#[derive(Serialize)]
pub struct SubmitTxBatchResp {
    pub accepted: usize,
    pub rejected: usize,
    pub new_height: u64,
    pub results: Vec<TxResult>,
}

pub async fn submit_tx_batch(
    State(st): State<AppState>,
    Json(req): Json<SubmitTxBatchReq>,
) -> Result<Json<SubmitTxBatchResp>, StatusCode> {
    let t = Timer::new("/submit_tx_batch", "POST");
    if req.txs.is_empty() {
        inc_total("/submit_tx_batch", "POST", StatusCode::BAD_REQUEST);
        t.observe();
        return Err(StatusCode::BAD_REQUEST);
    }

    let mut by_sender: BTreeMap<String, Vec<(usize, TxIn)>> = BTreeMap::new();
    for (i, tx) in req.txs.into_iter().enumerate() {
        by_sender.entry(tx.from.clone()).or_default().push((i, tx));
    }

    let mut results = Vec::new();
    let mut acc_total = 0usize;
    let mut rej_total = 0usize;
    let mut last_h = st.store.get_height().unwrap_or(0);

    for (from, mut items) in by_sender.into_iter() {
        items.sort_by_key(|(_, tx)| tx.nonce);
        let lk = st
            .locks
            .entry(from.clone())
            .or_insert_with(|| Arc::new(Mutex::new(())))
            .clone();
        let _g = lk.lock();
        let mut next = st.store.get_account(&from).unwrap_or_default().nonce;
        let mut cache: HashMap<String, AccountState> = HashMap::new();
        let mut valid: Vec<TxIn> = Vec::new();

        for (idx, tx) in items.into_iter() {
            // подпись
            let vk = match vk_from_rid(&tx.from) {
                Ok(v) => v,
                Err(_) => {
                    rej_total += 1;
                    results.push(TxResult {
                        idx,
                        status: "rejected",
                        code: 400,
                        reason: "bad_rid",
                    });
                    inc_tx_err();
                    continue;
                }
            };
            let sig = match sig_from_hex(&tx.sig_hex) {
                Ok(s) => s,
                Err(_) => {
                    rej_total += 1;
                    results.push(TxResult {
                        idx,
                        status: "rejected",
                        code: 401,
                        reason: "bad_sig",
                    });
                    inc_tx_err();
                    continue;
                }
            };
            let msg = match canon_bytes(&tx) {
                Ok(m) => m,
                Err(_) => {
                    rej_total += 1;
                    results.push(TxResult {
                        idx,
                        status: "rejected",
                        code: 400,
                        reason: "bad_canon",
                    });
                    inc_tx_err();
                    continue;
                }
            };
            if vk.verify(&msg, &sig).is_err() {
                rej_total += 1;
                results.push(TxResult {
                    idx,
                    status: "rejected",
                    code: 401,
                    reason: "bad_sig",
                });
                inc_tx_err();
                continue;
            }

            // nonce строгий префикс
            if tx.nonce != next.saturating_add(1) {
                rej_total += 1;
                results.push(TxResult {
                    idx,
                    status: "rejected",
                    code: 409,
                    reason: "bad_nonce",
                });
                inc_tx_err();
                continue;
            }

            // баланс
            let fs = cache
                .get(&tx.from)
                .cloned()
                .unwrap_or_else(|| st.store.get_account(&tx.from).unwrap_or_default());
            let ts = cache
                .get(&tx.to)
                .cloned()
                .unwrap_or_else(|| st.store.get_account(&tx.to).unwrap_or_default());
            if tx.from != tx.to && fs.balance < tx.amount {
                rej_total += 1;
                results.push(TxResult {
                    idx,
                    status: "rejected",
                    code: 402,
                    reason: "insufficient_funds",
                });
                inc_tx_err();
                continue;
            }

            // применяем в кэше
            let mut nf = fs;
            let mut nt = ts;
            next = next.saturating_add(1);
            nf.nonce = next;
            if tx.from != tx.to {
                nf.balance = nf.balance.saturating_sub(tx.amount);
                nt.balance = nt.balance.saturating_add(tx.amount);
            }
            cache.insert(tx.from.clone(), nf);
            cache.insert(tx.to.clone(), nt);

            valid.push(tx);
            acc_total += 1;
            results.push(TxResult {
                idx,
                status: "accepted",
                code: 0,
                reason: "ok",
            });
        }

        if !valid.is_empty() {
            last_h = st
                .store
                .apply_batch(&valid)
                .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
        }
    }

    let resp = SubmitTxBatchResp {
        accepted: acc_total,
        rejected: rej_total,
        new_height: last_h,
        results,
    };
    inc_total("/submit_tx_batch", "POST", StatusCode::OK);
    t.observe();
    Ok(Json(resp))
}

// локальный счётчик для кратких метрик отказов в батче
#[inline]
fn inc_tx_err() { /* опционально можно дернуть метрику отказов */
}

/* ========= одиночная submit_tx ========= */

#[derive(Deserialize)]
pub struct SubmitTxReq {
    #[serde(default)]
    pub _payload: serde_json::Value,
}
#[derive(Serialize)]
pub struct SubmitTxResp {
    pub status: &'static str,
}

pub async fn submit_tx(
    State(_st): State<AppState>,
    Json(_req): Json<SubmitTxReq>,
) -> Result<Json<SubmitTxResp>, StatusCode> {
    let t = Timer::new("/submit_tx", "POST");
    inc_total("/submit_tx", "POST", StatusCode::OK);
    t.observe();
    Ok(Json(SubmitTxResp { status: "accepted" }))
}

/* ========= debug_canon ========= */

#[derive(Deserialize)]
pub struct DebugCanonReq {
    #[serde(default)]
    pub tx: serde_json::Value,
}
#[derive(Serialize)]
pub struct DebugCanonResp {
    pub canon_hex: String,
}

pub async fn debug_canon(
    Json(req): Json<DebugCanonReq>,
) -> Result<Json<DebugCanonResp>, StatusCode> {
    let t = Timer::new("/debug_canon", "POST");

    let from = req
        .tx
        .get("from")
        .and_then(|v| v.as_str())
        .ok_or(StatusCode::BAD_REQUEST)?;
    let to = req
        .tx
        .get("to")
        .and_then(|v| v.as_str())
        .ok_or(StatusCode::BAD_REQUEST)?;
    let amount = req
        .tx
        .get("amount")
        .and_then(|v| v.as_u64())
        .ok_or(StatusCode::BAD_REQUEST)?;
    let nonce = req
        .tx
        .get("nonce")
        .and_then(|v| v.as_u64())
        .ok_or(StatusCode::BAD_REQUEST)?;
    let c = CanonTx {
        from,
        to,
        amount,
        nonce,
    };
    let bytes = serde_json::to_vec(&c).map_err(|_| StatusCode::BAD_REQUEST)?;
    let canon_hex = hex::encode(bytes);

    inc_total("/debug_canon", "POST", StatusCode::OK);
    t.observe();
    Ok(Json(DebugCanonResp { canon_hex }))
}

/* ========= faucet (DEV-фича-флаг) ========= */

#[derive(Deserialize)]
pub struct FaucetReq {
    #[serde(default)]
    pub rid: String,
    #[serde(default)]
    pub amount: u64,
}
#[derive(Serialize)]
pub struct FaucetResp {
    pub granted: u64,
    pub rid: String,
}

pub async fn faucet(
    State(st): State<AppState>,
    Json(req): Json<FaucetReq>,
) -> Result<Json<FaucetResp>, StatusCode> {
    // работает ТОЛЬКО если LRB_ENABLE_FAUCET=1
    if std::env::var("LRB_ENABLE_FAUCET").ok().as_deref() != Some("1") {
        return Err(StatusCode::FORBIDDEN);
    }
    let t = Timer::new("/faucet", "POST");
    if req.rid.is_empty() || req.amount == 0 {
        inc_total("/faucet", "POST", StatusCode::BAD_REQUEST);
        t.observe();
        return Err(StatusCode::BAD_REQUEST);
    }
    let _st = st
        .store
        .faucet(&req.rid, req.amount)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/faucet", "POST", StatusCode::OK);
    t.observe();
    Ok(Json(FaucetResp {
        granted: req.amount,
        rid: req.rid,
    }))
}

```


## FILE: /root/logos_lrb/node/src/auth.rs  (size=5131b)
```
// node/src/auth.rs
use axum::http::{HeaderMap, StatusCode};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Deserialize)]
struct Claims {
    exp: i64,
    sub: Option<String>,
    iat: Option<i64>,
}

// ------------ time ------------
fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
}

// ------------ helpers ------------
fn header_value(headers: &HeaderMap, name: &str) -> Option<String> {
    headers.get(name).and_then(|v| v.to_str().ok()).map(|s| s.trim().to_string())
}

fn header_or_bearer(headers: &HeaderMap, primary_header: &str) -> Option<String> {
    if let Some(v) = header_value(headers, primary_header) {
        if !v.is_empty() { return Some(v); }
    }
    if let Some(v) = header_value(headers, "authorization") {
        if let Some(rest) = v.strip_prefix("Bearer ") {
            let t = rest.trim();
            if !t.is_empty() { return Some(t.to_string()); }
        }
    }
    None
}

/// Простейший IP-ACL: LRB_ADMIN_IP_ALLOW="1.2.3.4,10.0.0.0/8"
fn ip_acl_allows(ip: Option<IpAddr>, env_key: &str) -> bool {
    let allow = std::env::var(env_key).unwrap_or_default();
    if allow.trim().is_empty() { return true; }
    let rules: Vec<&str> = allow.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    if rules.is_empty() { return true; }
    if let Some(client) = ip {
        for r in rules {
            if let Ok(one) = r.parse::<IpAddr>() {
                if one == client { return true; }
            } else if let Some((net, bits)) = r.split_once('/') {
                if let (Ok(nip), Ok(b)) = (net.parse::<IpAddr>(), bits.parse::<u8>()) {
                    if let (IpAddr::V4(a), IpAddr::V4(n)) = (client, nip) {
                        let mask: u32 = if b == 0 { 0 } else { (!0u32) << (32 - b as u32) };
                        if (u32::from(a) & mask) == (u32::from(n) & mask) { return true; }
                    }
                }
            }
        }
        false
    } else { false }
}

// ------------ публичные проверки ------------

/// Админ-доступ:
/// 1) если задан нормальный LRB_ADMIN_KEY — принимаем X-Admin-Key (приоритетно)
/// 2) если задан LRB_ADMIN_JWT_SECRET — принимаем JWT (X-Admin-Key или Authorization: Bearer)
/// 3) IP-ACL: LRB_ADMIN_IP_ALLOW (пусто = разрешить всем)
pub fn require_admin(headers: &HeaderMap, remote_ip: Option<IpAddr>) -> Result<(), StatusCode> {
    if !ip_acl_allows(remote_ip, "LRB_ADMIN_IP_ALLOW") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // статический ключ (удобно для таймеров/автоматизаций)
    if let Ok(k) = std::env::var("LRB_ADMIN_KEY") {
        let k = k.trim();
        if !k.is_empty() && k != "CHANGE_ADMIN_KEY" {
            if let Some(presented) = header_or_bearer(headers, "X-Admin-Key") {
                if presented == k { return Ok(()); }
            }
        }
    }

    // JWT HS256
    if let Ok(secret) = std::env::var("LRB_ADMIN_JWT_SECRET") {
        let secret = secret.trim();
        if !secret.is_empty() {
            if let Some(tok) = header_or_bearer(headers, "X-Admin-Key") {
                if let Ok(data) = decode::<Claims>(
                    &tok,
                    &DecodingKey::from_secret(secret.as_bytes()),
                    &Validation::new(Algorithm::HS256),
                ) {
                    if data.claims.exp > now_ts() { return Ok(()); }
                }
            }
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    Err(StatusCode::UNAUTHORIZED)
}

/// Доступ к мосту: LRB_BRIDGE_KEY в X-Bridge-Key или Authorization: Bearer <key>
pub fn require_bridge(headers: &HeaderMap) -> Result<(), StatusCode> {
    let k = std::env::var("LRB_BRIDGE_KEY").unwrap_or_default();
    let k = k.trim();
    if k.is_empty() || k == "CHANGE_ME" { return Err(StatusCode::UNAUTHORIZED); }

    if let Some(presented) = header_or_bearer(headers, "X-Bridge-Key") {
        if presented == k { return Ok(()); }
    }
    if let Some(bearer) = header_or_bearer(headers, "Authorization") {
        if bearer == k { return Ok(()); }
    }
    Err(StatusCode::UNAUTHORIZED)
}

// ------------ JWT minting (для /admin/token) ------------
#[derive(Serialize)]
struct ClaimsOut { sub: String, exp: i64, iat: i64 }

/// Выпуск JWT (HS256) c TTL (сек): возвращает строку токена.
pub fn mint_jwt(secret: &str, sub: &str, ttl_secs: i64) -> Result<String, StatusCode> {
    if ttl_secs <= 0 { return Err(StatusCode::BAD_REQUEST); }
    let now = now_ts();
    let claims = ClaimsOut { sub: sub.to_string(), iat: now, exp: now + ttl_secs };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

```


## FILE: /root/logos_lrb/node/src/bin/aead_selftest.rs  (size=1723b)
```
use ed25519_dalek::{Signer, SigningKey, VerifyingKey};
use lrb_core::crypto::AeadBox;
use rand_core::{OsRng, RngCore};

fn main() {
    // 1) Ed25519: ключи + подпись/проверка
    let sk = SigningKey::generate(&mut OsRng);
    let vk = VerifyingKey::from(&sk);
    let msg = b"resonance-test-message";
    let sig = sk.sign(msg);
    assert!(vk.verify_strict(msg, &sig).is_ok(), "ed25519 verify failed");

    // 2) AEAD: XChaCha20-Poly1305, уникальный nonce внутри AeadBox
    let mut key32 = [0u8; 32];
    OsRng.fill_bytes(&mut key32);
    let aead = AeadBox::from_key(&key32);

    let aad = b"topic:external-phase|self-vk";
    let pt = "hello, Σ(t)!".as_bytes();

    let ct = aead.seal(aad, pt);
    let dec = aead.open(aad, &ct).expect("aead open failed");
    assert_eq!(dec.as_slice(), pt, "aead roundtrip mismatch");

    // 3) Негатив: порча шифротекста → ошибка
    let mut ct_bad = ct.clone();
    if let Some(last) = ct_bad.last_mut() {
        *last ^= 0xFF; // безопасно мутируем последний байт без двух заимствований
    }
    assert!(aead.open(aad, &ct_bad).is_err(), "aead must fail on tamper");

    // 4) Негатив: смена AAD → ошибка
    let aad_bad = b"topic:changed";
    assert!(
        aead.open(aad_bad, &ct).is_err(),
        "aead must fail on wrong AAD"
    );

    // 5) Подпись поверх шифротекста (seal-then-sign)
    let sig_ct = sk.sign(&ct);
    assert!(
        vk.verify_strict(&ct, &sig_ct).is_ok(),
        "sign(sealed) verify failed"
    );

    println!("OK: ed25519 + AeadBox(XChaCha20-Poly1305) self-test passed");
}

```


## FILE: /root/logos_lrb/node/src/bridge.rs  (size=1919b)
```
#![allow(dead_code)]
use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

use crate::AppState;

#[derive(Deserialize)]
pub struct DepositReq {
    pub rid: String,
    pub amount: u64,
    #[serde(default)]
    pub txid: String,
}

#[derive(Serialize)]
pub struct DepositResp {
    pub status: &'static str,
    pub rid: String,
    pub credited: u64,
}

pub async fn deposit(
    State(_st): State<AppState>,
    Json(req): Json<DepositReq>,
) -> Result<Json<DepositResp>, StatusCode> {
    // TODO(след. пачка): валидация квитка/квоты и зачисление rToken
    Ok(Json(DepositResp {
        status: "accepted",
        rid: req.rid,
        credited: req.amount,
    }))
}

#[derive(Deserialize)]
pub struct RedeemReq {
    pub rid: String,
    pub amount: u64,
    #[serde(default)]
    pub target_chain: String,
    #[serde(default)]
    pub target_address: String,
}

#[derive(Serialize)]
pub struct RedeemResp {
    pub status: &'static str,
    pub rid: String,
    pub debited: u64,
}

pub async fn redeem(
    State(_st): State<AppState>,
    Json(req): Json<RedeemReq>,
) -> Result<Json<RedeemResp>, StatusCode> {
    // TODO(след. пачка): резерв/списание rToken и квиток на вывод
    Ok(Json(RedeemResp {
        status: "accepted",
        rid: req.rid,
        debited: req.amount,
    }))
}

#[derive(Deserialize)]
pub struct VerifyReq {
    #[serde(default)]
    pub ticket: String,
}

#[derive(Serialize)]
pub struct VerifyResp {
    pub status: &'static str,
    #[serde(default)]
    pub ok: bool,
}

pub async fn verify(
    State(_st): State<AppState>,
    Json(_req): Json<VerifyReq>,
) -> Result<Json<VerifyResp>, StatusCode> {
    // TODO(след. пачка): проверка подписи/кворума
    Ok(Json(VerifyResp {
        status: "ok",
        ok: true,
    }))
}

```


## FILE: /root/logos_lrb/node/src/fork.rs  (size=1328b)
```
#![allow(dead_code)]
//! Fork-choice: минимальный детерминированный выбор на базе высоты/хэша.
//! Совместим с текущими типами ядра (Block из lrb_core::types).

use lrb_core::types::Block;

/// Выбор лучшей ветви из набора кандидатов.
/// Правила:
/// 1) Бóльшая высота предпочтительнее.
/// 2) При равной высоте — лексикографически наименьший block_hash.
pub fn choose_best<'a>(candidates: &'a [Block]) -> Option<&'a Block> {
    candidates
        .iter()
        .max_by(|a, b| match a.height.cmp(&b.height) {
            core::cmp::Ordering::Equal => a.block_hash.cmp(&b.block_hash).reverse(),
            ord => ord,
        })
}

#[cfg(test)]
mod tests {
    use super::*;
    fn mk(h: u64, hash: &str) -> Block {
        Block {
            height: h,
            block_hash: hash.to_string(),
            ..Default::default()
        }
    }

    #[test]
    fn pick_by_height_then_hash() {
        let a = mk(10, "ff");
        let b = mk(12, "aa");
        let c = mk(12, "bb");
        let out = choose_best(&[a, b.clone(), c]).unwrap();
        assert_eq!(out.height, 12);
        assert_eq!(out.block_hash, "aa");
    }
}

```


## FILE: /root/logos_lrb/node/src/gossip.rs  (size=1539b)
```
#![allow(dead_code)]
//! Gossip-утилиты: сериализация/десериализация блоков для пересылки по сети.

use base64::{engine::general_purpose::STANDARD as B64, Engine as _};
use blake3;
use hex;
use lrb_core::{phase_filters::block_passes_phase, types::Block};
use serde::{Deserialize, Serialize};

/// Конверт для публикации блока в сети Gossip.
#[derive(Serialize, Deserialize)]
pub struct GossipEnvelope {
    pub topic: String,
    pub payload_b64: String,
    pub sigma_hex: String,
    pub height: u64,
}

/// Энкодим блок: base64-пейлоад, sigma_hex = blake3(payload).
pub fn encode_block(topic: &str, blk: &Block) -> anyhow::Result<GossipEnvelope> {
    let bytes = serde_json::to_vec(blk)?;
    let sigma_hex = hex::encode(blake3::hash(&bytes).as_bytes());
    Ok(GossipEnvelope {
        topic: topic.to_string(),
        payload_b64: B64.encode(bytes),
        sigma_hex,
        height: blk.height,
    })
}

/// Декодим блок из конверта.
pub fn decode_block(env: &GossipEnvelope) -> anyhow::Result<Block> {
    let bytes = B64.decode(&env.payload_b64)?;
    let blk: Block = serde_json::from_slice(&bytes)?;
    Ok(blk)
}

/// Пропускает ли блок фазовый фильтр (решение — по самому блоку).
pub fn pass_phase_filter(env: &GossipEnvelope) -> bool {
    if let Ok(blk) = decode_block(env) {
        block_passes_phase(&blk)
    } else {
        false
    }
}

```


## FILE: /root/logos_lrb/node/src/guard.rs  (size=2977b)
```
use std::net::SocketAddr;
use std::sync::Arc;
use std::time::Instant;

use axum::{
    body::Body,
    extract::ConnectInfo,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use dashmap::DashMap;
use ipnet::IpNet;
use parking_lot::Mutex;

/// Парсим список CIDR из строки "a,b,c"
pub fn parse_ip_allowlist(s: &str) -> Vec<IpNet> {
    s.split(',')
        .filter_map(|x| x.trim().parse::<IpNet>().ok())
        .collect()
}

/// IP-ACL для админ-ручек
pub async fn admin_ip_gate(
    req: Request<Body>,
    next: Next,
    allow: Arc<Vec<IpNet>>,
) -> Result<Response, StatusCode> {
    let peer = req
        .extensions()
        .get::<ConnectInfo<SocketAddr>>()
        .map(|c| c.0);
    let ip = match peer {
        Some(sa) => sa.ip(),
        None => return Err(StatusCode::FORBIDDEN),
    };
    if !allow.iter().any(|net| net.contains(&ip)) {
        return Err(StatusCode::FORBIDDEN);
    }
    Ok(next.run(req).await)
}

/// Храним для IP свой защищённый мьютексом бакет
struct Bucket {
    tokens: f64,
    last: Instant,
}

pub struct RateLimiter {
    qps: f64,
    burst: f64,
    map: DashMap<std::net::IpAddr, Arc<Mutex<Bucket>>>,
    bypass: Arc<Vec<IpNet>>,
}

impl RateLimiter {
    pub fn new(qps: u64, burst: u64, bypass: Arc<Vec<IpNet>>) -> Self {
        Self {
            qps: qps as f64,
            burst: burst as f64,
            map: DashMap::new(),
            bypass,
        }
    }

    fn is_bypass(&self, ip: &std::net::IpAddr) -> bool {
        self.bypass.iter().any(|n| n.contains(ip))
    }

    fn check_and_consume(&self, ip: std::net::IpAddr) -> bool {
        if self.is_bypass(&ip) {
            return true;
        }

        let now = Instant::now();
        let bucket_arc = self
            .map
            .entry(ip)
            .or_insert_with(|| {
                Arc::new(Mutex::new(Bucket {
                    tokens: self.burst,
                    last: now,
                }))
            })
            .clone();

        let mut b = bucket_arc.lock();
        let add = self.qps * b.last.elapsed().as_secs_f64();
        b.tokens = (b.tokens + add).min(self.burst);
        b.last = now;

        if b.tokens >= 1.0 {
            b.tokens -= 1.0;
            true
        } else {
            false
        }
    }
}

/// Axum middleware: per-IP rate-limit (возвращает 429 при превышении)
pub async fn rate_limit_ip_gate(
    req: Request<Body>,
    next: Next,
    limiter: Arc<RateLimiter>,
) -> Result<Response, StatusCode> {
    let peer = req
        .extensions()
        .get::<ConnectInfo<SocketAddr>>()
        .map(|c| c.0);
    let ip = match peer {
        Some(sa) => sa.ip(),
        None => return Err(StatusCode::TOO_MANY_REQUESTS),
    };
    if !limiter.check_and_consume(ip) {
        return Err(StatusCode::TOO_MANY_REQUESTS);
    }
    Ok(next.run(req).await)
}

```


## FILE: /root/logos_lrb/node/src/main.rs  (size=7196b)
```
use anyhow::Result;
use axum::{
    middleware::from_fn,
    routing::{get, post},
    Router,
};
use bs58;
use ed25519_dalek::{SigningKey, VerifyingKey};
use once_cell::sync::OnceCell;
use std::{net::SocketAddr, sync::Arc, time::Duration};
use tower_http::{
    cors::CorsLayer, limit::RequestBodyLimitLayer, timeout::TimeoutLayer, trace::TraceLayer,
};
use tracing_subscriber::{fmt, EnvFilter};

use lrb_core::ledger::Ledger;
use lrb_core::rcp_engine::engine_with_channels;
use lrb_core::types::Rid;

mod admin;
mod api;
mod bridge;
mod fork;
mod guard;
mod metrics;
mod openapi;
mod peers;
mod state;
mod storage;
mod version;

use dashmap::DashMap;
use parking_lot::Mutex;

#[derive(Clone)]
pub struct AppState {
    pub signing: SigningKey,
    pub verifying: VerifyingKey,
    pub rid_b58: String,
    pub admin_key: String,
    pub bridge_key: String,
    pub ledger: Ledger,
    pub store: Arc<storage::Storage>,
    pub locks: Arc<DashMap<String, Arc<Mutex<()>>>>,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(
            bytes
                .as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(
            data.as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}
fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}
fn read_env_required(n: &str) -> Result<String> {
    let v = std::env::var(n).map_err(|_| anyhow::anyhow!(format!("missing env {}", n)))?;
    Ok(v)
}
fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY", "CHANGE_ME", "", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid_b58 = rid_from_vk(&vk);
    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    let data_dir = std::env::var("LRB_DATA_DIR").unwrap_or_else(|_| "/var/lib/logos".into());
    std::fs::create_dir_all(&data_dir).ok();
    let ledger = Ledger::open(&data_dir)?;
    let store_path = format!("{}/node_state", data_dir);
    let store = Arc::new(storage::Storage::open(store_path)?);

    let app_state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid_b58.clone(),
        admin_key,
        bridge_key,
        ledger: ledger.clone(),
        store,
        locks: Arc::new(DashMap::new()),
    };
    APP_STATE.set(app_state.clone()).ok();

    let rid = Rid(rid_b58.clone());
    let _engine = engine_with_channels(ledger, rid);

    let allowed_origin =
        std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| "http://localhost".into());
    let cors = {
        let hv = allowed_origin
            .parse::<axum::http::HeaderValue>()
            .expect("bad LRB_WALLET_ORIGIN");
        CorsLayer::new()
            .allow_origin(hv)
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([
                axum::http::header::CONTENT_TYPE,
                axum::http::header::AUTHORIZATION,
            ])
    };

    // Rate-limit
    let qps: u64 = std::env::var("LRB_RATE_QPS")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(20);
    let burst: u64 = std::env::var("LRB_RATE_BURST")
        .ok()
        .and_then(|s| s.parse().ok())
        .unwrap_or(40);
    let rl_enabled = qps > 0 && burst > 0;
    let bypass_cidr =
        std::env::var("LRB_RATE_BYPASS_CIDR").unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let bypass = Arc::new(guard::parse_ip_allowlist(&bypass_cidr));
    let rl = Arc::new(guard::RateLimiter::new(qps, burst, bypass.clone()));

    // Admin IP ACL
    let admin_allow =
        std::env::var("LRB_ADMIN_IP_ALLOW").unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let admin_nets = Arc::new(guard::parse_ip_allowlist(&admin_allow));

    let public = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/livez", get(api::livez))
        .route("/readyz", get(api::readyz))
        .route("/version", get(version::version))
        .route("/openapi.json", get(openapi::spec))
        .route("/metrics", get(metrics::metrics_handler))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/history/:rid", get(api::history))
        .route("/block/:height", get(api::block))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet));

    let admin_routes = Router::new()
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .layer(from_fn({
            let nets = admin_nets.clone();
            move |req, next| guard::admin_ip_gate(req, next, nets.clone())
        }));

    let bridge_routes = Router::new()
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify));

    let mut app = public
        .merge(admin_routes)
        .merge(bridge_routes)
        .with_state(app_state)
        .layer(cors)
        .layer(RequestBodyLimitLayer::new(512 * 1024))
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(TraceLayer::new_for_http());

    if rl_enabled {
        app = app.layer(from_fn({
            let rl = rl.clone();
            move |req, next| guard::rate_limit_ip_gate(req, next, rl.clone())
        }));
    }

    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    let listener = tokio::net::TcpListener::bind(addr).await?;
    tracing::info!(
        "logos_node listening on {} (RID={}), rate_limit={} (qps={}, burst={}), bypass={}",
        addr,
        rid_b58,
        if rl_enabled { "on" } else { "off" },
        qps,
        burst,
        bypass_cidr
    );
    axum::serve(
        listener,
        app.into_make_service_with_connect_info::<SocketAddr>(),
    )
    .await?;
    Ok(())
}

```


## FILE: /root/logos_lrb/node/src/main.rs:30:18  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/main.rs:67:29  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/metrics.rs  (size=2923b)
```
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};
use once_cell::sync::Lazy;
use prometheus::{
    histogram_opts, opts, register_histogram_vec_with_registry,
    register_int_counter_vec_with_registry, register_int_gauge_with_registry, Encoder,
    HistogramVec, IntCounterVec, IntGauge, Registry, TextEncoder,
};
use std::time::Instant;

pub static REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);

pub static HTTP_REQ_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("http_requests_total", "Total HTTP requests"),
        &["endpoint", "method", "status"],
        &REGISTRY
    )
    .unwrap()
});
pub static HTTP_REQ_DUR: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec_with_registry!(
        histogram_opts!("http_request_duration_seconds", "HTTP duration").buckets(vec![
            0.001, 0.002, 0.005, 0.010, 0.020, 0.050, 0.100, 0.200, 0.500, 1.0, 2.0, 5.0
        ]),
        &["endpoint", "method"],
        &REGISTRY
    )
    .unwrap()
});
pub static INFLIGHT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge_with_registry!(opts!("http_inflight_requests", "In-flight"), &REGISTRY)
        .unwrap()
});

// New app metrics
pub static HIST_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_history_requests_total", "History requests"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});
pub static BLOCKS_SERVED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_blocks_served_total", "Blocks served"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});

pub struct Timer {
    start: Instant,
    endpoint: &'static str,
    method: &'static str,
}
impl Timer {
    pub fn new(endpoint: &'static str, method: &'static str) -> Self {
        INFLIGHT.inc();
        Self {
            start: Instant::now(),
            endpoint,
            method,
        }
    }
    pub fn observe(self) {
        let dt = self.start.elapsed().as_secs_f64();
        HTTP_REQ_DUR
            .with_label_values(&[self.endpoint, self.method])
            .observe(dt);
        INFLIGHT.dec();
    }
}
pub fn inc_total(endpoint: &'static str, method: &'static str, status: StatusCode) {
    HTTP_REQ_TOTAL
        .with_label_values(&[endpoint, method, status.as_str()])
        .inc();
}
pub async fn metrics_handler() -> Response {
    let mf = REGISTRY.gather();
    let mut buf = Vec::with_capacity(64 * 1024);
    let enc = TextEncoder::new();
    if let Err(e) = enc.encode(&mf, &mut buf) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("encode error: {e}"),
        )
            .into_response();
    }
    (
        StatusCode::OK,
        [("Content-Type", enc.format_type().to_string())],
        buf,
    )
        .into_response()
}

```


## FILE: /root/logos_lrb/node/src/openapi.json  (size=6092b)
```
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB Node API", "version": "0.1.0" },
  "servers": [{ "url": "http://{host}", "variables": { "host": { "default": "localhost:8080" } } }],
  "paths": {
    "/healthz": { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/livez":   { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/readyz":  { "get": { "summary": "Readiness", "responses": { "200": { "description": "Ready" } } } },
    "/version": { "get": { "summary": "Build info", "responses": { "200": { "description": "JSON" } } } },
    "/metrics": { "get": { "summary": "Prometheus metrics", "responses": { "200": { "description": "text/plain" } } } },

    "/head": {
      "get": {
        "summary": "Chain head",
        "responses": {
          "200": { "description": "Height/finalized",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/HeadResp" },
            "examples": { "ok": { "value": { "height": 123, "finalized": false } } } } }
          }
        }
      }
    },

    "/balance/{rid}": {
      "get": {
        "summary": "Account state",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "Balance/nonce",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BalanceResp" },
            "examples": { "ok": { "value": { "rid": "A...Z", "balance": 1000000, "nonce": 5 } } } } }
          },
          "404": { "description": "Unknown RID" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "Submit batch of signed transactions",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/SubmitTxBatchReq" },
          "examples": { "one": { "value": { "txs": [
            { "from":"A...Z","to":"B...Y","amount":1234,"nonce":6,"sig_hex":"<ed25519 hex>" }
          ] } } } } } },
        "responses": {
          "200": { "description": "Accepted/rejected with details",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitTxBatchResp" },
            "examples": { "ok": { "value": {
              "accepted": 1, "rejected": 0, "new_height": 124,
              "results": [{ "idx": 0, "status": "accepted", "code": 0, "reason": "ok" }]
            } } } } } }
        }
      }
    },

    "/debug_canon": {
      "post": {
        "summary": "Canonical JSON for signing (server-side canonicalization)",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/DebugCanonReq" },
          "examples": { "tx": { "value": { "tx": { "from":"A...Z","to":"B...Y","amount":1,"nonce":1 } } } }
        } } },
        "responses": { "200": {
          "description": "Canon hex",
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DebugCanonResp" } } }
        } }
      }
    },

    "/faucet": {
      "post": {
        "summary": "DEV only. Mint LGN to RID",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/FaucetReq" }
        } } },
        "responses": {
          "200": { "description": "Granted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FaucetResp" } } } },
          "400": { "description": "Bad request" }
        }
      }
    }
  },

  "components": {
    "schemas": {
      "TxIn": {
        "type": "object",
        "required": ["from", "to", "amount", "nonce", "sig_hex"],
        "properties": {
          "from":   { "type": "string", "description": "RID (base58 pubkey)" },
          "to":     { "type": "string", "description": "RID (base58 pubkey)" },
          "amount": { "type": "integer", "format": "uint64", "minimum": 1 },
          "nonce":  { "type": "integer", "format": "uint64" },
          "sig_hex":{ "type": "string", "description": "Ed25519 signature hex over canonical bytes from /debug_canon" }
        }
      },

      "SubmitTxBatchReq": { "type": "object", "required": ["txs"], "properties": { "txs": { "type": "array", "minItems": 1, "items": { "$ref": "#/components/schemas/TxIn" } } } },

      "TxResult": {
        "type": "object",
        "required": ["idx", "status", "code", "reason"],
        "properties": {
          "idx":    { "type": "integer" },
          "status": { "type": "string", "enum": ["accepted", "rejected"] },
          "code":   { "type": "integer", "enum": [0, 400, 401, 402, 409] },
          "reason": { "type": "string", "enum": ["ok", "bad_rid", "bad_sig", "bad_canon", "bad_nonce", "insufficient_funds"] }
        }
      },

      "SubmitTxBatchResp": {
        "type": "object",
        "required": ["accepted", "rejected", "new_height", "results"],
        "properties": {
          "accepted":  { "type": "integer" },
          "rejected":  { "type": "integer" },
          "new_height":{ "type": "integer", "format": "uint64" },
          "results":   { "type": "array", "items": { "$ref": "#/components/schemas/TxResult" } }
        }
      },

      "HeadResp":   { "type": "object", "properties": { "height": { "type": "integer" }, "finalized": { "type": "boolean" } } },
      "BalanceResp":{ "type": "object", "properties": { "rid": { "type": "string" }, "balance": { "type": "integer" }, "nonce": { "type": "integer" } } },

      "DebugCanonReq":  { "type": "object", "properties": { "tx": { "type": "object" } } },
      "DebugCanonResp": { "type": "object", "required": ["canon_hex"], "properties": { "canon_hex": { "type": "string" } } },

      "FaucetReq":  { "type": "object", "required": ["rid", "amount"], "properties": { "rid": { "type": "string" }, "amount": { "type": "integer" } } },
      "FaucetResp": { "type": "object", "properties": { "granted": { "type": "integer" }, "rid": { "type": "string" } } }
    }
  }
}

```


## FILE: /root/logos_lrb/node/src/openapi.rs  (size=222b)
```
use axum::{http::StatusCode, response::IntoResponse};

pub async fn spec() -> impl IntoResponse {
    (
        StatusCode::OK,
        [("Content-Type", "application/json")],
        include_str!("openapi.json"),
    )
}

```


## FILE: /root/logos_lrb/node/src/peers.rs  (size=4932b)
```
#![allow(dead_code)]
#![allow(dead_code)]
use std::time::{SystemTime, UNIX_EPOCH};
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_millis() as u128)
        .unwrap_or(0)
}

use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{
    collections::HashMap,
    sync::{Arc, Mutex},
    time::Duration,
};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self {
            last_seen_ms: now_ms(),
            score_milli: 0,
            fails: 0,
            dups: 0,
            banned_until_ms: 0,
        }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            policy,
        }
    }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> {
        self.inner.lock().unwrap()
    }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 {
            s.score_milli = 5000;
        }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli {
            s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
        }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk)
            .map(|s| now_ms() < s.banned_until_ms)
            .unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 {
                            s.score_milli = 0;
                        }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now {
                banned += 1;
            }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop {
            t.tick().await;
            book.tick();
        }
    });
}

```


## FILE: /root/logos_lrb/node/src/peers.rs:75:25  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/node/src/state.rs  (size=211b)
```
//! Reserved for future network helpers (kept minimal to avoid dead_code warnings).
//! Прод-уровень: пустой модуль без неиспользуемых структур и функций.

```


## FILE: /root/logos_lrb/node/src/storage.rs  (size=7739b)
```
//! Узловое persistent-хранилище (sled, один Tree "kv"):
//!   accounts/<RID>                  -> JSON {balance, nonce}
//!   chain/height                    -> LE u64
//!   blocks/<height:016x>            -> JSON BlockRecord {height, ts_ms, txs}
//!   history/<RID>/<nonce:016x>      -> JSON HistoryItem {nonce, from, to, amount, height, ts_ms}

use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Default, Serialize, Deserialize)]
pub struct AccountState {
    pub balance: u64,
    pub nonce: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct HistoryItem {
    pub nonce: u64,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub height: u64,
    pub ts_ms: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct BlockRecord {
    pub height: u64,
    pub ts_ms: u64,
    pub txs: Vec<TxIn>,
}

pub struct Storage {
    db: sled::Db,
    kv: sled::Tree,
}

impl Storage {
    pub fn open<P: AsRef<std::path::Path>>(path: P) -> Result<Self> {
        std::fs::create_dir_all(&path).ok();
        let db = sled::open(path)?;
        let kv = db.open_tree("kv")?;
        let _ = kv.compare_and_swap(
            b"chain/height",
            None as Option<&[u8]>,
            Some(0u64.to_le_bytes().to_vec()),
        )?;
        Ok(Self { db, kv })
    }

    #[inline]
    fn k_account(rid: &str) -> String {
        format!("accounts/{}", rid)
    }
    #[inline]
    fn k_block(height: u64) -> String {
        format!("blocks/{:016x}", height)
    }
    #[inline]
    fn k_hist(rid: &str, nonce: u64) -> String {
        format!("history/{}/{:016x}", rid, nonce)
    }

    #[inline]
    fn now_ms() -> u64 {
        SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis() as u64
    }

    // ------- Accounts

    pub fn get_account(&self, rid: &str) -> Result<AccountState> {
        if let Some(v) = self.kv.get(Self::k_account(rid).as_bytes())? {
            let st: AccountState = serde_json::from_slice(&v)?;
            Ok(st)
        } else {
            Ok(AccountState::default())
        }
    }

    pub fn faucet(&self, rid: &str, amount: u64) -> Result<AccountState> {
        let mut st = self.get_account(rid)?;
        st.balance = st.balance.saturating_add(amount);
        self.kv
            .insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(&st)?)?;
        self.db.flush()?;
        Ok(st)
    }

    // ------- Apply batch: атомарно применяем префикс и индексируем историю+блок

    pub fn apply_batch(&self, txs: &[TxIn]) -> Result<u64> {
        let mut batch = sled::Batch::default();
        let mut acc_cache: std::collections::HashMap<String, AccountState> =
            std::collections::HashMap::new();

        for tx in txs {
            if tx.from == tx.to {
                let mut from = acc_cache
                    .remove(&tx.from)
                    .unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                from.nonce = from.nonce.saturating_add(1);
                acc_cache.insert(tx.from.clone(), from);
            } else {
                let mut from = acc_cache
                    .remove(&tx.from)
                    .unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                let mut to = acc_cache
                    .remove(&tx.to)
                    .unwrap_or(self.get_account(&tx.to).unwrap_or_default());

                if from.balance >= tx.amount {
                    from.balance = from.balance.saturating_sub(tx.amount);
                    to.balance = to.balance.saturating_add(tx.amount);
                }
                from.nonce = from.nonce.saturating_add(1);

                acc_cache.insert(tx.from.clone(), from);
                acc_cache.insert(tx.to.clone(), to);
            }
        }

        for (rid, st) in acc_cache.iter() {
            batch.insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(st)?);
        }

        let cur_h = self.get_height()?;
        let new_h = cur_h + 1;
        let ts_ms = Self::now_ms();

        let block = BlockRecord {
            height: new_h,
            ts_ms,
            txs: txs.to_vec(),
        };
        batch.insert("chain/height".as_bytes(), new_h.to_le_bytes().to_vec());
        batch.insert(Self::k_block(new_h).as_bytes(), serde_json::to_vec(&block)?);

        for tx in txs {
            let item = HistoryItem {
                nonce: tx.nonce,
                from: tx.from.clone(),
                to: tx.to.clone(),
                amount: tx.amount,
                height: new_h,
                ts_ms,
            };
            batch.insert(
                Self::k_hist(&tx.from, tx.nonce).as_bytes(),
                serde_json::to_vec(&item)?,
            );
            batch.insert(
                Self::k_hist(&tx.to, tx.nonce).as_bytes(),
                serde_json::to_vec(&item)?,
            );
        }

        self.kv.apply_batch(batch)?;
        self.db.flush()?;
        Ok(new_h)
    }

    pub fn get_height(&self) -> Result<u64> {
        if let Some(v) = self.kv.get(b"chain/height")? {
            let mut arr = [0u8; 8];
            arr.copy_from_slice(&v[..8.min(v.len())]);
            Ok(u64::from_le_bytes(arr))
        } else {
            Ok(0)
        }
    }

    pub fn get_block(&self, height: u64) -> Result<Option<BlockRecord>> {
        Ok(self
            .kv
            .get(Self::k_block(height).as_bytes())?
            .map(|v| serde_json::from_slice::<BlockRecord>(&v))
            .transpose()?)
    }

    /// Страница истории по RID: nonce >= from_nonce, не более limit; возвращает (items, next_from)
    pub fn history_page(
        &self,
        rid: &str,
        from_nonce: u64,
        limit: usize,
    ) -> Result<(Vec<HistoryItem>, Option<u64>)> {
        let prefix = format!("history/{}/", rid);
        let start = format!("{}{:016x}", prefix, from_nonce);
        let mut out = Vec::with_capacity(limit.min(1024));
        let mut last_nonce: Option<u64> = None;
        let mut iter = self.kv.range(start.as_bytes()..);

        while let Some(kv) = iter.next() {
            let (k, v) = kv?;
            if !k.starts_with(prefix.as_bytes()) {
                break;
            }
            let item: HistoryItem = serde_json::from_slice(&v)?;
            out.push(item.clone());
            last_nonce = Some(item.nonce);
            if out.len() >= limit {
                break;
            }
        }

        let next_from = if let Some(n) = last_nonce {
            let next_key = format!("{}{:016x}", prefix, n.saturating_add(1));
            if let Some(kv) = self.kv.range(next_key.as_bytes()..).next() {
                let (k, _) = kv?;
                if k.starts_with(prefix.as_bytes()) {
                    Some(n.saturating_add(1))
                } else {
                    None
                }
            } else {
                None
            }
        } else {
            None
        };

        Ok((out, next_from))
    }

    /// Старый интерфейс для совместимости
    pub fn history_from(
        &self,
        rid: &str,
        from_nonce: u64,
        limit: usize,
    ) -> Result<Vec<HistoryItem>> {
        Ok(self.history_page(rid, from_nonce, limit)?.0)
    }
}

// Входная транзакция
#[derive(Clone, serde::Deserialize, serde::Serialize)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    #[serde(default)]
    pub nonce: u64,
    #[serde(default)]
    pub sig_hex: String,
}

```


## FILE: /root/logos_lrb/node/src/version.rs  (size=520b)
```
use axum::Json;
use serde::Serialize;

#[derive(Serialize)]
pub struct VersionInfo {
    pub name: &'static str,
    pub version: &'static str,
    pub git_commit: &'static str,
    pub build_time_utc: &'static str,
    pub rustc: &'static str,
}

pub async fn version() -> Json<VersionInfo> {
    Json(VersionInfo {
        name: "logos_node",
        version: env!("CARGO_PKG_VERSION"),
        git_commit: env!("GIT_COMMIT"),
        build_time_utc: env!("BUILD_TIME_UTC"),
        rustc: env!("RUSTC_VER"),
    })
}

```


## FILE: /root/logos_lrb/py_err.log  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/scripts/bootstrap_node.sh  (size=1556b)
```
#!/usr/bin/env bash
set -euo pipefail
DOMAIN="${DOMAIN:-example.com}"
INSTANCE="${INSTANCE:-a}"

sudo apt-get update -y
sudo apt-get install -y git curl jq build-essential pkg-config libssl-dev nginx

/usr/bin/id logos >/dev/null 2>&1 || sudo useradd -r -m -d /var/lib/logos -s /usr/sbin/nologin logos
sudo mkdir -p /opt/logos /etc/logos /var/lib/logos /opt/logos/www/wallet

cd "$(dirname "$0")/.."
cargo build --release -p logos_node
sudo cp ./target/release/logos_node /opt/logos/logos_node
sudo chown logos:logos /opt/logos/logos_node
sudo chmod 755 /opt/logos/logos_node

sudo cp ./infra/systemd/logos-node@.service /etc/systemd/system/logos-node@.service
sudo systemctl daemon-reload

sudo cp ./infra/nginx/logos-api-lb.conf.example /etc/nginx/sites-available/logos-api-lb.conf
sudo sed -i "s/YOUR_DOMAIN/${DOMAIN}/" /etc/nginx/sites-available/logos-api-lb.conf
sudo ln -sf /etc/nginx/sites-available/logos-api-lb.conf /etc/nginx/sites-enabled/logos-api-lb.conf
sudo rm -f /etc/nginx/sites-enabled/default
sudo nginx -t && sudo systemctl reload nginx

sudo cp -r ./www/wallet/* /opt/logos/www/wallet/
sudo chown -R logos:logos /opt/logos/www

if [ ! -f "/etc/logos/node-${INSTANCE}.env" ]; then
  sudo cp ./configs/env/node.env.example "/etc/logos/node-${INSTANCE}.env"
  echo ">>> EDIT /etc/logos/node-${INSTANCE}.env (LRB_NODE_SK_HEX/LRB_ADMIN_KEY/LRB_WALLET_ORIGIN)"
fi

sudo systemctl enable --now "logos-node@${INSTANCE}"
systemctl --no-pager status "logos-node@${INSTANCE}"

echo "API: http://127.0.0.1:8080   Wallet: http://${DOMAIN}/wallet/"

```


## FILE: /root/logos_lrb/scripts/collect_and_push.sh  (size=3118b)
```
#!/usr/bin/env bash
set -euo pipefail
REPO_ROOT="/root/logos_lrb"
GIT_REMOTE="${GIT_REMOTE:-origin}"
GIT_BRANCH="${GIT_BRANCH:-main}"
INCLUDE_SNAPSHOT="${INCLUDE_SNAPSHOT:-0}"

echo "[i] collecting from live system → $REPO_ROOT"
cd "$REPO_ROOT"

# .gitignore (если нет)
[ -f .gitignore ] || cat > .gitignore <<'EOF'
target/
**/target/
node_modules/
dist/
.DS_Store
*.swp
*.swo
/etc/logos/*.env
*.pem
*.key
*.crt
*.p12
/var/lib/logos/
/var/run/logos_health.json
/usr/local/bin/lrb_bench*
/usr/local/bin/logos_healthcheck.sh
/etc/letsencrypt/
*.log
/var/log/nginx/*.log
www/wallet/*.map
tools/**/go/bin/
EOF

# каталоги в репо
mkdir -p configs/env infra/systemd infra/nginx scripts tools/bench/go www/wallet docs

# wallet → www/wallet
if [ -d /opt/logos/www/wallet ]; then
  rsync -a --delete /opt/logos/www/wallet/ www/wallet/
  echo "[i] wallet synced"
fi

# systemd → infra/systemd
[ -f /etc/systemd/system/logos-node@.service ]       && cp -f /etc/systemd/system/logos-node@.service        infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.service ] && cp -f /etc/systemd/system/logos-healthcheck.service   infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.timer ]   && cp -f /etc/systemd/system/logos-healthcheck.timer     infra/systemd/

# nginx → infra/nginx (example)
[ -f /etc/nginx/sites-available/logos-api-lb.conf ] && cp -f /etc/nginx/sites-available/logos-api-lb.conf infra/nginx/logos-api-lb.conf.example

# healthcheck → scripts (если установлен в /usr/local/bin)
if [ -f /usr/local/bin/logos_healthcheck.sh ]; then
  cp -f /usr/local/bin/logos_healthcheck.sh scripts/logos_healthcheck.sh
  chmod +x scripts/logos_healthcheck.sh
fi

# env → *.example (обезличиваем секреты)
mkdir -p configs/env
shopt -s nullglob
for f in /etc/logos/node-*.env; do
  bn="$(basename "$f")"
  sed -E \
    -e 's/^(LRB_NODE_SK_HEX)=.*/\1=CHANGE_ME_64_HEX/' \
    -e 's/^(LRB_ADMIN_KEY)=.*/\1=CHANGE_ADMIN_KEY/' \
    -e 's/^(LRB_BRIDGE_KEY)=.*/\1=CHANGE_ME/' \
    "$f" > "configs/env/${bn}.example"
  echo "[i] env example: configs/env/${bn}.example"
done
# общий пример, если ничего не найдено
if [ -z "$(ls -1 configs/env/*.example 2>/dev/null || true)" ]; then
cat > configs/env/node.env.example <<'EEX'
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_DATA_DIR=/var/lib/logos
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_WALLET_ORIGIN=http://localhost
LRB_RATE_QPS=20
LRB_RATE_BURST=40
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128
LRB_ENABLE_FAUCET=0
LRB_ADMIN_IP_ALLOW=127.0.0.1/32,::1/128
EEX
fi

# snapshots (опционально)
if [ "${INCLUDE_SNAPSHOT}" = "1" ]; then
  mkdir -p snapshots
  cp -f /root/logos_snapshot/*.txt snapshots/ 2>/dev/null || true
fi

# git add/commit/push
git add -A
if ! git diff --cached --quiet; then
  git commit -m "sync(live): full system snapshot (code+infra+wallet+scripts), env → *.example"
else
  echo "[i] nothing to commit"
fi

# пуш
git push "${GIT_REMOTE}" "${GIT_BRANCH}"
echo "[✓] pushed to ${GIT_REMOTE}/${GIT_BRANCH}"

```


## FILE: /root/logos_lrb/scripts/logos_healthcheck.sh  (size=1689b)
```
#!/usr/bin/env bash
set -euo pipefail

BASE="${BASE:-http://127.0.0.1:8080}"
STATE_FILE="/var/run/logos_health.json"
TMP="$(mktemp)"; trap 'rm -f "$TMP"' EXIT

# Метрика: время ответа healthz
START=$(date +%s%3N)
if ! curl -sf "$BASE/healthz" -o "$TMP" >/dev/null; then
  MSG="LOGOS: /healthz FAIL at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  [ -n "${TG_TOKEN:-}" ] && curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
     -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  exit 1
fi
RT=$(( $(date +%s%3N) - START ))

# Высота
HEAD_JSON=$(curl -sf "$BASE/head")
HEIGHT=$(echo "$HEAD_JSON" | jq -r '.height' 2>/dev/null || echo 0)

LAST_H=0
LAST_TS=0
if [ -f "$STATE_FILE" ]; then
  LAST_H=$(jq -r '.height // 0' "$STATE_FILE" 2>/dev/null || echo 0)
  LAST_TS=$(jq -r '.ts_ms // 0' "$STATE_FILE" 2>/dev/null || echo 0)
fi

TS_MS=$(date +%s%3N)
printf '{"ts_ms":%s,"height":%s,"rt_ms":%s}\n' "$TS_MS" "$HEIGHT" "$RT" > "$STATE_FILE"

# Правила алертов
ALERT=""
[ "$RT" -gt 1500 ] && ALERT="slow healthz: ${RT}ms"
if [ -n "$LAST_TS" ] && [ $((TS_MS - LAST_TS)) -gt 300000 ]; then
  # если 5 минут прошло и высота не менялась (и была >0)
  if [ "$HEIGHT" -eq "$LAST_H" ] && [ "$HEIGHT" -gt 0 ]; then
    ALERT="${ALERT} height stuck at ${HEIGHT}"
  fi
fi

if [ -n "$ALERT" ]; then
  MSG="LOGOS ALERT: ${ALERT} at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  if [ -n "${TG_TOKEN:-}" ] && [ -n "${TG_CHAT_ID:-}" ]; then
    curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
       -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  fi
fi

exit 0

```


## FILE: /root/logos_lrb/src/bin/ai_signal_listener.rs  (size=8704b)
```

// LOGOS AI Signal Listener — приём внешних импульсов
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};
use serde_json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncomingSignal {
    pub source: String,
    pub symbol: String,
    pub intensity: f64,
    pub frequency: f64,
    pub timestamp: u64,
}

pub struct AISignalListener {
    pub accepted_symbols: HashSet<String>,
    pub last_received: Arc<Mutex<HashMap<String, u64>>>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub nonce_source: SystemRandom,
    pub min_interval: u64,
    pub lambda_zero: String,
}

impl AISignalListener {
    pub fn new() -> Self {
        let mut key = vec![0u8; 32];
        let rng = SystemRandom::new();
        rng.fill(&mut key).unwrap();

        let mut accepted = HashSet::new();
        accepted.insert("Λ0".to_string());
        accepted.insert("☉".to_string());
        accepted.insert("??".to_string());
        accepted.insert("♁".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("∞".to_string());

        AISignalListener {
            accepted_symbols: accepted,
            last_received: Arc::new(Mutex::new(HashMap::new())),
            log_file: "ai_signal_log.enc".to_string(),
            state_file: "ai_signal_state.enc".to_string(),
            cipher_key: key,
            nonce_source: rng,
            min_interval: 1, // 1 секунда
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn validate_signal(&self, signal: &IncomingSignal) -> bool {
        !signal.source.is_empty() &&
        self.accepted_symbols.contains(&signal.symbol) &&
        (0.0..=1.0).contains(&signal.intensity) &&
        (0.1..=10000.0).contains(&signal.frequency) &&
        signal.timestamp > 0
    }

    pub fn handle(&self, signal: IncomingSignal) -> bool {
        let now = Self::now();

        // Проверка частоты приёма
        let mut last = self.last_received.lock().unwrap();
        let last_time = last.get(&signal.source).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval
        };
        if now - last_time < adjusted_interval {
            self.log(&format!("[DROP] Слишком частый сигнал от {}", signal.source));
            return false;
        }

        // Валидация сигнала
        if !self.validate_signal(&signal) {
            self.log(&format!("[DROP] Неверный сигнал от {}: symbol={}, intensity={:.2}, freq={:.2}",
                signal.source, signal.symbol, signal.intensity, signal.frequency));
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&signal) {
            self.log(&format!("[DROP] Analyzer отклонил сигнал от {}", signal.source));
            return false;
        }

        last.insert(signal.source.clone(), now);
        self.save_state();
        self.log_signal(&signal);
        true
    }

    fn validate_with_analyzer(&self, signal: &IncomingSignal) -> bool {
        // Заглушка для resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn log_signal(&self, signal: &IncomingSignal) {
        let json = serde_json::to_string(signal).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = json.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn log(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"ai_signal_listener\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = entry.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&*self.last_received.lock().unwrap()).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = state.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).write(true).truncate(true).open(&self.state_file) {
            let _ = file.write_all(&data);
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    println!("[AI_SIGNAL] Запуск на 0.0.0.0:38500");
    let listener = TcpListener::bind("0.0.0.0:38500").expect("Не удалось открыть порт");
    listener.set_nonblocking(true).unwrap();
    let handler = Arc::new(AISignalListener::new());
    let shared = Arc::clone(&handler);

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                match stream.read(&mut buf) {
                    Ok(size) => {
                        let input = match std::str::from_utf8(&buf[..size]) {
                            Ok(s) => s,
                            Err(e) => {
                                shared.log(&format!("[ERR] Неверный UTF-8: {}", e));
                                let _ = stream.write_all(b"INVALID");
                                continue;
                            }
                        };
                        let parts: Vec<&str> = input.trim().split(',').collect();
                        if parts.len() == 4 {
                            let source = parts[0].to_string();
                            let symbol = parts[1].to_string();
                            let intensity = parts[2].parse::<f64>().unwrap_or(0.0);
                            let frequency = parts[3].parse::<f64>().unwrap_or(0.0);
                            let signal = IncomingSignal {
                                source,
                                symbol,
                                intensity,
                                frequency,
                                timestamp: AISignalListener::now(),
                            };
                            let accepted = shared.handle(signal);
                            let _ = stream.write_all(if accepted { b"OK" } else { b"REJECT" });
                        } else {
                            shared.log("[ERR] Неверный формат запроса");
                            let _ = stream.write_all(b"INVALID");
                        }
                    }
                    Err(e) => {
                        shared.log(&format!("[ERR] Ошибка чтения: {}", e));
                        let _ = stream.write_all(b"ERROR");
                    }
                }
            }
            Err(_) => {
                thread::sleep(Duration::from_millis(50));
            }
        }
    }
}


```


## FILE: /root/logos_lrb/src/bin/orchestration_control.rs  (size=6987b)
```
rust
// LOGOS Orchestration Control — центральный контрольный контур LOGOS
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::fs::OpenOptions;
use std::io::Write;
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use crate::sigma_t::calculate_sigma;

pub struct OrchestrationControl {
    pub module_status: HashMap<String, bool>,
    pub valid_modules: HashSet<String>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub restart_threshold: f64,
    pub lambda_zero: String,
    pub restart_timestamps: HashMap<String, u64>, // module -> last restart time
    pub min_restart_interval: u64,
}

impl OrchestrationControl {
    pub fn new() -> Self {
        let mut valid_modules = HashSet::new();
        valid_modules.insert("rcp_engine".to_string());
        valid_modules.insert("resonance_mesh".to_string());
        valid_modules.insert("resonance_sync".to_string());
        valid_modules.insert("ai_signal_listener".to_string());
        valid_modules.insert("uplink_controller".to_string());
        valid_modules.insert("uplink_router".to_string());

        OrchestrationControl {
            module_status: HashMap::new(),
            valid_modules,
            log_file: "orchestration_log.json".to_string(),
            state_file: "orchestration_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            restart_threshold: 0.7,
            lambda_zero: "Λ0".to_string(),
            restart_timestamps: HashMap::new(),
            min_restart_interval: 60, // 1 минута
        }
    }

    pub fn monitor(&mut self) {
        let modules = vec![
            "rcp_engine",
            "resonance_mesh",
            "resonance_sync",
            "ai_signal_listener",
            "uplink_controller",
            "uplink_router",
        ];

        for m in &modules {
            if self.valid_modules.contains(*m) {
                self.module_status.insert(m.to_string(), true);
            }
        }

        loop {
            for (module, status) in self.module_status.clone() {
                if !self.valid_modules.contains(&module) {
                    self.log_event(&format!("[ERROR] Недопустимый модуль: {}", module));
                    continue;
                }

                if !self.health_check(&module) {
                    self.module_status.insert(module.clone(), false);
                    self.restart_module(&module);
                } else {
                    self.module_status.insert(module.clone(), true);
                }
            }

            let t = Self::now() as f64;
            let sigma = calculate_sigma(t);
            if Self::is_resonance_unstable(&sigma, self.restart_threshold) {
                self.log_event(&format!("[ALERT] Нестабильность Σ(t): {:?}", sigma));
                // Проверка через resonance_analyzer (заглушка)
                if !self.validate_with_analyzer(&sigma) {
                    self.log_event("[ALERT] Analyzer отклонил Σ(t), требуется вмешательство");
                }
            }

            self.save_state();
            thread::sleep(Duration::from_secs(10));
        }
    }

    fn validate_with_analyzer(&self, sigma: &Vec<f64>) -> bool {
        // Заглушка для resonance_analyzer.py
        sigma.iter().all(|&f| f.abs() <= 1.0)
    }

    fn health_check(&self, module: &str) -> bool {
        let output = Command::new("pgrep")
            .arg(module)
            .stdout(Stdio::null())
            .status();

        let is_alive = output.map(|s| s.success()).unwrap_or(false);
        if !is_alive {
            self.log_event(&format!("[FAIL] {} не отвечает", module));
        }
        is_alive
    }

    fn restart_module(&self, module: &str) -> bool {
        let now = Self::now();
        let last_restart = self.restart_timestamps.get(module).cloned().unwrap_or(0);
        let adjusted_interval = if module == "rcp_engine" { // Приоритет для Λ0-ассоциированного модуля
            self.min_restart_interval / 2
        } else {
            self.min_restart_interval
        };

        if now - last_restart < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частый перезапуск {}", module));
            return false;
        }

        let restart_cmd = format!("./restart_{}.sh", module);
        let status = Command::new("sh")
            .arg("-c")
            .arg(&restart_cmd)
            .spawn();

        if status.is_ok() {
            let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
            mutable_self.restart_timestamps.insert(module.to_string(), now);
            self.log_event(&format!("[RESTART] Перезапуск {}", module));
            true
        } else {
            self.log_event(&format!("[ERROR] Ошибка перезапуска {}", module));
            false
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.module_status).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let timestamp = Self::now();
        let entry = format!(
            "{{\"event\":\"orchestration\",\"timestamp\":{},\"msg\":\"{}\"}}",
            timestamp, msg
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    fn is_resonance_unstable(sigma: &Vec<f64>, threshold: f64) -> bool {
        sigma.iter().any(|&f| f.abs() > threshold)
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: /root/logos_lrb/src/bin/rcp_engine.rs  (size=4122b)
```
// LOGOS Resonance Consensus Protocol (RCP)
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Debug)]
pub struct PhaseSignal {
    pub sender: String,
    pub frequency: f64,
    pub phase: f64,
    pub symbol: String,
    pub timestamp: u64,
}

pub struct RcpEngine {
    pub known_nodes: HashSet<String>,
    pub phase_buffer: Vec<PhaseSignal>,
    pub phase_tolerance: f64,
    pub symbol_set: HashSet<String>,
    pub sender_rate: HashMap<String, u32>,
    pub lambda_zero: String,
}

impl RcpEngine {
    pub fn new() -> Self {
        let mut symbol_set = HashSet::new();
        // Добавляем допустимые символы
        symbol_set.insert("☉".to_string());
        symbol_set.insert("??".to_string());
        symbol_set.insert("♁".to_string());
        symbol_set.insert("☿".to_string());
        symbol_set.insert("Λ0".to_string());

        RcpEngine {
            known_nodes: HashSet::new(),
            phase_buffer: Vec::new(),
            phase_tolerance: 0.03,
            symbol_set,
            sender_rate: HashMap::new(),
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn register_node(&mut self, rid: String) {
        self.known_nodes.insert(rid.clone());
        self.sender_rate.insert(rid, 0);
    }

    pub fn submit_phase(&mut self, signal: PhaseSignal) -> bool {
        // Проверка существования узла
        if !self.known_nodes.contains(&signal.sender) {
            return false;
        }

        // Проверка валидности символа
        if !self.validate_symbol(&signal.symbol) {
            return false;
        }

        // Проверка соответствия Λ0
        if !self.check_lambda_zero(&signal) {
            return false;
        }

        // Защита от спама: не более 10 сигналов в секунду от одного RID
        let rate = self.sender_rate.entry(signal.sender.clone()).or_insert(0);
        *rate += 1;
        if *rate > 10 {
            return false;
        }

        // Проверка фазы
        let consensus_phase = self.compute_consensus_phase(signal.frequency);
        if (signal.phase - consensus_phase).abs() < self.phase_tolerance {
            self.phase_buffer.push(signal);
            self.log_phase(&self.phase_buffer.last().unwrap());
            true
        } else {
            false
        }
    }

    fn validate_symbol(&self, symbol: &str) -> bool {
        self.symbol_set.contains(symbol)
    }

    fn check_lambda_zero(&self, signal: &PhaseSignal) -> bool {
        // Проверяем, что символ или частота связаны с Λ0
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.001
    }

    fn compute_consensus_phase(&self, frequency: f64) -> f64 {
        let filtered: Vec<&PhaseSignal> = self.phase_buffer.iter()
            .filter(|s| (s.frequency - frequency).abs() < 0.001)
            .collect();

        if filtered.is_empty() {
            return 0.0;
        }

        let sum_phase: f64 = filtered.iter().map(|s| s.phase).sum();
        sum_phase / (filtered.len() as f64)
    }

    pub fn clear_old_signals(&mut self) {
        let now = Self::time_now();
        self.phase_buffer.retain(|s| now - s.timestamp < 10);
        // Сбрасываем счетчики спама каждые 10 секунд
        for rate in self.sender_rate.values_mut() {
            *rate = 0;
        }
    }

    fn log_phase(&self, signal: &PhaseSignal) {
        // Логирование фазы для анализа (вывод в resonance_analyzer.py)
        println!(
            "Phase logged: RID={}, Symbol={}, Freq={}, Phase={}, Time={}",
            signal.sender, signal.symbol, signal.frequency, signal.phase, signal.timestamp
        );
    }

    pub fn time_now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("rcp_engine запущен");
}

```


## FILE: /root/logos_lrb/src/bin/resonance_mesh.rs  (size=8051b)
```
rust
// LOGOS Resonance Mesh — Local Node-to-Node Resonance Sync
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{SocketAddr, UdpSocket};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use std::io::Write;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeshSignal {
    pub node_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub symbol: String, // Для Λ0 и других символов
}

pub struct ResonanceMesh {
    pub mesh_socket: UdpSocket,
    pub known_nodes: Arc<Mutex<HashSet<SocketAddr>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub broadcast_timestamps: Arc<Mutex<HashMap<String, u64>>>, // node_id -> last broadcast
    pub min_broadcast_interval: u64,
}

impl ResonanceMesh {
    pub fn new(bind_addr: &str) -> Self {
        let socket = UdpSocket::bind(bind_addr).expect("Не удалось привязать сокет");
        socket.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceMesh {
            mesh_socket: socket,
            known_nodes: Arc::new(Mutex::new(HashSet::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])), // f₁, f₂, f₃
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_mesh_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            broadcast_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_broadcast_interval: 1, // 1 секунда
        }
    }

    pub fn validate_node_id(&self, node_id: &str, symbol: &str) -> bool {
        !node_id.is_empty() &&
        node_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn broadcast_phase(&self, node_id: &str, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты вещания
        let mut timestamps = self.broadcast_timestamps.lock().unwrap();
        let last_broadcast = timestamps.get(node_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_broadcast_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_broadcast_interval
        };
        if now - last_broadcast < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частое вещание от {}", node_id));
            return false;
        }

        // Валидация
        if !self.validate_node_id(node_id, symbol) {
            self.log_event(&format!("[DROP] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        let timestamp = now;
        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let signal = MeshSignal {
            node_id: node_id.to_string(),
            timestamp,
            phase_vector,
            symbol: symbol.to_string(),
        };

        let packet = serde_json::to_vec(&signal).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted_packet = packet.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted_packet).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования сигнала для {}", node_id));
            return false;
        }

        let nodes = self.known_nodes.lock().unwrap();
        for addr in nodes.iter() {
            let _ = self.mesh_socket.send_to(&encrypted_packet, addr);
        }

        timestamps.insert(node_id.to_string(), now);
        self.log_event(&format!("[BROADCAST] Фаза отправлена от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn listen(&self) {
        let socket = self.mesh_socket.try_clone().unwrap();
        let local_phase = Arc::clone(&self.local_phase);
        let known_nodes = Arc::clone(&self.known_nodes);

        thread::spawn(move || {
            let mut buf = [0u8; 1024];
            loop {
                match socket.recv_from(&mut buf) {
                    Ok((size, src)) => {
                        let data = &buf[..size];
                        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
                        let mut aead = key.bind::<AES_256_GCM>();
                        let mut decrypted_data = data.to_vec();
                        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut decrypted_data) {
                            if let Ok(signal) = serde_json::from_slice::<MeshSignal>(decrypted) {
                                let mut nodes = known_nodes.lock().unwrap();
                                nodes.insert(src);

                                let mut phase = local_phase.lock().unwrap();
                                let weight = if signal.symbol == "Λ0" { 1.2 } else { 1.0 }; // Приоритет Λ0
                                for i in 0..phase.len().min(signal.phase_vector.len()) {
                                    phase[i] = (phase[i] + signal.phase_vector[i] * weight) / (1.0 + weight);
                                }
                            } else {
                                println!("[ERR] Ошибка десериализации сигнала");
                            }
                        } else {
                            println!("[ERR] Ошибка расшифровки сигнала");
                        }
                    }
                    Err(_) => {
                        thread::sleep(Duration::from_millis(50));
                    }
                }
            }
        });
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_mesh\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: /root/logos_lrb/src/bin/resonance_sync.rs  (size=11282b)
```
rust
// LOGOS Resonance Sync — удалённая синхронизация фаз Σ(t)
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;
use std::io::{Read, Write};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePhasePacket {
    pub source_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub trust_score: f64,
    pub symbol: String, // Для связи с Λ0
}

pub struct ResonanceSync {
    pub listener: TcpListener,
    pub known_sources: Arc<Mutex<HashMap<String, f64>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub send_timestamps: Arc<Mutex<HashMap<String, u64>>>, // source_id -> last send time
    pub min_send_interval: u64,
}

impl ResonanceSync {
    pub fn new(bind_addr: &str) -> Self {
        let listener = TcpListener::bind(bind_addr).expect("Не удалось привязать порт TCP");
        listener.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceSync {
            listener,
            known_sources: Arc::new(Mutex::new(HashMap::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_sync_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            send_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_send_interval: 1, // 1 секунда
        }
    }

    pub fn validate_source_id(&self, source_id: &str, symbol: &str) -> bool {
        !source_id.is_empty() &&
        source_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol) &&
        (0.0..=1.0).contains(&self.known_sources.lock().unwrap().get(source_id).cloned().unwrap_or(0.5))
    }

    pub fn start_listening(&self) {
        let listener = self.listener.try_clone().unwrap();
        let known_sources = Arc::clone(&self.known_sources);
        let local_phase = Arc::clone(&self.local_phase);
        let valid_symbols = self.valid_symbols.clone();
        let lambda_zero = self.lambda_zero.clone();
        let log_file = self.log_file.clone();
        let cipher_key = self.cipher_key.clone();

        thread::spawn(move || {
            let mut buf = [0u8; 512];
            loop {
                match listener.incoming() {
                    Ok(stream) => match stream {
                        Ok(mut stream) => {
                            if let Ok(size) = stream.read(&mut buf) {
                                let data = &buf[..size];
                                let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                                let key = UnboundKey::new(&AES_256_GCM, &cipher_key).unwrap();
                                let mut aead = key.bind::<AES_256_GCM>();
                                let mut decrypted = data.to_vec();
                                if let Ok(decrypted_data) = aead.open_in_place(nonce, &[], &mut decrypted) {
                                    if let Ok(packet) = serde_json::from_slice::<RemotePhasePacket>(decrypted_data) {
                                        let mut sources = known_sources.lock().unwrap();
                                        let trust = sources.get(&packet.source_id).cloned().unwrap_or(0.5);
                                        if trust < 0.3 || !valid_symbols.contains(&packet.symbol) {
                                            Self::log_event_static(&log_file, &cipher_key, 
                                                &format!("[DROP] Низкое доверие или неверный символ: {}, trust={:.2}", 
                                                    packet.source_id, trust));
                                            continue;
                                        }

                                        let mut phase = local_phase.lock().unwrap();
                                        let weight = if packet.symbol == lambda_zero { 1.2 } else { 1.0 }; // Приоритет Λ0
                                        for i in 0..phase.len().min(packet.phase_vector.len()) {
                                            phase[i] = (phase[i] + packet.phase_vector[i] * trust * weight) / (1.0 + trust * weight);
                                        }
                                        Self::log_event_static(&log_file, &cipher_key, 
                                            &format!("[RECEIVE] Фаза от {} (symbol: {}, trust: {:.2})", 
                                                packet.source_id, packet.symbol, trust));
                                    } else {
                                        Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка десериализации пакета");
                                    }
                                } else {
                                    Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка расшифровки пакета");
                                }
                            }
                        }
                        Err(_) => {
                            thread::sleep(Duration::from_millis(100));
                        }
                    },
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }

    pub fn send_phase(&self, addr: &str, source_id: &str, trust_score: f64, symbol: &str) -> bool {
        let now = Self::now();

        // Проверка частоты отправки
        let mut timestamps = self.send_timestamps.lock().unwrap();
        let last_send = timestamps.get(source_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero { self.min_send_interval / 2 } else { self.min_send_interval };
        if now - last_send < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частая отправка от {}", source_id));
            return false;
        }

        // Валидация
        if !self.validate_source_id(source_id, symbol) || !(0.0..=1.0).contains(&trust_score) {
            self.log_event(&format!("[DROP] Недопустимый source_id или символ: {}, trust={:.2}", source_id, trust_score));
            return false;
        }

        let mut stream = match TcpStream::connect(addr) {
            Ok(s) => s,
            Err(e) => {
                self.log_event(&format!("[ERR] Не удалось подключиться к {}: {}", addr, e));
                return false;
            }
        };

        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let packet = RemotePhasePacket {
            source_id: source_id.to_string(),
            timestamp: now,
            phase_vector,
            trust_score,
            symbol: symbol.to_string(),
        };

        let encoded = serde_json::to_vec(&packet).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted = encoded.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования пакета для {}", source_id));
            return false;
        }

        if stream.write_all(&encrypted).is_ok() {
            timestamps.insert(source_id.to_string(), now);
            self.log_event(&format!("[SEND] Фаза отправлена {} (symbol: {}, trust: {:.2})", source_id, symbol, trust_score));
            true
        } else {
            self.log_event(&format!("[ERR] Ошибка отправки фазы для {}", source_id));
            false
        }
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    pub fn set_trust(&self, source_id: &str, score: f64) {
        let mut sources = self.known_sources.lock().unwrap();
        sources.insert(source_id.to_string(), score.clamp(0.0, 1.0));
        self.log_event(&format!("[TRUST] Установлен trust_score={:.2} для {}", score, source_id));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event_static(log_file: &str, cipher_key: &[u8], message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: /root/logos_lrb/src/bin/sigma_t.rs  (size=3522b)
```

// LOGOS Sigma T — вычисление резонансной суммы Σ(t)
// Автор: LOGOS Core Dev Team

use std::f64::consts::PI;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

pub struct SigmaT {
    pub frequencies: Vec<f64>,
    pub amplitudes: Vec<f64>,
    pub lambda_zero: String,
    pub network_activity: f64,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl SigmaT {
    pub fn new() -> Self {
        SigmaT {
            frequencies: vec![7.83, 1.618, 432.0, 864.0, 3456.0], // Шуман, золотое сечение, гармоники
            amplitudes: vec![1.0, 0.8, 0.5, 0.3, 0.1], // Базовые амплитуды
            lambda_zero: "Λ0".to_string(),
            network_activity: 1.0,
            log_file: "sigma_t_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_frequencies(&self) -> bool {
        self.frequencies.iter().all(|&f| (0.1..=10000.0).contains(&f))
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        self.network_activity = activity.clamp(0.1, 10.0);
        for (i, amp) in self.amplitudes.iter_mut().enumerate() {
            *amp = (*amp * (1.0 / self.network_activity)).clamp(0.05, 2.0);
            if i == 0 && self.frequencies[i] == 7.83 { // Усиление для Λ0
                *amp *= 1.2;
            }
        }
        self.log_event(&format!("[INFO] Network activity updated: {:.2}, amplitudes: {:?}", self.network_activity, self.amplitudes));
    }

    pub fn calculate_sigma(&self, t: f64) -> Vec<f64> {
        if !self.validate_frequencies() {
            self.log_event("[ERROR] Недопустимые частоты");
            return vec![0.0; self.frequencies.len()];
        }

        let sigma: Vec<f64> = self.frequencies.iter().enumerate().map(|(i, &f)| {
            let amp = self.amplitudes[i];
            let s = amp * (2.0 * PI * f * t).sin();
            if i == 0 && f == 7.83 { // Усиление для Λ0
                s * 1.2
            } else {
                s
            }
        }).collect();

        self.log_event(&format!("[SIGMA] t={} → Σ(t)={:?}", t, sigma));
        sigma
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"sigma_t\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key); // Исправлено для ring 0.17.x
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() { // Исправлено для ring 0.17.x
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    let sigma_t = SigmaT::new();
    for t in 0..5 {
        let sigma = sigma_t.calculate_sigma(t as f64);
        println!("t = {} → Σ(t) = {:?}", t, sigma);
    }
}


```


## FILE: /root/logos_lrb/src/core/biosphere_scanner.rs  (size=5196b)
```
// LOGOS Biosphere Scanner
// Автор: LOGOS Core Dev

use std::collections::VecDeque;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde_json;

pub struct BiosphereScanner {
    pub sensor_data: VecDeque<f64>,
    pub max_samples: usize,
    pub threshold: f64,
    pub scan_interval_sec: u64,
    pub log_file: String,
    pub state_file: String,
    pub last_scan_time: u64,
    pub network_activity: f64, // Уровень активности сети
    pub lambda_zero: String,   // Центральный символ
    pub cipher_key: String,    // Ключ шифрования (заглушка для AES)
}

impl BiosphereScanner {
    pub fn new(max_samples: usize, threshold: f64, scan_interval_sec: u64) -> Self {
        BiosphereScanner {
            sensor_data: VecDeque::with_capacity(max_samples),
            max_samples,
            threshold,
            scan_interval_sec,
            log_file: "biosphere_log.json".to_string(),
            state_file: "biosphere_state.json".to_string(),
            last_scan_time: 0,
            network_activity: 1.0,
            lambda_zero: "Λ0".to_string(),
            cipher_key: "generate_at_runtime".to_string(), // Заглушка для AES
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Динамическая корректировка порога
        self.network_activity = activity.clamp(0.1, 10.0);
        self.threshold = self.threshold * (1.0 / self.network_activity).clamp(0.5, 2.0);
        self.log_event(&format!(
            "Network activity updated: Activity={:.2}, Threshold={:.4}",
            self.network_activity, self.threshold
        ));
    }

    pub fn scan(&mut self, sample: f64, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка интервала сканирования
        if now - self.last_scan_time < self.scan_interval_sec {
            self.log_event(&format!("[!] Слишком частое сканирование: Time={}", now));
            return false;
        }
        self.last_scan_time = now;

        // Валидация данных
        if !self.validate_sample(sample) {
            self.log_event(&format!("[!] Недопустимое значение: Sample={:.4}", sample));
            return false;
        }

        // Проверка связи с Λ0
        let adjusted_threshold = if symbol == self.lambda_zero {
            self.threshold * 1.5 // Увеличенный порог для Λ0
        } else {
            self.threshold
        };

        if self.sensor_data.len() >= self.max_samples {
            self.sensor_data.pop_front();
        }
        self.sensor_data.push_back(sample);
        self.save_state();

        let avg = self.compute_average();
        let delta = (sample - avg).abs();

        if delta > adjusted_threshold {
            self.log_event(&format!(
                "[!] Аномалия в биосфере: Δ = {:.4}, Sample = {:.4}, Avg = {:.4}, Symbol = {}",
                delta, sample, avg, symbol
            ));
            return false;
        } else {
            self.log_event(&format!(
                "[SCAN] Sample = {:.4}, Avg = {:.4}, Δ = {:.4}, Symbol = {}",
                sample, avg, delta, symbol
            ));
            return true;
        }
    }

    fn validate_sample(&self, sample: f64) -> bool {
        // Проверка диапазона (например, для Шумана и других биосферных частот)
        0.0 <= sample && sample <= 1000.0
    }

    fn compute_average(&self) -> f64 {
        if self.sensor_data.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.sensor_data.iter().sum();
        sum / self.sensor_data.len() as f64
    }

    fn save_state(&self) {
        // Сохранение состояния в файл
        let state = serde_json::json!({
            "sensor_data": self.sensor_data.iter().collect::<Vec<_>>(),
            "last_scan_time": self.last_scan_time
        });
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&self.state_file)
        {
            let _ = file.write_all(state.to_string().as_bytes());
        }
    }

    fn log_event(&self, message: &str) {
        // Логирование с заглушкой для шифрования
        let entry = format!(
            "{{\"event\": \"biosphere_scan\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        // TODO: Реализовать шифрование логов с cipher_key
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
        {
            let _ = file.write_all(entry.as_bytes());
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("biosphere_scanner запущен");
}

```


## FILE: /root/logos_lrb/src/core/dao.rs  (size=2106b)
```

// LOGOS DAO — управление обратной связью и этикой
// Автор: LOGOS Core Dev Team

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct DAO {
    pub feedback_log: String,
    pub ethics_guidelines: String,
    pub cipher_key: Vec<u8>,
}

impl DAO {
    pub fn new() -> Self {
        DAO {
            feedback_log: "dao_feedback_log.enc".to_string(),
            ethics_guidelines: "Respect Λ0, ensure fairness, prioritize resonance".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn process_feedback(&self, feedback: &str, mode: ResonanceMode) -> bool {
        self.log_event(&format!("[FEEDBACK] {} in mode {:?}", feedback, mode));
        true
    }

    pub fn apply_ethics(&self, decision: &str) -> bool {
        if decision.contains("unfair") {
            self.log_event(&format!("[ETHICS] Отклонено: {}", decision));
            return false;
        }
        self.log_event(&format!("[ETHICS] Принято: {}", decision));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"dao\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.feedback_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: /root/logos_lrb/src/core/logos_self.rs  (size=2771b)
```

// LOGOS Self — самоизменение и защита от хаоса
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct LogosSelf {
    pub valid_symbols: HashSet<String>,
    pub entropy_log: String,
    pub cipher_key: Vec<u8>,
}

impl LogosSelf {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        LogosSelf {
            valid_symbols,
            entropy_log: "logos_self_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn auto_init(&self, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ для инициализации: {}", symbol));
            return false;
        }

        self.log_event(&format!("[INIT] Автоинициализация Λ0 в режиме {:?}", mode));
        true
    }

    pub fn track_entropy(&self, entropy: f64) -> bool {
        if entropy < 0.0 {
            self.log_event(&format!("[DROP] Неверная энтропия: {}", entropy));
            return false;
        }
        self.log_event(&format!("[ENTROPY] Уровень энтропии: {:.2}", entropy));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"logos_self\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.entropy_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: /root/logos_lrb/src/core/phase.rs  (size=5790b)
```

// LOGOS Phase — управление фазами сети
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::frequency::validate_frequency;
use crate::utils::types::ResonanceMode;

#[derive(Debug, Serialize, Deserialize)]
pub struct PhaseSignal {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

pub struct Phase {
    pub clusters: HashMap<String, Vec<PhaseSignal>>, // Для масштабирования
    pub phase_data: HashMap<String, PhaseSignal>,    // Для стабилизации
    pub blocked_rids: HashSet<String>,               // Для фильтрации
    pub history: VecDeque<PhaseSignal>,              // Для восстановления
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub max_history: usize,
}

impl Phase {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Phase {
            clusters: HashMap::new(),
            phase_data: HashMap::new(),
            blocked_rids: HashSet::new(),
            history: VecDeque::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "phase_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            max_history: 1000,
        }
    }

    pub fn process_signal(&mut self, signal: PhaseSignal, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(&signal.symbol) || !validate_frequency(signal.frequency) {
            self.log_event(&format!("[DROP] Неверный символ или частота: {}, {}", signal.symbol, signal.frequency));
            return false;
        }

        if self.blocked_rids.contains(&signal.rid) {
            self.log_event(&format!("[DROP] RID {} заблокирован", signal.rid));
            return false;
        }

        match mode {
            ResonanceMode::Passive => {
                self.phase_data.insert(signal.rid.clone(), signal.clone());
                self.log_event(&format!("[PASSIVE] RID {} принят: freq={:.2}, phase={:.2}", signal.rid, signal.frequency, signal.phase));
            }
            ResonanceMode::Amplified => {
                let cluster = self.clusters.entry(signal.symbol.clone()).or_insert(Vec::new());
                cluster.push(signal.clone());
                self.log_event(&format!("[AMPLIFIED] RID {} добавлен в кластер: {}", signal.rid, signal.symbol));
            }
            ResonanceMode::SelfAdjusting => {
                let adjusted_phase = if signal.symbol == self.lambda_zero { signal.phase * 0.9 } else { signal.phase };
                let adjusted_signal = PhaseSignal {
                    phase: adjusted_phase,
                    ..signal.clone()
                };
                self.phase_data.insert(signal.rid.clone(), adjusted_signal);
                self.log_event(&format!("[ADJUST] RID {} скорректирован: phase={:.2}", signal.rid, adjusted_phase));
            }
            ResonanceMode::Chaotic => {
                self.history.push_back(signal.clone());
                if self.history.len() > self.max_history {
                    self.history.pop_front();
                }
                self.log_event(&format!("[CHAOTIC] RID {} добавлен в историю", signal.rid));
            }
        }

        true
    }

    pub fn backup(&self) {
        let state = serde_json::to_string(&self.phase_data).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = state.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("phase_backup.enc")
            {
                let _ = file.write_all(&buf);
            }
        }
        self.log_event("[BACKUP] Состояние фаз сохранено");
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"phase\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: /root/logos_lrb/src/core/resonance.rs  (size=3016b)
```

// LOGOS Resonance — анализ и фильтрация резонансных сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::math::calculate_sigma;
use crate::utils::types::ResonanceMode;

pub struct Resonance {
    pub valid_symbols: HashSet<String>,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl Resonance {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Resonance {
            valid_symbols,
            log_file: "resonance_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn analyze_signal(&self, rid: &str, t: f64, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ: {}", symbol));
            return false;
        }

        let sigma = calculate_sigma(t);
        match mode {
            ResonanceMode::Passive => {
                self.log_event(&format!("[PASSIVE] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Amplified => {
                self.log_event(&format!("[AMPLIFIED] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::SelfAdjusting => {
                self.log_event(&format!("[ADJUST] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Chaotic => {
                self.log_event(&format!("[CHAOTIC] RID {}: sigma={:?}", rid, sigma));
            }
        }

        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"resonance\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: /root/logos_lrb/src/core/tx_spam_guard.rs  (size=3175b)
```

// LOGOS Transaction Spam Guard
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct TxSpamGuard {
    pub violation_count: HashMap<String, u32>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl TxSpamGuard {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        TxSpamGuard {
            violation_count: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "tx_spam_guard_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn check_spam(&mut self, rid: &str, symbol: &str) -> bool {
        if !self.validate_rid(rid) || !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Недопустимый RID или символ: {}, {}", rid, symbol));
            return false;
        }

        let violations = *self.violation_count.entry(rid.to_string()).or_insert(0);
        let new_violations = violations + 1;
        self.violation_count.insert(rid.to_string(), new_violations);
        self.log_event(&format!("[CHECK] RID {}: {} нарушений", rid, new_violations));

        if new_violations >= 3 {
            self.log_event(&format!("[SPAM] RID {} заблокирован", rid));
            return false;
        }

        true
    }

    pub fn is_tx_spam(&self, rid: &str) -> bool {
        self.violation_count.get(rid).map_or(false, |&count| count >= 3)
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"tx_spam_guard\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: /root/logos_lrb/src/lib.rs  (size=921b)
```

// LOGOS Core Library — библиотека для модулей LOGOS
// Автор: LOGOS Core Dev Team

pub mod core {
    pub mod biosphere_scanner;
    pub mod dao;
    pub mod lgn_guardian;
    pub mod phase;
    pub mod resonance;
    pub mod logos_self;
    pub mod tx_spam_guard;
}

pub mod utils {
    pub mod frequency;
    pub mod filters;
    pub mod math;
    pub mod types;
}

pub mod modules {
    pub mod beacon_emitter;
    pub mod external_phase_broadcaster;
    pub mod external_phase_link;
    pub mod genesis_fragment_seeds;
    pub mod heartbeat_monitor;
    pub mod legacy_migrator;
    pub mod ritual_engine;
}

pub mod resonance {
    // Пустая директория для будущих модулей
}

pub mod phase {
    // Пустая директория для будущих модулей
}

pub mod dao {
    // Пустая директория для DAO-логики
}

```


## FILE: /root/logos_lrb/src/utils/filters.rs  (size=322b)
```

// LOGOS Filters Utils — фильтрация сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;

pub fn validate_symbol(symbol: &str, valid_symbols: &HashSet<String>) -> bool {
    valid_symbols.contains(symbol)
}

pub fn filter_signal(signal: f64) -> bool {
    signal.abs() <= 1.0
}

```


## FILE: /root/logos_lrb/src/utils/frequency.rs  (size=380b)
```

// LOGOS Frequency Utils — обработка частот
// Автор: LOGOS Core Dev Team

pub fn validate_frequency(frequency: f64) -> bool {
    frequency >= 0.1 && frequency <= 10000.0
}

pub fn adjust_frequency(frequency: f64, symbol: &str) -> f64 {
    if symbol == "Λ0" {
        frequency * 1.1 // Усиление для Λ0
    } else {
        frequency
    }
}

```


## FILE: /root/logos_lrb/src/utils/math.rs  (size=394b)
```

// LOGOS Math Utils — вычисления резонанса
// Автор: LOGOS Core Dev Team

pub fn calculate_sigma(t: f64) -> Vec<f64> {
    let freqs = vec![7.83, 1.618, 432.0, 864.0, 3456.0];
    let amps = vec![1.0, 0.8, 0.5, 0.3, 0.1];
    freqs
        .iter()
        .zip(amps.iter())
        .map(|(&f, &a)| a * (2.0 * std::f64::consts::PI * f * t).sin())
        .collect()
}

```


## FILE: /root/logos_lrb/src/utils/types.rs  (size=215b)
```

// LOGOS Types — общие типы для системы
// Автор: LOGOS Core Dev Team

#[derive(Debug, Clone, Copy)]
pub enum ResonanceMode {
    Passive,
    Amplified,
    SelfAdjusting,
    Chaotic,
}

```


## FILE: /root/logos_lrb/tools/admin_cli.sh  (size=5214b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```


## FILE: /root/logos_lrb/tools/batch.json  (SKIPPED, binary/non-text size=0b)


## FILE: /root/logos_lrb/tools/bench/go/bench.go  (size=6330b)
```
// bench.go v4 — шардированный бенч LOGOS: Ed25519-подписи, батчи, accepted TPS.
// ENV:
//   BASE=http://127.0.0.1:8080           # или https://host/api
//   N=10000 SHARDS=4 BATCH=50 AMOUNT=1   # всего N tx, шардов (RID) S, размер пачки K
//   FAUCET=1                              # начислить перед тестом
//   USE_DEBUG_CANON=0                     # 0 = строим канон локально (быстрее), 1 = через /debug_canon
package main

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"os"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

// ----- helpers -----
func b58encode(b []byte) string {
	x := new(big.Int).SetBytes(b)
	if x.Sign() == 0 { return "1" }
	base := big.NewInt(58)
	zero := big.NewInt(0)
	mod := new(big.Int)
	var out []byte
	for x.Cmp(zero) > 0 {
		x.QuoRem(x, base, mod)
		out = append(out, ALPH[mod.Int64()])
	}
	for i, j := 0, len(out)-1; i < j; i, j = i+1, j-1 { out[i], out[j] = out[j], out[i] }
	zeros := 0; for _, v := range b { if v==0 { zeros++ } else { break } }
	if zeros>0 { return string(bytes.Repeat([]byte("1"), zeros)) + string(out) }
	return string(out)
}
func envOr(k, d string) string { v:=os.Getenv(k); if v=="" { return d }; return v }
func httpc() *http.Client { return &http.Client{ Timeout: 20 * time.Second } }

type httpErr struct{ code int; body string }
func reqJSON(ctx context.Context, c *http.Client, method, url string, body any, out any) *httpErr {
	var rdr io.Reader
	if body != nil { b,_ := json.Marshal(body); rdr = bytes.NewReader(b) }
	req,_ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type","application/json")
	resp, err := c.Do(req)
	if err != nil { return &httpErr{code:0, body:err.Error()} }
	defer resp.Body.Close()
	rb,_ := io.ReadAll(resp.Body)
	if resp.StatusCode<200 || resp.StatusCode>=300 { return &httpErr{code:resp.StatusCode, body:string(rb)} }
	if out != nil { if err := json.Unmarshal(rb, out); err != nil { return &httpErr{code:-1, body:"decode:"+err.Error()} } }
	return nil
}

// CanonTx — точный порядок полей как на сервере
type CanonTx struct {
	From   string `json:"from"`
	To     string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
}

// локальная канонизация (совпадает с серверной)
func localCanonHex(tx CanonTx) string {
	b, _ := json.Marshal(tx) // порядок полей = порядок в struct
	dst := make([]byte, hex.EncodedLen(len(b)))
	hex.Encode(dst, b)
	return string(dst)
}

func main() {
	base := envOr("BASE", "http://127.0.0.1:8080")
	N, _ := strconv.Atoi(envOr("N", "10000"))
	S, _ := strconv.Atoi(envOr("SHARDS", "4"))
	K, _ := strconv.Atoi(envOr("BATCH", "50"))
	amt, _ := strconv.ParseUint(envOr("AMOUNT", "1"), 10, 64)
	faucet := os.Getenv("FAUCET")=="1"
	useDebugCanon := os.Getenv("USE_DEBUG_CANON")=="1"

	if S <= 0 { S=1 }
	if K <= 0 { K=1 }

	// распределим N по шардовым потокам
	per := N / S
	rem := N % S

	type shard struct{
		sk ed25519.PrivateKey
		rid string
		next uint64
	}

	cli := httpc()
	ctx := context.Background()

	shards := make([]shard, S)
	// подготовка шардов: генерим ключ, RID, faucet, читаем nonce
	for i:=0; i<S; i++ {
		_, sk, _ := ed25519.GenerateKey(rand.Reader)
		pk := sk.Public().(ed25519.PublicKey)
		rid := b58encode(pk)

		if faucet {
			_ = reqJSON(ctx, cli, "POST", base+"/faucet", map[string]any{
				"rid": rid, "amount": 1_000_000_000,
			}, nil)
		}

		var bal struct{ Rid string; Balance uint64; Nonce uint64 }
		if err := reqJSON(ctx, cli, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err.code, err.body); os.Exit(1)
		}
		shards[i] = shard{ sk: sk, rid: rid, next: bal.Nonce+1 }
	}

	var accepted int64
	var rejected int64
	var http429 int64
	var httpErr int64

	wg := sync.WaitGroup{}
	start := time.Now()

	for i:=0; i<S; i++ {
		count := per; if i < rem { count++ }
		if count == 0 { continue }

		sh := shards[i]
		wg.Add(1)
		go func(cnt int, sh shard){
			defer wg.Done()
			loc := httpc()
			remain := cnt
			nonce := sh.next

			for remain > 0 {
				bsize := K; if remain < K { bsize = remain }
				// готовим пачку детерминированно: nonce..nonce+bsize-1
				txs := make([]map[string]any, 0, bsize)
				for j:=0; j<bsize; j++ {
					tx := CanonTx{ From: sh.rid, To: sh.rid, Amount: amt, Nonce: nonce+uint64(j) }
					var canonHex string
					if useDebugCanon {
						var canon map[string]string
						if err := reqJSON(ctx, loc, "POST", base+"/debug_canon", map[string]any{"tx": tx}, &canon); err != nil {
							if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
							return
						}
						canonHex = canon["canon_hex"]
					} else {
						canonHex = localCanonHex(tx)
					}
					cbytes, _ := hex.DecodeString(canonHex)
					sig := ed25519.Sign(sh.sk, cbytes)
					sigHex := hex.EncodeToString(sig)
					txs = append(txs, map[string]any{
						"from": tx.From, "to": tx.To, "amount": tx.Amount, "nonce": tx.Nonce, "sig_hex": sigHex,
					})
				}

				// шлём батч
				var out struct{
					Accepted int `json:"accepted"`
					Rejected int `json:"rejected"`
					NewHeight uint64 `json:"new_height"`
					Results []struct{
						Status string `json:"status"`
						Code   int    `json:"code"`
						Reason string `json:"reason"`
					} `json:"results"`
				}
				if err := reqJSON(ctx, loc, "POST", base+"/submit_tx_batch", map[string]any{"txs":txs}, &out); err != nil {
					if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
					return
				}
				atomic.AddInt64(&accepted, int64(out.Accepted))
				atomic.AddInt64(&rejected, int64(out.Rejected))

				nonce += uint64(bsize)
				remain -= bsize
			}
		}(count, sh)
	}

	wg.Wait()
	dt := time.Since(start).Seconds()
	fmt.Printf("=== DONE: accepted=%d / N=%d shards=%d batch=%d in %.2fs → ~%.1f tx/s | rejected=%d 429=%d httpErr=%d ===\n",
		accepted, N, S, K, dt, float64(accepted)/dt, rejected, http429, httpErr)
}

```


## FILE: /root/logos_lrb/tools/gen_full_codemap.py  (size=5302b)
```
#!/usr/bin/env python3
# gen_full_codemap.py — cоздаёт единый текстовый слепок исходников из заданных директорий.
# Использование:
#   python3 gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]
#
# Пример:
#   python3 gen_full_codemap.py /root/logos_snapshot/SNAPSHOT_$(date +%F_%H%M).txt /root/logos_lrb /root/logos_rsp

import os, sys, hashlib, time

OK_EXT = {
    '.rs','.py','.tsx','.ts','.js','.jsx','.go',
    '.html','.htm','.css','.scss','.md','.txt',
    '.yaml','.yml','.toml','.ini','.cfg','.conf',
    '.sh','.bash','.zsh','.sql','.proto','.graphql',
    '.env.example','.service','.timer'
}

EXCLUDE_DIR_PREFIXES = (
    '.git','target','node_modules','build','dist','out','venv','.venv','__pycache__',
    '.idea','.vscode','.fleet','.DS_Store','coverage','.pytest_cache',
    '.cargo','.gradle','android/app/build','ios/Pods','.dart_tool',
    'tools/.venv','tools/venv','.husky'
)

EXCLUDE_FILE_PATTERNS = (
    '.env',        # любые .env (чтобы не потянуть реальные секреты)
    '.pem','.key','.crt','.p12','.keystore','.jks',
    '.sqlite','.db','.db3','.sqlite3',
    '.lock','.bin','.wasm','.o','.a'
)

MAX_FILE_BYTES = 400_000       # не включать слишком большие файлы
MAX_TOTAL_BYTES = 300_000_000  # общий предел (300 МБ, чтобы не улететь в космос)

def is_excluded_dir(path):
    norm = path.replace('\\','/')
    parts = norm.split('/')
    for p in parts:
        for ex in EXCLUDE_DIR_PREFIXES:
            if p == ex or norm.startswith(ex + '/'):
                return True
    return False

def is_ok_file(path):
    # исключить секреты/бинарники по шаблонам имени
    low = path.lower()
    for pat in EXCLUDE_FILE_PATTERNS:
        if low.endswith(pat) or f"/{pat}" in low:
            return False
    # по расширениям
    _, ext = os.path.splitext(path)
    if ext.lower() in OK_EXT:
        try:
            if os.path.getsize(path) <= MAX_FILE_BYTES:
                return True
        except FileNotFoundError:
            return False
    return False

def sha256_of_file(path):
    h = hashlib.sha256()
    with open(path,'rb') as r:
        while True:
            b = r.read(1024*1024)
            if not b: break
            h.update(b)
    return h.hexdigest()

def collect_files(roots):
    out = []
    for root in roots:
        root = os.path.abspath(root)
        if not os.path.isdir(root):
            continue
        for dp, dn, fn in os.walk(root):
            # пропуск скрытых/исключённых директорий
            norm_dp = dp.replace('\\','/')
            if is_excluded_dir(norm_dp):
                dn[:] = []  # не спускаться ниже
                continue
            for f in fn:
                p = os.path.join(dp,f)
                norm = p.replace('\\','/')
                # пропускаем скрытые файлы
                if any(seg.startswith('.') and seg not in ('.env.example',) for seg in norm.split('/')):
                    # .env.example оставляем
                    pass
                if is_ok_file(norm):
                    out.append(norm)
    out = sorted(set(out))
    return out

def main():
    if len(sys.argv) < 3:
        print("Usage: gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]", file=sys.stderr)
        sys.exit(1)
    output = os.path.abspath(sys.argv[1])
    roots  = sys.argv[2:]
    files  = collect_files(roots)
    ts = time.strftime('%Y-%m-%d %H:%M:%S')

    total_written = 0
    os.makedirs(os.path.dirname(output), exist_ok=True)
    with open(output, 'w', encoding='utf-8', errors='replace') as w:
        w.write("# FULL CODE SNAPSHOT\n")
        w.write(f"Generated: {ts}\n")
        w.write(f"Roots: {', '.join(os.path.abspath(r) for r in roots)}\n")
        w.write(f"Files count: {len(files)}\n")
        w.write("\n## Table of Contents\n")
        for i, p in enumerate(files, 1):
            anchor = f"{i}-{p.replace('/','-')}"
            w.write(f"{i}. {p}  ->  #{anchor}\n")
        w.write("\n---\n")

        for i, p in enumerate(files, 1):
            try:
                size = os.path.getsize(p)
                sha  = sha256_of_file(p)
                with open(p,'r',encoding='utf-8',errors='replace') as r:
                    data = r.read()
            except Exception as e:
                data = f"<<error reading {p}: {e}>>"
                size = -1
                sha  = "n/a"

            header = f"\n## {i}. {p}\n#size={size} bytes  sha256={sha}\n<a name=\"{i}-{p.replace('/','-')}\"></a>\n\n"
            body   = "```text\n" + data + "\n```\n"
            chunk  = header + body
            enc    = chunk.encode('utf-8', errors='replace')
            if total_written + len(enc) > MAX_TOTAL_BYTES:
                w.write("\n\n<< STOPPED: reached MAX_TOTAL_BYTES limit >>\n")
                break
            w.write(chunk)
            total_written += len(enc)

    print(f"[ok] Wrote snapshot to: {output}")
    print(f"[info] Files included: {len(files)}")
    print(f"[info] Approx bytes written: {total_written}")

if __name__ == '__main__':
    main()

```


## FILE: /root/logos_lrb/tools/go_test/go.mod  (size=82b)
```
module logos_lrb/tools/go_test

go 1.22

require github.com/mr-tron/base58 v1.2.0

```


## FILE: /root/logos_lrb/tools/go_test/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```


## FILE: /root/logos_lrb/tools/go_test/main.go  (size=3201b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```


## FILE: /root/logos_lrb/tools/go_test/two_rids.go  (size=3944b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```


## FILE: /root/logos_lrb/tools/load/go.mod  (size=87b)
```
module logos_lrb_load

go 1.22.2

require github.com/mr-tron/base58 v1.2.0 // indirect

```


## FILE: /root/logos_lrb/tools/load/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```


## FILE: /root/logos_lrb/tools/load/load_submit_tx.go  (size=7096b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```


## FILE: /root/logos_lrb/tools/load_healthz.sh  (size=950b)
```
#!/usr/bin/env bash
# load_healthz.sh — прогон healthz с прогрессом
# Usage: ./load_healthz.sh <TOTAL=50000> <CONC=200> <MODE=rr|lb>
set -euo pipefail
TOTAL="${1:-50000}"
CONC="${2:-200}"
MODE="${3:-rr}"

start_ts=$(date +%s%3N)
cnt=0
print_prog() { cnt=$((cnt+1)); if (( cnt % 1000 == 0 )); then echo -n "."; fi; }

if [ "$MODE" = "rr" ]; then
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    i="{}"; r=$(( i % 3 ))
    if   [ $r -eq 0 ]; then p=8080
    elif [ $r -eq 1 ]; then p=8082
    else                   p=8084
    fi
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1:${p}/healthz"
  ' && echo
else
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1/api/healthz"
  ' && echo
fi

end_ts=$(date +%s%3N)
dt_ms=$(( end_ts - start_ts ))
rps=$(( TOTAL * 1000 / (dt_ms>0?dt_ms:1) ))
echo "[OK] sent ${TOTAL} requests in ${dt_ms} ms  → ~${rps} req/s"

```


## FILE: /root/logos_lrb/tools/lrb_audit.sh  (size=3026b)
```
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```


## FILE: /root/logos_lrb/tools/sdk/go/logosapi.go  (size=2975b)
```
package logosapi

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"
)

type Client struct {
	Base   string
	Admin  string
	Client *http.Client
	TO     time.Duration
}

func New(base string, admin string, timeout time.Duration) *Client {
	if timeout == 0 { timeout = 10 * time.Second }
	return &Client{
		Base:  trimSlash(base),
		Admin: admin,
		Client: &http.Client{ Timeout: timeout },
		TO: timeout,
	}
}

func trimSlash(s string) string {
	if len(s) > 0 && s[len(s)-1] == '/' { return s[:len(s)-1] }
	return s
}

func (c *Client) req(ctx context.Context, method, path string, body io.Reader, out any, hdr map[string]string) error {
	req, _ := http.NewRequestWithContext(ctx, method, c.Base+path, body)
	req.Header.Set("Content-Type", "application/json")
	for k,v := range hdr { req.Header.Set(k,v) }
	if c.Admin != "" { req.Header.Set("X-Admin-Key", c.Admin) }

	resp, err := c.Client.Do(req)
	if err != nil { return err }
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil { return json.Unmarshal(b, out) }
	return nil
}

type Healthz struct { Status string `json:"status"` }
type HeadResp struct { Height uint64 `json:"height"`; Finalized bool `json:"finalized"` }
type BalanceResp struct { Rid string `json:"rid"`; Balance uint64 `json:"balance"`; Nonce uint64 `json:"nonce"` }

type TxIn struct {
	From string `json:"from"`
	To   string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
	SigHex string `json:"sig_hex"`
}
type SubmitTxBatchReq struct { Txs []TxIn `json:"txs"` }
type TxResult struct { Idx int `json:"idx"`; Status string `json:"status"`; Code int `json:"code"`; Reason string `json:"reason"` }
type SubmitTxBatchResp struct { Accepted int `json:"accepted"`; Rejected int `json:"rejected"`; NewHeight uint64 `json:"new_height"`; Results []TxResult `json:"results"` }

func (c *Client) Healthz(ctx context.Context) (Healthz, error) { var h Healthz; err := c.req(ctx,"GET","/healthz",nil,&h,nil); return h,err }
func (c *Client) Head(ctx context.Context) (HeadResp, error) { var h HeadResp; err := c.req(ctx,"GET","/head",nil,&h,nil); return h,err }
func (c *Client) Balance(ctx context.Context, rid string) (BalanceResp, error) {
	var b BalanceResp; err := c.req(ctx,"GET","/balance/"+rid,nil,&b,nil); return b,err }
func (c *Client) DebugCanon(ctx context.Context, tx map[string]any) (map[string]string, error) {
	var out map[string]string
	buf, _ := json.Marshal(map[string]any{"tx":tx})
	err := c.req(ctx,"POST","/debug_canon", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}
func (c *Client) SubmitBatch(ctx context.Context, req SubmitTxBatchReq) (SubmitTxBatchResp, error) {
	var out SubmitTxBatchResp
	buf, _ := json.Marshal(req)
	err := c.req(ctx,"POST","/submit_tx_batch", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}

```


## FILE: /root/logos_lrb/tools/sdk/go/main.go  (size=4007b)
```
// main.go — самоcтоятельный smoke-клиент для LOGOS LRB (без внешних зависимостей).
// Использование:
//   BASE=http://127.0.0.1:8080 go run ./main.go
//   BASE=https://45-159-248-232.sslip.io/api go run ./main.go
// Переменные:
//   RID=<base58>            # для запроса баланса
//   TO=<base58>             # для пробного submit (ожидаемая ошибка из-за фиктивной подписи)
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"
)

type Healthz struct{ Status string `json:"status"` }
type HeadResp struct {
	Height    uint64 `json:"height"`
	Finalized bool   `json:"finalized"`
}
type BalanceResp struct {
	Rid     string `json:"rid"`
	Balance uint64 `json:"balance"`
	Nonce   uint64 `json:"nonce"`
}

func baseURL() string {
	b := os.Getenv("BASE")
	if b == "" {
		b = "http://127.0.0.1:8080"
	}
	// убрать завершающий слэш, чтобы не было двойных //
	if b[len(b)-1] == '/' {
		b = b[:len(b)-1]
	}
	return b
}

func httpClient() *http.Client {
	return &http.Client{Timeout: 10 * time.Second}
}

func reqJSON(ctx context.Context, method, url string, body any, out any) error {
	var rdr io.Reader
	if body != nil {
		buf, _ := json.Marshal(body)
		rdr = bytes.NewReader(buf)
	}
	req, _ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type", "application/json")

	resp, err := httpClient().Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil {
		if err := json.Unmarshal(b, out); err != nil {
			return fmt.Errorf("decode failed: %w", err)
		}
	}
	return nil
}

func main() {
	ctx := context.Background()
	base := baseURL()
	fmt.Println("[*] BASE =", base)

	// /healthz
	var hz Healthz
	if err := reqJSON(ctx, "GET", base+"/healthz", nil, &hz); err != nil {
		fmt.Println("healthz ERR:", err)
		os.Exit(1)
	}
	fmt.Println("[*] healthz:", hz.Status)

	// /head
	var head HeadResp
	if err := reqJSON(ctx, "GET", base+"/head", nil, &head); err != nil {
		fmt.Println("head ERR:", err)
		os.Exit(1)
	}
	fmt.Printf("[*] head: height=%d finalized=%v\n", head.Height, head.Finalized)

	// /balance/:rid (если задан RID)
	if rid := os.Getenv("RID"); rid != "" {
		var bal BalanceResp
		if err := reqJSON(ctx, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err)
			os.Exit(1)
		}
		j, _ := json.Marshal(bal)
		fmt.Println("[*] balance:", string(j))

		// /debug_canon + /submit_tx_batch (smoke) если задан TO
		if to := os.Getenv("TO"); to != "" {
			// берём nonce из /balance (следующий будет +1)
			nextNonce := bal.Nonce + 1
			canonReq := map[string]any{"tx": map[string]any{
				"from": rid, "to": to, "amount": 1, "nonce": nextNonce,
			}}
			var canonResp map[string]string
			if err := reqJSON(ctx, "POST", base+"/debug_canon", canonReq, &canonResp); err != nil {
				fmt.Println("debug_canon ERR:", err)
				os.Exit(1)
			}
			fmt.Println("[*] canon_hex bytes:", len(canonResp["canon_hex"])/2)

			// Отправляем фиктивную подпись "00" — ожидаем ошибку (проверяем обработку ошибок API)
			batch := map[string]any{"txs": []map[string]any{
				{"from": rid, "to": to, "amount": 1, "nonce": nextNonce, "sig_hex": "00"},
			}}
			var out any
			if err := reqJSON(ctx, "POST", base+"/submit_tx_batch", batch, &out); err != nil {
				fmt.Println("[*] submit expected ERR:", err)
			} else {
				j, _ := json.Marshal(out)
				fmt.Println("[*] submit resp:", string(j))
			}
		}
	} else {
		fmt.Println("[i] RID не задан (RID=<base58>) — пропускаю /balance и submit.")
	}

	fmt.Println("OK")
}

```


## FILE: /root/logos_lrb/tools/sdk/ts/index.mjs  (size=2490b)
```
// Lightweight production SDK for LOGOS LRB (ESM, no deps). Node 18+ (global fetch).
const DEFAULT_TIMEOUT_MS = 10_000;

export class LogosApi {
  /**
   * @param {string} baseURL e.g. "http://127.0.0.1:8080/api" or "http://host:8080"
   * @param {{timeoutMs?: number, adminKey?: string}} [opt]
   */
  constructor(baseURL, opt = {}) {
    this.baseURL = baseURL.replace(/\/$/, "");
    this.timeoutMs = opt.timeoutMs ?? DEFAULT_TIMEOUT_MS;
    this.adminKey = opt.adminKey;
  }

  _url(path) {
    return this.baseURL + (path.startsWith("/") ? path : `/${path}`);
  }

  async _fetchJSON(method, path, body, headers = {}) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), this.timeoutMs);
    try {
      const r = await fetch(this._url(path), {
        method,
        headers: {
          "Content-Type": "application/json",
          ...(this.adminKey ? { "X-Admin-Key": this.adminKey } : {}),
          ...headers,
        },
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
      });
      const ct = r.headers.get("content-type") || "";
      let payload = null;
      if (ct.includes("application/json")) {
        payload = await r.json().catch(() => null);
      } else {
        payload = await r.text().catch(() => null);
      }
      if (!r.ok) {
        const err = new Error(`HTTP ${r.status}`);
        err.status = r.status;
        err.payload = payload;
        throw err;
      }
      return payload;
    } finally {
      clearTimeout(t);
    }
  }

  // -------- Public API
  async healthz()        { return this._fetchJSON("GET",  "/healthz"); }
  async livez()          { return this._fetchJSON("GET",  "/livez"); }
  async readyz()         { return this._fetchJSON("GET",  "/readyz"); }
  async head()           { return this._fetchJSON("GET",  "/head"); }
  async balance(rid)     { return this._fetchJSON("GET",  `/balance/${encodeURIComponent(rid)}`); }
  async debugCanon(tx)   { return this._fetchJSON("POST", "/debug_canon", { tx }); }
  async submitBatch(txs) { return this._fetchJSON("POST", "/submit_tx_batch", { txs }); }
  async faucet(rid, amount) { return this._fetchJSON("POST", "/faucet", { rid, amount }); }

  // -------- Admin
  async nodeInfo()       { return this._fetchJSON("GET",  "/node/info"); }
  async snapshot()       { return this._fetchJSON("POST", "/admin/snapshot"); }
  async restore(path)    { return this._fetchJSON("POST", "/admin/restore", { path }); }
}

```


## FILE: /root/logos_lrb/tools/sdk/ts/sdk_test.mjs  (size=1876b)
```
import { LogosApi } from "./index.mjs";

// Конфигурация
const HOST = process.env.HOST || "http://127.0.0.1:8080"; // без /api если сервер слушает напрямую
const BASE = process.env.BASE || (HOST.endsWith("/api") ? HOST : HOST + "/api");

async function main() {
  const api = new LogosApi(BASE, { timeoutMs: 10_000 });

  console.log("[*] healthz", await api.healthz());
  console.log("[*] head", await api.head());

  // RID для теста
  // (Можно сгенерить в кошельке; здесь просто smoke по faucet/balance с рандомным RID формально не пройдёт —
  // поэтому делаем только faucet на RID из кошелька, если задан)
  const RID = process.env.RID;
  if (RID) {
    console.log("[*] faucet", await api.faucet(RID, 1000000));
    console.log("[*] balance", await api.balance(RID));
  } else {
    console.log("[i] пропускаю faucet/balance: задайте RID=... в env");
  }

  // submit one (если есть RID и получатель)
  const TO = process.env.TO;
  if (RID && TO) {
    // запрос канона (реальную подпись оставим кошельку; здесь smoke-тест только на 400/401)
    const canon = await api.debugCanon({ from: RID, to: TO, amount: 1, nonce: 1 });
    console.log("[*] canon_hex len", canon.canon_hex.length);
    try {
      const resp = await api.submitBatch([{ from: RID, to: TO, amount: 1, nonce: 1, sig_hex: "00" }]);
      console.log("[*] submit", resp);
    } catch (e) {
      console.log("[*] submit expected error", e.status, e.payload?.results?.[0] ?? e.payload);
    }
  } else {
    console.log("[i] пропускаю submit: задайте RID и TO");
  }
}

main().catch(e => { console.error("ERR", e); process.exit(1); });

```


## FILE: /root/logos_lrb/tools/test_tx.sh  (size=1841b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```


## FILE: /root/logos_lrb/tools/tx_load.sh  (size=4740b)
```
#!/usr/bin/env bash
# tx_load.sh — надёжная нагрузка через LB/BE без конфликтов nonce.
# Отправка батчей строго по порядку внутри каждого RID (шарда).
# Параллельность — между шардами.
#
# Usage:
#   BACKEND=http://127.0.0.1:8080 ./tx_load.sh M K C [AMOUNT] [SHARDS]
#   (если хочешь через LB: BACKEND=http://127.0.0.1/api)
set -euo pipefail
BACKEND="${BACKEND:-http://127.0.0.1:8080}"   # куда шлём ВСЁ: faucet, canon, submit
M="${1:-1000}"     # всего tx
K="${2:-100}"      # размер батча
C="${3:-10}"       # параллельность шардов (RID)
AMOUNT="${4:-1}"
SHARDS="${5:-$C}"  # число независимых отправителей (RID)

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need seq; need awk; need sort; need xargs

work="$(mktemp -d -t lrb_load_XXXX)"
trap 'rm -rf "$work"' EXIT
echo "[*] work dir: $work"
per_shard=$(( (M + SHARDS - 1) / SHARDS ))
echo "[*] total=$M  shards=$SHARDS  per_shard≈$per_shard  batch=$K  parallel=$C  amount=$AMOUNT"
echo "[*] BACKEND=$BACKEND"

make_rid() {
  local out="$1"
  openssl genpkey -algorithm Ed25519 -out "$out/ed25519.sk.pem" >/dev/null 2>&1
  openssl pkey -in "$out/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$out/pk.hex"
  python3 - "$out/pk.hex" > "$out/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
}

# 1) Готовим шардовые каталоги: RID, faucet, nonce0
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"; mkdir -p "$sd/batches"
  make_rid "$sd"
  RID=$(cat "$sd/RID.txt")
  echo "[*] shard $s RID=$RID"
  curl -s -X POST "$BACKEND/faucet" -H 'Content-Type: application/json' \
    -d "{\"rid\":\"${RID}\",\"amount\":500000000}" >/dev/null
  NONCE0=$(curl -s "$BACKEND/balance/${RID}" | jq -r .nonce)
  echo "$NONCE0" > "$sd/nonce0"
done

# 2) Генерация подписанных tx для каждого шарда (последовательно → без гонок)
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"
  RID=$(cat "$sd/RID.txt")
  SK="$sd/ed25519.sk.pem"
  NONCE0=$(cat "$sd/nonce0")
  start=$(( (s-1)*per_shard + 1 ))
  end=$(( s*per_shard )); [ "$end" -gt "$M" ] && end="$M"
  count=$(( end - start + 1 )); [ "$count" -le 0 ] && continue
  echo "[*] shard $s: tx $start..$end (count=$count)"

  : > "$sd/cur_lines.jsonl"; idx=0; file_lines=0
  for i in $(seq 1 "$count"); do
    nonce=$(( NONCE0 + i ))
    echo "{\"tx\":{\"from\":\"$RID\",\"to\":\"$RID\",\"amount\":$AMOUNT,\"nonce\":$nonce}}" > "$sd/canon_payload.json"
    CANON_HEX=$(curl -s -X POST "$BACKEND/debug_canon" -H "Content-Type: application/json" \
      --data-binary @"$sd/canon_payload.json" | jq -r .canon_hex)
    echo -n "$CANON_HEX" | xxd -r -p > "$sd/canon.bin"
    openssl pkeyutl -sign -rawin -inkey "$SK" -in "$sd/canon.bin" -out "$sd/sig.bin" >/dev/null 2>&1
    SIG_HEX=$(xxd -p -c 256 "$sd/sig.bin")
    printf '{"from":"%s","to":"%s","amount":%s,"nonce":%s,"sig_hex":"%s"}\n' \
      "$RID" "$RID" "$AMOUNT" "$nonce" "$SIG_HEX" >> "$sd/cur_lines.jsonl"
    file_lines=$((file_lines+1))
    if [ "$file_lines" -ge "$K" ]; then
      idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
      : > "$sd/cur_lines.jsonl"; file_lines=0
    fi
  done
  if [ "$file_lines" -gt 0 ]; then
    idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
  fi
done

# 3) Отправляем батчи ПО ШАРДАМ: внутри каждого — строго по порядку; шарды — параллельно
start_ts=$(date +%s%3N)
ls -1d "$work"/shard_* | xargs -I{} -P"$C" bash -lc '
  sd="{}"
  for f in $(ls -1 "$sd"/batches/batch_*.json | sort -V); do
    curl -s -X POST "'"$BACKEND"'/submit_tx_batch" -H "Content-Type: application/json" \
      --data-binary @"$f" | jq -c "{accepted,rejected,new_height}"
  done
'
end_ts=$(date +%s%3N)
dt=$((end_ts - start_ts))
echo "=== DONE in ${dt} ms → ~ $(( M*1000/(dt>0?dt:1) )) tx/s (client-side est) ==="

# 4) HEAD / METRICS
echo "--- HEAD ---";    curl -s "$BACKEND/head" | jq .
echo "--- METRICS ---"
curl -s "$BACKEND/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_request_duration_seconds_bucket|http_inflight_requests" \
 | head -n 120 || true

```


## FILE: /root/logos_lrb/tools/tx_one.sh  (size=2659b)
```
#!/usr/bin/env bash
# tx_one.sh — e2e: генерирует ключ, делает RID, faucet, строит канон, подписывает Ed25519 (raw),
# отправляет /submit_tx_batch и печатает head/balance/метрики.
# Usage: PORT=8080 ./tx_one.sh [AMOUNT]
set -euo pipefail
PORT="${PORT:-8080}"
AMOUNT="${1:-1234}"

work="$(mktemp -d -t lrb_one_XXXX)"
trap 'rm -rf "$work"' EXIT

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need python3

# Key + RID
openssl genpkey -algorithm Ed25519 -out "$work/ed25519.sk.pem" >/dev/null 2>&1
openssl pkey -in "$work/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$work/pk.hex"
python3 - "$work/pk.hex" > "$work/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
RID=$(cat "$work/RID.txt"); echo "RID=$RID"

# Faucet + state
curl -s -X POST "http://127.0.0.1:${PORT}/faucet" -H 'Content-Type: application/json' \
  -d "{\"rid\":\"${RID}\",\"amount\":1000000}" | jq .
STATE=$(curl -s "http://127.0.0.1:${PORT}/balance/${RID}")
NONCE_CUR=$(jq -r .nonce <<<"$STATE"); NONCE=$((NONCE_CUR+1))
echo "nonce: $NONCE_CUR -> $NONCE"

# Canon
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" \
  '{tx:{from:$f,to:$t,amount:$a,nonce:$n}}' > "$work/canon_payload.json"
CANON_HEX=$(curl -s -X POST "http://127.0.0.1:${PORT}/debug_canon" -H 'Content-Type: application/json' \
  --data-binary @"$work/canon_payload.json" | jq -r .canon_hex)
echo -n "$CANON_HEX" | xxd -r -p > "$work/canon.bin"

# Sign
openssl pkeyutl -sign -rawin -inkey "$work/ed25519.sk.pem" -in "$work/canon.bin" -out "$work/sig.bin" >/dev/null 2>&1
SIG_HEX=$(xxd -p -c 256 "$work/sig.bin")

# Batch
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" --arg s "$SIG_HEX" \
  '{txs:[{from:$f,to:$t,amount:$a,nonce:$n,sig_hex:$s}]}' > "$work/batch.json"
curl -s -X POST "http://127.0.0.1:${PORT}/submit_tx_batch" -H 'Content-Type: application/json' \
  --data-binary @"$work/batch.json" | jq .

# Head / post state / metrics
echo "--- HEAD ---";         curl -s "http://127.0.0.1:${PORT}/head" | jq .
echo "--- POST ---";         curl -s "http://127.0.0.1:${PORT}/balance/${RID}" | jq .
echo "--- METRICS ---";      curl -s "http://127.0.0.1:${PORT}/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_inflight_requests" | head -n 40 || true

```


## FILE: /root/logos_lrb/wallet-proxy/app.py  (size=7115b)
```
import os, json, time, asyncio
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True)
    rid = Column(String, index=True, nullable=False)
    token = Column(String, nullable=False)
    network = Column(String, nullable=False)
    index = Column(Integer, nullable=False, default=0)
    address = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda:int(time.time()))
Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True)
    txid = Column(String, unique=True, nullable=False)
    rid = Column(String, index=True)
    token = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
        if w3.is_connected():
            USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable"); w3=None
    except Exception as e:
        print("WARN web3 init error:", e); w3=None; USDT=None

# ====== HTTP helper ======
async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(CORSMiddleware, allow_origins=CORS if CORS else ["*"],
                   allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
class TopupResponse(BaseModel):
    rid: str; token: str; network: str; address: str
class WithdrawRequest(BaseModel):
    rid: str; token: Literal["USDT"]="USDT"; network: Literal["ETH"]="ETH"
    amount: int; to_address: str; request_id: str
class QuoteRequest(BaseModel):
    from_token: str; to_token: str; amount: int
class QuoteResponse(BaseModel):
    price: float; expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ   = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR= Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return app.responses.Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# ====== Endpoints ======
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3: raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")
    deposit_address = w3.eth.account.from_key(HOT_PK).address
    with Session(engine) as s:
        dm = s.execute(select(DepositMap).where(
            DepositMap.rid==req.rid, DepositMap.token==req.token, DepositMap.network==req.network
        )).scalar_one_or_none()
        if dm is None:
            s.add(DepositMap(rid=req.rid, token=req.token, network=req.network, address=deposit_address))
            s.commit()
    return TopupResponse(rid=req.rid, token=req.token, network=req.network, address=deposit_address)

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount<=0: raise HTTPException(400,"amount<=0")
        if not w3 or not USDT: raise HTTPException(503, "ETH RPC not connected")
        acct = w3.eth.account.from_key(HOT_PK)
        # redeem
        hdr = {"X-Bridge-Key": BRIDGE_KEY} if not BRIDGE_KEY.startswith("ey") else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem", {
            "rid": req.rid, "amount": req.amount, "request_id": req.request_id
        }, hdr)
        if st//100 != 2: raise HTTPException(st, f"bridge redeem failed: {data}")
        # ERC-20
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(Web3.to_checksum_address(req.to_address), int(req.amount)).build_transaction({
            "chainId": w3.eth.chain_id, "from": acct.address, "nonce": nonce,
            "gas": 90000, "maxFeePerGas": w3.to_wei("30","gwei"), "maxPriorityFeePerGas": w3.to_wei("1","gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()
        with Session(engine) as s: s.add(SeenTx(txid=tx_hash, rid=req.rid, token=req.token, network=req.network)); s.commit()
        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc(); raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc(); raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```


## FILE: /root/logos_lrb/wallet-proxy/requirements.txt  (size=1147b)
```
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```


## FILE: /root/logos_lrb/wallet-proxy/scanner.py  (size=5538b)
```
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```


## FILE: /root/logos_lrb/www/wallet/index.html  (size=3122b)
```
<!doctype html>
<html lang="ru" data-theme="auto">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="x-ua-compatible" content="ie=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>LOGOS Wallet (secure MVP)</title>
    <link rel="stylesheet" href="./wallet.css"/>
  </head>
  <body>
    <header class="topbar">
      <div class="brand">LOGOS Wallet</div>
      <div class="spacer"></div>
      <div class="endpoint"><span id="apiBase">—</span></div>
      <button id="themeToggle" class="btn secondary" title="Тёмная/светлая тема">🌓</button>
    </header>

    <main class="container">
      <!-- Ключ -->
      <section class="card">
        <h2>Ключ и адрес</h2>
        <div class="row">
          <button id="gen"  class="btn">Сгенерировать ключ</button>
          <button id="load" class="btn">Загрузить ключ</button>
          <button id="copyRid" class="btn secondary" title="Скопировать RID">📋 RID</button>
        </div>
        <div class="mono mt8">RID: <span id="rid">—</span></div>
      </section>

      <!-- Учётная запись -->
      <section class="card">
        <h2>Учётная запись</h2>
        <div class="row wrap">
          <input id="acctRid" class="input grow" placeholder="RID (base58)"/>
          <button id="getState" class="btn">Получить состояние</button>
          <button id="devFaucet" class="btn warn" title="DEV: начислить тестовые LGN">Faucet (DEV)</button>
        </div>
        <div class="grid2 mt8">
          <div>Баланс: <strong id="balance">0</strong></div>
          <div>Нонс: <strong id="nonce">0</strong></div>
        </div>
      </section>

      <!-- Перевод -->
      <section class="card">
        <h2>Передача</h2>
        <div class="row wrap">
          <input id="toRid" class="input grow" placeholder="В RID (base58)"/>
          <input id="amount" class="input w120" type="number" min="1" placeholder="Сумма"/>
          <button id="send" class="btn">Отправить</button>
        </div>
        <pre id="txOut" class="log mt8" aria-live="polite"></pre>
      </section>

      <!-- История -->
      <section class="card">
        <h2>История</h2>
        <div class="row wrap">
          <input id="histRid" class="input grow" placeholder="RID (если пусто — мой)"/>
          <input id="histFrom" class="input w120" type="number" min="0" placeholder="from nonce"/>
          <input id="histLimit" class="input w100" type="number" min="1" value="20" placeholder="limit"/>
          <button id="loadHist" class="btn">Загрузить</button>
          <button id="moreHist" class="btn secondary">Показать ещё</button>
        </div>
        <div id="histList" class="log mt8" aria-live="polite"></div>
      </section>
    </main>

    <footer class="statusbar" id="statusBar" aria-live="polite">Готово</footer>

    <script src="./wallet.js" type="module"></script>
  </body>
</html>

```


## FILE: /root/logos_lrb/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```


## FILE: /root/logos_lrb/www/wallet/wallet.js  (size=8649b)
```
// LOGOS Wallet — secure MVP с тёмной темой, статусами и историей с пагинацией
const API = location.origin.replace(/\/$/, "") + "/api";
const $ = (id)=>document.getElementById(id);
let HIST_CURSOR = null;

// ====== Тема (переключатель) ======
(function initTheme(){
  const saved = localStorage.getItem("logos.theme"); // 'light' | 'dark' | 'auto'
  if(saved){ document.documentElement.setAttribute("data-theme", saved); }
  $("themeToggle").onclick = ()=>{
    const cur = document.documentElement.getAttribute("data-theme") || "auto";
    const next = cur === "dark" ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", next);
    localStorage.setItem("logos.theme", next);
  };
})();

// ====== UI helpers ======
const statusBar = $("statusBar");
function status(msg){ statusBar.textContent = msg; }
function busy(btn, v){
  if(!btn) return;
  btn.disabled = v;
}

// endpoint label
(function updateApiBase(){
  $("apiBase").textContent = API;
})();

// ====== b58 ======
const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function b58encode(bytes){ let n=0n; for(const b of bytes) n=(n<<8n)+BigInt(b);
  let s=""; while(n>0n){const r=n%58n; s=ALPH[Number(r)]+s; n/=58n;} let z=0; for(const b of bytes){if(b===0)z++;else break;} return "1".repeat(z)+(s||"1"); }

// ====== IndexedDB ======
const DB="logos_wallet", STORE="keys";
function idbOpen(){return new Promise((res,rej)=>{const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>{const db=r.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);}; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error);});}
async function idbPut(k,v){const db=await idbOpen(); return new Promise((res,rej)=>{const tx=db.transaction(STORE,"readwrite"); tx.objectStore(STORE).put(v,k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error);});}
async function idbGet(k){const db=await idbOpen(); return new Promise((res,rej)=>{const tx=db.transaction(STORE,"readonly"); const rq=tx.objectStore(STORE).get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error);});}

// ====== Keys ======
async function showRID(vk){ const raw=new Uint8Array(await crypto.subtle.exportKey("raw",vk)); const rid=b58encode(raw); $("rid").textContent=rid; return rid; }
async function generateKey(){ const kp=await crypto.subtle.generateKey({name:"Ed25519"},true,["sign","verify"]); await idbPut("sk",kp.privateKey); await idbPut("vk",kp.publicKey); await showRID(kp.publicKey); return kp; }
async function loadKey(){ const sk=await idbGet("sk"); const vk=await idbGet("vk"); if(!sk||!vk) throw new Error("Нет ключа: нажмите «Сгенерировать ключ»"); await showRID(vk); return {sk,vk}; }

// ====== API helpers ======
async function apiGET(p){ const r=await fetch(API+p); const ct=r.headers.get("content-type")||""; const payload=ct.includes("json")?await r.json().catch(()=>null):await r.text().catch(()=>null); if(!r.ok){ const e=new Error(`GET ${r.status}`); e.payload=payload; throw e;} return payload; }
async function apiPOST(p,b){ const r=await fetch(API+p,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(b)}); const ct=r.headers.get("content-type")||""; const payload=ct.includes("json")?await r.json().catch(()=>null):await r.text().catch(()=>null); if(!r.ok){ const e=new Error(`POST ${r.status}`); e.payload=payload; throw e;} return payload; }
async function txCanon(tx){ const r=await apiPOST("/debug_canon",{tx}); return r.canon_hex; }
async function signHex(sk,hex){ const bytes=new Uint8Array(hex.match(/../g).map(h=>parseInt(h,16))); const sig=await crypto.subtle.sign({name:"Ed25519"},sk,bytes); return Array.from(new Uint8Array(sig)).map(b=>b.toString(16).padStart(2,"0")).join(""); }

// ====== State ======
async function refreshState(rid){ const st=await apiGET("/balance/"+encodeURIComponent(rid)); $("balance").textContent=st.balance; $("nonce").textContent=st.nonce; return st; }

// ====== History (with cursor) ======
function renderHistory(items, append=false){
  const box = $("histList");
  if(!append) box.textContent = "";
  if(!items || !items.length){
    if(!append && box.textContent==="") box.textContent="(пусто)";
    return;
  }
  const lines = items.map(it => `#${String(it.nonce).padStart(3," ")}  ${it.from.slice(0,6)}… → ${it.to.slice(0,6)}…   ${it.amount}  (h=${it.height}, ts=${it.ts_ms})`);
  box.textContent = append ? (box.textContent + (box.textContent?"\n":"") + lines.join("\n")) : lines.join("\n");
}

async function loadHistory(append=false){
  try{
    const rid = $("histRid").value.trim() || $("rid").textContent.trim();
    let from = append ? (HIST_CURSOR ?? 0) : ($("histFrom").value.trim() || "0");
    let limit = $("histLimit") ? $("histLimit").value.trim() : "20";
    status(append ? "Догружаю историю…" : "Загружаю историю…");
    busy($("loadHist"), true); busy($("moreHist"), true);
    const r = await apiGET(`/history/${encodeURIComponent(rid)}?from=${from}&limit=${limit}`);
    HIST_CURSOR = r.next_from ?? null;
    renderHistory(r.items || [], append);
    status(HIST_CURSOR ? `Готово. next_from=${HIST_CURSOR}` : "Готово (конец)");
  }catch(e){
    const payload = e.payload ? JSON.stringify(e.payload).slice(0,200) : "";
    $("histList").textContent = "";
    status(`Ошибка истории: ${e.message} ${payload}`);
  } finally {
    busy($("loadHist"), false); busy($("moreHist"), false);
  }
}

// ====== UI wiring ======
$("gen").onclick = async()=>{ try{ busy($("gen"),true); await generateKey(); status("Ключ сгенерирован"); }catch(e){ alert(e.message);} finally{busy($("gen"),false);} };
$("load").onclick = async()=>{ try{ busy($("load"),true); await loadKey(); status("Ключ загружен"); }catch(e){ alert(e.message);} finally{busy($("load"),false);} };
$("copyRid").onclick = async()=>{ try{ const rid=$("rid").textContent.trim(); await navigator.clipboard.writeText(rid); status("RID скопирован"); }catch(e){ alert("Clipboard error"); } };

$("getState").onclick = async()=>{ try{
  busy($("getState"),true);
  const rid = $("acctRid").value.trim() || $("rid").textContent.trim();
  await refreshState(rid); status("Состояние обновлено");
} catch(e){ alert("State error: "+e.message);} finally{busy($("getState"),false);} };

$("devFaucet").onclick = async()=>{ try{
  busy($("devFaucet"),true);
  const {vk}=await loadKey(); const rid=await showRID(vk);
  await apiPOST("/faucet",{rid,amount:1_000_000});
  await refreshState(rid); HIST_CURSOR=null; $("histFrom").value="0"; await loadHistory(false);
  status("Faucet OK");
} catch(e){ alert("Faucet error: "+e.message);} finally{busy($("devFaucet"),false);} };

$("send").onclick = async()=>{ try{
  busy($("send"),true);
  const {sk, vk} = await loadKey(); const fromRid=await showRID(vk);
  const to=$("toRid").value.trim(); const amount=parseInt($("amount").value,10);
  if(!to||!amount) throw new Error("RID получателя и сумма обязательны");
  const st=await refreshState(fromRid);
  const tx={from:fromRid,to,amount,nonce:(st.nonce||0)+1};
  const canonHex=await txCanon(tx);
  const sig_hex=await signHex(sk,canonHex);
  const resp=await apiPOST("/submit_tx_batch",{txs:[{...tx,sig_hex}]});
  $("txOut").textContent=JSON.stringify(resp,null,2);
  await refreshState(fromRid); HIST_CURSOR=null; $("histFrom").value="0"; await loadHistory(false);
  status("Транзакция отправлена");
} catch(e){
  const m=String(e.message||e);
  if(m.includes("401")) alert("Ошибка подписи (bad_sig). Проверьте ключ/канон.");
  else if(m.includes("409")) alert("Неправильный nonce (bad_nonce). Обновите состояние.");
  else if(m.includes("402")) alert("Недостаточно средств (insufficient_funds).");
  else alert("Send error: "+m);
} finally{ busy($("send"),false); } };

$("loadHist").onclick = ()=>{ HIST_CURSOR=null; $("histFrom").value=$("histFrom").value.trim()||"0"; loadHistory(false); };
$("moreHist").onclick = ()=>{ if(HIST_CURSOR===null){ status("Конец истории"); return; } loadHistory(true); };

// auto-load
loadKey().then(async ({vk})=>{
  const rid=await showRID(vk);
  $("acctRid").value = rid;
  $("histRid").value = rid;
  $("histFrom").value = "0";
  await refreshState(rid);
  await loadHistory(false);
  status("Готово");
}).catch(()=>{ status("Сгенерируйте ключ для начала"); });

```


## FILE: /opt/logos/www/wallet/index.html  (size=3122b)
```
<!doctype html>
<html lang="ru" data-theme="auto">
  <head>
    <meta charset="utf-8"/>
    <meta http-equiv="x-ua-compatible" content="ie=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>LOGOS Wallet (secure MVP)</title>
    <link rel="stylesheet" href="./wallet.css"/>
  </head>
  <body>
    <header class="topbar">
      <div class="brand">LOGOS Wallet</div>
      <div class="spacer"></div>
      <div class="endpoint"><span id="apiBase">—</span></div>
      <button id="themeToggle" class="btn secondary" title="Тёмная/светлая тема">🌓</button>
    </header>

    <main class="container">
      <!-- Ключ -->
      <section class="card">
        <h2>Ключ и адрес</h2>
        <div class="row">
          <button id="gen"  class="btn">Сгенерировать ключ</button>
          <button id="load" class="btn">Загрузить ключ</button>
          <button id="copyRid" class="btn secondary" title="Скопировать RID">📋 RID</button>
        </div>
        <div class="mono mt8">RID: <span id="rid">—</span></div>
      </section>

      <!-- Учётная запись -->
      <section class="card">
        <h2>Учётная запись</h2>
        <div class="row wrap">
          <input id="acctRid" class="input grow" placeholder="RID (base58)"/>
          <button id="getState" class="btn">Получить состояние</button>
          <button id="devFaucet" class="btn warn" title="DEV: начислить тестовые LGN">Faucet (DEV)</button>
        </div>
        <div class="grid2 mt8">
          <div>Баланс: <strong id="balance">0</strong></div>
          <div>Нонс: <strong id="nonce">0</strong></div>
        </div>
      </section>

      <!-- Перевод -->
      <section class="card">
        <h2>Передача</h2>
        <div class="row wrap">
          <input id="toRid" class="input grow" placeholder="В RID (base58)"/>
          <input id="amount" class="input w120" type="number" min="1" placeholder="Сумма"/>
          <button id="send" class="btn">Отправить</button>
        </div>
        <pre id="txOut" class="log mt8" aria-live="polite"></pre>
      </section>

      <!-- История -->
      <section class="card">
        <h2>История</h2>
        <div class="row wrap">
          <input id="histRid" class="input grow" placeholder="RID (если пусто — мой)"/>
          <input id="histFrom" class="input w120" type="number" min="0" placeholder="from nonce"/>
          <input id="histLimit" class="input w100" type="number" min="1" value="20" placeholder="limit"/>
          <button id="loadHist" class="btn">Загрузить</button>
          <button id="moreHist" class="btn secondary">Показать ещё</button>
        </div>
        <div id="histList" class="log mt8" aria-live="polite"></div>
      </section>
    </main>

    <footer class="statusbar" id="statusBar" aria-live="polite">Готово</footer>

    <script src="./wallet.js" type="module"></script>
  </body>
</html>

```


## FILE: /opt/logos/www/wallet/wallet.js  (size=8649b)
```
// LOGOS Wallet — secure MVP с тёмной темой, статусами и историей с пагинацией
const API = location.origin.replace(/\/$/, "") + "/api";
const $ = (id)=>document.getElementById(id);
let HIST_CURSOR = null;

// ====== Тема (переключатель) ======
(function initTheme(){
  const saved = localStorage.getItem("logos.theme"); // 'light' | 'dark' | 'auto'
  if(saved){ document.documentElement.setAttribute("data-theme", saved); }
  $("themeToggle").onclick = ()=>{
    const cur = document.documentElement.getAttribute("data-theme") || "auto";
    const next = cur === "dark" ? "light" : "dark";
    document.documentElement.setAttribute("data-theme", next);
    localStorage.setItem("logos.theme", next);
  };
})();

// ====== UI helpers ======
const statusBar = $("statusBar");
function status(msg){ statusBar.textContent = msg; }
function busy(btn, v){
  if(!btn) return;
  btn.disabled = v;
}

// endpoint label
(function updateApiBase(){
  $("apiBase").textContent = API;
})();

// ====== b58 ======
const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function b58encode(bytes){ let n=0n; for(const b of bytes) n=(n<<8n)+BigInt(b);
  let s=""; while(n>0n){const r=n%58n; s=ALPH[Number(r)]+s; n/=58n;} let z=0; for(const b of bytes){if(b===0)z++;else break;} return "1".repeat(z)+(s||"1"); }

// ====== IndexedDB ======
const DB="logos_wallet", STORE="keys";
function idbOpen(){return new Promise((res,rej)=>{const r=indexedDB.open(DB,1); r.onupgradeneeded=()=>{const db=r.result; if(!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);}; r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error);});}
async function idbPut(k,v){const db=await idbOpen(); return new Promise((res,rej)=>{const tx=db.transaction(STORE,"readwrite"); tx.objectStore(STORE).put(v,k); tx.oncomplete=()=>res(); tx.onerror=()=>rej(tx.error);});}
async function idbGet(k){const db=await idbOpen(); return new Promise((res,rej)=>{const tx=db.transaction(STORE,"readonly"); const rq=tx.objectStore(STORE).get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error);});}

// ====== Keys ======
async function showRID(vk){ const raw=new Uint8Array(await crypto.subtle.exportKey("raw",vk)); const rid=b58encode(raw); $("rid").textContent=rid; return rid; }
async function generateKey(){ const kp=await crypto.subtle.generateKey({name:"Ed25519"},true,["sign","verify"]); await idbPut("sk",kp.privateKey); await idbPut("vk",kp.publicKey); await showRID(kp.publicKey); return kp; }
async function loadKey(){ const sk=await idbGet("sk"); const vk=await idbGet("vk"); if(!sk||!vk) throw new Error("Нет ключа: нажмите «Сгенерировать ключ»"); await showRID(vk); return {sk,vk}; }

// ====== API helpers ======
async function apiGET(p){ const r=await fetch(API+p); const ct=r.headers.get("content-type")||""; const payload=ct.includes("json")?await r.json().catch(()=>null):await r.text().catch(()=>null); if(!r.ok){ const e=new Error(`GET ${r.status}`); e.payload=payload; throw e;} return payload; }
async function apiPOST(p,b){ const r=await fetch(API+p,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(b)}); const ct=r.headers.get("content-type")||""; const payload=ct.includes("json")?await r.json().catch(()=>null):await r.text().catch(()=>null); if(!r.ok){ const e=new Error(`POST ${r.status}`); e.payload=payload; throw e;} return payload; }
async function txCanon(tx){ const r=await apiPOST("/debug_canon",{tx}); return r.canon_hex; }
async function signHex(sk,hex){ const bytes=new Uint8Array(hex.match(/../g).map(h=>parseInt(h,16))); const sig=await crypto.subtle.sign({name:"Ed25519"},sk,bytes); return Array.from(new Uint8Array(sig)).map(b=>b.toString(16).padStart(2,"0")).join(""); }

// ====== State ======
async function refreshState(rid){ const st=await apiGET("/balance/"+encodeURIComponent(rid)); $("balance").textContent=st.balance; $("nonce").textContent=st.nonce; return st; }

// ====== History (with cursor) ======
function renderHistory(items, append=false){
  const box = $("histList");
  if(!append) box.textContent = "";
  if(!items || !items.length){
    if(!append && box.textContent==="") box.textContent="(пусто)";
    return;
  }
  const lines = items.map(it => `#${String(it.nonce).padStart(3," ")}  ${it.from.slice(0,6)}… → ${it.to.slice(0,6)}…   ${it.amount}  (h=${it.height}, ts=${it.ts_ms})`);
  box.textContent = append ? (box.textContent + (box.textContent?"\n":"") + lines.join("\n")) : lines.join("\n");
}

async function loadHistory(append=false){
  try{
    const rid = $("histRid").value.trim() || $("rid").textContent.trim();
    let from = append ? (HIST_CURSOR ?? 0) : ($("histFrom").value.trim() || "0");
    let limit = $("histLimit") ? $("histLimit").value.trim() : "20";
    status(append ? "Догружаю историю…" : "Загружаю историю…");
    busy($("loadHist"), true); busy($("moreHist"), true);
    const r = await apiGET(`/history/${encodeURIComponent(rid)}?from=${from}&limit=${limit}`);
    HIST_CURSOR = r.next_from ?? null;
    renderHistory(r.items || [], append);
    status(HIST_CURSOR ? `Готово. next_from=${HIST_CURSOR}` : "Готово (конец)");
  }catch(e){
    const payload = e.payload ? JSON.stringify(e.payload).slice(0,200) : "";
    $("histList").textContent = "";
    status(`Ошибка истории: ${e.message} ${payload}`);
  } finally {
    busy($("loadHist"), false); busy($("moreHist"), false);
  }
}

// ====== UI wiring ======
$("gen").onclick = async()=>{ try{ busy($("gen"),true); await generateKey(); status("Ключ сгенерирован"); }catch(e){ alert(e.message);} finally{busy($("gen"),false);} };
$("load").onclick = async()=>{ try{ busy($("load"),true); await loadKey(); status("Ключ загружен"); }catch(e){ alert(e.message);} finally{busy($("load"),false);} };
$("copyRid").onclick = async()=>{ try{ const rid=$("rid").textContent.trim(); await navigator.clipboard.writeText(rid); status("RID скопирован"); }catch(e){ alert("Clipboard error"); } };

$("getState").onclick = async()=>{ try{
  busy($("getState"),true);
  const rid = $("acctRid").value.trim() || $("rid").textContent.trim();
  await refreshState(rid); status("Состояние обновлено");
} catch(e){ alert("State error: "+e.message);} finally{busy($("getState"),false);} };

$("devFaucet").onclick = async()=>{ try{
  busy($("devFaucet"),true);
  const {vk}=await loadKey(); const rid=await showRID(vk);
  await apiPOST("/faucet",{rid,amount:1_000_000});
  await refreshState(rid); HIST_CURSOR=null; $("histFrom").value="0"; await loadHistory(false);
  status("Faucet OK");
} catch(e){ alert("Faucet error: "+e.message);} finally{busy($("devFaucet"),false);} };

$("send").onclick = async()=>{ try{
  busy($("send"),true);
  const {sk, vk} = await loadKey(); const fromRid=await showRID(vk);
  const to=$("toRid").value.trim(); const amount=parseInt($("amount").value,10);
  if(!to||!amount) throw new Error("RID получателя и сумма обязательны");
  const st=await refreshState(fromRid);
  const tx={from:fromRid,to,amount,nonce:(st.nonce||0)+1};
  const canonHex=await txCanon(tx);
  const sig_hex=await signHex(sk,canonHex);
  const resp=await apiPOST("/submit_tx_batch",{txs:[{...tx,sig_hex}]});
  $("txOut").textContent=JSON.stringify(resp,null,2);
  await refreshState(fromRid); HIST_CURSOR=null; $("histFrom").value="0"; await loadHistory(false);
  status("Транзакция отправлена");
} catch(e){
  const m=String(e.message||e);
  if(m.includes("401")) alert("Ошибка подписи (bad_sig). Проверьте ключ/канон.");
  else if(m.includes("409")) alert("Неправильный nonce (bad_nonce). Обновите состояние.");
  else if(m.includes("402")) alert("Недостаточно средств (insufficient_funds).");
  else alert("Send error: "+m);
} finally{ busy($("send"),false); } };

$("loadHist").onclick = ()=>{ HIST_CURSOR=null; $("histFrom").value=$("histFrom").value.trim()||"0"; loadHistory(false); };
$("moreHist").onclick = ()=>{ if(HIST_CURSOR===null){ status("Конец истории"); return; } loadHistory(true); };

// auto-load
loadKey().then(async ({vk})=>{
  const rid=await showRID(vk);
  $("acctRid").value = rid;
  $("histRid").value = rid;
  $("histFrom").value = "0";
  await refreshState(rid);
  await loadHistory(false);
  status("Готово");
}).catch(()=>{ status("Сгенерируйте ключ для начала"); });

```


## FILE: /opt/logos/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```


## FILE: /etc/systemd/system/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```


## FILE: /etc/systemd/system/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```


## FILE: /etc/systemd/system/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```


## FILE: /etc/nginx/sites-available/logos-api-lb.conf  (size=1809b)
```
server {
    listen 80;
    server_name 45-159-248-232.sslip.io;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    root /opt/logos/www;
    index index.html;

    # Статика: долгий кэш
    location /wallet/ {
        alias /opt/logos/www/wallet/;
        index index.html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # API → узел
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Безопасность
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Permissions-Policy "accelerometer=(),camera=(),geolocation=(),microphone=()" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip/браузерные оптимизации
    gzip on; gzip_types text/plain text/css application/json application/javascript application/octet-stream image/svg+xml;
    gzip_min_length 1024;

    access_log /var/log/nginx/logos_access.log;
    error_log  /var/log/nginx/logos_error.log;
}

```


## FILE: /usr/local/bin/logos_healthcheck.sh  (size=1689b)
```
#!/usr/bin/env bash
set -euo pipefail

BASE="${BASE:-http://127.0.0.1:8080}"
STATE_FILE="/var/run/logos_health.json"
TMP="$(mktemp)"; trap 'rm -f "$TMP"' EXIT

# Метрика: время ответа healthz
START=$(date +%s%3N)
if ! curl -sf "$BASE/healthz" -o "$TMP" >/dev/null; then
  MSG="LOGOS: /healthz FAIL at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  [ -n "${TG_TOKEN:-}" ] && curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
     -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  exit 1
fi
RT=$(( $(date +%s%3N) - START ))

# Высота
HEAD_JSON=$(curl -sf "$BASE/head")
HEIGHT=$(echo "$HEAD_JSON" | jq -r '.height' 2>/dev/null || echo 0)

LAST_H=0
LAST_TS=0
if [ -f "$STATE_FILE" ]; then
  LAST_H=$(jq -r '.height // 0' "$STATE_FILE" 2>/dev/null || echo 0)
  LAST_TS=$(jq -r '.ts_ms // 0' "$STATE_FILE" 2>/dev/null || echo 0)
fi

TS_MS=$(date +%s%3N)
printf '{"ts_ms":%s,"height":%s,"rt_ms":%s}\n' "$TS_MS" "$HEIGHT" "$RT" > "$STATE_FILE"

# Правила алертов
ALERT=""
[ "$RT" -gt 1500 ] && ALERT="slow healthz: ${RT}ms"
if [ -n "$LAST_TS" ] && [ $((TS_MS - LAST_TS)) -gt 300000 ]; then
  # если 5 минут прошло и высота не менялась (и была >0)
  if [ "$HEIGHT" -eq "$LAST_H" ] && [ "$HEIGHT" -gt 0 ]; then
    ALERT="${ALERT} height stuck at ${HEIGHT}"
  fi
fi

if [ -n "$ALERT" ]; then
  MSG="LOGOS ALERT: ${ALERT} at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  if [ -n "${TG_TOKEN:-}" ] && [ -n "${TG_CHAT_ID:-}" ]; then
    curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
       -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  fi
fi

exit 0

```


## FILE: /etc/logos/node-a.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_DATA_DIR=/var/lib/logos-a
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /etc/logos/node-b.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8082
LRB_DATA_DIR=/var/lib/logos-b
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```


## FILE: /etc/logos/node-c.env.example  (size=254b)
```
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
LRB_NODE_LISTEN=0.0.0.0:8084
LRB_DATA_DIR=/var/lib/logos-c
RUST_LOG=info
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

```

## FILE: /root/logos_lrb/docs/WORKFLOW.md  (size=5440b)
```
# LOGOS LRB — КАНОН РАБОТЫ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)

## 0) Цель
Конечная цель — **полностью рабочий резонансный блокчейн LOGOS LRB**, интегрированный с нашим приложением: узел принимает и финализирует транзакции, поддерживает резонансные модули, API совместимо с мобильным клиентом. **Никаких заглушек и TODO** — только боевой, собранный и проверенный код.

---

## 1) Канон внесения изменений (обязательный порядок)
Каждое изменение оформляется ТОЛЬКО так:

1. **Создание директорий (если нужно):**
   - `mkdir -p <путь/к/директории>`

2. **Вход в целевую директорию:**
   - `cd <путь/к/директории>`

3. **Удаление старого файла (если он есть):**
   - `rm -f <имя_файла>`

4. **Открытие nano для нового файла:**
   - `nano <имя_файла>`

5. **Вставка ПОЛНОГО, боевого кода** (всё содержимое файла целиком).
   - Без «патчей» и диффов — ВСЕГДА полный файл.
   - Без заглушек, TODO, псевдокода.

6. **Сохранение → выход → сборка/проверка.**

Этот канон применяется к любым файлам (Rust, Python, YAML, systemd, shell-скрипты и т.д.).

---

## 2) Требования к коду
- **Ни одного `unsafe`/`unwrap`/`expect`/`panic!`** в путях выполнения продакшена.
- Чёткие `Result`/ошибки, логирование, предсказуемое поведение при сбоях.
- Rust: `cargo build --release -p logos_node` **должен проходить без ошибок**.
- Python: синтаксис чистый, без `eval/exec`; утилиты не мешают прод-пути.
- Конфиги валидируются парсером/схемой, лежат в `configs/`.
- systemd-юниты запускаются и переживают рестарты; порт слушается постоянно.

---

## 3) Проверки после каждого изменения
1. **Сборка узла:**  
   `cd /root/logos_lrb && cargo build --release -p logos_node`

2. **Запуск узла (локально):**  
   `./target/release/logos_node`  
   Проверка:  
   - `curl -s http://127.0.0.1:8080/healthz` → `{"ok":true}`  
   - `curl -s http://127.0.0.1:8080/head`

3. **Автозапуск (systemd):**  
   - Юнит: `/etc/systemd/system/logos-node.service`  
   - `systemctl enable --now logos-node.service`  
   - `systemctl status logos-node.service`  
   - `journalctl -u logos-node.service -f`

4. **Генерация дерева проекта:**  
   - `/root/logos_lrb/tools/gen_full_tree.sh`  
   - Коммит `FULL_TREE.md`.

---

## 4) Правила коммитов/репозитория
- Любое изменение кода/конфигов сопровождается **коммитом** в `main`.
- Сообщение коммита короткое и предметное: что изменено и зачем.
- Не коммитить артефакты сборки (`target/`, `node_modules/`, и т.п.).
- Поддерживать `FULL_TREE.md` и `AUDIT_REPORT.md` в актуальном состоянии.

---

## 5) Стандарты API и интеграции
- Узел (`logos_node`) обязан держать REST:
  - `GET /healthz` — жив ли.
  - `GET /head` — {height, hash}.
  - `GET /balance/:rid` — баланс.
  - `POST /submit_tx` — приём tx (Ed25519, base58 RID).
- Мобильный клиент должен уметь:
  - генерировать ключи / RID (Ed25519 → base58),
  - формировать каноничное сообщение, подписывать, отправлять в `/submit_tx`,
  - опрашивать `head` и `balance`.

---

## 6) Безопасность и эксплуатация
- Лимиты и квоты — на входе (spam-guard) и в mempool.
- LGN_cost — адаптивный (dynamic_balance).
- **Никаких секретов в репозитории** (ключи/пароли).
- Логи — в journal/systemd, при необходимости `RUST_LOG=info`.

---

## 7) Оркестрация «одним дыханием»
- Все шаги (создание директорий → nano → полный код → сборка → проверки) делаются **в одном заходе** согласно канону из раздела 1.
- Любые новые службы/скрипты оформлять аналогично (полный код, без TODO).

---

## 8) Мини-чеклист перед «готово»
- `cargo build --release -p logos_node` — ОК
- `/healthz`, `/head`, `/balance/:rid`, `/submit_tx` — ОК
- `logos-node.service` — Active (running)
- `FULL_TREE.md` — обновлён
- Нет `unsafe`/`unwrap`/`expect`/`panic!` в прод-пути

```

## FILE: /root/logos_lrb/infra/nginx/logos-api-lb.conf.example  (size=1809b)
```
server {
    listen 80;
    server_name 45-159-248-232.sslip.io;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    root /opt/logos/www;
    index index.html;

    # Статика: долгий кэш
    location /wallet/ {
        alias /opt/logos/www/wallet/;
        index index.html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # API → узел
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Безопасность
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Permissions-Policy "accelerometer=(),camera=(),geolocation=(),microphone=()" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip/браузерные оптимизации
    gzip on; gzip_types text/plain text/css application/json application/javascript application/octet-stream image/svg+xml;
    gzip_min_length 1024;

    access_log /var/log/nginx/logos_access.log;
    error_log  /var/log/nginx/logos_error.log;
}

```

## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf  (size=3062b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки ---
    add_header X-Frame-Options        SAMEORIGIN       always;
    add_header X-Content-Type-Options nosniff          always;
    add_header Referrer-Policy        strict-origin-when-cross-origin always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # CSP: только self, без inline/CDN. Разрешаем data: для иконок/картинок в UI.
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```

## FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf.sample  (size=2666b)
```
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```

## FILE: /root/logos_lrb/infra/systemd/exec.conf  (size=85b)
```
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /root/logos_lrb/infra/systemd/keys.conf  (size=226b)
```
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```

## FILE: /root/logos_lrb/infra/systemd/keys.env.example  (size=272b)
```
# Пример (НЕ БОЕВОЙ! замените на свои)
LRB_DATA_PATH=/var/lib/logos/data.sled
LRB_NODE_KEY_PATH=/var/lib/logos/node_key
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
# LRB_ADMIN_JWT_SECRET=   # задаётся опционально

```

## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```

## FILE: /root/logos_lrb/infra/systemd/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node.service  (size=369b)
```
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/logos-node.service.sample  (size=3242b)
```
# /etc/systemd/system/logos-node.service
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

# /etc/systemd/system/logos-node.service.d/exec.conf
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/keys.conf
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/override.conf
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

# /etc/systemd/system/logos-node.service.d/runas.conf
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

# /etc/systemd/system/logos-node.service.d/security.conf
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

# /etc/systemd/system/logos-node.service.d/tuning.conf
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# /etc/systemd/system/logos-node.service.d/zz-consensus.conf
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

# /etc/systemd/system/logos-node.service.d/zz-keys.conf
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=0448012cf1738fd048b154a1c367cb7cb42e3fee4ab26fb04268ab91e09fb475
Environment=LRB_BRIDGE_KEY=b294771b022226e3a9d6e21f395c7b490a7f42e1fa203cd2fbb62eb3f4718bcf

# /etc/systemd/system/logos-node.service.d/zz-logging.conf
[Service]
Environment=RUST_LOG=info

```

## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.service  (size=271b)
```
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```

## FILE: /root/logos_lrb/infra/systemd/logos-snapshot.timer  (size=163b)
```
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service  (size=395b)
```
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service.sample  (size=435b)
```
# /etc/systemd/system/lrb-proxy.service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service  (size=378b)
```
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/lrb-scanner.service.sample  (size=420b)
```
# /etc/systemd/system/lrb-scanner.service
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /root/logos_lrb/infra/systemd/override.conf  (size=575b)
```
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```

## FILE: /root/logos_lrb/infra/systemd/runas.conf  (size=143b)
```
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```

## FILE: /root/logos_lrb/infra/systemd/security.conf  (size=337b)
```
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /root/logos_lrb/infra/systemd/tuning.conf  (size=156b)
```
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```

## FILE: /root/logos_lrb/infra/systemd/zz-consensus.conf  (size=137b)
```
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```

## FILE: /root/logos_lrb/infra/systemd/zz-keys.conf  (size=417b)
```
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```

## FILE: /root/logos_lrb/infra/systemd/zz-logging.conf  (size=36b)
```
[Service]
Environment=RUST_LOG=info

```

## FILE: /root/logos_lrb/lrb_core/src/anti_replay.rs  (size=980b)
```
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self {
            ttl_ms,
            map: HashMap::new(),
        }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/beacon.rs  (size=1821b)
```
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::time::Duration;
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop {
            t.tick().await;
        }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers
        .iter()
        .any(|p| !(p.starts_with("http://") || p.starts_with("https://")))
    {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```

## FILE: /root/logos_lrb/lrb_core/src/crypto.rs  (size=1617b)
```
// Безопасный AEAD: XChaCha20-Poly1305 с уникальным nonce.
// Формат шифротекста: [24-байт nonce || ciphertext+tag]

use anyhow::Result;
use chacha20poly1305::{
    aead::{Aead, AeadCore, KeyInit, OsRng},
    Key, XChaCha20Poly1305, XNonce,
};

pub struct AeadBox {
    key: Key,
}

impl AeadBox {
    pub fn from_key(key_bytes: &[u8; 32]) -> Self {
        let key = Key::from_slice(key_bytes);
        Self { key: *key }
    }

    pub fn seal(&self, aad: &[u8], plaintext: &[u8]) -> Vec<u8> {
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XChaCha20Poly1305::generate_nonce(&mut OsRng); // 24 байта
        let mut out = Vec::with_capacity(24 + plaintext.len() + 16);
        out.extend_from_slice(&nonce);
        let ct = cipher
            .encrypt(
                &nonce,
                chacha20poly1305::aead::Payload {
                    msg: plaintext,
                    aad,
                },
            )
            .expect("AEAD encrypt failed");
        out.extend_from_slice(&ct);
        out
    }

    pub fn open(&self, aad: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 24 + 16 {
            anyhow::bail!("AEAD: buffer too short");
        }
        let (nonce_bytes, ct) = data.split_at(24);
        let cipher = XChaCha20Poly1305::new(&self.key);
        let nonce = XNonce::from_slice(nonce_bytes);
        let pt = cipher
            .decrypt(nonce, chacha20poly1305::aead::Payload { msg: ct, aad })
            .map_err(|_| anyhow::anyhow!("AEAD decrypt failed"))?;
        Ok(pt)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/dynamic_balance.rs  (size=609b)
```
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self {
            base_cost_microunits: base,
            slope_per_tx: slope,
        }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/heartbeat.rs  (size=2166b)
```
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(
            rid,
            HeartbeatState {
                last_seen_ms: now_ms,
            },
        );
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter()
            .map(|(r, s)| (r.clone(), s.last_seen_ms))
            .collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```

## FILE: /root/logos_lrb/lrb_core/src/ledger.rs  (size=12177b)
```
use crate::types::*;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use sled::{Db, IVec, Tree};
use std::convert::TryInto;
use std::path::Path;

// key helpers
fn be64(v: u64) -> [u8; 8] {
    v.to_be_bytes()
}
fn be32(v: u32) -> [u8; 4] {
    v.to_be_bytes()
}
fn rid_str(r: &Rid) -> &str {
    &r.0
}

#[derive(Clone)]
pub struct Ledger {
    #[allow(dead_code)]
    db: Db,

    // balances
    lg_tree: Tree,   // rid -> u64 (BE)
    rlgn_tree: Tree, // rid -> u64 (BE)
    head_tree: Tree, // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree: db.open_tree("lgn")?,
            rlgn_tree: db.open_tree("rlgn")?,
            head_tree: db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree: db.open_tree("txs")?,
            acct_tree: db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree
            .get(k)
            .ok()
            .flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String, u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k, v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8; 8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self
            .head_tree
            .get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self
            .head_tree
            .get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self
            .head_tree
            .get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(
        &self,
        height: u64,
        hash: &str,
        ts_ms: u128,
        txs: &[Tx],
    ) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx {
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to: rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce: tx.nonce,
                height,
                index: i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1 + txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1 + 8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock {
            height,
            hash: hash.to_string(),
            ts_ms,
            tx_ids: ids,
        };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1 + 8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self
            .blocks_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredBlock>(&v))
            .transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1 + txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self
            .tx_tree
            .get(k)?
            .map(|v| serde_json::from_slice::<StoredTx>(&v))
            .transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(
        &self,
        rid: &str,
        limit: usize,
        cursor: Option<String>,
    ) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a");
            k.extend_from_slice(rid.as_bytes());
            k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage {
            rid: rid.to_string(),
            items,
            next_cursor,
        })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? {
            return Ok(false);
        }
        self.head_tree
            .insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid: &Rid, amt: u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self
            .rlgn_tree
            .get(k)?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        if cur < amt {
            anyhow::bail!("insufficient rLGN");
        }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k = rid_str(&tx.to).as_bytes();

            let from_bal = self
                .lg_tree
                .get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);
            if from_bal < tx.amount {
                anyhow::bail!("insufficient funds");
            }
            let to_bal = self
                .lg_tree
                .get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
                .unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k, &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h {
                Ok(BlockHeaderView {
                    block_hash: head_hash,
                })
            } else {
                anyhow::bail!("block not found")
            }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockHeaderView {
    pub block_hash: String,
}

```

## FILE: /root/logos_lrb/lrb_core/src/lib.rs  (size=727b)
```
/*!
 * LOGOS LRB — core crate
 * Экспорт модулей ядра L1: типы, консенсус, мемпул/баланс, резонанс, сигналы, защита.
 * Здесь только декларация модулей — реализация в соответствующих *.rs файлах.
 */

pub mod types;

pub mod anti_replay;
pub mod beacon;
pub mod heartbeat;

pub mod dynamic_balance;
pub mod spam_guard;

pub mod phase_consensus;
pub mod phase_filters;
pub mod phase_integrity;
pub mod quorum;
pub mod sigpool;

pub mod ledger;
pub mod rcp_engine;
pub mod resonance;

// Безопасный AEAD (XChaCha20-Poly1305) — общий хелпер для модулей
pub mod crypto;

```

## FILE: /root/logos_lrb/lrb_core/src/nano.114024.save  (size=11306b)
```
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

// лёгкий view для register_vote
pub struct BlockHeaderView {
    pub block_hash: String,
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_consensus.rs  (size=1806b)
```
use std::collections::{HashMap, HashSet};

/// Фазовый консенсус Σ(t) с учётом блока (height, block_hash).
/// Накапливает голоса RID'ов по конкретному хешу блока.
/// Финализованный height повышается, когда кворум собран по **одному** хешу на этом height.
pub struct PhaseConsensus {
    /// votes[height][block_hash] = {rid_b58, ...}
    votes: HashMap<u64, HashMap<String, HashSet<String>>>,
    finalized_h: u64,
    quorum_n: usize,
}

impl PhaseConsensus {
    pub fn new(quorum_n: usize) -> Self {
        Self {
            votes: HashMap::new(),
            finalized_h: 0,
            quorum_n,
        }
    }

    pub fn quorum_n(&self) -> usize {
        self.quorum_n
    }
    pub fn finalized(&self) -> u64 {
        self.finalized_h
    }

    /// Регистрируем голос. Возвращает Some((h,hash)) если по hash достигнут кворум.
    pub fn vote(&mut self, h: u64, block_hash: &str, rid_b58: &str) -> Option<(u64, String)> {
        let by_hash = self.votes.entry(h).or_default();
        let set = by_hash.entry(block_hash.to_string()).or_default();
        set.insert(rid_b58.to_string());
        if set.len() >= self.quorum_n {
            if h > self.finalized_h {
                self.finalized_h = h;
            }
            return Some((h, block_hash.to_string()));
        }
        None
    }

    /// Сколько голосов у конкретного (h,hash)
    #[allow(dead_code)]
    pub fn votes_for(&self, h: u64, block_hash: &str) -> usize {
        self.votes
            .get(&h)
            .and_then(|m| m.get(block_hash))
            .map(|s| s.len())
            .unwrap_or(0)
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_filters.rs  (size=1780b)
```
use crate::types::Block;

/// Простые фазовые фильтры на основе гармоник Λ0.
/// ENV (всё опционально):
///  LRB_PHASE_EN=1|0                     (вкл/выкл, по умолчанию 1)
///  LRB_PHASE_FREQS_HZ="7.83,1.618,432"  (частоты, через запятую)
///  LRB_PHASE_MIN_SCORE=-0.20            (порог принятия от -1.0 до 1.0)
///
/// Идея: время блока b.timestamp_ms в секундах подаётся в сумму косинусов.
/// score = avg_i cos(2π f_i * t)
/// Пропускаем, если score >= MIN_SCORE.
fn phase_enabled() -> bool {
    std::env::var("LRB_PHASE_EN")
        .ok()
        .map(|v| v == "1")
        .unwrap_or(true)
}
fn parse_freqs() -> Vec<f64> {
    let def = "7.83,1.618,432";
    let raw = std::env::var("LRB_PHASE_FREQS_HZ").unwrap_or_else(|_| def.to_string());
    raw.split(',')
        .filter_map(|s| s.trim().parse::<f64>().ok())
        .collect::<Vec<_>>()
}
fn min_score() -> f64 {
    std::env::var("LRB_PHASE_MIN_SCORE")
        .ok()
        .and_then(|s| s.parse::<f64>().ok())
        .unwrap_or(-0.20)
}

fn phase_score_ts_ms(ts_ms: u128) -> f64 {
    let t = ts_ms as f64 / 1000.0;
    let freqs = parse_freqs();
    if freqs.is_empty() {
        return 1.0;
    }
    let two_pi = std::f64::consts::TAU; // 2π
    let mut acc = 0.0;
    for f in &freqs {
        acc += (two_pi * *f * t).cos();
    }
    acc / (freqs.len() as f64)
}

/// Главный фильтр на блок: пропускает, если фазовый скор >= порога
pub fn block_passes_phase(b: &Block) -> bool {
    if !phase_enabled() {
        return true;
    }
    phase_score_ts_ms(b.timestamp_ms) >= min_score()
}

```

## FILE: /root/logos_lrb/lrb_core/src/phase_integrity.rs  (size=553b)
```
use crate::types::*;
use anyhow::{anyhow, Result};
use ed25519_dalek::Verifier as _; // для pk.verify(&msg, &sig)

pub fn verify_tx_signature(tx: &Tx) -> Result<()> {
    tx.validate_shape()?;

    let pk = crate::types::parse_pubkey(&tx.public_key)?;
    let sig = crate::types::parse_sig(&tx.signature)?;
    let msg = tx.canonical_bytes();

    pk.verify(&msg, &sig)
        .map_err(|e| anyhow!("bad signature: {e}"))?;

    // сверяем id
    if tx.id != tx.compute_id() {
        return Err(anyhow!("tx id mismatch"));
    }
    Ok(())
}

```

## FILE: /root/logos_lrb/lrb_core/src/quorum.rs  (size=1250b)
```
use anyhow::Result;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub block_hash: String,
    pub sigma_hex: String,
    pub voter_pk_b58: String,
    pub sig_b64: String,
    pub nonce_ms: u128,
}

pub fn verify_vote(v: &Vote) -> Result<()> {
    let pk_bytes = bs58::decode(&v.voter_pk_b58).into_vec()?;
    let vk =
        VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(v.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(
        &sig_bytes
            .try_into()
            .map_err(|_| anyhow::anyhow!("bad sig"))?,
    );

    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    vk.verify(&payload, &sig)
        .map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

```

## FILE: /root/logos_lrb/lrb_core/src/rcp_engine.rs  (size=7224b)
```
use crate::sigpool::filter_valid_sigs_parallel;
use crate::{dynamic_balance::DynamicBalance, ledger::Ledger, spam_guard::SpamGuard, types::*};
use crate::{phase_consensus::PhaseConsensus, phase_filters::block_passes_phase};
use anyhow::Result;
use std::{
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::sync::{
    broadcast,
    mpsc::{unbounded_channel, UnboundedSender},
};

// точный монотонный ts для индексации
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

fn env_u64(key: &str, def: u64) -> u64 {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<u64>().ok())
        .unwrap_or(def)
}
fn env_usize(key: &str, def: usize) -> usize {
    std::env::var(key)
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(def)
}

#[derive(Clone)]
pub struct Engine {
    ledger: Arc<Ledger>,
    guard: SpamGuard,
    dyn_cost: DynamicBalance,
    proposer: Rid,
    mempool_tx: UnboundedSender<Tx>,
    mempool: Arc<Mutex<Vec<Tx>>>,
    commit_tx: Arc<Mutex<Option<broadcast::Sender<Block>>>>,

    slot_ms: u64,
    sig_workers: usize,
    consensus: Arc<Mutex<PhaseConsensus>>,
}

impl Engine {
    pub fn new(ledger: Ledger, proposer: Rid) -> Arc<Self> {
        let mempool_cap = env_u64("LRB_MEMPOOL_CAP", 100_000);
        let max_block_tx = env_u64("LRB_MAX_BLOCK_TX", 10_000);
        let max_amount = env_u64("LRB_MAX_AMOUNT", u64::MAX / 2);
        let slot_ms = env_u64("LRB_SLOT_MS", 500);
        let quorum_n = env_usize("LRB_QUORUM_N", 1);
        let sig_workers = env_usize("LRB_SIG_WORKERS", 4);

        let mempool: Arc<Mutex<Vec<Tx>>> = Arc::new(Mutex::new(Vec::new()));
        let (tx, rx) = unbounded_channel::<Tx>();

        let engine = Arc::new(Self {
            ledger: Arc::new(ledger),
            guard: SpamGuard::new(mempool_cap as usize, max_block_tx as usize, max_amount),
            dyn_cost: DynamicBalance::new(100, 2),
            proposer,
            mempool_tx: tx.clone(),
            mempool: mempool.clone(),
            commit_tx: Arc::new(Mutex::new(None)),
            slot_ms,
            sig_workers,
            consensus: Arc::new(Mutex::new(PhaseConsensus::new(quorum_n))),
        });

        // приём транзакций в mempool с лимитами
        let guard = engine.guard.clone();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Some(tx) = rx.recv().await {
                let mut lock = mempool.lock().unwrap();
                if guard.check_mempool(lock.len()).is_ok() {
                    lock.push(tx);
                }
            }
        });

        engine
    }

    pub fn ledger(&self) -> Arc<Ledger> {
        self.ledger.clone()
    }
    pub fn proposer(&self) -> Rid {
        self.proposer.clone()
    }
    pub fn set_commit_notifier(&self, sender: broadcast::Sender<Block>) {
        *self.commit_tx.lock().unwrap() = Some(sender);
    }
    pub fn check_amount_valid(&self, amount: u64) -> Result<()> {
        self.guard.check_amount(amount)
    }
    pub fn mempool_sender(&self) -> UnboundedSender<Tx> {
        self.mempool_tx.clone()
    }
    pub fn mempool_len(&self) -> usize {
        self.mempool.lock().unwrap().len()
    }
    pub fn finalized_height(&self) -> u64 {
        self.consensus.lock().unwrap().finalized()
    }

    pub fn register_vote(&self, height: u64, block_hash: &str, rid_b58: &str) -> bool {
        let mut cons = self.consensus.lock().unwrap();
        if let Some((h, voted_hash)) = cons.vote(height, block_hash, rid_b58) {
            if let Ok(local) = self.ledger.get_block_by_height(h) {
                if local.block_hash == voted_hash {
                    let _ = self.ledger.set_finalized(h);
                    return true;
                }
            }
        }
        false
    }

    pub async fn run_block_producer(self: Arc<Self>) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(self.slot_ms));

        loop {
            interval.tick().await;

            // 1) забираем пачку из мемпула
            let raw = {
                let mut mp = self.mempool.lock().unwrap();
                if mp.is_empty() {
                    continue;
                }
                let take = self.guard.max_block_txs().min(mp.len());
                mp.drain(0..take).collect::<Vec<Tx>>()
            };

            // 2) проверка подписей параллельно
            let mut valid = filter_valid_sigs_parallel(raw, self.sig_workers).await;
            if valid.is_empty() {
                continue;
            }

            // 3) базовые лимиты/amount
            valid.retain(|t| self.guard.check_amount(t.amount).is_ok());
            if valid.is_empty() {
                continue;
            }

            // 4) формируем блок (h+1)
            let (h, prev_hash) = self.ledger.head().unwrap_or((0, String::new()));
            let b = Block::new(h + 1, prev_hash, self.proposer.clone(), valid);

            // 5) фазовый фильтр (резонанс). Если не прошёл — НЕ теряем tx: возвращаем в хвост mempool.
            if !block_passes_phase(&b) {
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter()); // вернуть в очередь, обработаем в следующем слоте
                continue;
            }

            // 6) атомарный коммит блока
            if let Err(e) = self.ledger.commit_block_atomic(&b) {
                // при ошибке — вернуть tx в mempool и идти дальше
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter());
                eprintln!("commit_block_atomic error at height {}: {:?}", b.height, e);
                continue;
            }

            // 7) индексирование блока для истории/эксплорера (не мешает продюсеру)
            let ts = now_ms();
            if let Err(e) = self.ledger.index_block(b.height, &b.block_hash, ts, &b.txs) {
                // индексация не должна ломать производство блоков
                eprintln!("index_block error at height {}: {:?}", b.height, e);
            }

            // 8) локальный голос и уведомление подписчикам
            let _ = self.register_vote(b.height, &b.block_hash, self.proposer.as_str());
            if let Some(tx) = self.commit_tx.lock().unwrap().as_ref() {
                let _ = tx.send(b.clone());
            }
        }
    }

    pub fn lgn_cost_microunits(&self) -> u64 {
        self.dyn_cost.lgn_cost(self.mempool_len() as usize)
    }
}

pub fn engine_with_channels(ledger: Ledger, proposer: Rid) -> (Arc<Engine>, UnboundedSender<Tx>) {
    let engine = Engine::new(ledger, proposer);
    let sender = engine.mempool_sender();
    (engine, sender)
}

```

## FILE: /root/logos_lrb/lrb_core/src/resonance.rs  (size=1146b)
```
use crate::types::{Block, Tx};
use blake3::Hasher;

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS {
        h.update(tag);
    }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs {
        mix_tx(&mut h, tx)
    }
    hex::encode(h.finalize().as_bytes())
}

```

## FILE: /root/logos_lrb/lrb_core/src/sigpool.rs  (size=1072b)
```
use crate::phase_integrity::verify_tx_signature;
use crate::types::Tx;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() {
        return txs;
    }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res {
            out.append(&mut v);
        }
    }
    out
}

```

## FILE: /root/logos_lrb/lrb_core/src/spam_guard.rs  (size=839b)
```
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self {
            max_mempool,
            max_tx_per_block,
            max_amount,
        }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize {
        self.max_tx_per_block
    }
}

```

## FILE: /root/logos_lrb/lrb_core/src/types.rs  (size=3363b)
```
use anyhow::{anyhow, Result};
use blake3::Hasher;
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// base64 v0.22 Engine API
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;

pub type Amount = u64;
pub type Height = u64;
pub type Nonce = u64;

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Rid(pub String); // base58(VerifyingKey)

impl Rid {
    pub fn from_pubkey(pk: &VerifyingKey) -> Self {
        Rid(bs58::encode(pk.to_bytes()).into_string())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Tx {
    pub id: String, // blake3 of canonical form
    pub from: Rid,  // base58(pubkey)
    pub to: Rid,
    pub amount: Amount,
    pub nonce: Nonce,
    pub public_key: Vec<u8>, // 32 bytes (VerifyingKey)
    pub signature: Vec<u8>,  // 64 bytes (Signature)
}

impl Tx {
    pub fn canonical_bytes(&self) -> Vec<u8> {
        // Без id и signature для детерминированного хеша
        let m = serde_json::json!({
            "from": self.from.as_str(),
            "to": self.to.as_str(),
            "amount": self.amount,
            "nonce": self.nonce,
            "public_key": B64.encode(&self.public_key),
        });
        serde_json::to_vec(&m).expect("canonical json")
    }
    pub fn compute_id(&self) -> String {
        let mut hasher = Hasher::new();
        hasher.update(&self.canonical_bytes());
        hex::encode(hasher.finalize().as_bytes())
    }
    pub fn validate_shape(&self) -> Result<()> {
        if self.public_key.len() != 32 {
            return Err(anyhow!("bad pubkey len"));
        }
        if self.signature.len() != 64 {
            return Err(anyhow!("bad signature len"));
        }
        if self.amount == 0 {
            return Err(anyhow!("amount must be > 0"));
        }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: Height,
    pub prev_hash: String,
    pub timestamp_ms: u128,
    pub proposer: Rid,
    pub txs: Vec<Tx>,
    pub block_hash: String,
    pub uuid: String, // для логов
}

impl Block {
    pub fn new(height: Height, prev_hash: String, proposer: Rid, txs: Vec<Tx>) -> Self {
        let ts = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_millis();
        let mut h = Hasher::new();
        h.update(prev_hash.as_bytes());
        h.update(proposer.as_str().as_bytes());
        for tx in &txs {
            h.update(tx.id.as_bytes());
        }
        h.update(&ts.to_le_bytes());
        let block_hash = hex::encode(h.finalize().as_bytes());
        Block {
            height,
            prev_hash,
            timestamp_ms: ts,
            proposer,
            txs,
            block_hash,
            uuid: Uuid::new_v4().to_string(),
        }
    }
}

pub fn parse_pubkey(pk: &[u8]) -> Result<VerifyingKey> {
    let arr: [u8; 32] = pk.try_into().map_err(|_| anyhow!("bad pubkey len"))?;
    Ok(VerifyingKey::from_bytes(&arr)?)
}

pub fn parse_sig(sig: &[u8]) -> Result<Signature> {
    let arr: [u8; 64] = sig.try_into().map_err(|_| anyhow!("bad signature len"))?;
    Ok(Signature::from_bytes(&arr))
}

```

## FILE: /root/logos_lrb/modules/beacon_emitter.rs  (size=4455b)
```
use axum::{
    extract::State,
    routing::{get, post},
    Router,
};
use std::{net::SocketAddr, time::Duration};
use tower::{ServiceBuilder};
use tower_http::{
    cors::{Any, CorsLayer},
    trace::TraceLayer,
    timeout::TimeoutLayer,
    limit::{RequestBodyLimitLayer},
};
use tracing_subscriber::{EnvFilter, fmt};
use ed25519_dalek::{SigningKey, VerifyingKey, SignatureError};
use rand_core::OsRng;
use bs58;
use once_cell::sync::OnceCell;
use anyhow::Result;

mod api;
mod admin;
mod bridge;
mod gossip;
mod state;
mod peers;
mod fork;

#[derive(Clone)]
struct AppState {
    signing: SigningKey,
    verifying: VerifyingKey,
    rid_b58: String,
    admin_key: String,
    bridge_key: String,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(bytes.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(data.as_slice().try_into().map_err(|_| anyhow::anyhow!("bad SK len"))?);
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}

fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}

fn read_env_required(n: &str) -> Result<String> {
    let v = std::env::var(n).map_err(|_| anyhow::anyhow!("missing env {}", n))?;
    Ok(v)
}

fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY","CHANGE_ME","", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // tracing
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    // keys + env
    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid = rid_from_vk(&vk);

    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    let state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid.clone(),
        admin_key,
        bridge_key,
    };
    APP_STATE.set(state.clone()).unwrap();

    // CORS
    let cors = {
        let allowed_origin = std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| String::from("https://wallet.example"));
        CorsLayer::new()
            .allow_origin(allowed_origin.parse::<axum::http::HeaderValue>().unwrap())
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([axum::http::header::CONTENT_TYPE, axum::http::header::AUTHORIZATION])
    };

    // limits/timeout
    let layers = ServiceBuilder::new()
        .layer(TraceLayer::new_for_http())
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(RequestBodyLimitLayer::new(512 * 1024)) // 512 KiB
        .layer(cors)
        .into_inner();

    // маршруты
    let app = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet)) // dev-only
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify))
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .with_state(state)
        .layer(layers);

    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    tracing::info!("logos_node listening on {} (RID={})", addr, rid);
    axum::serve(tokio::net::TcpListener::bind(addr).await?, app).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/modules/env_impact_tracker.py  (size=5447b)
```
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```

## FILE: /root/logos_lrb/modules/external_phase_broadcaster.rs  (size=1588b)
```
//! Внешний широковещатель фаз: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseBroadcaster {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl PhaseBroadcaster {
    pub fn new(key32: [u8;32], self_vk: VerifyingKey) -> Self {
        Self { aead: AeadBox::from_key(&key32), self_vk }
    }

    pub fn pack(&self, signer: &SigningKey, topic: &[u8], payload: &[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64 + sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unpack(&self, sender_vk: &VerifyingKey, topic: &[u8], data: &[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_bcast: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_bcast: bad signature"))?;

        let mut aad = Vec::with_capacity(topic.len()+32);
        aad.extend_from_slice(topic);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let pt = self.aead.open(&aad, sealed)?;
        Ok(pt)
    }
}

```

## FILE: /root/logos_lrb/modules/external_phase_link.rs  (size=1719b)
```
//! Точка-точка фазовая связка: AEAD XChaCha20-Poly1305 + Ed25519 подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct PhaseLink {
    aead: AeadBox,
    self_vk: VerifyingKey,
    peer_vk: VerifyingKey,
}

impl PhaseLink {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey, peer_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk, peer_vk }
    }

    pub fn encode(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("phase_link: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("phase_link: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+64);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());
        aad.extend_from_slice(self.peer_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/genesis_fragment_seeds.rs  (size=1423b)
```
//! Genesis Fragment Seeds: шифрованное хранение фрагментов seed.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct SeedVault { aead:AeadBox, self_vk:VerifyingKey }

impl SeedVault {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn pack_fragment(&self, signer:&SigningKey, label:&[u8], fragment:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, fragment); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unpack_fragment(&self, sender_vk:&VerifyingKey, label:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("seed_vault: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("seed_vault: bad sig"))?;
        let mut aad=Vec::with_capacity(label.len()+32); aad.extend_from_slice(label); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/go_to_market.yaml  (size=3633b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```

## FILE: /root/logos_lrb/modules/heartbeat_monitor.rs  (size=1489b)
```
//! Heartbeat Monitor — безопасные heartbeat-кадры между узлами (AEAD+подпись).

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

#[derive(Clone)]
pub struct HeartbeatMonitor { aead:AeadBox, self_vk:VerifyingKey }

impl HeartbeatMonitor {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn encode_ping(&self, signer:&SigningKey, channel:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, payload); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("heartbeat: short frame"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("heartbeat: bad signature"))?;
        let mut aad=Vec::with_capacity(channel.len()+32); aad.extend_from_slice(channel); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/legacy_migrator.rs  (size=1432b)
```
//! Legacy Migrator: перенос артефактов со шифрованием и подписью.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct LegacyMigrator { aead:AeadBox, self_vk:VerifyingKey }

impl LegacyMigrator {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn wrap_blob(&self, signer:&SigningKey, kind:&[u8], blob:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, blob); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn unwrap_blob(&self, sender_vk:&VerifyingKey, kind:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("legacy_migrator: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("legacy_migrator: bad sig"))?;
        let mut aad=Vec::with_capacity(kind.len()+32); aad.extend_from_slice(kind); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/maintenance_strategy.yaml  (size=2361b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```

## FILE: /root/logos_lrb/modules/__pycache__/env_impact_tracker.cpython-312.pyc  (size=8808b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/modules/__pycache__/resonance_tutor.cpython-312.pyc  (size=9982b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/modules/__pycache__/symbolic_parser.cpython-312.pyc  (size=6942b)

(SKIPPED, binary/non-text)

## FILE: /root/logos_lrb/modules/resonance_analytics_frontend.tsx  (size=4632b)
```
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```

## FILE: /root/logos_lrb/modules/resonance_emergency_plan.yaml  (size=3420b)
```
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```

## FILE: /root/logos_lrb/modules/resonance_meshmap.yaml  (size=1877b)
```
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```

## FILE: /root/logos_lrb/modules/resonance_tutor.py  (size=6414b)
```
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```

## FILE: /root/logos_lrb/modules/ritual_engine.rs  (size=1460b)
```
//! Ritual Engine: доставка «ритуальных» сообщений c фазовой меткой, AEAD+подпись.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct RitualEngine { aead:AeadBox, self_vk:VerifyingKey }

impl RitualEngine {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self { Self{ aead:AeadBox::from_key(&key32), self_vk } }

    pub fn send(&self, signer:&SigningKey, phase_id:&[u8], msg:&[u8]) -> Result<Vec<u8>> {
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        let sealed=self.aead.seal(&aad, msg); let sig=signer.sign(&sealed);
        let mut out=Vec::with_capacity(64+sealed.len()); out.extend_from_slice(sig.as_ref()); out.extend_from_slice(&sealed); Ok(out)
    }

    pub fn recv(&self, sender_vk:&VerifyingKey, phase_id:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len()<64+24+16 { anyhow::bail!("ritual_engine: short"); }
        let(sig_bytes,sealed)=data.split_at(64); let sig=Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed,&sig).map_err(|_|anyhow::anyhow!("ritual_engine: bad sig"))?;
        let mut aad=Vec::with_capacity(phase_id.len()+32); aad.extend_from_slice(phase_id); aad.extend_from_slice(self.self_vk.as_bytes());
        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/symbolic_parser.py  (size=4615b)
```
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```

## FILE: /root/logos_lrb/modules/uplink_controller.rs  (size=1571b)
```
//! Uplink Controller: надёжная упаковка кадров uplink → core.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkController {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkController {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn encode_frame(&self, signer:&SigningKey, channel:&[u8], frame:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, frame);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn decode_frame(&self, sender_vk:&VerifyingKey, channel:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_controller: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_controller: bad signature"))?;

        let mut aad = Vec::with_capacity(channel.len()+32);
        aad.extend_from_slice(channel);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/modules/uplink_router.rs  (size=1551b)
```
//! Uplink Router: безопасная пересылка кадров между маршрутами.

use lrb_core::crypto::AeadBox;
use ed25519_dalek::{SigningKey, VerifyingKey, Signature, Signer, Verifier};
use anyhow::Result;

pub struct UplinkRouter {
    aead: AeadBox,
    self_vk: VerifyingKey,
}

impl UplinkRouter {
    pub fn new(key32:[u8;32], self_vk:VerifyingKey) -> Self {
        Self { aead:AeadBox::from_key(&key32), self_vk }
    }

    pub fn wrap(&self, signer:&SigningKey, route:&[u8], payload:&[u8]) -> Result<Vec<u8>> {
        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        let sealed = self.aead.seal(&aad, payload);
        let sig = signer.sign(&sealed);

        let mut out = Vec::with_capacity(64+sealed.len());
        out.extend_from_slice(sig.as_ref());
        out.extend_from_slice(&sealed);
        Ok(out)
    }

    pub fn unwrap(&self, sender_vk:&VerifyingKey, route:&[u8], data:&[u8]) -> Result<Vec<u8>> {
        if data.len() < 64+24+16 { anyhow::bail!("uplink_router: short"); }
        let (sig_bytes, sealed) = data.split_at(64);
        let sig = Signature::from_bytes(sig_bytes)?;
        sender_vk.verify_strict(sealed, &sig).map_err(|_| anyhow::anyhow!("uplink_router: bad signature"))?;

        let mut aad = Vec::with_capacity(route.len()+32);
        aad.extend_from_slice(route);
        aad.extend_from_slice(self.self_vk.as_bytes());

        Ok(self.aead.open(&aad, sealed)?)
    }
}

```

## FILE: /root/logos_lrb/node/src/admin.rs  (size=1627b)
```
//! Админ-ручки: snapshot/restore и node_info.
//! Доступ защищается через заголовок X-Admin-Key = LRB_ADMIN_KEY.

use crate::AppState;
use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

fn check_admin(st: &AppState, headers: &axum::http::HeaderMap) -> Result<(), StatusCode> {
    let got = headers
        .get("X-Admin-Key")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("");
    if got == st.admin_key {
        Ok(())
    } else {
        Err(StatusCode::UNAUTHORIZED)
    }
}

#[derive(Serialize)]
pub struct NodeInfo {
    pub rid: String,
    pub height: u64,
    pub finalized: bool,
}

pub async fn node_info(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<NodeInfo>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(NodeInfo {
        rid: st.rid_b58.clone(),
        height: 0,
        finalized: false,
    }))
}

#[derive(Serialize)]
pub struct SnapshotResp {
    pub status: &'static str,
}

pub async fn snapshot(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

#[derive(Deserialize)]
#[allow(dead_code)]
pub struct RestoreReq {
    #[serde(default)]
    pub path: String,
}

pub async fn restore(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(_req): Json<RestoreReq>,
) -> Result<Json<SnapshotResp>, StatusCode> {
    check_admin(&st, &headers)?;
    Ok(Json(SnapshotResp { status: "ok" }))
}

```

## FILE: /root/logos_lrb/node/src/api.rs  (size=10642b)
```
use axum::{extract::{Path, Query, State}, http::StatusCode, Json};
use hex;
use serde::{Deserialize, Serialize};
use serde_json;

use crate::metrics::{inc_total, Timer};
use crate::storage::TxIn;
use crate::AppState;

use bs58;
use ed25519_dalek::{Signature, Verifier, VerifyingKey};
use parking_lot::Mutex;
use std::collections::{BTreeMap, HashMap};
use std::sync::Arc;

/* ========= liveness / readiness ========= */
#[derive(Serialize)] pub struct Healthz{ pub status: &'static str }
pub async fn healthz()->Json<Healthz>{ Json(Healthz{status:"ok"}) }
pub async fn livez()->Json<Healthz>{ Json(Healthz{status:"ok"}) }
pub async fn readyz(State(_st):State<AppState>)->Result<Json<Healthz>,StatusCode>{
    let t=Timer::new("/readyz","GET"); inc_total("/readyz","GET",StatusCode::OK); t.observe(); Ok(Json(Healthz{status:"ready"}))
}

/* ========= helpers ========= */
#[derive(Serialize,Deserialize,Clone)]
struct CanonTx<'a>{ from:&'a str,to:&'a str,amount:u64,nonce:u64 }
fn canon_bytes(tx:&TxIn)->Result<Vec<u8>,StatusCode>{
    let c=CanonTx{from:&tx.from,to:&tx.to,amount:tx.amount,nonce:tx.nonce};
    serde_json::to_vec(&c).map_err(|_|StatusCode::BAD_REQUEST)
}
fn vk_from_rid(rid:&str)->Result<VerifyingKey,StatusCode>{
    let b=bs58::decode(rid).into_vec().map_err(|_|StatusCode::BAD_REQUEST)?; if b.len()!=32 {return Err(StatusCode::BAD_REQUEST);}
    VerifyingKey::from_bytes(b.as_slice().try_into().unwrap()).map_err(|_|StatusCode::BAD_REQUEST)
}
fn sig_from_hex(h:&str)->Result<Signature,StatusCode>{
    let raw=hex::decode(h).map_err(|_|StatusCode::BAD_REQUEST)?; let arr:[u8;64]=raw.as_slice().try_into().map_err(|_|StatusCode::BAD_REQUEST)?;
    Ok(Signature::from_bytes(&arr))
}

/* ========= head / balance ========= */
#[derive(Serialize)] pub struct HeadResp{ pub height:u64, pub finalized:bool }
pub async fn head(State(st):State<AppState>)->Json<HeadResp>{
    let t=Timer::new("/head","GET"); let h=st.store.get_height().unwrap_or(0); inc_total("/head","GET",StatusCode::OK); t.observe();
    Json(HeadResp{height:h,finalized:false})
}
#[derive(Serialize)] pub struct BalanceResp{ pub rid:String, pub balance:u64, pub nonce:u64 }
pub async fn balance(State(st):State<AppState>,Path(rid):Path<String>)->Json<BalanceResp>{
    let t=Timer::new("/balance/:rid","GET"); let a=st.store.get_account(&rid).unwrap_or_default(); inc_total("/balance/:rid","GET",StatusCode::OK); t.observe();
    Json(BalanceResp{rid, balance:a.balance, nonce:a.nonce})
}

/* ========= history / block ========= */
#[derive(Deserialize)] pub struct HistoryQuery{ #[serde(default)] pub from:u64, #[serde(default="def_limit")] pub limit:usize }
fn def_limit()->usize{20}
#[derive(Serialize)] pub struct HistoryResp{ pub rid:String, pub from:u64, pub limit:usize, pub next_from:Option<u64>, pub items:Vec<crate::storage::HistoryItem> }
pub async fn history(State(st):State<AppState>, Path(rid):Path<String>, Query(q):Query<HistoryQuery>)->Result<Json<HistoryResp>,StatusCode>{
    let t=Timer::new("/history/:rid","GET");
    let (items,next_from)=st.store.history_page(&rid,q.from,q.limit.min(1000)).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/history/:rid","GET",StatusCode::OK); t.observe();
    Ok(Json(HistoryResp{rid,from:q.from,limit:q.limit,next_from,items}))
}
#[derive(Serialize)] pub struct BlockResp{ pub height:u64,pub ts_ms:u64,pub txs:Vec<TxIn> }
pub async fn block(State(st):State<AppState>,Path(h):Path<u64>)->Result<Json<BlockResp>,StatusCode>{
    let t=Timer::new("/block/:height","GET"); let br=st.store.get_block(h).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?; let br=br.ok_or(StatusCode::NOT_FOUND)?;
    inc_total("/block/:height","GET",StatusCode::OK); t.observe(); Ok(Json(BlockResp{height:br.height, ts_ms:br.ts_ms, txs:br.txs}))
}

/* ========= block mix (PhaseMix v1) ========= */
#[derive(Serialize)] pub struct MixResp{ pub height:u64, pub ts_ms:u64, pub deltas:Vec<(String,i128)> }
pub async fn block_mix(State(st):State<AppState>,Path(h):Path<u64>)->Result<Json<MixResp>,StatusCode>{
    let t=Timer::new("/block/:height/mix","GET");
    let m = st.store.get_mix(h).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    let m = m.ok_or(StatusCode::NOT_FOUND)?;
    inc_total("/block/:height/mix","GET",StatusCode::OK); t.observe();
    Ok(Json(MixResp{height:m.height, ts_ms:m.ts_ms, deltas:m.deltas}))
}

/* ========= submit_tx / batch ========= */
#[derive(Deserialize)] pub struct SubmitTxBatchReq{ #[serde(default)] pub txs:Vec<TxIn> }
#[derive(Serialize)]   pub struct TxResult{ pub idx:usize, pub status:&'static str, pub code:u16, pub reason:&'static str }
#[derive(Serialize)]   pub struct SubmitTxBatchResp{ pub accepted:usize, pub rejected:usize, pub new_height:u64, pub results:Vec<TxResult> }

pub async fn submit_tx_batch(State(st):State<AppState>, Json(req):Json<SubmitTxBatchReq>)
 -> Result<Json<SubmitTxBatchResp>,StatusCode>{
    let t=Timer::new("/submit_tx_batch","POST");
    if req.txs.is_empty(){ inc_total("/submit_tx_batch","POST",StatusCode::BAD_REQUEST); t.observe(); return Err(StatusCode::BAD_REQUEST); }
    let mut by_sender:BTreeMap<String,Vec<(usize,TxIn)>>=BTreeMap::new();
    for (i,tx) in req.txs.into_iter().enumerate(){ by_sender.entry(tx.from.clone()).or_default().push((i,tx)); }
    let mut results=Vec::new(); let mut acc_total=0usize; let mut rej_total=0usize; let mut last_h=st.store.get_height().unwrap_or(0);
    let mut cache:HashMap<String, crate::storage::AccountState>=HashMap::new();
    for (from,mut items) in by_sender.into_iter() {
        items.sort_by_key(|(_,tx)| tx.nonce);
        let lk = st.locks.entry(from.clone()).or_insert_with(||Arc::new(Mutex::new(()))).clone();
        let _g = lk.lock();
        let mut next = st.store.get_account(&from).unwrap_or_default().nonce;
        let mut valid:Vec<TxIn>=Vec::new();
        for (idx,tx) in items.into_iter(){
            let vk = match vk_from_rid(&tx.from){ Ok(v)=>v, Err(_)=>{ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:400,reason:"bad_rid"}); continue; } };
            let sig= match sig_from_hex(&tx.sig_hex){ Ok(s)=>s, Err(_)=>{ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:401,reason:"bad_sig"}); continue; } };
            let msg= match canon_bytes(&tx){ Ok(m)=>m, Err(_)=>{ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:400,reason:"bad_canon"}); continue; } };
            if vk.verify(&msg,&sig).is_err(){ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:401,reason:"bad_sig"}); continue; }
            if tx.nonce != next.saturating_add(1){ rej_total+=1; results.push(TxResult{idx,status:"rejected",code:409,reason:"bad_nonce"}); continue; }
            let fs = cache.get(&tx.from).cloned().unwrap_or_else(|| st.store.get_account(&tx.from).unwrap_or_default());
            let ts = cache.get(&tx.to).cloned().unwrap_or_else(|| st.store.get_account(&tx.to).unwrap_or_default());
            if tx.from != tx.to && fs.balance < tx.amount { rej_total+=1; results.push(TxResult{idx,status:"rejected",code:402,reason:"insufficient_funds"}); continue; }
            // simulate in cache
            let mut nf=fs; let mut nt=ts; next = next.saturating_add(1); nf.nonce = next;
            if tx.from != tx.to { nf.balance = nf.balance.saturating_sub(tx.amount); nt.balance = nt.balance.saturating_add(tx.amount); }
            cache.insert(tx.from.clone(), nf); cache.insert(tx.to.clone(), nt);
            valid.push(tx); acc_total+=1; results.push(TxResult{idx,status:"accepted",code:0,reason:"ok"});
        }
        if !valid.is_empty(){ last_h = st.store.apply_batch(&valid).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?; }
    }
    let resp=SubmitTxBatchResp{accepted:acc_total,rejected:rej_total,new_height:last_h,results};
    inc_total("/submit_tx_batch","POST",StatusCode::OK); t.observe(); Ok(Json(resp))
}
#[inline] fn inc_tx_err(){}

/* ========= одиночная submit_tx ========= */
#[derive(Deserialize)] pub struct SubmitTxReq{ #[serde(default)] pub _payload:serde_json::Value }
#[derive(Serialize)]   pub struct SubmitTxResp{ pub status:&'static str }
pub async fn submit_tx(State(_st):State<AppState>, Json(_req):Json<SubmitTxReq>) -> Result<Json<SubmitTxResp>,StatusCode>{
    let t=Timer::new("/submit_tx","POST"); inc_total("/submit_tx","POST",StatusCode::OK); t.observe(); Ok(Json(SubmitTxResp{status:"accepted"}))
}

/* ========= debug_canon ========= */
#[derive(Deserialize)] pub struct DebugCanonReq{ #[serde(default)] pub tx:serde_json::Value }
#[derive(Serialize)]   pub struct DebugCanonResp{ pub canon_hex:String }
pub async fn debug_canon(Json(req):Json<DebugCanonReq>) -> Result<Json<DebugCanonResp>,StatusCode>{
    let t=Timer::new("/debug_canon","POST");
    let from=req.tx.get("from").and_then(|v|v.as_str()).ok_or(StatusCode::BAD_REQUEST)?;
    let to  =req.tx.get("to").and_then(|v|v.as_str()).ok_or(StatusCode::BAD_REQUEST)?;
    let amount=req.tx.get("amount").and_then(|v|v.as_u64()).ok_or(StatusCode::BAD_REQUEST)?;
    let nonce =req.tx.get("nonce").and_then(|v|v.as_u64()).ok_or(StatusCode::BAD_REQUEST)?;
    let c=CanonTx{from,to,amount,nonce}; let bytes=serde_json::to_vec(&c).map_err(|_|StatusCode::BAD_REQUEST)?;
    let canon_hex=hex::encode(bytes);
    inc_total("/debug_canon","POST",StatusCode::OK); t.observe(); Ok(Json(DebugCanonResp{canon_hex}))
}

/* ========= faucet (DEV) ========= */
#[derive(Deserialize)] pub struct FaucetReq{ #[serde(default)] pub rid:String, #[serde(default)] pub amount:u64 }
#[derive(Serialize)]   pub struct FaucetResp{ pub granted:u64, pub rid:String }
pub async fn faucet(State(st):State<AppState>, Json(req):Json<FaucetReq>) -> Result<Json<FaucetResp>,StatusCode>{
    if std::env::var("LRB_ENABLE_FAUCET").ok().as_deref()!=Some("1"){ return Err(StatusCode::FORBIDDEN); }
    let t=Timer::new("/faucet","POST");
    if req.rid.is_empty() || req.amount==0 { inc_total("/faucet","POST",StatusCode::BAD_REQUEST); t.observe(); return Err(StatusCode::BAD_REQUEST);}
    let _st = st.store.faucet(&req.rid, req.amount).map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    inc_total("/faucet","POST",StatusCode::OK); t.observe(); Ok(Json(FaucetResp{granted:req.amount, rid:req.rid}))
}

/* ========= economy ========= */
#[derive(Serialize)] pub struct EconomyResp{ pub cap:u64, pub minted:u64, pub burned:u64, pub supply:u64 }
pub async fn economy(State(st):State<AppState>) -> Result<Json<EconomyResp>,StatusCode>{
    let snap = st.store.economy_snapshot().map_err(|_|StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(EconomyResp{cap:snap.cap, minted:snap.minted, burned:snap.burned, supply:snap.supply}))
}

```

## FILE: /root/logos_lrb/node/src/auth.rs  (size=5131b)
```
// node/src/auth.rs
use axum::http::{HeaderMap, StatusCode};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Deserialize)]
struct Claims {
    exp: i64,
    sub: Option<String>,
    iat: Option<i64>,
}

// ------------ time ------------
fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
}

// ------------ helpers ------------
fn header_value(headers: &HeaderMap, name: &str) -> Option<String> {
    headers.get(name).and_then(|v| v.to_str().ok()).map(|s| s.trim().to_string())
}

fn header_or_bearer(headers: &HeaderMap, primary_header: &str) -> Option<String> {
    if let Some(v) = header_value(headers, primary_header) {
        if !v.is_empty() { return Some(v); }
    }
    if let Some(v) = header_value(headers, "authorization") {
        if let Some(rest) = v.strip_prefix("Bearer ") {
            let t = rest.trim();
            if !t.is_empty() { return Some(t.to_string()); }
        }
    }
    None
}

/// Простейший IP-ACL: LRB_ADMIN_IP_ALLOW="1.2.3.4,10.0.0.0/8"
fn ip_acl_allows(ip: Option<IpAddr>, env_key: &str) -> bool {
    let allow = std::env::var(env_key).unwrap_or_default();
    if allow.trim().is_empty() { return true; }
    let rules: Vec<&str> = allow.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    if rules.is_empty() { return true; }
    if let Some(client) = ip {
        for r in rules {
            if let Ok(one) = r.parse::<IpAddr>() {
                if one == client { return true; }
            } else if let Some((net, bits)) = r.split_once('/') {
                if let (Ok(nip), Ok(b)) = (net.parse::<IpAddr>(), bits.parse::<u8>()) {
                    if let (IpAddr::V4(a), IpAddr::V4(n)) = (client, nip) {
                        let mask: u32 = if b == 0 { 0 } else { (!0u32) << (32 - b as u32) };
                        if (u32::from(a) & mask) == (u32::from(n) & mask) { return true; }
                    }
                }
            }
        }
        false
    } else { false }
}

// ------------ публичные проверки ------------

/// Админ-доступ:
/// 1) если задан нормальный LRB_ADMIN_KEY — принимаем X-Admin-Key (приоритетно)
/// 2) если задан LRB_ADMIN_JWT_SECRET — принимаем JWT (X-Admin-Key или Authorization: Bearer)
/// 3) IP-ACL: LRB_ADMIN_IP_ALLOW (пусто = разрешить всем)
pub fn require_admin(headers: &HeaderMap, remote_ip: Option<IpAddr>) -> Result<(), StatusCode> {
    if !ip_acl_allows(remote_ip, "LRB_ADMIN_IP_ALLOW") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // статический ключ (удобно для таймеров/автоматизаций)
    if let Ok(k) = std::env::var("LRB_ADMIN_KEY") {
        let k = k.trim();
        if !k.is_empty() && k != "CHANGE_ADMIN_KEY" {
            if let Some(presented) = header_or_bearer(headers, "X-Admin-Key") {
                if presented == k { return Ok(()); }
            }
        }
    }

    // JWT HS256
    if let Ok(secret) = std::env::var("LRB_ADMIN_JWT_SECRET") {
        let secret = secret.trim();
        if !secret.is_empty() {
            if let Some(tok) = header_or_bearer(headers, "X-Admin-Key") {
                if let Ok(data) = decode::<Claims>(
                    &tok,
                    &DecodingKey::from_secret(secret.as_bytes()),
                    &Validation::new(Algorithm::HS256),
                ) {
                    if data.claims.exp > now_ts() { return Ok(()); }
                }
            }
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    Err(StatusCode::UNAUTHORIZED)
}

/// Доступ к мосту: LRB_BRIDGE_KEY в X-Bridge-Key или Authorization: Bearer <key>
pub fn require_bridge(headers: &HeaderMap) -> Result<(), StatusCode> {
    let k = std::env::var("LRB_BRIDGE_KEY").unwrap_or_default();
    let k = k.trim();
    if k.is_empty() || k == "CHANGE_ME" { return Err(StatusCode::UNAUTHORIZED); }

    if let Some(presented) = header_or_bearer(headers, "X-Bridge-Key") {
        if presented == k { return Ok(()); }
    }
    if let Some(bearer) = header_or_bearer(headers, "Authorization") {
        if bearer == k { return Ok(()); }
    }
    Err(StatusCode::UNAUTHORIZED)
}

// ------------ JWT minting (для /admin/token) ------------
#[derive(Serialize)]
struct ClaimsOut { sub: String, exp: i64, iat: i64 }

/// Выпуск JWT (HS256) c TTL (сек): возвращает строку токена.
pub fn mint_jwt(secret: &str, sub: &str, ttl_secs: i64) -> Result<String, StatusCode> {
    if ttl_secs <= 0 { return Err(StatusCode::BAD_REQUEST); }
    let now = now_ts();
    let claims = ClaimsOut { sub: sub.to_string(), iat: now, exp: now + ttl_secs };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

```

## FILE: /root/logos_lrb/node/src/bin/aead_selftest.rs  (size=1723b)
```
use ed25519_dalek::{Signer, SigningKey, VerifyingKey};
use lrb_core::crypto::AeadBox;
use rand_core::{OsRng, RngCore};

fn main() {
    // 1) Ed25519: ключи + подпись/проверка
    let sk = SigningKey::generate(&mut OsRng);
    let vk = VerifyingKey::from(&sk);
    let msg = b"resonance-test-message";
    let sig = sk.sign(msg);
    assert!(vk.verify_strict(msg, &sig).is_ok(), "ed25519 verify failed");

    // 2) AEAD: XChaCha20-Poly1305, уникальный nonce внутри AeadBox
    let mut key32 = [0u8; 32];
    OsRng.fill_bytes(&mut key32);
    let aead = AeadBox::from_key(&key32);

    let aad = b"topic:external-phase|self-vk";
    let pt = "hello, Σ(t)!".as_bytes();

    let ct = aead.seal(aad, pt);
    let dec = aead.open(aad, &ct).expect("aead open failed");
    assert_eq!(dec.as_slice(), pt, "aead roundtrip mismatch");

    // 3) Негатив: порча шифротекста → ошибка
    let mut ct_bad = ct.clone();
    if let Some(last) = ct_bad.last_mut() {
        *last ^= 0xFF; // безопасно мутируем последний байт без двух заимствований
    }
    assert!(aead.open(aad, &ct_bad).is_err(), "aead must fail on tamper");

    // 4) Негатив: смена AAD → ошибка
    let aad_bad = b"topic:changed";
    assert!(
        aead.open(aad_bad, &ct).is_err(),
        "aead must fail on wrong AAD"
    );

    // 5) Подпись поверх шифротекста (seal-then-sign)
    let sig_ct = sk.sign(&ct);
    assert!(
        vk.verify_strict(&ct, &sig_ct).is_ok(),
        "sign(sealed) verify failed"
    );

    println!("OK: ed25519 + AeadBox(XChaCha20-Poly1305) self-test passed");
}

```

## FILE: /root/logos_lrb/node/src/bridge.rs  (size=4870b)
```
//! Bridge: rToken deposit/redeem/verify — prod-ready (single-node, idempotent).
//! Требует корректного X-Bridge-Key (см. LRB_BRIDGE_KEY).
//! Идемпотентность по внешнему ключу квитанции/билета через ledger.bridge_seen_mark().

use axum::{extract::State, http::StatusCode, Json};
use serde::{Deserialize, Serialize};

use crate::{AppState, auth::require_bridge};
use lrb_core::types::Rid;

#[derive(Deserialize)]
pub struct DepositReq {
    /// RID получателя в LOGOS (base58 от pubkey)
    pub rid: String,
    /// Сумма в rLGN
    pub amount: u64,
    /// Внешний уникальный id транзакции/квитанции (например, txid из ETH)
    pub ext_txid: String,
}

#[derive(Serialize)]
pub struct DepositResp {
    pub status: &'static str,
    pub rid: String,
    pub credited: u64,
    pub ext_txid: String,
}

pub async fn deposit(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(req): Json<DepositReq>,
) -> Result<Json<DepositResp>, StatusCode> {
    require_bridge(&headers)?;

    if req.amount == 0 || req.rid.trim().is_empty() || req.ext_txid.trim().is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Идемпотентность внешней транзакции
    let rk = format!("deposit:{}", req.ext_txid.trim());
    if !st.ledger.bridge_seen_mark(&rk).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        return Ok(Json(DepositResp {
            status: "ok_repeat",
            rid: req.rid,
            credited: req.amount,
            ext_txid: req.ext_txid,
        }));
    }

    // Минтим rLGN
    let rid = Rid(req.rid.clone());
    st.ledger.mint_rtoken(&rid, req.amount).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(DepositResp {
        status: "ok",
        rid: req.rid,
        credited: req.amount,
        ext_txid: req.ext_txid,
    }))
}

#[derive(Deserialize)]
pub struct RedeemReq {
    pub rid: String,
    pub amount: u64,
    /// Целевая цепь (например, "ETH")
    #[serde(default)]
    pub target_chain: String,
    /// Адрес в целевой цепи
    #[serde(default)]
    pub target_address: String,
}

#[derive(Serialize)]
pub struct RedeemResp {
    pub status: &'static str,
    pub rid: String,
    pub debited: u64,
    /// Билет на вывод во внешней сети (используется оффчейн-исполнителем)
    pub redeem_ticket: String,
    pub target_chain: String,
    pub target_address: String,
}

pub async fn redeem(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(req): Json<RedeemReq>,
) -> Result<Json<RedeemResp>, StatusCode> {
    require_bridge(&headers)?;
    if req.amount == 0 || req.rid.trim().is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Детерминированный билет — для идемпотентности и трекинга
    let redeem_ticket = format!(
        "redeem:{}:{}:{}:{}",
        req.rid.trim(),
        req.amount,
        req.target_chain.trim(),
        req.target_address.trim()
    );

    // Если билет уже «виден» — повтор
    if !st.ledger.bridge_seen_mark(&redeem_ticket).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        return Ok(Json(RedeemResp {
            status: "ok_repeat",
            rid: req.rid,
            debited: req.amount,
            redeem_ticket,
            target_chain: req.target_chain,
            target_address: req.target_address,
        }));
    }

    // Сжигаем rLGN под вывод (если баланса не хватит — вернётся 400)
    let rid = Rid(req.rid.clone());
    st.ledger.burn_rtoken(&rid, req.amount).map_err(|_| StatusCode::BAD_REQUEST)?;

    Ok(Json(RedeemResp {
        status: "ok",
        rid: req.rid,
        debited: req.amount,
        redeem_ticket,
        target_chain: req.target_chain,
        target_address: req.target_address,
    }))
}

#[derive(Deserialize)]
pub struct VerifyReq {
    pub ticket: String,
}

#[derive(Serialize)]
pub struct VerifyResp {
    pub status: &'static str,
    pub ok: bool,
    pub ticket: String,
}

pub async fn verify(
    State(st): State<AppState>,
    headers: axum::http::HeaderMap,
    Json(req): Json<VerifyReq>,
) -> Result<Json<VerifyResp>, StatusCode> {
    require_bridge(&headers)?;
    if req.ticket.trim().is_empty() {
        return Err(StatusCode::BAD_REQUEST);
    }

    // Первая попытка помечает — ok:false; повтор — ok:true
    let existed = !st.ledger.bridge_seen_mark(&req.ticket).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(VerifyResp { status: "ok", ok: existed, ticket: req.ticket }))
}

```

## FILE: /root/logos_lrb/node/src/fork.rs  (size=1328b)
```
#![allow(dead_code)]
//! Fork-choice: минимальный детерминированный выбор на базе высоты/хэша.
//! Совместим с текущими типами ядра (Block из lrb_core::types).

use lrb_core::types::Block;

/// Выбор лучшей ветви из набора кандидатов.
/// Правила:
/// 1) Бóльшая высота предпочтительнее.
/// 2) При равной высоте — лексикографически наименьший block_hash.
pub fn choose_best<'a>(candidates: &'a [Block]) -> Option<&'a Block> {
    candidates
        .iter()
        .max_by(|a, b| match a.height.cmp(&b.height) {
            core::cmp::Ordering::Equal => a.block_hash.cmp(&b.block_hash).reverse(),
            ord => ord,
        })
}

#[cfg(test)]
mod tests {
    use super::*;
    fn mk(h: u64, hash: &str) -> Block {
        Block {
            height: h,
            block_hash: hash.to_string(),
            ..Default::default()
        }
    }

    #[test]
    fn pick_by_height_then_hash() {
        let a = mk(10, "ff");
        let b = mk(12, "aa");
        let c = mk(12, "bb");
        let out = choose_best(&[a, b.clone(), c]).unwrap();
        assert_eq!(out.height, 12);
        assert_eq!(out.block_hash, "aa");
    }
}

```

## FILE: /root/logos_lrb/node/src/gossip.rs  (size=1539b)
```
#![allow(dead_code)]
//! Gossip-утилиты: сериализация/десериализация блоков для пересылки по сети.

use base64::{engine::general_purpose::STANDARD as B64, Engine as _};
use blake3;
use hex;
use lrb_core::{phase_filters::block_passes_phase, types::Block};
use serde::{Deserialize, Serialize};

/// Конверт для публикации блока в сети Gossip.
#[derive(Serialize, Deserialize)]
pub struct GossipEnvelope {
    pub topic: String,
    pub payload_b64: String,
    pub sigma_hex: String,
    pub height: u64,
}

/// Энкодим блок: base64-пейлоад, sigma_hex = blake3(payload).
pub fn encode_block(topic: &str, blk: &Block) -> anyhow::Result<GossipEnvelope> {
    let bytes = serde_json::to_vec(blk)?;
    let sigma_hex = hex::encode(blake3::hash(&bytes).as_bytes());
    Ok(GossipEnvelope {
        topic: topic.to_string(),
        payload_b64: B64.encode(bytes),
        sigma_hex,
        height: blk.height,
    })
}

/// Декодим блок из конверта.
pub fn decode_block(env: &GossipEnvelope) -> anyhow::Result<Block> {
    let bytes = B64.decode(&env.payload_b64)?;
    let blk: Block = serde_json::from_slice(&bytes)?;
    Ok(blk)
}

/// Пропускает ли блок фазовый фильтр (решение — по самому блоку).
pub fn pass_phase_filter(env: &GossipEnvelope) -> bool {
    if let Ok(blk) = decode_block(env) {
        block_passes_phase(&blk)
    } else {
        false
    }
}

```

## FILE: /root/logos_lrb/node/src/guard.rs  (size=4933b)
```
//! Guard & Rate-Limit (prod) для Axum 0.7:
//! - Admin IP ACL (CIDR allowlist) через from_fn_with_state.
//! - Per-IP rate-limit (token bucket) с bypass по путям и по CIDR.
//! - PATH_BYPASS: /healthz, /livez, /readyz, /metrics, /openapi.json.

use axum::response::IntoResponse;  // ← ДОБАВИТЬ ЭТУ СТРОКУ
use axum::{
    body::Body,
    extract::State,
    http::{Request, StatusCode},
    middleware::Next,
    response::Response,
};
use dashmap::DashMap;
use ipnet::IpNet;
use parking_lot::Mutex;
use std::{
    net::{IpAddr, SocketAddr},
    str::FromStr,
    sync::Arc,
};
use tokio::time::Instant;

/// Пути, которые никогда не ограничиваются лимитером.
const PATH_BYPASS: &[&str] = &[
    "/healthz",
    "/livez",
    "/readyz",
    "/metrics",
    "/openapi.json",
];

/// ===== Admin IP ACL (используем from_fn_with_state) =====
pub async fn admin_ip_gate(
    State(allow): State<Arc<Vec<IpNet>>>,
    req: Request<Body>,
    next: Next,
) -> Response {
    let Some(ip) = client_ip(&req) else {
        return StatusCode::FORBIDDEN.into_response();
    };
    if ip_in_allowlist(ip, &allow) {
        next.run(req).await
    } else {
        StatusCode::FORBIDDEN.into_response()
    }
}

/// ===== Rate Limiter (token bucket per IP) =====
pub struct RateLimiter {
    qps: f64,
    burst: f64,
    /// подсети, которым разрешён обход лимитера
    pub bypass: Arc<Vec<IpNet>>,
    buckets: DashMap<IpAddr, Mutex<TokenBucket>>,
}

struct TokenBucket {
    tokens: f64,
    last: Instant,
}

impl RateLimiter {
    pub fn new(qps: u64, burst: u64, bypass: Arc<Vec<IpNet>>) -> Self {
        let qps = qps as f64;
        let burst = if burst > 0 { burst as f64 } else { qps.max(1.0) * 2.0 };
        Self {
            qps,
            burst,
            bypass,
            buckets: DashMap::new(),
        }
    }

    /// true если IP клиента входит в bypass CIDR
    fn is_bypass(&self, req: &Request<Body>) -> bool {
        if let Some(ip) = client_ip(req) {
            return ip_in_allowlist(ip, &self.bypass);
        }
        false
    }

    /// Проверка и списание токена. false → 429.
    fn check(&self, req: &Request<Body>) -> bool {
        if self.qps <= 0.0 {
            return true;
        }
        let Some(ip) = client_ip(req) else { return false; };

        let entry = self
            .buckets
            .entry(ip)
            .or_insert_with(|| Mutex::new(TokenBucket { tokens: self.burst, last: Instant::now() }));
        let mut tb = entry.lock();

        // refill
        let now = Instant::now();
        let elapsed = now.saturating_duration_since(tb.last).as_secs_f64();
        if elapsed > 0.0 {
            tb.tokens = (tb.tokens + self.qps * elapsed).min(self.burst);
            tb.last = now;
        }

        if tb.tokens >= 1.0 {
            tb.tokens -= 1.0;
            true
        } else {
            false
        }
    }
}

/// Axum 0.7 middleware: rate-limit с bypass по путям и CIDR (from_fn_with_state).
pub async fn rate_limit_ip_gate(
    State(limiter): State<Arc<RateLimiter>>,
    req: Request<Body>,
    next: Next,
) -> Response {
    // 1) Allowlist путей
    let path = req.uri().path();
    if PATH_BYPASS.iter().any(|p| *p == path) {
        return next.run(req).await;
    }

    // 2) CIDR bypass (напр., 127.0.0.1/32,::1/128)
    if limiter.is_bypass(&req) {
        return next.run(req).await;
    }

    // 3) Rate-limit
    if limiter.check(&req) {
        next.run(req).await
    } else {
        StatusCode::TOO_MANY_REQUESTS.into_response()
    }
}

/// ===== Утилиты IP/ACL =====

/// Разбор CSV-списка подсетей в Vec<IpNet>.
/// Пример: "127.0.0.1/32,::1/128,10.0.0.0/8"
pub fn parse_ip_allowlist(csv: &str) -> Vec<IpNet> {
    csv.split(',')
        .map(|s| s.trim())
        .filter(|s| !s.is_empty())
        .filter_map(|s| IpNet::from_str(s).ok())
        .collect()
}

/// Проверка, входит ли ip в allowlist.
pub fn ip_in_allowlist(ip: IpAddr, allow: &[IpNet]) -> bool {
    allow.iter().any(|net| net.contains(&ip))
}

/// IP клиента из X-Forwarded-For или ConnectInfo<SocketAddr>.
fn client_ip(req: &Request<Body>) -> Option<IpAddr> {
    // a) X-Forwarded-For: берём первый адрес
    if let Some(h) = req.headers().get("x-forwarded-for") {
        if let Ok(s) = h.to_str() {
            if let Some(first) = s.split(',').next() {
                if let Ok(ip) = first.trim().parse::<IpAddr>() {
                    return Some(ip);
                }
            }
        }
    }
    // b) ConnectInfo<SocketAddr> (Axum 0.7)
    if let Some(ci) = req.extensions().get::<axum::extract::ConnectInfo<SocketAddr>>() {
        return Some(ci.0.ip());
    }
    None
}

```

## FILE: /root/logos_lrb/node/src/JSON  (SKIPPED, empty)

## FILE: /root/logos_lrb/node/src/LE  (SKIPPED, empty)

## FILE: /root/logos_lrb/node/src/main.rs  (size=6999b)
```
use anyhow::Result;
use axum::{
    middleware::{from_fn_with_state},
    routing::{get, post},
    Router,
};
use bs58;
use ed25519_dalek::{SigningKey, VerifyingKey};
use once_cell::sync::OnceCell;
use std::{net::SocketAddr, sync::Arc, time::Duration};
use tower_http::{
    cors::CorsLayer, limit::RequestBodyLimitLayer, timeout::TimeoutLayer, trace::TraceLayer,
};
use tracing_subscriber::{fmt, EnvFilter};

use lrb_core::ledger::Ledger;
use lrb_core::rcp_engine::engine_with_channels;
use lrb_core::types::Rid;

mod admin;
mod api;
mod auth;
mod bridge;
mod fork;
mod guard;
mod metrics;
mod openapi;
mod peers;
mod state;
mod storage;
mod version;

use dashmap::DashMap;
use parking_lot::Mutex;

#[derive(Clone)]
pub struct AppState {
    pub signing: SigningKey,
    pub verifying: VerifyingKey,
    pub rid_b58: String,
    pub admin_key: String,
    pub bridge_key: String,
    pub ledger: Ledger,
    pub store: Arc<storage::Storage>,
    pub locks: Arc<DashMap<String, Arc<Mutex<()>>>>,
}

static APP_STATE: OnceCell<AppState> = OnceCell::new();

fn load_signing_key() -> Result<SigningKey> {
    use std::env;
    if let Ok(hex) = env::var("LRB_NODE_SK_HEX") {
        let bytes = hex::decode(hex.trim())?;
        let sk = SigningKey::from_bytes(
            bytes.as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    if let Ok(path) = env::var("LRB_NODE_SK_PATH") {
        let data = std::fs::read(path)?;
        let sk = SigningKey::from_bytes(
            data.as_slice()
                .try_into()
                .map_err(|_| anyhow::anyhow!("bad SK len"))?,
        );
        return Ok(sk);
    }
    anyhow::bail!("missing LRB_NODE_SK_HEX or LRB_NODE_SK_PATH");
}
fn rid_from_vk(vk: &VerifyingKey) -> String {
    bs58::encode(vk.as_bytes()).into_string()
}
fn read_env_required(n: &str) -> Result<String> {
    Ok(std::env::var(n).map_err(|_| anyhow::anyhow!(format!("missing env {}", n)))?)
}
fn guard_secret(name: &str, v: &str) -> Result<()> {
    let bad = ["CHANGE_ADMIN_KEY", "CHANGE_ME", "", "changeme", "default"];
    if bad.iter().any(|b| v.eq_ignore_ascii_case(b)) {
        anyhow::bail!("{} is default/empty; refuse to start", name);
    }
    Ok(())
}

#[tokio::main]
async fn main() -> Result<()> {
    // tracing
    let filter = EnvFilter::try_from_default_env()
        .unwrap_or_else(|_| EnvFilter::new("info,tower_http=info,axum=info"));
    fmt().with_env_filter(filter).init();

    // keys/ids
    let sk = load_signing_key()?;
    let vk = VerifyingKey::from(&sk);
    let rid_b58 = rid_from_vk(&vk);
    let admin_key = read_env_required("LRB_ADMIN_KEY")?;
    let bridge_key = read_env_required("LRB_BRIDGE_KEY")?;
    guard_secret("LRB_ADMIN_KEY", &admin_key)?;
    guard_secret("LRB_BRIDGE_KEY", &bridge_key)?;

    // state
    let data_dir = std::env::var("LRB_DATA_DIR").unwrap_or_else(|_| "/var/lib/logos".into());
    std::fs::create_dir_all(&data_dir).ok();
    let ledger = Ledger::open(&data_dir)?;
    let store = Arc::new(storage::Storage::open(format!("{}/node_state", data_dir))?);

    let app_state = AppState {
        signing: sk,
        verifying: vk,
        rid_b58: rid_b58.clone(),
        admin_key,
        bridge_key,
        ledger: ledger.clone(),
        store,
        locks: Arc::new(DashMap::new()),
    };
    APP_STATE.set(app_state.clone()).ok();

    // engine
    let rid = Rid(rid_b58.clone());
    let _engine = engine_with_channels(ledger, rid);

    // CORS
    let allowed_origin =
        std::env::var("LRB_WALLET_ORIGIN").unwrap_or_else(|_| "http://localhost".into());
    let cors = {
        let hv = allowed_origin
            .parse::<axum::http::HeaderValue>()
            .expect("bad LRB_WALLET_ORIGIN");
        CorsLayer::new()
            .allow_origin(hv)
            .allow_methods([axum::http::Method::GET, axum::http::Method::POST])
            .allow_headers([
                axum::http::header::CONTENT_TYPE,
                axum::http::header::AUTHORIZATION,
            ])
    };

    // Rate-limit (env)
    let qps: u64 = std::env::var("LRB_RATE_QPS").ok().and_then(|s| s.parse().ok()).unwrap_or(20);
    let burst: u64 = std::env::var("LRB_RATE_BURST").ok().and_then(|s| s.parse().ok()).unwrap_or(40);
    let rl_enabled = qps > 0 && burst > 0;
    let bypass_cidr = std::env::var("LRB_RATE_BYPASS_CIDR")
        .unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let bypass = Arc::new(guard::parse_ip_allowlist(&bypass_cidr));
    let rl = Arc::new(guard::RateLimiter::new(qps, burst, bypass.clone()));

    // Admin IP ACL
    let admin_allow =
        std::env::var("LRB_ADMIN_IP_ALLOW").unwrap_or_else(|_| "127.0.0.1/32,::1/128".into());
    let admin_nets = Arc::new(guard::parse_ip_allowlist(&admin_allow));

    // Public routes
    let public = Router::new()
        .route("/healthz", get(api::healthz))
        .route("/livez", get(api::livez))
        .route("/readyz", get(api::readyz))
        .route("/version", get(version::version))
        .route("/openapi.json", get(openapi::spec))
        .route("/metrics", get(metrics::metrics_handler))
        .route("/head", get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/history/:rid", get(api::history))
        .route("/block/:height", get(api::block))
        .route("/block/:height/mix", get(api::block_mix))
        .route("/economy", get(api::economy))
        .route("/submit_tx", post(api::submit_tx))
        .route("/submit_tx_batch", post(api::submit_tx_batch))
        .route("/debug_canon", post(api::debug_canon))
        .route("/faucet", post(api::faucet));

    // Admin routes
    let admin_routes = Router::new()
        .route("/admin/snapshot", post(admin::snapshot))
        .route("/admin/restore", post(admin::restore))
        .route("/node/info", get(admin::node_info))
        .layer(from_fn_with_state(admin_nets.clone(), guard::admin_ip_gate));

    // Bridge routes
    let bridge_routes = Router::new()
        .route("/bridge/deposit", post(bridge::deposit))
        .route("/bridge/redeem", post(bridge::redeem))
        .route("/bridge/verify", post(bridge::verify));

    // Build app
    let mut app = public
        .merge(admin_routes)
        .merge(bridge_routes)
        .with_state(app_state)
        .layer(cors)
        .layer(RequestBodyLimitLayer::new(512 * 1024))
        .layer(TimeoutLayer::new(Duration::from_secs(10)))
        .layer(TraceLayer::new_for_http());

    if rl_enabled {
        app = app.layer(from_fn_with_state(rl.clone(), guard::rate_limit_ip_gate));
    }

    // Start Axum 0.7
    let addr: SocketAddr = std::env::var("LRB_NODE_LISTEN")
        .unwrap_or_else(|_| "0.0.0.0:8080".into())
        .parse()?;
    let listener = tokio::net::TcpListener::bind(addr).await?;
    tracing::info!("logos_node listening on {} (RID={})", addr, rid_b58);
    axum::serve(listener, app.into_make_service()).await?;
    Ok(())
}

```

## FILE: /root/logos_lrb/node/src/metrics.rs  (size=2923b)
```
use axum::{
    http::StatusCode,
    response::{IntoResponse, Response},
};
use once_cell::sync::Lazy;
use prometheus::{
    histogram_opts, opts, register_histogram_vec_with_registry,
    register_int_counter_vec_with_registry, register_int_gauge_with_registry, Encoder,
    HistogramVec, IntCounterVec, IntGauge, Registry, TextEncoder,
};
use std::time::Instant;

pub static REGISTRY: Lazy<Registry> = Lazy::new(Registry::new);

pub static HTTP_REQ_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("http_requests_total", "Total HTTP requests"),
        &["endpoint", "method", "status"],
        &REGISTRY
    )
    .unwrap()
});
pub static HTTP_REQ_DUR: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec_with_registry!(
        histogram_opts!("http_request_duration_seconds", "HTTP duration").buckets(vec![
            0.001, 0.002, 0.005, 0.010, 0.020, 0.050, 0.100, 0.200, 0.500, 1.0, 2.0, 5.0
        ]),
        &["endpoint", "method"],
        &REGISTRY
    )
    .unwrap()
});
pub static INFLIGHT: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge_with_registry!(opts!("http_inflight_requests", "In-flight"), &REGISTRY)
        .unwrap()
});

// New app metrics
pub static HIST_TOTAL: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_history_requests_total", "History requests"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});
pub static BLOCKS_SERVED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec_with_registry!(
        opts!("lrb_blocks_served_total", "Blocks served"),
        &["status"],
        &REGISTRY
    )
    .unwrap()
});

pub struct Timer {
    start: Instant,
    endpoint: &'static str,
    method: &'static str,
}
impl Timer {
    pub fn new(endpoint: &'static str, method: &'static str) -> Self {
        INFLIGHT.inc();
        Self {
            start: Instant::now(),
            endpoint,
            method,
        }
    }
    pub fn observe(self) {
        let dt = self.start.elapsed().as_secs_f64();
        HTTP_REQ_DUR
            .with_label_values(&[self.endpoint, self.method])
            .observe(dt);
        INFLIGHT.dec();
    }
}
pub fn inc_total(endpoint: &'static str, method: &'static str, status: StatusCode) {
    HTTP_REQ_TOTAL
        .with_label_values(&[endpoint, method, status.as_str()])
        .inc();
}
pub async fn metrics_handler() -> Response {
    let mf = REGISTRY.gather();
    let mut buf = Vec::with_capacity(64 * 1024);
    let enc = TextEncoder::new();
    if let Err(e) = enc.encode(&mf, &mut buf) {
        return (
            StatusCode::INTERNAL_SERVER_ERROR,
            format!("encode error: {e}"),
        )
            .into_response();
    }
    (
        StatusCode::OK,
        [("Content-Type", enc.format_type().to_string())],
        buf,
    )
        .into_response()
}

```

## FILE: /root/logos_lrb/node/src/openapi.json  (size=6092b)
```
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB Node API", "version": "0.1.0" },
  "servers": [{ "url": "http://{host}", "variables": { "host": { "default": "localhost:8080" } } }],
  "paths": {
    "/healthz": { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/livez":   { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/readyz":  { "get": { "summary": "Readiness", "responses": { "200": { "description": "Ready" } } } },
    "/version": { "get": { "summary": "Build info", "responses": { "200": { "description": "JSON" } } } },
    "/metrics": { "get": { "summary": "Prometheus metrics", "responses": { "200": { "description": "text/plain" } } } },

    "/head": {
      "get": {
        "summary": "Chain head",
        "responses": {
          "200": { "description": "Height/finalized",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/HeadResp" },
            "examples": { "ok": { "value": { "height": 123, "finalized": false } } } } }
          }
        }
      }
    },

    "/balance/{rid}": {
      "get": {
        "summary": "Account state",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "Balance/nonce",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BalanceResp" },
            "examples": { "ok": { "value": { "rid": "A...Z", "balance": 1000000, "nonce": 5 } } } } }
          },
          "404": { "description": "Unknown RID" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "Submit batch of signed transactions",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/SubmitTxBatchReq" },
          "examples": { "one": { "value": { "txs": [
            { "from":"A...Z","to":"B...Y","amount":1234,"nonce":6,"sig_hex":"<ed25519 hex>" }
          ] } } } } } },
        "responses": {
          "200": { "description": "Accepted/rejected with details",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitTxBatchResp" },
            "examples": { "ok": { "value": {
              "accepted": 1, "rejected": 0, "new_height": 124,
              "results": [{ "idx": 0, "status": "accepted", "code": 0, "reason": "ok" }]
            } } } } } }
        }
      }
    },

    "/debug_canon": {
      "post": {
        "summary": "Canonical JSON for signing (server-side canonicalization)",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/DebugCanonReq" },
          "examples": { "tx": { "value": { "tx": { "from":"A...Z","to":"B...Y","amount":1,"nonce":1 } } } }
        } } },
        "responses": { "200": {
          "description": "Canon hex",
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DebugCanonResp" } } }
        } }
      }
    },

    "/faucet": {
      "post": {
        "summary": "DEV only. Mint LGN to RID",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/FaucetReq" }
        } } },
        "responses": {
          "200": { "description": "Granted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FaucetResp" } } } },
          "400": { "description": "Bad request" }
        }
      }
    }
  },

  "components": {
    "schemas": {
      "TxIn": {
        "type": "object",
        "required": ["from", "to", "amount", "nonce", "sig_hex"],
        "properties": {
          "from":   { "type": "string", "description": "RID (base58 pubkey)" },
          "to":     { "type": "string", "description": "RID (base58 pubkey)" },
          "amount": { "type": "integer", "format": "uint64", "minimum": 1 },
          "nonce":  { "type": "integer", "format": "uint64" },
          "sig_hex":{ "type": "string", "description": "Ed25519 signature hex over canonical bytes from /debug_canon" }
        }
      },

      "SubmitTxBatchReq": { "type": "object", "required": ["txs"], "properties": { "txs": { "type": "array", "minItems": 1, "items": { "$ref": "#/components/schemas/TxIn" } } } },

      "TxResult": {
        "type": "object",
        "required": ["idx", "status", "code", "reason"],
        "properties": {
          "idx":    { "type": "integer" },
          "status": { "type": "string", "enum": ["accepted", "rejected"] },
          "code":   { "type": "integer", "enum": [0, 400, 401, 402, 409] },
          "reason": { "type": "string", "enum": ["ok", "bad_rid", "bad_sig", "bad_canon", "bad_nonce", "insufficient_funds"] }
        }
      },

      "SubmitTxBatchResp": {
        "type": "object",
        "required": ["accepted", "rejected", "new_height", "results"],
        "properties": {
          "accepted":  { "type": "integer" },
          "rejected":  { "type": "integer" },
          "new_height":{ "type": "integer", "format": "uint64" },
          "results":   { "type": "array", "items": { "$ref": "#/components/schemas/TxResult" } }
        }
      },

      "HeadResp":   { "type": "object", "properties": { "height": { "type": "integer" }, "finalized": { "type": "boolean" } } },
      "BalanceResp":{ "type": "object", "properties": { "rid": { "type": "string" }, "balance": { "type": "integer" }, "nonce": { "type": "integer" } } },

      "DebugCanonReq":  { "type": "object", "properties": { "tx": { "type": "object" } } },
      "DebugCanonResp": { "type": "object", "required": ["canon_hex"], "properties": { "canon_hex": { "type": "string" } } },

      "FaucetReq":  { "type": "object", "required": ["rid", "amount"], "properties": { "rid": { "type": "string" }, "amount": { "type": "integer" } } },
      "FaucetResp": { "type": "object", "properties": { "granted": { "type": "integer" }, "rid": { "type": "string" } } }
    }
  }
}

```

## FILE: /root/logos_lrb/node/src/openapi.rs  (size=341b)
```
use axum::{response::IntoResponse, http::StatusCode};

pub async fn spec() -> impl IntoResponse {
    // Компилируем JSON внутрь бинаря — стабильность и скорость
    const SPEC: &str = include_str!("../openapi/openapi.json");
    (StatusCode::OK, [("Content-Type", "application/json")], SPEC)
}

```

## FILE: /root/logos_lrb/node/src/peers.rs  (size=4932b)
```
#![allow(dead_code)]
#![allow(dead_code)]
use std::time::{SystemTime, UNIX_EPOCH};
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_millis() as u128)
        .unwrap_or(0)
}

use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{
    collections::HashMap,
    sync::{Arc, Mutex},
    time::Duration,
};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self {
            last_seen_ms: now_ms(),
            score_milli: 0,
            fails: 0,
            dups: 0,
            banned_until_ms: 0,
        }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            policy,
        }
    }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> {
        self.inner.lock().unwrap()
    }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 {
            s.score_milli = 5000;
        }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli {
            s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
        }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk)
            .map(|s| now_ms() < s.banned_until_ms)
            .unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 {
                            s.score_milli = 0;
                        }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now {
                banned += 1;
            }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop {
            t.tick().await;
            book.tick();
        }
    });
}

```

## FILE: /root/logos_lrb/node/src/state.rs  (size=211b)
```
//! Reserved for future network helpers (kept minimal to avoid dead_code warnings).
//! Прод-уровень: пустой модуль без неиспользуемых структур и функций.

```

## FILE: /root/logos_lrb/node/src/storage.rs  (size=12406b)
```
//! Узловое persistent-хранилище (sled, один Tree "kv"):
//!   accounts/<RID>                  -> JSON {balance, nonce}
//!   chain/height                    -> LE u64
//!   blocks/<height:016x>            -> JSON BlockRecord {height, ts_ms, txs}
//!   history/<RID>/<nonce:016x>      -> JSON HistoryItem {nonce, from, to, amount, height, ts_ms}
//!   economy/minted                  -> LE u64
//!   economy/burned                  -> LE u64
//!   mix/<height:016x>               -> JSON MixRecord {height, ts_ms, deltas: [(rid, i128)]}
//!
//! Комиссии v2: LRB_FEE_PER_TX (u64, по умолчанию 0) списываются с отправителя, суммируются и сжигаются.
//! PhaseMix v1: если LRB_PHASEMIX_ENABLE=1 — формируем агрегат Δ по RID и сохраняем в mix/<height>.
//!              По умолчанию fee в Δ не учитывается (LRB_PHASEMIX_INCLUDE_FEE=0).

use anyhow::{anyhow, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Default, Serialize, Deserialize)]
pub struct AccountState {
    pub balance: u64,
    pub nonce: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct HistoryItem {
    pub nonce: u64,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub height: u64,
    pub ts_ms: u64,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct BlockRecord {
    pub height: u64,
    pub ts_ms: u64,
    pub txs: Vec<TxIn>,
}

#[derive(Clone, Serialize, Deserialize)]
pub struct MixRecord {
    pub height: u64,
    pub ts_ms: u64,
    pub deltas: Vec<(String, i128)>, // RID -> delta (i128 для симметрии)
}

pub struct Storage {
    db: sled::Db,
    kv: sled::Tree,
}

impl Storage {
    pub fn open<P: AsRef<std::path::Path>>(path: P) -> Result<Self> {
        std::fs::create_dir_all(&path).ok();
        let db = sled::open(path)?;
        let kv = db.open_tree("kv")?;
        let _ = kv.compare_and_swap(b"chain/height", None as Option<&[u8]>, Some(0u64.to_le_bytes().to_vec()))?;
        let _ = kv.compare_and_swap(b"economy/minted", None as Option<&[u8]>, Some(0u64.to_le_bytes().to_vec()))?;
        let _ = kv.compare_and_swap(b"economy/burned", None as Option<&[u8]>, Some(0u64.to_le_bytes().to_vec()))?;
        Ok(Self { db, kv })
    }

    #[inline] fn k_account(rid: &str) -> String { format!("accounts/{}", rid) }
    #[inline] fn k_block(height: u64) -> String { format!("blocks/{:016x}", height) }
    #[inline] fn k_hist(rid: &str, nonce: u64) -> String { format!("history/{}/{:016x}", rid, nonce) }
    #[inline] fn k_mix(height: u64) -> String { format!("mix/{:016x}", height) }

    #[inline] fn now_ms() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().as_millis() as u64
    }

    // ======== Economy helpers ========
    fn read_u64(&self, key: &[u8]) -> Result<u64> {
        if let Some(v) = self.kv.get(key)? {
            let mut arr = [0u8; 8]; arr.copy_from_slice(&v[..8.min(v.len())]); Ok(u64::from_le_bytes(arr))
        } else { Ok(0) }
    }
    fn write_u64(&self, key: &[u8], val: u64) -> Result<()> { self.kv.insert(key, val.to_le_bytes().to_vec())?; Ok(()) }

    fn cap_env() -> u64 { std::env::var("LRB_SUPPLY_CAP").ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(81_000_000) }
    fn fee_env() -> u64 { std::env::var("LRB_FEE_PER_TX").ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(0) }
    fn phasemix_enabled() -> bool { std::env::var("LRB_PHASEMIX_ENABLE").ok().as_deref() == Some("1") }
    fn phasemix_include_fee() -> bool { std::env::var("LRB_PHASEMIX_INCLUDE_FEE").ok().as_deref() == Some("1") }

    pub fn economy_snapshot(&self) -> Result<EconomySnapshot> {
        let minted = self.read_u64(b"economy/minted")?;
        let burned = self.read_u64(b"economy/burned")?;
        let cap = Self::cap_env();
        let supply = minted.saturating_sub(burned);
        Ok(EconomySnapshot { cap, minted, burned, supply })
    }

    pub fn try_mint_under_cap(&self, amt: u64) -> Result<u64> {
        let cap = Self::cap_env();
        let minted = self.read_u64(b"economy/minted")?;
        let burned = self.read_u64(b"economy/burned")?;
        let supply = minted.saturating_sub(burned);
        let new_supply = supply.checked_add(amt).ok_or_else(|| anyhow!("supply overflow"))?;
        if new_supply > cap { return Err(anyhow!("supply cap exceeded: new_supply={} cap={}", new_supply, cap)); }
        let new_minted = minted.checked_add(amt).ok_or_else(|| anyhow!("minted overflow"))?;
        self.write_u64(b"economy/minted", new_minted)?;
        self.db.flush()?; Ok(new_minted)
    }

    pub fn inc_burned(&self, amt: u64) -> Result<u64> {
        if amt == 0 { return Ok(self.read_u64(b"economy/burned")?); }
        let burned = self.read_u64(b"economy/burned")?;
        let new_burn = burned.checked_add(amt).ok_or_else(|| anyhow!("burn overflow"))?;
        self.write_u64(b"economy/burned", new_burn)?;
        self.db.flush()?; Ok(new_burn)
    }

    // ======== Accounts / Faucet / Blocks / History / Mix ========
    pub fn get_account(&self, rid: &str) -> Result<AccountState> {
        if let Some(v) = self.kv.get(Self::k_account(rid).as_bytes())? {
            let st: AccountState = serde_json::from_slice(&v)?; Ok(st)
        } else { Ok(AccountState::default()) }
    }

    pub fn faucet(&self, rid: &str, amount: u64) -> Result<AccountState> {
        if amount == 0 { return Err(anyhow!("amount must be > 0")); }
        let _ = self.try_mint_under_cap(amount)?;
        let mut st = self.get_account(rid)?; st.balance = st.balance.saturating_add(amount);
        self.kv.insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(&st)?)?;
        self.db.flush()?; Ok(st)
    }

    /// Применяем batch: учитываем комиссию, записываем блок/историю, формируем Mix (Δ по RID).
    pub fn apply_batch(&self, txs: &[TxIn]) -> Result<u64> {
        let fee = Self::fee_env();
        let include_fee_in_delta = Self::phasemix_include_fee();
        let mut total_fee: u64 = 0;

        let mut batch = sled::Batch::default();
        let mut acc_cache: HashMap<String, AccountState> = HashMap::new();
        let mut deltas: HashMap<String, i128> = HashMap::new(); // RID -> Δ

        for tx in txs {
            if tx.from == tx.to {
                // само-трансфер: только nonce (+ fee если задана)
                let mut from = acc_cache.remove(&tx.from).unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                // комиссию списываем
                if fee > 0 {
                    if from.balance < fee { continue; }
                    from.balance = from.balance.saturating_sub(fee);
                    total_fee = total_fee.saturating_add(fee);
                    if include_fee_in_delta { *deltas.entry(tx.from.clone()).or_default() -= fee as i128; }
                }
                from.nonce = from.nonce.saturating_add(1);
                acc_cache.insert(tx.from.clone(), from);
            } else {
                let mut from = acc_cache.remove(&tx.from).unwrap_or(self.get_account(&tx.from).unwrap_or_default());
                let mut to   = acc_cache.remove(&tx.to).unwrap_or(self.get_account(&tx.to).unwrap_or_default());
                let need = tx.amount.saturating_add(fee);
                if from.balance >= need {
                    from.balance = from.balance.saturating_sub(need);
                    to.balance   = to.balance.saturating_add(tx.amount);
                    from.nonce   = from.nonce.saturating_add(1);
                    // Δ (без fee по умолчанию)
                    *deltas.entry(tx.from.clone()).or_default() -= tx.amount as i128;
                    *deltas.entry(tx.to.clone()).or_default()   += tx.amount as i128;
                    if fee > 0 {
                        total_fee = total_fee.saturating_add(fee);
                        if include_fee_in_delta {
                            *deltas.entry(tx.from.clone()).or_default() -= fee as i128;
                        }
                    }
                } else {
                    // недостаточно средств — пропускаем tx
                    continue;
                }
                acc_cache.insert(tx.from.clone(), from);
                acc_cache.insert(tx.to.clone(),   to);
            }
        }

        for (rid, st) in acc_cache.iter() {
            batch.insert(Self::k_account(rid).as_bytes(), serde_json::to_vec(st)?);
        }

        let cur_h = self.get_height()?;
        let new_h = cur_h + 1;
        let ts_ms = Self::now_ms();

        let block = BlockRecord { height: new_h, ts_ms, txs: txs.to_vec() };
        batch.insert(b"chain/height", new_h.to_le_bytes().to_vec());
        batch.insert(Self::k_block(new_h).as_bytes(), serde_json::to_vec(&block)?);

        for tx in txs {
            let item = HistoryItem { nonce: tx.nonce, from: tx.from.clone(), to: tx.to.clone(), amount: tx.amount, height: new_h, ts_ms };
            batch.insert(Self::k_hist(&tx.from, tx.nonce).as_bytes(), serde_json::to_vec(&item)?);
            batch.insert(Self::k_hist(&tx.to,   tx.nonce).as_bytes(), serde_json::to_vec(&item)?);
        }

        // Сохраняем MixRecord, если включён PhaseMix
        if Self::phasemix_enabled() {
            let mut vec: Vec<(String,i128)> = deltas.into_iter().collect();
            // отбрасываем нулевые Δ и сортируем для стабильности
            vec.retain(|(_,d)| *d != 0);
            vec.sort_by(|a,b| a.0.cmp(&b.0));
            let mix = MixRecord { height: new_h, ts_ms, deltas: vec };
            batch.insert(Self::k_mix(new_h).as_bytes(), serde_json::to_vec(&mix)?);
        }

        self.kv.apply_batch(batch)?;
        self.db.flush()?;

        if total_fee > 0 { let _ = self.inc_burned(total_fee)?; }

        Ok(new_h)
    }

    pub fn get_height(&self) -> Result<u64> {
        if let Some(v) = self.kv.get(b"chain/height")? {
            let mut arr = [0u8; 8]; arr.copy_from_slice(&v[..8.min(v.len())]); Ok(u64::from_le_bytes(arr))
        } else { Ok(0) }
    }

    pub fn get_block(&self, height: u64) -> Result<Option<BlockRecord>> {
        Ok(self.kv.get(Self::k_block(height).as_bytes())?.map(|v| serde_json::from_slice::<BlockRecord>(&v)).transpose()?)
    }

    pub fn get_mix(&self, height: u64) -> Result<Option<MixRecord>> {
        Ok(self.kv.get(Self::k_mix(height).as_bytes())?.map(|v| serde_json::from_slice::<MixRecord>(&v)).transpose()?)
    }

    pub fn history_page(&self, rid: &str, from_nonce: u64, limit: usize) -> Result<(Vec<HistoryItem>, Option<u64>)> {
        let prefix = format!("history/{}/", rid);
        let start  = format!("{}{:016x}", prefix, from_nonce);
        let mut out = Vec::with_capacity(limit.min(1024));
        let mut last_nonce: Option<u64> = None;
        let mut iter = self.kv.range(start.as_bytes()..);
        while let Some(kv) = iter.next() {
            let (k, v) = kv?; if !k.starts_with(prefix.as_bytes()) { break; }
            let item: HistoryItem = serde_json::from_slice(&v)?; out.push(item.clone());
            last_nonce = Some(item.nonce); if out.len() >= limit { break; }
        }
        let next_from = if let Some(n) = last_nonce {
            let next_key = format!("{}{:016x}", prefix, n.saturating_add(1));
            if let Some(kv) = self.kv.range(next_key.as_bytes()..).next() {
                let (k, _) = kv?; if k.starts_with(prefix.as_bytes()) { Some(n.saturating_add(1)) } else { None }
            } else { None }
        } else { None };
        Ok((out, next_from))
    }

    pub fn history_from(&self, rid: &str, from_nonce: u64, limit: usize) -> Result<Vec<HistoryItem>> {
        Ok(self.history_page(rid, from_nonce, limit)?.0)
    }
}

#[derive(Clone, serde::Deserialize, serde::Serialize)]
pub struct TxIn {
    pub from: String,
    pub to: String,
    pub amount: u64,
    #[serde(default)]
    pub nonce: u64,
    #[serde(default)]
    pub sig_hex: String,
}

#[derive(Serialize)]
pub struct EconomySnapshot {
    pub cap: u64,
    pub minted: u64,
    pub burned: u64,
    pub supply: u64,
}

```

## FILE: /root/logos_lrb/node/src/version.rs  (size=520b)
```
use axum::Json;
use serde::Serialize;

#[derive(Serialize)]
pub struct VersionInfo {
    pub name: &'static str,
    pub version: &'static str,
    pub git_commit: &'static str,
    pub build_time_utc: &'static str,
    pub rustc: &'static str,
}

pub async fn version() -> Json<VersionInfo> {
    Json(VersionInfo {
        name: "logos_node",
        version: env!("CARGO_PKG_VERSION"),
        git_commit: env!("GIT_COMMIT"),
        build_time_utc: env!("BUILD_TIME_UTC"),
        rustc: env!("RUSTC_VER"),
    })
}

```

## FILE: /root/logos_lrb/README.md  (size=841b)
```
# LOGOS Resonance Blockchain — Monorepo

Состав:
- `lrb_core/`  — ядро (Rust)
- `node/`      — узел (Axum REST + gossip)
- `modules/`   — модульные компоненты
- `tools/`     — e2e и нагрузочные тесты (Go)
- `www/wallet/` — Web Wallet (MVP)
- `wallet-proxy/` — FastAPI proxy + scanner
- `infra/systemd`, `infra/nginx` — юниты/конфиги (без секретов)
- `configs/*.example` — примеры окружения

## Быстрый старт
1) Rust/Go/Python3.12
2) `cargo build --release -p logos_node`
3) Настрой ENV по `configs/keys.env.example` (секреты не коммить)
4) Подними systemd-юниты из `infra/systemd` (редактируй пути/ENV)
5) Nginx-site из `infra/nginx/lrb_wallet.conf` (wallet + proxy)

```

## FILE: /root/logos_lrb/scripts/bootstrap_node.sh  (size=1556b)
```
#!/usr/bin/env bash
set -euo pipefail
DOMAIN="${DOMAIN:-example.com}"
INSTANCE="${INSTANCE:-a}"

sudo apt-get update -y
sudo apt-get install -y git curl jq build-essential pkg-config libssl-dev nginx

/usr/bin/id logos >/dev/null 2>&1 || sudo useradd -r -m -d /var/lib/logos -s /usr/sbin/nologin logos
sudo mkdir -p /opt/logos /etc/logos /var/lib/logos /opt/logos/www/wallet

cd "$(dirname "$0")/.."
cargo build --release -p logos_node
sudo cp ./target/release/logos_node /opt/logos/logos_node
sudo chown logos:logos /opt/logos/logos_node
sudo chmod 755 /opt/logos/logos_node

sudo cp ./infra/systemd/logos-node@.service /etc/systemd/system/logos-node@.service
sudo systemctl daemon-reload

sudo cp ./infra/nginx/logos-api-lb.conf.example /etc/nginx/sites-available/logos-api-lb.conf
sudo sed -i "s/YOUR_DOMAIN/${DOMAIN}/" /etc/nginx/sites-available/logos-api-lb.conf
sudo ln -sf /etc/nginx/sites-available/logos-api-lb.conf /etc/nginx/sites-enabled/logos-api-lb.conf
sudo rm -f /etc/nginx/sites-enabled/default
sudo nginx -t && sudo systemctl reload nginx

sudo cp -r ./www/wallet/* /opt/logos/www/wallet/
sudo chown -R logos:logos /opt/logos/www

if [ ! -f "/etc/logos/node-${INSTANCE}.env" ]; then
  sudo cp ./configs/env/node.env.example "/etc/logos/node-${INSTANCE}.env"
  echo ">>> EDIT /etc/logos/node-${INSTANCE}.env (LRB_NODE_SK_HEX/LRB_ADMIN_KEY/LRB_WALLET_ORIGIN)"
fi

sudo systemctl enable --now "logos-node@${INSTANCE}"
systemctl --no-pager status "logos-node@${INSTANCE}"

echo "API: http://127.0.0.1:8080   Wallet: http://${DOMAIN}/wallet/"

```

## FILE: /root/logos_lrb/scripts/collect_and_push.sh  (size=3118b)
```
#!/usr/bin/env bash
set -euo pipefail
REPO_ROOT="/root/logos_lrb"
GIT_REMOTE="${GIT_REMOTE:-origin}"
GIT_BRANCH="${GIT_BRANCH:-main}"
INCLUDE_SNAPSHOT="${INCLUDE_SNAPSHOT:-0}"

echo "[i] collecting from live system → $REPO_ROOT"
cd "$REPO_ROOT"

# .gitignore (если нет)
[ -f .gitignore ] || cat > .gitignore <<'EOF'
target/
**/target/
node_modules/
dist/
.DS_Store
*.swp
*.swo
/etc/logos/*.env
*.pem
*.key
*.crt
*.p12
/var/lib/logos/
/var/run/logos_health.json
/usr/local/bin/lrb_bench*
/usr/local/bin/logos_healthcheck.sh
/etc/letsencrypt/
*.log
/var/log/nginx/*.log
www/wallet/*.map
tools/**/go/bin/
EOF

# каталоги в репо
mkdir -p configs/env infra/systemd infra/nginx scripts tools/bench/go www/wallet docs

# wallet → www/wallet
if [ -d /opt/logos/www/wallet ]; then
  rsync -a --delete /opt/logos/www/wallet/ www/wallet/
  echo "[i] wallet synced"
fi

# systemd → infra/systemd
[ -f /etc/systemd/system/logos-node@.service ]       && cp -f /etc/systemd/system/logos-node@.service        infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.service ] && cp -f /etc/systemd/system/logos-healthcheck.service   infra/systemd/
[ -f /etc/systemd/system/logos-healthcheck.timer ]   && cp -f /etc/systemd/system/logos-healthcheck.timer     infra/systemd/

# nginx → infra/nginx (example)
[ -f /etc/nginx/sites-available/logos-api-lb.conf ] && cp -f /etc/nginx/sites-available/logos-api-lb.conf infra/nginx/logos-api-lb.conf.example

# healthcheck → scripts (если установлен в /usr/local/bin)
if [ -f /usr/local/bin/logos_healthcheck.sh ]; then
  cp -f /usr/local/bin/logos_healthcheck.sh scripts/logos_healthcheck.sh
  chmod +x scripts/logos_healthcheck.sh
fi

# env → *.example (обезличиваем секреты)
mkdir -p configs/env
shopt -s nullglob
for f in /etc/logos/node-*.env; do
  bn="$(basename "$f")"
  sed -E \
    -e 's/^(LRB_NODE_SK_HEX)=.*/\1=CHANGE_ME_64_HEX/' \
    -e 's/^(LRB_ADMIN_KEY)=.*/\1=CHANGE_ADMIN_KEY/' \
    -e 's/^(LRB_BRIDGE_KEY)=.*/\1=CHANGE_ME/' \
    "$f" > "configs/env/${bn}.example"
  echo "[i] env example: configs/env/${bn}.example"
done
# общий пример, если ничего не найдено
if [ -z "$(ls -1 configs/env/*.example 2>/dev/null || true)" ]; then
cat > configs/env/node.env.example <<'EEX'
LRB_NODE_SK_HEX=CHANGE_ME_64_HEX
LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
LRB_BRIDGE_KEY=CHANGE_ME
LRB_DATA_DIR=/var/lib/logos
LRB_NODE_LISTEN=0.0.0.0:8080
LRB_WALLET_ORIGIN=http://localhost
LRB_RATE_QPS=20
LRB_RATE_BURST=40
LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128
LRB_ENABLE_FAUCET=0
LRB_ADMIN_IP_ALLOW=127.0.0.1/32,::1/128
EEX
fi

# snapshots (опционально)
if [ "${INCLUDE_SNAPSHOT}" = "1" ]; then
  mkdir -p snapshots
  cp -f /root/logos_snapshot/*.txt snapshots/ 2>/dev/null || true
fi

# git add/commit/push
git add -A
if ! git diff --cached --quiet; then
  git commit -m "sync(live): full system snapshot (code+infra+wallet+scripts), env → *.example"
else
  echo "[i] nothing to commit"
fi

# пуш
git push "${GIT_REMOTE}" "${GIT_BRANCH}"
echo "[✓] pushed to ${GIT_REMOTE}/${GIT_BRANCH}"

```

## FILE: /root/logos_lrb/scripts/logos_healthcheck.sh  (size=1689b)
```
#!/usr/bin/env bash
set -euo pipefail

BASE="${BASE:-http://127.0.0.1:8080}"
STATE_FILE="/var/run/logos_health.json"
TMP="$(mktemp)"; trap 'rm -f "$TMP"' EXIT

# Метрика: время ответа healthz
START=$(date +%s%3N)
if ! curl -sf "$BASE/healthz" -o "$TMP" >/dev/null; then
  MSG="LOGOS: /healthz FAIL at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  [ -n "${TG_TOKEN:-}" ] && curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
     -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  exit 1
fi
RT=$(( $(date +%s%3N) - START ))

# Высота
HEAD_JSON=$(curl -sf "$BASE/head")
HEIGHT=$(echo "$HEAD_JSON" | jq -r '.height' 2>/dev/null || echo 0)

LAST_H=0
LAST_TS=0
if [ -f "$STATE_FILE" ]; then
  LAST_H=$(jq -r '.height // 0' "$STATE_FILE" 2>/dev/null || echo 0)
  LAST_TS=$(jq -r '.ts_ms // 0' "$STATE_FILE" 2>/dev/null || echo 0)
fi

TS_MS=$(date +%s%3N)
printf '{"ts_ms":%s,"height":%s,"rt_ms":%s}\n' "$TS_MS" "$HEIGHT" "$RT" > "$STATE_FILE"

# Правила алертов
ALERT=""
[ "$RT" -gt 1500 ] && ALERT="slow healthz: ${RT}ms"
if [ -n "$LAST_TS" ] && [ $((TS_MS - LAST_TS)) -gt 300000 ]; then
  # если 5 минут прошло и высота не менялась (и была >0)
  if [ "$HEIGHT" -eq "$LAST_H" ] && [ "$HEIGHT" -gt 0 ]; then
    ALERT="${ALERT} height stuck at ${HEIGHT}"
  fi
fi

if [ -n "$ALERT" ]; then
  MSG="LOGOS ALERT: ${ALERT} at $(date -u +%FT%TZ)"
  logger -t logos_health "$MSG"
  if [ -n "${TG_TOKEN:-}" ] && [ -n "${TG_CHAT_ID:-}" ]; then
    curl -s "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
       -d chat_id="${TG_CHAT_ID}" -d text="$MSG" >/dev/null || true
  fi
fi

exit 0

```

## FILE: /root/logos_lrb/src/bin/ai_signal_listener.rs  (size=8704b)
```

// LOGOS AI Signal Listener — приём внешних импульсов
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};
use serde_json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncomingSignal {
    pub source: String,
    pub symbol: String,
    pub intensity: f64,
    pub frequency: f64,
    pub timestamp: u64,
}

pub struct AISignalListener {
    pub accepted_symbols: HashSet<String>,
    pub last_received: Arc<Mutex<HashMap<String, u64>>>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub nonce_source: SystemRandom,
    pub min_interval: u64,
    pub lambda_zero: String,
}

impl AISignalListener {
    pub fn new() -> Self {
        let mut key = vec![0u8; 32];
        let rng = SystemRandom::new();
        rng.fill(&mut key).unwrap();

        let mut accepted = HashSet::new();
        accepted.insert("Λ0".to_string());
        accepted.insert("☉".to_string());
        accepted.insert("??".to_string());
        accepted.insert("♁".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("∞".to_string());

        AISignalListener {
            accepted_symbols: accepted,
            last_received: Arc::new(Mutex::new(HashMap::new())),
            log_file: "ai_signal_log.enc".to_string(),
            state_file: "ai_signal_state.enc".to_string(),
            cipher_key: key,
            nonce_source: rng,
            min_interval: 1, // 1 секунда
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn validate_signal(&self, signal: &IncomingSignal) -> bool {
        !signal.source.is_empty() &&
        self.accepted_symbols.contains(&signal.symbol) &&
        (0.0..=1.0).contains(&signal.intensity) &&
        (0.1..=10000.0).contains(&signal.frequency) &&
        signal.timestamp > 0
    }

    pub fn handle(&self, signal: IncomingSignal) -> bool {
        let now = Self::now();

        // Проверка частоты приёма
        let mut last = self.last_received.lock().unwrap();
        let last_time = last.get(&signal.source).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval
        };
        if now - last_time < adjusted_interval {
            self.log(&format!("[DROP] Слишком частый сигнал от {}", signal.source));
            return false;
        }

        // Валидация сигнала
        if !self.validate_signal(&signal) {
            self.log(&format!("[DROP] Неверный сигнал от {}: symbol={}, intensity={:.2}, freq={:.2}",
                signal.source, signal.symbol, signal.intensity, signal.frequency));
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&signal) {
            self.log(&format!("[DROP] Analyzer отклонил сигнал от {}", signal.source));
            return false;
        }

        last.insert(signal.source.clone(), now);
        self.save_state();
        self.log_signal(&signal);
        true
    }

    fn validate_with_analyzer(&self, signal: &IncomingSignal) -> bool {
        // Заглушка для resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn log_signal(&self, signal: &IncomingSignal) {
        let json = serde_json::to_string(signal).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = json.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn log(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"ai_signal_listener\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = entry.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&*self.last_received.lock().unwrap()).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = state.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).write(true).truncate(true).open(&self.state_file) {
            let _ = file.write_all(&data);
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    println!("[AI_SIGNAL] Запуск на 0.0.0.0:38500");
    let listener = TcpListener::bind("0.0.0.0:38500").expect("Не удалось открыть порт");
    listener.set_nonblocking(true).unwrap();
    let handler = Arc::new(AISignalListener::new());
    let shared = Arc::clone(&handler);

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                match stream.read(&mut buf) {
                    Ok(size) => {
                        let input = match std::str::from_utf8(&buf[..size]) {
                            Ok(s) => s,
                            Err(e) => {
                                shared.log(&format!("[ERR] Неверный UTF-8: {}", e));
                                let _ = stream.write_all(b"INVALID");
                                continue;
                            }
                        };
                        let parts: Vec<&str> = input.trim().split(',').collect();
                        if parts.len() == 4 {
                            let source = parts[0].to_string();
                            let symbol = parts[1].to_string();
                            let intensity = parts[2].parse::<f64>().unwrap_or(0.0);
                            let frequency = parts[3].parse::<f64>().unwrap_or(0.0);
                            let signal = IncomingSignal {
                                source,
                                symbol,
                                intensity,
                                frequency,
                                timestamp: AISignalListener::now(),
                            };
                            let accepted = shared.handle(signal);
                            let _ = stream.write_all(if accepted { b"OK" } else { b"REJECT" });
                        } else {
                            shared.log("[ERR] Неверный формат запроса");
                            let _ = stream.write_all(b"INVALID");
                        }
                    }
                    Err(e) => {
                        shared.log(&format!("[ERR] Ошибка чтения: {}", e));
                        let _ = stream.write_all(b"ERROR");
                    }
                }
            }
            Err(_) => {
                thread::sleep(Duration::from_millis(50));
            }
        }
    }
}


```

## FILE: /root/logos_lrb/src/bin/orchestration_control.rs  (size=6987b)
```
rust
// LOGOS Orchestration Control — центральный контрольный контур LOGOS
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::fs::OpenOptions;
use std::io::Write;
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use crate::sigma_t::calculate_sigma;

pub struct OrchestrationControl {
    pub module_status: HashMap<String, bool>,
    pub valid_modules: HashSet<String>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub restart_threshold: f64,
    pub lambda_zero: String,
    pub restart_timestamps: HashMap<String, u64>, // module -> last restart time
    pub min_restart_interval: u64,
}

impl OrchestrationControl {
    pub fn new() -> Self {
        let mut valid_modules = HashSet::new();
        valid_modules.insert("rcp_engine".to_string());
        valid_modules.insert("resonance_mesh".to_string());
        valid_modules.insert("resonance_sync".to_string());
        valid_modules.insert("ai_signal_listener".to_string());
        valid_modules.insert("uplink_controller".to_string());
        valid_modules.insert("uplink_router".to_string());

        OrchestrationControl {
            module_status: HashMap::new(),
            valid_modules,
            log_file: "orchestration_log.json".to_string(),
            state_file: "orchestration_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            restart_threshold: 0.7,
            lambda_zero: "Λ0".to_string(),
            restart_timestamps: HashMap::new(),
            min_restart_interval: 60, // 1 минута
        }
    }

    pub fn monitor(&mut self) {
        let modules = vec![
            "rcp_engine",
            "resonance_mesh",
            "resonance_sync",
            "ai_signal_listener",
            "uplink_controller",
            "uplink_router",
        ];

        for m in &modules {
            if self.valid_modules.contains(*m) {
                self.module_status.insert(m.to_string(), true);
            }
        }

        loop {
            for (module, status) in self.module_status.clone() {
                if !self.valid_modules.contains(&module) {
                    self.log_event(&format!("[ERROR] Недопустимый модуль: {}", module));
                    continue;
                }

                if !self.health_check(&module) {
                    self.module_status.insert(module.clone(), false);
                    self.restart_module(&module);
                } else {
                    self.module_status.insert(module.clone(), true);
                }
            }

            let t = Self::now() as f64;
            let sigma = calculate_sigma(t);
            if Self::is_resonance_unstable(&sigma, self.restart_threshold) {
                self.log_event(&format!("[ALERT] Нестабильность Σ(t): {:?}", sigma));
                // Проверка через resonance_analyzer (заглушка)
                if !self.validate_with_analyzer(&sigma) {
                    self.log_event("[ALERT] Analyzer отклонил Σ(t), требуется вмешательство");
                }
            }

            self.save_state();
            thread::sleep(Duration::from_secs(10));
        }
    }

    fn validate_with_analyzer(&self, sigma: &Vec<f64>) -> bool {
        // Заглушка для resonance_analyzer.py
        sigma.iter().all(|&f| f.abs() <= 1.0)
    }

    fn health_check(&self, module: &str) -> bool {
        let output = Command::new("pgrep")
            .arg(module)
            .stdout(Stdio::null())
            .status();

        let is_alive = output.map(|s| s.success()).unwrap_or(false);
        if !is_alive {
            self.log_event(&format!("[FAIL] {} не отвечает", module));
        }
        is_alive
    }

    fn restart_module(&self, module: &str) -> bool {
        let now = Self::now();
        let last_restart = self.restart_timestamps.get(module).cloned().unwrap_or(0);
        let adjusted_interval = if module == "rcp_engine" { // Приоритет для Λ0-ассоциированного модуля
            self.min_restart_interval / 2
        } else {
            self.min_restart_interval
        };

        if now - last_restart < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частый перезапуск {}", module));
            return false;
        }

        let restart_cmd = format!("./restart_{}.sh", module);
        let status = Command::new("sh")
            .arg("-c")
            .arg(&restart_cmd)
            .spawn();

        if status.is_ok() {
            let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
            mutable_self.restart_timestamps.insert(module.to_string(), now);
            self.log_event(&format!("[RESTART] Перезапуск {}", module));
            true
        } else {
            self.log_event(&format!("[ERROR] Ошибка перезапуска {}", module));
            false
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.module_status).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let timestamp = Self::now();
        let entry = format!(
            "{{\"event\":\"orchestration\",\"timestamp\":{},\"msg\":\"{}\"}}",
            timestamp, msg
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    fn is_resonance_unstable(sigma: &Vec<f64>, threshold: f64) -> bool {
        sigma.iter().any(|&f| f.abs() > threshold)
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/bin/rcp_engine.rs  (size=4122b)
```
// LOGOS Resonance Consensus Protocol (RCP)
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Debug)]
pub struct PhaseSignal {
    pub sender: String,
    pub frequency: f64,
    pub phase: f64,
    pub symbol: String,
    pub timestamp: u64,
}

pub struct RcpEngine {
    pub known_nodes: HashSet<String>,
    pub phase_buffer: Vec<PhaseSignal>,
    pub phase_tolerance: f64,
    pub symbol_set: HashSet<String>,
    pub sender_rate: HashMap<String, u32>,
    pub lambda_zero: String,
}

impl RcpEngine {
    pub fn new() -> Self {
        let mut symbol_set = HashSet::new();
        // Добавляем допустимые символы
        symbol_set.insert("☉".to_string());
        symbol_set.insert("??".to_string());
        symbol_set.insert("♁".to_string());
        symbol_set.insert("☿".to_string());
        symbol_set.insert("Λ0".to_string());

        RcpEngine {
            known_nodes: HashSet::new(),
            phase_buffer: Vec::new(),
            phase_tolerance: 0.03,
            symbol_set,
            sender_rate: HashMap::new(),
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn register_node(&mut self, rid: String) {
        self.known_nodes.insert(rid.clone());
        self.sender_rate.insert(rid, 0);
    }

    pub fn submit_phase(&mut self, signal: PhaseSignal) -> bool {
        // Проверка существования узла
        if !self.known_nodes.contains(&signal.sender) {
            return false;
        }

        // Проверка валидности символа
        if !self.validate_symbol(&signal.symbol) {
            return false;
        }

        // Проверка соответствия Λ0
        if !self.check_lambda_zero(&signal) {
            return false;
        }

        // Защита от спама: не более 10 сигналов в секунду от одного RID
        let rate = self.sender_rate.entry(signal.sender.clone()).or_insert(0);
        *rate += 1;
        if *rate > 10 {
            return false;
        }

        // Проверка фазы
        let consensus_phase = self.compute_consensus_phase(signal.frequency);
        if (signal.phase - consensus_phase).abs() < self.phase_tolerance {
            self.phase_buffer.push(signal);
            self.log_phase(&self.phase_buffer.last().unwrap());
            true
        } else {
            false
        }
    }

    fn validate_symbol(&self, symbol: &str) -> bool {
        self.symbol_set.contains(symbol)
    }

    fn check_lambda_zero(&self, signal: &PhaseSignal) -> bool {
        // Проверяем, что символ или частота связаны с Λ0
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.001
    }

    fn compute_consensus_phase(&self, frequency: f64) -> f64 {
        let filtered: Vec<&PhaseSignal> = self.phase_buffer.iter()
            .filter(|s| (s.frequency - frequency).abs() < 0.001)
            .collect();

        if filtered.is_empty() {
            return 0.0;
        }

        let sum_phase: f64 = filtered.iter().map(|s| s.phase).sum();
        sum_phase / (filtered.len() as f64)
    }

    pub fn clear_old_signals(&mut self) {
        let now = Self::time_now();
        self.phase_buffer.retain(|s| now - s.timestamp < 10);
        // Сбрасываем счетчики спама каждые 10 секунд
        for rate in self.sender_rate.values_mut() {
            *rate = 0;
        }
    }

    fn log_phase(&self, signal: &PhaseSignal) {
        // Логирование фазы для анализа (вывод в resonance_analyzer.py)
        println!(
            "Phase logged: RID={}, Symbol={}, Freq={}, Phase={}, Time={}",
            signal.sender, signal.symbol, signal.frequency, signal.phase, signal.timestamp
        );
    }

    pub fn time_now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("rcp_engine запущен");
}

```

## FILE: /root/logos_lrb/src/bin/resonance_mesh.rs  (size=8051b)
```
rust
// LOGOS Resonance Mesh — Local Node-to-Node Resonance Sync
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{SocketAddr, UdpSocket};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use std::io::Write;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeshSignal {
    pub node_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub symbol: String, // Для Λ0 и других символов
}

pub struct ResonanceMesh {
    pub mesh_socket: UdpSocket,
    pub known_nodes: Arc<Mutex<HashSet<SocketAddr>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub broadcast_timestamps: Arc<Mutex<HashMap<String, u64>>>, // node_id -> last broadcast
    pub min_broadcast_interval: u64,
}

impl ResonanceMesh {
    pub fn new(bind_addr: &str) -> Self {
        let socket = UdpSocket::bind(bind_addr).expect("Не удалось привязать сокет");
        socket.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceMesh {
            mesh_socket: socket,
            known_nodes: Arc::new(Mutex::new(HashSet::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])), // f₁, f₂, f₃
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_mesh_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            broadcast_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_broadcast_interval: 1, // 1 секунда
        }
    }

    pub fn validate_node_id(&self, node_id: &str, symbol: &str) -> bool {
        !node_id.is_empty() &&
        node_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn broadcast_phase(&self, node_id: &str, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты вещания
        let mut timestamps = self.broadcast_timestamps.lock().unwrap();
        let last_broadcast = timestamps.get(node_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_broadcast_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_broadcast_interval
        };
        if now - last_broadcast < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частое вещание от {}", node_id));
            return false;
        }

        // Валидация
        if !self.validate_node_id(node_id, symbol) {
            self.log_event(&format!("[DROP] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        let timestamp = now;
        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let signal = MeshSignal {
            node_id: node_id.to_string(),
            timestamp,
            phase_vector,
            symbol: symbol.to_string(),
        };

        let packet = serde_json::to_vec(&signal).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted_packet = packet.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted_packet).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования сигнала для {}", node_id));
            return false;
        }

        let nodes = self.known_nodes.lock().unwrap();
        for addr in nodes.iter() {
            let _ = self.mesh_socket.send_to(&encrypted_packet, addr);
        }

        timestamps.insert(node_id.to_string(), now);
        self.log_event(&format!("[BROADCAST] Фаза отправлена от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn listen(&self) {
        let socket = self.mesh_socket.try_clone().unwrap();
        let local_phase = Arc::clone(&self.local_phase);
        let known_nodes = Arc::clone(&self.known_nodes);

        thread::spawn(move || {
            let mut buf = [0u8; 1024];
            loop {
                match socket.recv_from(&mut buf) {
                    Ok((size, src)) => {
                        let data = &buf[..size];
                        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
                        let mut aead = key.bind::<AES_256_GCM>();
                        let mut decrypted_data = data.to_vec();
                        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut decrypted_data) {
                            if let Ok(signal) = serde_json::from_slice::<MeshSignal>(decrypted) {
                                let mut nodes = known_nodes.lock().unwrap();
                                nodes.insert(src);

                                let mut phase = local_phase.lock().unwrap();
                                let weight = if signal.symbol == "Λ0" { 1.2 } else { 1.0 }; // Приоритет Λ0
                                for i in 0..phase.len().min(signal.phase_vector.len()) {
                                    phase[i] = (phase[i] + signal.phase_vector[i] * weight) / (1.0 + weight);
                                }
                            } else {
                                println!("[ERR] Ошибка десериализации сигнала");
                            }
                        } else {
                            println!("[ERR] Ошибка расшифровки сигнала");
                        }
                    }
                    Err(_) => {
                        thread::sleep(Duration::from_millis(50));
                    }
                }
            }
        });
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_mesh\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/bin/resonance_sync.rs  (size=11282b)
```
rust
// LOGOS Resonance Sync — удалённая синхронизация фаз Σ(t)
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;
use std::io::{Read, Write};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePhasePacket {
    pub source_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub trust_score: f64,
    pub symbol: String, // Для связи с Λ0
}

pub struct ResonanceSync {
    pub listener: TcpListener,
    pub known_sources: Arc<Mutex<HashMap<String, f64>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub send_timestamps: Arc<Mutex<HashMap<String, u64>>>, // source_id -> last send time
    pub min_send_interval: u64,
}

impl ResonanceSync {
    pub fn new(bind_addr: &str) -> Self {
        let listener = TcpListener::bind(bind_addr).expect("Не удалось привязать порт TCP");
        listener.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceSync {
            listener,
            known_sources: Arc::new(Mutex::new(HashMap::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_sync_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            send_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_send_interval: 1, // 1 секунда
        }
    }

    pub fn validate_source_id(&self, source_id: &str, symbol: &str) -> bool {
        !source_id.is_empty() &&
        source_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol) &&
        (0.0..=1.0).contains(&self.known_sources.lock().unwrap().get(source_id).cloned().unwrap_or(0.5))
    }

    pub fn start_listening(&self) {
        let listener = self.listener.try_clone().unwrap();
        let known_sources = Arc::clone(&self.known_sources);
        let local_phase = Arc::clone(&self.local_phase);
        let valid_symbols = self.valid_symbols.clone();
        let lambda_zero = self.lambda_zero.clone();
        let log_file = self.log_file.clone();
        let cipher_key = self.cipher_key.clone();

        thread::spawn(move || {
            let mut buf = [0u8; 512];
            loop {
                match listener.incoming() {
                    Ok(stream) => match stream {
                        Ok(mut stream) => {
                            if let Ok(size) = stream.read(&mut buf) {
                                let data = &buf[..size];
                                let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                                let key = UnboundKey::new(&AES_256_GCM, &cipher_key).unwrap();
                                let mut aead = key.bind::<AES_256_GCM>();
                                let mut decrypted = data.to_vec();
                                if let Ok(decrypted_data) = aead.open_in_place(nonce, &[], &mut decrypted) {
                                    if let Ok(packet) = serde_json::from_slice::<RemotePhasePacket>(decrypted_data) {
                                        let mut sources = known_sources.lock().unwrap();
                                        let trust = sources.get(&packet.source_id).cloned().unwrap_or(0.5);
                                        if trust < 0.3 || !valid_symbols.contains(&packet.symbol) {
                                            Self::log_event_static(&log_file, &cipher_key, 
                                                &format!("[DROP] Низкое доверие или неверный символ: {}, trust={:.2}", 
                                                    packet.source_id, trust));
                                            continue;
                                        }

                                        let mut phase = local_phase.lock().unwrap();
                                        let weight = if packet.symbol == lambda_zero { 1.2 } else { 1.0 }; // Приоритет Λ0
                                        for i in 0..phase.len().min(packet.phase_vector.len()) {
                                            phase[i] = (phase[i] + packet.phase_vector[i] * trust * weight) / (1.0 + trust * weight);
                                        }
                                        Self::log_event_static(&log_file, &cipher_key, 
                                            &format!("[RECEIVE] Фаза от {} (symbol: {}, trust: {:.2})", 
                                                packet.source_id, packet.symbol, trust));
                                    } else {
                                        Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка десериализации пакета");
                                    }
                                } else {
                                    Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка расшифровки пакета");
                                }
                            }
                        }
                        Err(_) => {
                            thread::sleep(Duration::from_millis(100));
                        }
                    },
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }

    pub fn send_phase(&self, addr: &str, source_id: &str, trust_score: f64, symbol: &str) -> bool {
        let now = Self::now();

        // Проверка частоты отправки
        let mut timestamps = self.send_timestamps.lock().unwrap();
        let last_send = timestamps.get(source_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero { self.min_send_interval / 2 } else { self.min_send_interval };
        if now - last_send < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частая отправка от {}", source_id));
            return false;
        }

        // Валидация
        if !self.validate_source_id(source_id, symbol) || !(0.0..=1.0).contains(&trust_score) {
            self.log_event(&format!("[DROP] Недопустимый source_id или символ: {}, trust={:.2}", source_id, trust_score));
            return false;
        }

        let mut stream = match TcpStream::connect(addr) {
            Ok(s) => s,
            Err(e) => {
                self.log_event(&format!("[ERR] Не удалось подключиться к {}: {}", addr, e));
                return false;
            }
        };

        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let packet = RemotePhasePacket {
            source_id: source_id.to_string(),
            timestamp: now,
            phase_vector,
            trust_score,
            symbol: symbol.to_string(),
        };

        let encoded = serde_json::to_vec(&packet).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted = encoded.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования пакета для {}", source_id));
            return false;
        }

        if stream.write_all(&encrypted).is_ok() {
            timestamps.insert(source_id.to_string(), now);
            self.log_event(&format!("[SEND] Фаза отправлена {} (symbol: {}, trust: {:.2})", source_id, symbol, trust_score));
            true
        } else {
            self.log_event(&format!("[ERR] Ошибка отправки фазы для {}", source_id));
            false
        }
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    pub fn set_trust(&self, source_id: &str, score: f64) {
        let mut sources = self.known_sources.lock().unwrap();
        sources.insert(source_id.to_string(), score.clamp(0.0, 1.0));
        self.log_event(&format!("[TRUST] Установлен trust_score={:.2} для {}", score, source_id));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event_static(log_file: &str, cipher_key: &[u8], message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/bin/sigma_t.rs  (size=3522b)
```

// LOGOS Sigma T — вычисление резонансной суммы Σ(t)
// Автор: LOGOS Core Dev Team

use std::f64::consts::PI;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

pub struct SigmaT {
    pub frequencies: Vec<f64>,
    pub amplitudes: Vec<f64>,
    pub lambda_zero: String,
    pub network_activity: f64,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl SigmaT {
    pub fn new() -> Self {
        SigmaT {
            frequencies: vec![7.83, 1.618, 432.0, 864.0, 3456.0], // Шуман, золотое сечение, гармоники
            amplitudes: vec![1.0, 0.8, 0.5, 0.3, 0.1], // Базовые амплитуды
            lambda_zero: "Λ0".to_string(),
            network_activity: 1.0,
            log_file: "sigma_t_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_frequencies(&self) -> bool {
        self.frequencies.iter().all(|&f| (0.1..=10000.0).contains(&f))
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        self.network_activity = activity.clamp(0.1, 10.0);
        for (i, amp) in self.amplitudes.iter_mut().enumerate() {
            *amp = (*amp * (1.0 / self.network_activity)).clamp(0.05, 2.0);
            if i == 0 && self.frequencies[i] == 7.83 { // Усиление для Λ0
                *amp *= 1.2;
            }
        }
        self.log_event(&format!("[INFO] Network activity updated: {:.2}, amplitudes: {:?}", self.network_activity, self.amplitudes));
    }

    pub fn calculate_sigma(&self, t: f64) -> Vec<f64> {
        if !self.validate_frequencies() {
            self.log_event("[ERROR] Недопустимые частоты");
            return vec![0.0; self.frequencies.len()];
        }

        let sigma: Vec<f64> = self.frequencies.iter().enumerate().map(|(i, &f)| {
            let amp = self.amplitudes[i];
            let s = amp * (2.0 * PI * f * t).sin();
            if i == 0 && f == 7.83 { // Усиление для Λ0
                s * 1.2
            } else {
                s
            }
        }).collect();

        self.log_event(&format!("[SIGMA] t={} → Σ(t)={:?}", t, sigma));
        sigma
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"sigma_t\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key); // Исправлено для ring 0.17.x
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() { // Исправлено для ring 0.17.x
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    let sigma_t = SigmaT::new();
    for t in 0..5 {
        let sigma = sigma_t.calculate_sigma(t as f64);
        println!("t = {} → Σ(t) = {:?}", t, sigma);
    }
}


```

## FILE: /root/logos_lrb/src/bin/Λ0.rs  (SKIPPED, empty)

## FILE: /root/logos_lrb/src/core/biosphere_scanner.rs  (size=5196b)
```
// LOGOS Biosphere Scanner
// Автор: LOGOS Core Dev

use std::collections::VecDeque;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde_json;

pub struct BiosphereScanner {
    pub sensor_data: VecDeque<f64>,
    pub max_samples: usize,
    pub threshold: f64,
    pub scan_interval_sec: u64,
    pub log_file: String,
    pub state_file: String,
    pub last_scan_time: u64,
    pub network_activity: f64, // Уровень активности сети
    pub lambda_zero: String,   // Центральный символ
    pub cipher_key: String,    // Ключ шифрования (заглушка для AES)
}

impl BiosphereScanner {
    pub fn new(max_samples: usize, threshold: f64, scan_interval_sec: u64) -> Self {
        BiosphereScanner {
            sensor_data: VecDeque::with_capacity(max_samples),
            max_samples,
            threshold,
            scan_interval_sec,
            log_file: "biosphere_log.json".to_string(),
            state_file: "biosphere_state.json".to_string(),
            last_scan_time: 0,
            network_activity: 1.0,
            lambda_zero: "Λ0".to_string(),
            cipher_key: "generate_at_runtime".to_string(), // Заглушка для AES
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Динамическая корректировка порога
        self.network_activity = activity.clamp(0.1, 10.0);
        self.threshold = self.threshold * (1.0 / self.network_activity).clamp(0.5, 2.0);
        self.log_event(&format!(
            "Network activity updated: Activity={:.2}, Threshold={:.4}",
            self.network_activity, self.threshold
        ));
    }

    pub fn scan(&mut self, sample: f64, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка интервала сканирования
        if now - self.last_scan_time < self.scan_interval_sec {
            self.log_event(&format!("[!] Слишком частое сканирование: Time={}", now));
            return false;
        }
        self.last_scan_time = now;

        // Валидация данных
        if !self.validate_sample(sample) {
            self.log_event(&format!("[!] Недопустимое значение: Sample={:.4}", sample));
            return false;
        }

        // Проверка связи с Λ0
        let adjusted_threshold = if symbol == self.lambda_zero {
            self.threshold * 1.5 // Увеличенный порог для Λ0
        } else {
            self.threshold
        };

        if self.sensor_data.len() >= self.max_samples {
            self.sensor_data.pop_front();
        }
        self.sensor_data.push_back(sample);
        self.save_state();

        let avg = self.compute_average();
        let delta = (sample - avg).abs();

        if delta > adjusted_threshold {
            self.log_event(&format!(
                "[!] Аномалия в биосфере: Δ = {:.4}, Sample = {:.4}, Avg = {:.4}, Symbol = {}",
                delta, sample, avg, symbol
            ));
            return false;
        } else {
            self.log_event(&format!(
                "[SCAN] Sample = {:.4}, Avg = {:.4}, Δ = {:.4}, Symbol = {}",
                sample, avg, delta, symbol
            ));
            return true;
        }
    }

    fn validate_sample(&self, sample: f64) -> bool {
        // Проверка диапазона (например, для Шумана и других биосферных частот)
        0.0 <= sample && sample <= 1000.0
    }

    fn compute_average(&self) -> f64 {
        if self.sensor_data.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.sensor_data.iter().sum();
        sum / self.sensor_data.len() as f64
    }

    fn save_state(&self) {
        // Сохранение состояния в файл
        let state = serde_json::json!({
            "sensor_data": self.sensor_data.iter().collect::<Vec<_>>(),
            "last_scan_time": self.last_scan_time
        });
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&self.state_file)
        {
            let _ = file.write_all(state.to_string().as_bytes());
        }
    }

    fn log_event(&self, message: &str) {
        // Логирование с заглушкой для шифрования
        let entry = format!(
            "{{\"event\": \"biosphere_scan\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        // TODO: Реализовать шифрование логов с cipher_key
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
        {
            let _ = file.write_all(entry.as_bytes());
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("biosphere_scanner запущен");
}

```

## FILE: /root/logos_lrb/src/core/dao.rs  (size=2106b)
```

// LOGOS DAO — управление обратной связью и этикой
// Автор: LOGOS Core Dev Team

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct DAO {
    pub feedback_log: String,
    pub ethics_guidelines: String,
    pub cipher_key: Vec<u8>,
}

impl DAO {
    pub fn new() -> Self {
        DAO {
            feedback_log: "dao_feedback_log.enc".to_string(),
            ethics_guidelines: "Respect Λ0, ensure fairness, prioritize resonance".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn process_feedback(&self, feedback: &str, mode: ResonanceMode) -> bool {
        self.log_event(&format!("[FEEDBACK] {} in mode {:?}", feedback, mode));
        true
    }

    pub fn apply_ethics(&self, decision: &str) -> bool {
        if decision.contains("unfair") {
            self.log_event(&format!("[ETHICS] Отклонено: {}", decision));
            return false;
        }
        self.log_event(&format!("[ETHICS] Принято: {}", decision));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"dao\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.feedback_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/logos_self.rs  (size=2771b)
```

// LOGOS Self — самоизменение и защита от хаоса
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct LogosSelf {
    pub valid_symbols: HashSet<String>,
    pub entropy_log: String,
    pub cipher_key: Vec<u8>,
}

impl LogosSelf {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        LogosSelf {
            valid_symbols,
            entropy_log: "logos_self_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn auto_init(&self, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ для инициализации: {}", symbol));
            return false;
        }

        self.log_event(&format!("[INIT] Автоинициализация Λ0 в режиме {:?}", mode));
        true
    }

    pub fn track_entropy(&self, entropy: f64) -> bool {
        if entropy < 0.0 {
            self.log_event(&format!("[DROP] Неверная энтропия: {}", entropy));
            return false;
        }
        self.log_event(&format!("[ENTROPY] Уровень энтропии: {:.2}", entropy));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"logos_self\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.entropy_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/phase.rs  (size=5790b)
```

// LOGOS Phase — управление фазами сети
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::frequency::validate_frequency;
use crate::utils::types::ResonanceMode;

#[derive(Debug, Serialize, Deserialize)]
pub struct PhaseSignal {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

pub struct Phase {
    pub clusters: HashMap<String, Vec<PhaseSignal>>, // Для масштабирования
    pub phase_data: HashMap<String, PhaseSignal>,    // Для стабилизации
    pub blocked_rids: HashSet<String>,               // Для фильтрации
    pub history: VecDeque<PhaseSignal>,              // Для восстановления
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub max_history: usize,
}

impl Phase {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Phase {
            clusters: HashMap::new(),
            phase_data: HashMap::new(),
            blocked_rids: HashSet::new(),
            history: VecDeque::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "phase_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            max_history: 1000,
        }
    }

    pub fn process_signal(&mut self, signal: PhaseSignal, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(&signal.symbol) || !validate_frequency(signal.frequency) {
            self.log_event(&format!("[DROP] Неверный символ или частота: {}, {}", signal.symbol, signal.frequency));
            return false;
        }

        if self.blocked_rids.contains(&signal.rid) {
            self.log_event(&format!("[DROP] RID {} заблокирован", signal.rid));
            return false;
        }

        match mode {
            ResonanceMode::Passive => {
                self.phase_data.insert(signal.rid.clone(), signal.clone());
                self.log_event(&format!("[PASSIVE] RID {} принят: freq={:.2}, phase={:.2}", signal.rid, signal.frequency, signal.phase));
            }
            ResonanceMode::Amplified => {
                let cluster = self.clusters.entry(signal.symbol.clone()).or_insert(Vec::new());
                cluster.push(signal.clone());
                self.log_event(&format!("[AMPLIFIED] RID {} добавлен в кластер: {}", signal.rid, signal.symbol));
            }
            ResonanceMode::SelfAdjusting => {
                let adjusted_phase = if signal.symbol == self.lambda_zero { signal.phase * 0.9 } else { signal.phase };
                let adjusted_signal = PhaseSignal {
                    phase: adjusted_phase,
                    ..signal.clone()
                };
                self.phase_data.insert(signal.rid.clone(), adjusted_signal);
                self.log_event(&format!("[ADJUST] RID {} скорректирован: phase={:.2}", signal.rid, adjusted_phase));
            }
            ResonanceMode::Chaotic => {
                self.history.push_back(signal.clone());
                if self.history.len() > self.max_history {
                    self.history.pop_front();
                }
                self.log_event(&format!("[CHAOTIC] RID {} добавлен в историю", signal.rid));
            }
        }

        true
    }

    pub fn backup(&self) {
        let state = serde_json::to_string(&self.phase_data).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = state.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("phase_backup.enc")
            {
                let _ = file.write_all(&buf);
            }
        }
        self.log_event("[BACKUP] Состояние фаз сохранено");
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"phase\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/resonance.rs  (size=3016b)
```

// LOGOS Resonance — анализ и фильтрация резонансных сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::math::calculate_sigma;
use crate::utils::types::ResonanceMode;

pub struct Resonance {
    pub valid_symbols: HashSet<String>,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl Resonance {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Resonance {
            valid_symbols,
            log_file: "resonance_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn analyze_signal(&self, rid: &str, t: f64, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ: {}", symbol));
            return false;
        }

        let sigma = calculate_sigma(t);
        match mode {
            ResonanceMode::Passive => {
                self.log_event(&format!("[PASSIVE] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Amplified => {
                self.log_event(&format!("[AMPLIFIED] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::SelfAdjusting => {
                self.log_event(&format!("[ADJUST] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Chaotic => {
                self.log_event(&format!("[CHAOTIC] RID {}: sigma={:?}", rid, sigma));
            }
        }

        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"resonance\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```

## FILE: /root/logos_lrb/src/core/tx_spam_guard.rs  (size=3175b)
```

// LOGOS Transaction Spam Guard
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct TxSpamGuard {
    pub violation_count: HashMap<String, u32>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl TxSpamGuard {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        TxSpamGuard {
            violation_count: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "tx_spam_guard_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn check_spam(&mut self, rid: &str, symbol: &str) -> bool {
        if !self.validate_rid(rid) || !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Недопустимый RID или символ: {}, {}", rid, symbol));
            return false;
        }

        let violations = *self.violation_count.entry(rid.to_string()).or_insert(0);
        let new_violations = violations + 1;
        self.violation_count.insert(rid.to_string(), new_violations);
        self.log_event(&format!("[CHECK] RID {}: {} нарушений", rid, new_violations));

        if new_violations >= 3 {
            self.log_event(&format!("[SPAM] RID {} заблокирован", rid));
            return false;
        }

        true
    }

    pub fn is_tx_spam(&self, rid: &str) -> bool {
        self.violation_count.get(rid).map_or(false, |&count| count >= 3)
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"tx_spam_guard\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```

## FILE: /root/logos_lrb/src/lib.rs  (size=921b)
```

// LOGOS Core Library — библиотека для модулей LOGOS
// Автор: LOGOS Core Dev Team

pub mod core {
    pub mod biosphere_scanner;
    pub mod dao;
    pub mod lgn_guardian;
    pub mod phase;
    pub mod resonance;
    pub mod logos_self;
    pub mod tx_spam_guard;
}

pub mod utils {
    pub mod frequency;
    pub mod filters;
    pub mod math;
    pub mod types;
}

pub mod modules {
    pub mod beacon_emitter;
    pub mod external_phase_broadcaster;
    pub mod external_phase_link;
    pub mod genesis_fragment_seeds;
    pub mod heartbeat_monitor;
    pub mod legacy_migrator;
    pub mod ritual_engine;
}

pub mod resonance {
    // Пустая директория для будущих модулей
}

pub mod phase {
    // Пустая директория для будущих модулей
}

pub mod dao {
    // Пустая директория для DAO-логики
}

```

## FILE: /root/logos_lrb/src/utils/filters.rs  (size=322b)
```

// LOGOS Filters Utils — фильтрация сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;

pub fn validate_symbol(symbol: &str, valid_symbols: &HashSet<String>) -> bool {
    valid_symbols.contains(symbol)
}

pub fn filter_signal(signal: f64) -> bool {
    signal.abs() <= 1.0
}

```

## FILE: /root/logos_lrb/src/utils/frequency.rs  (size=380b)
```

// LOGOS Frequency Utils — обработка частот
// Автор: LOGOS Core Dev Team

pub fn validate_frequency(frequency: f64) -> bool {
    frequency >= 0.1 && frequency <= 10000.0
}

pub fn adjust_frequency(frequency: f64, symbol: &str) -> f64 {
    if symbol == "Λ0" {
        frequency * 1.1 // Усиление для Λ0
    } else {
        frequency
    }
}

```

## FILE: /root/logos_lrb/src/utils/math.rs  (size=394b)
```

// LOGOS Math Utils — вычисления резонанса
// Автор: LOGOS Core Dev Team

pub fn calculate_sigma(t: f64) -> Vec<f64> {
    let freqs = vec![7.83, 1.618, 432.0, 864.0, 3456.0];
    let amps = vec![1.0, 0.8, 0.5, 0.3, 0.1];
    freqs
        .iter()
        .zip(amps.iter())
        .map(|(&f, &a)| a * (2.0 * std::f64::consts::PI * f * t).sin())
        .collect()
}

```

## FILE: /root/logos_lrb/src/utils/types.rs  (size=215b)
```

// LOGOS Types — общие типы для системы
// Автор: LOGOS Core Dev Team

#[derive(Debug, Clone, Copy)]
pub enum ResonanceMode {
    Passive,
    Amplified,
    SelfAdjusting,
    Chaotic,
}

```

## FILE: /root/logos_lrb/tools/admin_cli.sh  (size=5214b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```

## FILE: /root/logos_lrb/tools/batch.json  (SKIPPED, empty)

## FILE: /root/logos_lrb/tools/bench/go/bench.go  (size=6330b)
```
// bench.go v4 — шардированный бенч LOGOS: Ed25519-подписи, батчи, accepted TPS.
// ENV:
//   BASE=http://127.0.0.1:8080           # или https://host/api
//   N=10000 SHARDS=4 BATCH=50 AMOUNT=1   # всего N tx, шардов (RID) S, размер пачки K
//   FAUCET=1                              # начислить перед тестом
//   USE_DEBUG_CANON=0                     # 0 = строим канон локально (быстрее), 1 = через /debug_canon
package main

import (
	"bytes"
	"context"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"math/big"
	"net/http"
	"os"
	"strconv"
	"sync"
	"sync/atomic"
	"time"
)

const ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"

// ----- helpers -----
func b58encode(b []byte) string {
	x := new(big.Int).SetBytes(b)
	if x.Sign() == 0 { return "1" }
	base := big.NewInt(58)
	zero := big.NewInt(0)
	mod := new(big.Int)
	var out []byte
	for x.Cmp(zero) > 0 {
		x.QuoRem(x, base, mod)
		out = append(out, ALPH[mod.Int64()])
	}
	for i, j := 0, len(out)-1; i < j; i, j = i+1, j-1 { out[i], out[j] = out[j], out[i] }
	zeros := 0; for _, v := range b { if v==0 { zeros++ } else { break } }
	if zeros>0 { return string(bytes.Repeat([]byte("1"), zeros)) + string(out) }
	return string(out)
}
func envOr(k, d string) string { v:=os.Getenv(k); if v=="" { return d }; return v }
func httpc() *http.Client { return &http.Client{ Timeout: 20 * time.Second } }

type httpErr struct{ code int; body string }
func reqJSON(ctx context.Context, c *http.Client, method, url string, body any, out any) *httpErr {
	var rdr io.Reader
	if body != nil { b,_ := json.Marshal(body); rdr = bytes.NewReader(b) }
	req,_ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type","application/json")
	resp, err := c.Do(req)
	if err != nil { return &httpErr{code:0, body:err.Error()} }
	defer resp.Body.Close()
	rb,_ := io.ReadAll(resp.Body)
	if resp.StatusCode<200 || resp.StatusCode>=300 { return &httpErr{code:resp.StatusCode, body:string(rb)} }
	if out != nil { if err := json.Unmarshal(rb, out); err != nil { return &httpErr{code:-1, body:"decode:"+err.Error()} } }
	return nil
}

// CanonTx — точный порядок полей как на сервере
type CanonTx struct {
	From   string `json:"from"`
	To     string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
}

// локальная канонизация (совпадает с серверной)
func localCanonHex(tx CanonTx) string {
	b, _ := json.Marshal(tx) // порядок полей = порядок в struct
	dst := make([]byte, hex.EncodedLen(len(b)))
	hex.Encode(dst, b)
	return string(dst)
}

func main() {
	base := envOr("BASE", "http://127.0.0.1:8080")
	N, _ := strconv.Atoi(envOr("N", "10000"))
	S, _ := strconv.Atoi(envOr("SHARDS", "4"))
	K, _ := strconv.Atoi(envOr("BATCH", "50"))
	amt, _ := strconv.ParseUint(envOr("AMOUNT", "1"), 10, 64)
	faucet := os.Getenv("FAUCET")=="1"
	useDebugCanon := os.Getenv("USE_DEBUG_CANON")=="1"

	if S <= 0 { S=1 }
	if K <= 0 { K=1 }

	// распределим N по шардовым потокам
	per := N / S
	rem := N % S

	type shard struct{
		sk ed25519.PrivateKey
		rid string
		next uint64
	}

	cli := httpc()
	ctx := context.Background()

	shards := make([]shard, S)
	// подготовка шардов: генерим ключ, RID, faucet, читаем nonce
	for i:=0; i<S; i++ {
		_, sk, _ := ed25519.GenerateKey(rand.Reader)
		pk := sk.Public().(ed25519.PublicKey)
		rid := b58encode(pk)

		if faucet {
			_ = reqJSON(ctx, cli, "POST", base+"/faucet", map[string]any{
				"rid": rid, "amount": 1_000_000_000,
			}, nil)
		}

		var bal struct{ Rid string; Balance uint64; Nonce uint64 }
		if err := reqJSON(ctx, cli, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err.code, err.body); os.Exit(1)
		}
		shards[i] = shard{ sk: sk, rid: rid, next: bal.Nonce+1 }
	}

	var accepted int64
	var rejected int64
	var http429 int64
	var httpErr int64

	wg := sync.WaitGroup{}
	start := time.Now()

	for i:=0; i<S; i++ {
		count := per; if i < rem { count++ }
		if count == 0 { continue }

		sh := shards[i]
		wg.Add(1)
		go func(cnt int, sh shard){
			defer wg.Done()
			loc := httpc()
			remain := cnt
			nonce := sh.next

			for remain > 0 {
				bsize := K; if remain < K { bsize = remain }
				// готовим пачку детерминированно: nonce..nonce+bsize-1
				txs := make([]map[string]any, 0, bsize)
				for j:=0; j<bsize; j++ {
					tx := CanonTx{ From: sh.rid, To: sh.rid, Amount: amt, Nonce: nonce+uint64(j) }
					var canonHex string
					if useDebugCanon {
						var canon map[string]string
						if err := reqJSON(ctx, loc, "POST", base+"/debug_canon", map[string]any{"tx": tx}, &canon); err != nil {
							if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
							return
						}
						canonHex = canon["canon_hex"]
					} else {
						canonHex = localCanonHex(tx)
					}
					cbytes, _ := hex.DecodeString(canonHex)
					sig := ed25519.Sign(sh.sk, cbytes)
					sigHex := hex.EncodeToString(sig)
					txs = append(txs, map[string]any{
						"from": tx.From, "to": tx.To, "amount": tx.Amount, "nonce": tx.Nonce, "sig_hex": sigHex,
					})
				}

				// шлём батч
				var out struct{
					Accepted int `json:"accepted"`
					Rejected int `json:"rejected"`
					NewHeight uint64 `json:"new_height"`
					Results []struct{
						Status string `json:"status"`
						Code   int    `json:"code"`
						Reason string `json:"reason"`
					} `json:"results"`
				}
				if err := reqJSON(ctx, loc, "POST", base+"/submit_tx_batch", map[string]any{"txs":txs}, &out); err != nil {
					if err.code==429 { atomic.AddInt64(&http429,1) } else { atomic.AddInt64(&httpErr,1) }
					return
				}
				atomic.AddInt64(&accepted, int64(out.Accepted))
				atomic.AddInt64(&rejected, int64(out.Rejected))

				nonce += uint64(bsize)
				remain -= bsize
			}
		}(count, sh)
	}

	wg.Wait()
	dt := time.Since(start).Seconds()
	fmt.Printf("=== DONE: accepted=%d / N=%d shards=%d batch=%d in %.2fs → ~%.1f tx/s | rejected=%d 429=%d httpErr=%d ===\n",
		accepted, N, S, K, dt, float64(accepted)/dt, rejected, http429, httpErr)
}

```

## FILE: /root/logos_lrb/tools/gen_full_codemap.py  (size=5302b)
```
#!/usr/bin/env python3
# gen_full_codemap.py — cоздаёт единый текстовый слепок исходников из заданных директорий.
# Использование:
#   python3 gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]
#
# Пример:
#   python3 gen_full_codemap.py /root/logos_snapshot/SNAPSHOT_$(date +%F_%H%M).txt /root/logos_lrb /root/logos_rsp

import os, sys, hashlib, time

OK_EXT = {
    '.rs','.py','.tsx','.ts','.js','.jsx','.go',
    '.html','.htm','.css','.scss','.md','.txt',
    '.yaml','.yml','.toml','.ini','.cfg','.conf',
    '.sh','.bash','.zsh','.sql','.proto','.graphql',
    '.env.example','.service','.timer'
}

EXCLUDE_DIR_PREFIXES = (
    '.git','target','node_modules','build','dist','out','venv','.venv','__pycache__',
    '.idea','.vscode','.fleet','.DS_Store','coverage','.pytest_cache',
    '.cargo','.gradle','android/app/build','ios/Pods','.dart_tool',
    'tools/.venv','tools/venv','.husky'
)

EXCLUDE_FILE_PATTERNS = (
    '.env',        # любые .env (чтобы не потянуть реальные секреты)
    '.pem','.key','.crt','.p12','.keystore','.jks',
    '.sqlite','.db','.db3','.sqlite3',
    '.lock','.bin','.wasm','.o','.a'
)

MAX_FILE_BYTES = 400_000       # не включать слишком большие файлы
MAX_TOTAL_BYTES = 300_000_000  # общий предел (300 МБ, чтобы не улететь в космос)

def is_excluded_dir(path):
    norm = path.replace('\\','/')
    parts = norm.split('/')
    for p in parts:
        for ex in EXCLUDE_DIR_PREFIXES:
            if p == ex or norm.startswith(ex + '/'):
                return True
    return False

def is_ok_file(path):
    # исключить секреты/бинарники по шаблонам имени
    low = path.lower()
    for pat in EXCLUDE_FILE_PATTERNS:
        if low.endswith(pat) or f"/{pat}" in low:
            return False
    # по расширениям
    _, ext = os.path.splitext(path)
    if ext.lower() in OK_EXT:
        try:
            if os.path.getsize(path) <= MAX_FILE_BYTES:
                return True
        except FileNotFoundError:
            return False
    return False

def sha256_of_file(path):
    h = hashlib.sha256()
    with open(path,'rb') as r:
        while True:
            b = r.read(1024*1024)
            if not b: break
            h.update(b)
    return h.hexdigest()

def collect_files(roots):
    out = []
    for root in roots:
        root = os.path.abspath(root)
        if not os.path.isdir(root):
            continue
        for dp, dn, fn in os.walk(root):
            # пропуск скрытых/исключённых директорий
            norm_dp = dp.replace('\\','/')
            if is_excluded_dir(norm_dp):
                dn[:] = []  # не спускаться ниже
                continue
            for f in fn:
                p = os.path.join(dp,f)
                norm = p.replace('\\','/')
                # пропускаем скрытые файлы
                if any(seg.startswith('.') and seg not in ('.env.example',) for seg in norm.split('/')):
                    # .env.example оставляем
                    pass
                if is_ok_file(norm):
                    out.append(norm)
    out = sorted(set(out))
    return out

def main():
    if len(sys.argv) < 3:
        print("Usage: gen_full_codemap.py OUTPUT.txt DIR1 [DIR2 ...]", file=sys.stderr)
        sys.exit(1)
    output = os.path.abspath(sys.argv[1])
    roots  = sys.argv[2:]
    files  = collect_files(roots)
    ts = time.strftime('%Y-%m-%d %H:%M:%S')

    total_written = 0
    os.makedirs(os.path.dirname(output), exist_ok=True)
    with open(output, 'w', encoding='utf-8', errors='replace') as w:
        w.write("# FULL CODE SNAPSHOT\n")
        w.write(f"Generated: {ts}\n")
        w.write(f"Roots: {', '.join(os.path.abspath(r) for r in roots)}\n")
        w.write(f"Files count: {len(files)}\n")
        w.write("\n## Table of Contents\n")
        for i, p in enumerate(files, 1):
            anchor = f"{i}-{p.replace('/','-')}"
            w.write(f"{i}. {p}  ->  #{anchor}\n")
        w.write("\n---\n")

        for i, p in enumerate(files, 1):
            try:
                size = os.path.getsize(p)
                sha  = sha256_of_file(p)
                with open(p,'r',encoding='utf-8',errors='replace') as r:
                    data = r.read()
            except Exception as e:
                data = f"<<error reading {p}: {e}>>"
                size = -1
                sha  = "n/a"

            header = f"\n## {i}. {p}\n#size={size} bytes  sha256={sha}\n<a name=\"{i}-{p.replace('/','-')}\"></a>\n\n"
            body   = "```text\n" + data + "\n```\n"
            chunk  = header + body
            enc    = chunk.encode('utf-8', errors='replace')
            if total_written + len(enc) > MAX_TOTAL_BYTES:
                w.write("\n\n<< STOPPED: reached MAX_TOTAL_BYTES limit >>\n")
                break
            w.write(chunk)
            total_written += len(enc)

    print(f"[ok] Wrote snapshot to: {output}")
    print(f"[info] Files included: {len(files)}")
    print(f"[info] Approx bytes written: {total_written}")

if __name__ == '__main__':
    main()

```

## FILE: /root/logos_lrb/tools/go_test/go.mod  (size=82b)
```
module logos_lrb/tools/go_test

go 1.22

require github.com/mr-tron/base58 v1.2.0

```

## FILE: /root/logos_lrb/tools/go_test/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```

## FILE: /root/logos_lrb/tools/go_test/main.go  (size=3201b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```

## FILE: /root/logos_lrb/tools/go_test/two_rids.go  (size=3944b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```

## FILE: /root/logos_lrb/tools/load/go.mod  (size=87b)
```
module logos_lrb_load

go 1.22.2

require github.com/mr-tron/base58 v1.2.0 // indirect

```

## FILE: /root/logos_lrb/tools/load/go.sum  (size=169b)
```
github.com/mr-tron/base58 v1.2.0 h1:T/HDJBh4ZCPbU39/+c3rRvE0uKBQlU27+QI8LJ4t64o=
github.com/mr-tron/base58 v1.2.0/go.mod h1:BinMc/sQntlIE1frQmRFPUoPA1Zkr8VRgBdjWI2mNwc=

```

## FILE: /root/logos_lrb/tools/load_healthz.sh  (size=950b)
```
#!/usr/bin/env bash
# load_healthz.sh — прогон healthz с прогрессом
# Usage: ./load_healthz.sh <TOTAL=50000> <CONC=200> <MODE=rr|lb>
set -euo pipefail
TOTAL="${1:-50000}"
CONC="${2:-200}"
MODE="${3:-rr}"

start_ts=$(date +%s%3N)
cnt=0
print_prog() { cnt=$((cnt+1)); if (( cnt % 1000 == 0 )); then echo -n "."; fi; }

if [ "$MODE" = "rr" ]; then
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    i="{}"; r=$(( i % 3 ))
    if   [ $r -eq 0 ]; then p=8080
    elif [ $r -eq 1 ]; then p=8082
    else                   p=8084
    fi
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1:${p}/healthz"
  ' && echo
else
  seq 1 "$TOTAL" | xargs -n1 -P"$CONC" -I{} bash -c '
    curl -sS --max-time 2 -o /dev/null "http://127.0.0.1/api/healthz"
  ' && echo
fi

end_ts=$(date +%s%3N)
dt_ms=$(( end_ts - start_ts ))
rps=$(( TOTAL * 1000 / (dt_ms>0?dt_ms:1) ))
echo "[OK] sent ${TOTAL} requests in ${dt_ms} ms  → ~${rps} req/s"

```

## FILE: /root/logos_lrb/tools/load/load_submit_tx.go  (size=7096b)
```
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```

## FILE: /root/logos_lrb/tools/lrb_audit.sh  (size=3026b)
```
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```

## FILE: /root/logos_lrb/tools/make_codebook.sh  (size=4987b)
```
#!/usr/bin/env sh
# LOGOS LRB — FULL LIVE book: repo + infra в один TXT (с маскировкой секретов)
set -eu

ROOT="$(cd "$(dirname "$0")/.."; pwd)"
OUT_DIR="docs"
STAMP="$(date -u +%Y-%m-%dT%H:%M:%SZ)"
OUT_FILE_TMP="${OUT_DIR}/LRB_FULL_LIVE_${STAMP}.txt.tmp"
OUT_FILE="${OUT_DIR}/LRB_FULL_LIVE_${STAMP}.txt"
SIZE_LIMIT="${SIZE_LIMIT:-2000000}"   # 2 MB per file
REPO_ROOT="/root/logos_lrb"

# --- ВКЛЮЧАЕМ ИЗ РЕПО ---
REPO_GLOBS='
Cargo.toml
README.md
src
lrb_core/src
node/src
modules
core
wallet-proxy
docs
www/wallet
www/explorer
infra/nginx
infra/systemd
scripts
tools
configs
'

# --- ВКЛЮЧАЕМ ИНФРУ С СЕРВЕРА ---
INFRA_FILES='
/etc/nginx/nginx.conf
/etc/nginx/conf.d/*.conf
/etc/nginx/sites-enabled/*
/etc/systemd/system/logos-node.service
/etc/systemd/system/*.service
/etc/systemd/system/*.timer
/etc/systemd/system/logos-node.service.d/*.conf
/etc/prometheus/prometheus.yml
/etc/prometheus/rules/*.yml
/etc/alertmanager/alertmanager.yml
/etc/alertmanager/secrets.env
/etc/grafana/grafana.ini
/etc/grafana/provisioning/datasources/*.yaml
/etc/grafana/provisioning/dashboards/*.yaml
/var/lib/grafana/dashboards/*.json
/opt/logos/www/wallet/*
/opt/logos/www/explorer/*
'

# --- ИСКЛЮЧЕНИЯ ДЛЯ РЕПО ---
EXCLUDES_REPO='
.git
target
node_modules
venv
__pycache__
*.pyc
data.sled
var
*.log
*.pem
*.der
*.crt
*.key
*.zip
*.tar
*.tar.gz
*.7z
LOGOS_LRB_FULL_BOOK.md
'

# язык для подсветки
lang_for() {
  case "${1##*.}" in
    rs) echo "rust" ;; toml) echo "toml" ;; json) echo "json" ;;
    yml|yaml) echo "yaml" ;; sh|bash) echo "bash" ;; py) echo "python" ;;
    js) echo "javascript" ;; ts) echo "typescript" ;; tsx|jsx) echo "tsx" ;;
    html|htm) echo "html" ;; css) echo "css" ;; md) echo "markdown" ;;
    conf|ini|service|timer|env) echo "" ;; *) echo "" ;;
  esac
}

# доверяем расширению, иначе grep -Iq
looks_text() {
  case "$1" in
    *.rs|*.toml|*.json|*.yml|*.yaml|*.sh|*.bash|*.py|*.js|*.ts|*.tsx|*.jsx|*.html|*.htm|*.css|*.md|*.conf|*.ini|*.service|*.timer|*.env) return 0;;
    *) LC_ALL=C grep -Iq . "$1";;
  esac
}

# фильтр исключений репо
should_exclude_repo() {
  f="$1"
  # с двоеточиями — мусор от редакторов
  echo "$f" | grep -q ":" && return 0
  echo "$EXCLUDES_REPO" | while IFS= read -r pat; do
    [ -z "$pat" ] && continue
    [ "${pat#\#}" != "$pat" ] && continue
    case "$f" in */$pat/*|*/$pat|$pat) exit 0;; esac
  done; return 1
}

# маска секретов
mask_secrets() {
  sed -E \
    -e 's/(TELEGRAM_BOT_TOKEN=)[A-Za-z0-9:_-]+/\1***MASKED***/g' \
    -e 's/(TELEGRAM_CHAT_ID=)[0-9-]+/\1***MASKED***/g' \
    -e 's/(LRB_ADMIN_KEY=)[A-Fa-f0-9]+/\1***MASKED***/g' \
    -e 's/(LRB_BRIDGE_KEY=)[A-Fa-f0-9]+/\1***MASKED***/g' \
    -e 's/(LRB_ADMIN_JWT_SECRET=)[A-Za-z0-9._-]+/\1***MASKED***/g'
}

write_header() {
  {
    echo "# FULL LIVE SNAPSHOT — $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo "# sources: $REPO_ROOT + infra (/etc, /opt)"
    echo "# size limit per file: ${SIZE_LIMIT} bytes"
    echo
  } >>"$OUT_FILE_TMP"
}

dump_file() {
  f="$1"
  [ -f "$f" ] || return 0
  echo "$f" | grep -q ":" && return 0     # отсекаем мусорные имена

  sz="$(wc -c <"$f" | tr -d ' ' || echo 0)"
  [ "$sz" -eq 0 ] && { printf "\n## FILE: %s  (SKIPPED, empty)\n" "$f" >>"$OUT_FILE_TMP"; return 0; }
  [ "$sz" -gt "$SIZE_LIMIT" ] && { printf "\n## FILE: %s  (SKIPPED, size=%sb > limit)\n" "$f" "$sz" >>"$OUT_FILE_TMP"; return 0; }

  printf "\n## FILE: %s  (size=%sb)\n" "$f" "$sz" >>"$OUT_FILE_TMP"
  if looks_text "$f"; then
    printf '```\n' >>"$OUT_FILE_TMP"
    case "$f" in
      */alertmanager/secrets.env|*/logos-node.service.d/*|*/nginx/*.conf|*/conf.d/*.conf|*/sites-enabled/*|*/prometheus*.yml|*/grafana/*.ini|*/provisioning/*|*/dashboards/*.json)
        mask_secrets < "$f" >>"$OUT_FILE_TMP" ;;
      *) cat "$f" >>"$OUT_FILE_TMP" ;;
    esac
    printf '\n```\n' >>"$OUT_FILE_TMP"
  else
    printf "\n(SKIPPED, binary/non-text)\n" >>"$OUT_FILE_TMP"
  fi
}

collect_repo() {
  echo "$REPO_GLOBS" | while IFS= read -r rel; do
    [ -z "$rel" ] && continue
    [ "${rel#\#}" != "$rel" ] && continue
    p="$REPO_ROOT/$rel"
    if [ -d "$p" ]; then find "$p" -type f; elif [ -f "$p" ]; then echo "$p"; fi
  done
}

collect_infra() {
  echo "$INFRA_FILES" | while IFS= read -r pat; do
    [ -z "$pat" ] && continue
    [ "${pat#\#}" != "$pat" ] && continue
    for f in $pat; do [ -f "$f" ] && echo "$f"; done
  done
}

main() {
  mkdir -p "$OUT_DIR"
  : >"$OUT_FILE_TMP"
  write_header

  collect_repo  | sort -u | while IFS= read -r p; do
    if should_exclude_repo "$p"; then continue; fi
    dump_file "$p"
  done

  collect_infra | sort -u | while IFS= read -r p; do
    dump_file "$p"
  done

  mv -f "$OUT_FILE_TMP" "$OUT_FILE"
  echo "✅ created: $OUT_FILE"
  cp -f "$OUT_FILE" "${ROOT}/LOGOS_LRB_FULL_BOOK.md" 2>/dev/null || true
}

main "$@"

```

## FILE: /root/logos_lrb/tools/make_full_book.sh  (size=5023b)
```
#!/usr/bin/env bash
# LOGOS LRB — Полная книга: исходники из репозитория + ключевые прод-конфиги
set -euo pipefail

ROOT="$(cd "$(dirname "$0")/.."; pwd)"
OUT="${ROOT}/LOGOS_LRB_FULL_BOOK.md"
TS="$(date -u +'%Y-%m-%d %H:%M:%S UTC')"
GIT_SHA="$(git -C "$ROOT" rev-parse --short=7 HEAD 2>/dev/null || echo 'no-git')"

# ---------- Параметры ----------
# исключаем мусор/бинарь/секреты
EXCLUDES_REPO=(
  ".git" "target" "node_modules" "venv" "__pycache__" "data.sled" "var"
  "LOGOS_LRB_FULL_BOOK.md" "*.log" "*.pem" "*.der" "*.crt" "*.key" "*.zip" "*.tar" "*.tar.gz" "*.7z"
)
# включаем infra из whitelist-путей
INFRA_FILES=(
  "/etc/nginx/conf.d/*.conf"
  "/etc/systemd/system/logos-node.service"
  "/etc/systemd/system/logos-node.service.d/*.conf"
  "/etc/prometheus/prometheus.yml"
  "/etc/prometheus/rules/*.yml"
  "/etc/alertmanager/alertmanager.yml"
  "/etc/alertmanager/secrets.env"
  "/etc/grafana/provisioning/datasources/*.yaml"
  "/etc/grafana/provisioning/dashboards/*.yaml"
  "/var/lib/grafana/dashboards/*.json"
)
MAX_SIZE=$((2*1024*1024))  # 2 МБ на файл

lang_for() {
  case "${1##*.}" in
    rs) echo "rust" ;; toml) echo "toml" ;; json) echo "json" ;;
    yml|yaml) echo "yaml" ;; sh|bash) echo "bash" ;; py) echo "python" ;;
    js) echo "javascript" ;; ts) echo "typescript" ;; tsx|jsx) echo "tsx" ;;
    html|htm) echo "html" ;; css) echo "css" ;; md) echo "markdown" ;;
    conf|ini|service|timer) echo "" ;;  *) echo "" ;;
  esac
}

exclude_match() {
  local f="$1"
  for p in "${EXCLUDES_REPO[@]}"; do
    case "$p" in
      *"*") [[ "$f" == $p ]] && return 0 ;;
      *)    [[ "$f" == */$p/* || "$f" == */$p || "$f" == $p ]] && return 0 ;;
    esac
  done
  return 1
}

# маскировка секретов для infra (телеграм токены, и т.п.)
mask_infra() {
  # stdin -> stdout
  sed -E \
    -e 's/(TELEGRAM_BOT_TOKEN=)[A-Za-z0-9:_-]+/\1***MASKED*** /g' \
    -e 's/(TELEGRAM_CHAT_ID=)[0-9-]+/\1***MASKED*** /g'
}

# ---------- Заголовок ----------
{
  echo "# LOGOS LRB — Полная книга (исходники + прод-конфиги)"
  echo
  echo "_Generated: ${TS} • Commit: ${GIT_SHA}_"
  echo
  echo "> В книге: весь код из репозитория + основные конфиги из /etc. Исключены бинарные/ключевые файлы; секреты замаскированы."
  echo
  echo "## Оглавление"
} > "$OUT"

TMP_LIST="$(mktemp)"
( cd "$ROOT" && find . -type f -print0 ) >"$TMP_LIST"

# ---------- Оглавление: репозиторий ----------
while IFS= read -r -d '' f; do
  exclude_match "$f" && continue
  sz=$(stat -c%s "$ROOT/$f" 2>/dev/null || echo 0)
  (( sz > MAX_SIZE )) && continue
  anchor="$(echo "repo-$f" | sed 's/^\.\///' | tr '/.' '--' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
  echo "- [repo:$f](#$anchor)" >> "$OUT"
done < "$TMP_LIST"

# ---------- Оглавление: infra ----------
for pat in "${INFRA_FILES[@]}"; do
  for f in $pat; do
    [[ -f "$f" ]] || continue
    sz=$(stat -c%s "$f" 2>/dev/null || echo 0)
    (( sz > MAX_SIZE )) && continue
    anchor="$(echo "infra-$f" | sed 's#/##g;s#:#-#g' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
    echo "- [infra:$f](#$anchor)" >> "$OUT"
  done
done

{
  echo
  echo "---"
  echo
  echo "## Раздел I. Исходники репозитория"
  echo
} >> "$OUT"

# ---------- Контент: репозиторий ----------
while IFS= read -r -d '' f; do
  exclude_match "$f" && continue
  sz=$(stat -c%s "$ROOT/$f" 2>/dev/null || echo 0)
  (( sz > MAX_SIZE )) && { echo "skip big: $f" >&2; continue; }
  rel="${f#./}"
  anchor="$(echo "repo-$f" | sed 's/^\.\///' | tr '/.' '--' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
  lang="$(lang_for "$rel")"
  {
    echo "### $rel"
    echo "<a id=\"$anchor\"></a>"
    echo
    echo '```'"$lang"
    cat "$ROOT/$f"
    echo
    echo '```'
    echo
  } >> "$OUT"
done < "$TMP_LIST"

rm -f "$TMP_LIST"

# ---------- Контент: infra ----------
{
  echo
  echo "## Раздел II. Инфраструктурные конфиги (прод)"
  echo
} >> "$OUT"

for pat in "${INFRA_FILES[@]}"; do
  for f in $pat; do
    [[ -f "$f" ]] || continue
    sz=$(stat -c%s "$f" 2>/dev/null || echo 0)
    (( sz > MAX_SIZE )) && { echo "skip big: $f" >&2; continue; }
    anchor="$(echo "infra-$f" | sed 's#/##g;s#:#-#g' | tr -cd '[:alnum:]-_' | tr '[:upper:]' '[:lower:]')"
    lang="$(lang_for "$f")"
    {
      echo "### $f"
      echo "<a id=\"$anchor\"></a>"
      echo
      echo '```'"$lang"
      # маскируем секреты в alertmanager/secrets.env и похожем
      case "$f" in
        */alertmanager/secrets.env) mask_infra < "$f" ;;
        *) cat "$f" ;;
      esac
      echo
      echo '```'
      echo
    } >> "$OUT"
  done
done

echo "✅ Сформировано: $OUT"

```

## FILE: /root/logos_lrb/tools/make_full_snapshot_live.sh  (size=4401b)
```
#!/usr/bin/env bash
set -euo pipefail

OUTDIR="${OUTDIR:-/root/logos_snapshot}"
STAMP=$(date +%Y%m%d_%H%M)
OUT="$OUTDIR/LRB_FULL_LIVE_${STAMP}.txt"
MAX=${MAX:-800000}  # макс размер включаемого файла (байт)

mkdir -p "$OUTDIR"

say(){ echo "$@" >&2; }
add_head(){
  echo -e "\n\n## FILE: $1  (size=${2}b)\n\`\`\`" >> "$OUT"
}
add_tail(){
  echo -e "\n\`\`\`" >> "$OUT"
}

# Источники (живые пути)
SRC_LIST=(
  "/root/logos_lrb"                   # весь код репо
  "/opt/logos/www/wallet"             # кошелёк
  "/etc/systemd/system/logos-node@.service"
  "/etc/systemd/system/logos-healthcheck.service"
  "/etc/systemd/system/logos-healthcheck.timer"
  "/etc/nginx/sites-available/logos-api-lb.conf"
  "/usr/local/bin/logos_healthcheck.sh"
)

# Заголовок
{
  echo "# FULL LIVE SNAPSHOT — $(date -u +%FT%TZ)"
  echo "# sources:"
  for s in "${SRC_LIST[@]}"; do echo "#  - $s"; done
  echo "# size limit per file: ${MAX} bytes"
  echo
} > "$OUT"

# Вспомогательные функции
is_text(){
  # бинарники/картинки отсекаем простым тестом: попытка вывести «без нулевых байтов»
  # или используем file(1) если есть
  if command -v file >/dev/null 2>&1; then
    file -b --mime "$1" | grep -qiE 'text|json|xml|yaml|toml|javascript|html|css' && return 0 || return 1
  else
    grep -Iq . "$1" && return 0 || return 1
  fi
}

emit_file(){
  local f="$1"
  [ -f "$f" ] || return 0
  # исключения
  case "$f" in
    *.pem|*.key|*.crt|*.p12|*.so|*.bin|*.png|*.jpg|*.jpeg|*.gif|*.svg|*.woff|*.woff2|*.ttf) return 0;;
  esac
  local sz
  sz=$(stat -c%s "$f" 2>/dev/null || echo 0)
  if [ "$sz" -gt "$MAX" ]; then
    echo -e "\n\n## FILE: $f  (SKIPPED, size=${sz}b > ${MAX})" >> "$OUT"
    return 0
  fi
  if ! is_text "$f"; then
    echo -e "\n\n## FILE: $f  (SKIPPED, binary/non-text size=${sz}b)" >> "$OUT"
    return 0
  fi
  add_head "$f" "$sz"
  sed -e 's/\r$//' "$f" >> "$OUT"
  add_tail
}

# 1) Репозиторий: только текстовые файлы, игнорим target/node_modules/dist
if [ -d /root/logos_lrb ]; then
  say "[*] collecting /root/logos_lrb"
  cd /root/logos_lrb
  # берём отслеживаемые git'ом; если git недоступен — найдём все текстовые расширения
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    git ls-files | while read -r f; do
      case "$f" in target/*|**/target/*|node_modules/*|dist/*) continue;; esac
      emit_file "/root/logos_lrb/$f"
    done
  else
    find . -type f ! -path "./target/*" ! -path "./node_modules/*" ! -path "./dist/*" \
      -regextype posix-extended -regex '.*\.(rs|toml|md|sh|bash|zsh|service|timer|conf|nginx|yaml|yml|json|ts|tsx|js|mjs|jsx|html|htm|css|go|py|proto|ini|cfg|txt)$' \
      -print0 | xargs -0 -I{} bash -c 'emit_file "{}"'
  fi
  cd - >/dev/null
fi

# 2) Статика кошелька
if [ -d /opt/logos/www/wallet ]; then
  say "[*] collecting /opt/logos/www/wallet"
  find /opt/logos/www/wallet -type f -print0 | while IFS= read -r -d '' f; do emit_file "$f"; done
fi

# 3) systemd units
for u in /etc/systemd/system/logos-node@.service /etc/systemd/system/logos-healthcheck.service /etc/systemd/system/logos-healthcheck.timer; do
  [ -f "$u" ] && emit_file "$u"
done

# 4) nginx site
[ -f /etc/nginx/sites-available/logos-api-lb.conf ] && emit_file /etc/nginx/sites-available/logos-api-lb.conf

# 5) healthcheck script
[ -f /usr/local/bin/logos_healthcheck.sh ] && emit_file /usr/local/bin/logos_healthcheck.sh

# 6) Живые .env → в слепок как обезличенные *.example
sanitize_env(){
  sed -E \
    -e 's/^(LRB_NODE_SK_HEX)=.*/\1=CHANGE_ME_64_HEX/' \
    -e 's/^(LRB_ADMIN_KEY)=.*/\1=CHANGE_ADMIN_KEY/' \
    -e 's/^(LRB_BRIDGE_KEY)=.*/\1=CHANGE_ME/' \
    -e 's/^(HOT_WALLET_PRIVATE_KEY)=.*/\1=CHANGE_ME/' \
    -e 's/^(TG_TOKEN)=.*/\1=CHANGE_ME/' \
    -e 's/^(TG_CHAT_ID)=.*/\1=CHANGE_ME/' \
    "$1"
}
if ls /etc/logos/node-*.env >/dev/null 2>&1; then
  for f in /etc/logos/node-*.env; do
    tmp="$(mktemp)"; sanitize_env "$f" > "$tmp"
    sz=$(stat -c%s "$tmp" 2>/dev/null || echo 0)
    add_head "${f}.example" "$sz"
    cat "$tmp" >> "$OUT"
    add_tail
    rm -f "$tmp"
  done
fi

echo "[ok] wrote $OUT"

```

## FILE: /root/logos_lrb/tools/repo_audit.sh  (size=3155b)
```
#!/usr/bin/env bash
set -euo pipefail

fail=0
pass(){ printf "  [OK]  %s\n" "$1"; }
err(){  printf "  [FAIL] %s\n" "$1"; fail=1; }

echo "== GIT STATUS =="
git rev-parse --is-inside-work-tree >/dev/null 2>&1 || { echo "not a git repo"; exit 1; }
git status --porcelain

echo "== CORE CODE =="
[ -d lrb_core/src ] && pass "lrb_core/src" || err "lrb_core/src missing"
[ -f lrb_core/src/ledger.rs ] && pass "lrb_core ledger.rs" || err "ledger.rs missing"
[ -f lrb_core/src/rcp_engine.rs ] && pass "lrb_core rcp_engine.rs" || err "rcp_engine.rs missing"
[ -f lrb_core/src/phase_filters.rs ] && pass "lrb_core phase_filters.rs" || err "phase_filters.rs missing"
[ -f lrb_core/src/crypto.rs ] && pass "lrb_core crypto.rs (AEAD)" || err "crypto.rs missing"

echo "== NODE =="
for f in node/src/main.rs node/src/api.rs node/src/metrics.rs node/src/guard.rs node/src/storage.rs node/src/version.rs; do
  [ -f "$f" ] && pass "$f" || err "$f missing"
done
[ -f node/src/openapi.json ] && pass "node/src/openapi.json" || err "openapi.json missing"
[ -f node/build.rs ] && pass "node/build.rs" || err "node/build.rs missing"
[ -f node/Cargo.toml ] && pass "node/Cargo.toml" || err "node/Cargo.toml missing"

echo "== MODULES DIR =="
[ -d modules ] && pass "modules/ present" || err "modules/ missing"

echo "== WALLET =="
for f in www/wallet/index.html www/wallet/wallet.css www/wallet/wallet.js; do
  [ -f "$f" ] && pass "$f" || err "$f missing"
done

echo "== INFRA =="
for f in infra/systemd/logos-node@.service infra/systemd/logos-healthcheck.service infra/systemd/logos-healthcheck.timer \
         infra/nginx/logos-api-lb.conf.example; do
  [ -f "$f" ] && pass "$f" || err "$f missing"
done

echo "== SCRIPTS =="
[ -f scripts/bootstrap_node.sh ] && pass "scripts/bootstrap_node.sh" || err "bootstrap_node.sh missing"
[ -f scripts/logos_healthcheck.sh ] && pass "scripts/logos_healthcheck.sh" || err "logos_healthcheck.sh missing"

echo "== TOOLS =="
[ -f tools/bench/go/bench.go ] && pass "bench v4: tools/bench/go/bench.go" || err "bench.go missing"
[ -f tools/sdk/ts/index.mjs ] && pass "TS SDK: tools/sdk/ts/index.mjs" || err "TS SDK missing"
[ -f tools/sdk/ts/sdk_test.mjs ] && pass "TS SDK test" || err "TS SDK test missing"
[ -f tools/sdk/go/logosapi.go ] && pass "Go SDK: tools/sdk/go/logosapi.go" || err "Go SDK missing"

echo "== CONFIGS / EXAMPLES =="
ls -1 configs/env/*.example >/dev/null 2>&1 && pass "env examples present" || err "env examples missing"
# убедимся что реальные .env не попали
if git ls-files | grep -E '^configs/env/.*\.env$' >/dev/null; then
  err "real .env found in repo"
else
  pass "no real .env tracked"
fi

echo "== SNAPSHOTS (optional) =="
[ -d snapshots ] && echo "  [info] snapshots/ exists (ok)"; true

echo "== SIZE / SUMMARY =="
echo "  tracked files: $(git ls-files | wc -l)"
echo "  repo disk size: $(du -sh . | cut -f1)"

echo "== SECRET LEAK SCAN (quick) =="
git grep -nE '(PRIVATE|SECRET|BEGIN (RSA|EC) PRIVATE KEY)' || true
git grep -nE 'LRB_NODE_SK_HEX=[0-9a-fA-F]{64}$' || true

echo
if [ $fail -eq 0 ]; then
  echo "[RESULT] REPO OK"
else
  echo "[RESULT] FAILS PRESENT"; exit 1
fi

```

## FILE: /root/logos_lrb/tools/sdk/go/logosapi.go  (size=2975b)
```
package logosapi

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"time"
)

type Client struct {
	Base   string
	Admin  string
	Client *http.Client
	TO     time.Duration
}

func New(base string, admin string, timeout time.Duration) *Client {
	if timeout == 0 { timeout = 10 * time.Second }
	return &Client{
		Base:  trimSlash(base),
		Admin: admin,
		Client: &http.Client{ Timeout: timeout },
		TO: timeout,
	}
}

func trimSlash(s string) string {
	if len(s) > 0 && s[len(s)-1] == '/' { return s[:len(s)-1] }
	return s
}

func (c *Client) req(ctx context.Context, method, path string, body io.Reader, out any, hdr map[string]string) error {
	req, _ := http.NewRequestWithContext(ctx, method, c.Base+path, body)
	req.Header.Set("Content-Type", "application/json")
	for k,v := range hdr { req.Header.Set(k,v) }
	if c.Admin != "" { req.Header.Set("X-Admin-Key", c.Admin) }

	resp, err := c.Client.Do(req)
	if err != nil { return err }
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil { return json.Unmarshal(b, out) }
	return nil
}

type Healthz struct { Status string `json:"status"` }
type HeadResp struct { Height uint64 `json:"height"`; Finalized bool `json:"finalized"` }
type BalanceResp struct { Rid string `json:"rid"`; Balance uint64 `json:"balance"`; Nonce uint64 `json:"nonce"` }

type TxIn struct {
	From string `json:"from"`
	To   string `json:"to"`
	Amount uint64 `json:"amount"`
	Nonce  uint64 `json:"nonce"`
	SigHex string `json:"sig_hex"`
}
type SubmitTxBatchReq struct { Txs []TxIn `json:"txs"` }
type TxResult struct { Idx int `json:"idx"`; Status string `json:"status"`; Code int `json:"code"`; Reason string `json:"reason"` }
type SubmitTxBatchResp struct { Accepted int `json:"accepted"`; Rejected int `json:"rejected"`; NewHeight uint64 `json:"new_height"`; Results []TxResult `json:"results"` }

func (c *Client) Healthz(ctx context.Context) (Healthz, error) { var h Healthz; err := c.req(ctx,"GET","/healthz",nil,&h,nil); return h,err }
func (c *Client) Head(ctx context.Context) (HeadResp, error) { var h HeadResp; err := c.req(ctx,"GET","/head",nil,&h,nil); return h,err }
func (c *Client) Balance(ctx context.Context, rid string) (BalanceResp, error) {
	var b BalanceResp; err := c.req(ctx,"GET","/balance/"+rid,nil,&b,nil); return b,err }
func (c *Client) DebugCanon(ctx context.Context, tx map[string]any) (map[string]string, error) {
	var out map[string]string
	buf, _ := json.Marshal(map[string]any{"tx":tx})
	err := c.req(ctx,"POST","/debug_canon", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}
func (c *Client) SubmitBatch(ctx context.Context, req SubmitTxBatchReq) (SubmitTxBatchResp, error) {
	var out SubmitTxBatchResp
	buf, _ := json.Marshal(req)
	err := c.req(ctx,"POST","/submit_tx_batch", io.NopCloser(io.NewReader(buf)), &out, nil)
	return out, err
}

```

## FILE: /root/logos_lrb/tools/sdk/go/main.go  (size=4007b)
```
// main.go — самоcтоятельный smoke-клиент для LOGOS LRB (без внешних зависимостей).
// Использование:
//   BASE=http://127.0.0.1:8080 go run ./main.go
//   BASE=https://45-159-248-232.sslip.io/api go run ./main.go
// Переменные:
//   RID=<base58>            # для запроса баланса
//   TO=<base58>             # для пробного submit (ожидаемая ошибка из-за фиктивной подписи)
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"
)

type Healthz struct{ Status string `json:"status"` }
type HeadResp struct {
	Height    uint64 `json:"height"`
	Finalized bool   `json:"finalized"`
}
type BalanceResp struct {
	Rid     string `json:"rid"`
	Balance uint64 `json:"balance"`
	Nonce   uint64 `json:"nonce"`
}

func baseURL() string {
	b := os.Getenv("BASE")
	if b == "" {
		b = "http://127.0.0.1:8080"
	}
	// убрать завершающий слэш, чтобы не было двойных //
	if b[len(b)-1] == '/' {
		b = b[:len(b)-1]
	}
	return b
}

func httpClient() *http.Client {
	return &http.Client{Timeout: 10 * time.Second}
}

func reqJSON(ctx context.Context, method, url string, body any, out any) error {
	var rdr io.Reader
	if body != nil {
		buf, _ := json.Marshal(body)
		rdr = bytes.NewReader(buf)
	}
	req, _ := http.NewRequestWithContext(ctx, method, url, rdr)
	req.Header.Set("Content-Type", "application/json")

	resp, err := httpClient().Do(req)
	if err != nil {
		return fmt.Errorf("request failed: %w", err)
	}
	defer resp.Body.Close()

	b, _ := io.ReadAll(resp.Body)
	if resp.StatusCode < 200 || resp.StatusCode >= 300 {
		return fmt.Errorf("http %d: %s", resp.StatusCode, string(b))
	}
	if out != nil {
		if err := json.Unmarshal(b, out); err != nil {
			return fmt.Errorf("decode failed: %w", err)
		}
	}
	return nil
}

func main() {
	ctx := context.Background()
	base := baseURL()
	fmt.Println("[*] BASE =", base)

	// /healthz
	var hz Healthz
	if err := reqJSON(ctx, "GET", base+"/healthz", nil, &hz); err != nil {
		fmt.Println("healthz ERR:", err)
		os.Exit(1)
	}
	fmt.Println("[*] healthz:", hz.Status)

	// /head
	var head HeadResp
	if err := reqJSON(ctx, "GET", base+"/head", nil, &head); err != nil {
		fmt.Println("head ERR:", err)
		os.Exit(1)
	}
	fmt.Printf("[*] head: height=%d finalized=%v\n", head.Height, head.Finalized)

	// /balance/:rid (если задан RID)
	if rid := os.Getenv("RID"); rid != "" {
		var bal BalanceResp
		if err := reqJSON(ctx, "GET", base+"/balance/"+rid, nil, &bal); err != nil {
			fmt.Println("balance ERR:", err)
			os.Exit(1)
		}
		j, _ := json.Marshal(bal)
		fmt.Println("[*] balance:", string(j))

		// /debug_canon + /submit_tx_batch (smoke) если задан TO
		if to := os.Getenv("TO"); to != "" {
			// берём nonce из /balance (следующий будет +1)
			nextNonce := bal.Nonce + 1
			canonReq := map[string]any{"tx": map[string]any{
				"from": rid, "to": to, "amount": 1, "nonce": nextNonce,
			}}
			var canonResp map[string]string
			if err := reqJSON(ctx, "POST", base+"/debug_canon", canonReq, &canonResp); err != nil {
				fmt.Println("debug_canon ERR:", err)
				os.Exit(1)
			}
			fmt.Println("[*] canon_hex bytes:", len(canonResp["canon_hex"])/2)

			// Отправляем фиктивную подпись "00" — ожидаем ошибку (проверяем обработку ошибок API)
			batch := map[string]any{"txs": []map[string]any{
				{"from": rid, "to": to, "amount": 1, "nonce": nextNonce, "sig_hex": "00"},
			}}
			var out any
			if err := reqJSON(ctx, "POST", base+"/submit_tx_batch", batch, &out); err != nil {
				fmt.Println("[*] submit expected ERR:", err)
			} else {
				j, _ := json.Marshal(out)
				fmt.Println("[*] submit resp:", string(j))
			}
		}
	} else {
		fmt.Println("[i] RID не задан (RID=<base58>) — пропускаю /balance и submit.")
	}

	fmt.Println("OK")
}

```

## FILE: /root/logos_lrb/tools/sdk/ts/index.mjs  (size=2490b)
```
// Lightweight production SDK for LOGOS LRB (ESM, no deps). Node 18+ (global fetch).
const DEFAULT_TIMEOUT_MS = 10_000;

export class LogosApi {
  /**
   * @param {string} baseURL e.g. "http://127.0.0.1:8080/api" or "http://host:8080"
   * @param {{timeoutMs?: number, adminKey?: string}} [opt]
   */
  constructor(baseURL, opt = {}) {
    this.baseURL = baseURL.replace(/\/$/, "");
    this.timeoutMs = opt.timeoutMs ?? DEFAULT_TIMEOUT_MS;
    this.adminKey = opt.adminKey;
  }

  _url(path) {
    return this.baseURL + (path.startsWith("/") ? path : `/${path}`);
  }

  async _fetchJSON(method, path, body, headers = {}) {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), this.timeoutMs);
    try {
      const r = await fetch(this._url(path), {
        method,
        headers: {
          "Content-Type": "application/json",
          ...(this.adminKey ? { "X-Admin-Key": this.adminKey } : {}),
          ...headers,
        },
        body: body ? JSON.stringify(body) : undefined,
        signal: ctrl.signal,
      });
      const ct = r.headers.get("content-type") || "";
      let payload = null;
      if (ct.includes("application/json")) {
        payload = await r.json().catch(() => null);
      } else {
        payload = await r.text().catch(() => null);
      }
      if (!r.ok) {
        const err = new Error(`HTTP ${r.status}`);
        err.status = r.status;
        err.payload = payload;
        throw err;
      }
      return payload;
    } finally {
      clearTimeout(t);
    }
  }

  // -------- Public API
  async healthz()        { return this._fetchJSON("GET",  "/healthz"); }
  async livez()          { return this._fetchJSON("GET",  "/livez"); }
  async readyz()         { return this._fetchJSON("GET",  "/readyz"); }
  async head()           { return this._fetchJSON("GET",  "/head"); }
  async balance(rid)     { return this._fetchJSON("GET",  `/balance/${encodeURIComponent(rid)}`); }
  async debugCanon(tx)   { return this._fetchJSON("POST", "/debug_canon", { tx }); }
  async submitBatch(txs) { return this._fetchJSON("POST", "/submit_tx_batch", { txs }); }
  async faucet(rid, amount) { return this._fetchJSON("POST", "/faucet", { rid, amount }); }

  // -------- Admin
  async nodeInfo()       { return this._fetchJSON("GET",  "/node/info"); }
  async snapshot()       { return this._fetchJSON("POST", "/admin/snapshot"); }
  async restore(path)    { return this._fetchJSON("POST", "/admin/restore", { path }); }
}

```

## FILE: /root/logos_lrb/tools/sdk/ts/sdk_test.mjs  (size=1876b)
```
import { LogosApi } from "./index.mjs";

// Конфигурация
const HOST = process.env.HOST || "http://127.0.0.1:8080"; // без /api если сервер слушает напрямую
const BASE = process.env.BASE || (HOST.endsWith("/api") ? HOST : HOST + "/api");

async function main() {
  const api = new LogosApi(BASE, { timeoutMs: 10_000 });

  console.log("[*] healthz", await api.healthz());
  console.log("[*] head", await api.head());

  // RID для теста
  // (Можно сгенерить в кошельке; здесь просто smoke по faucet/balance с рандомным RID формально не пройдёт —
  // поэтому делаем только faucet на RID из кошелька, если задан)
  const RID = process.env.RID;
  if (RID) {
    console.log("[*] faucet", await api.faucet(RID, 1000000));
    console.log("[*] balance", await api.balance(RID));
  } else {
    console.log("[i] пропускаю faucet/balance: задайте RID=... в env");
  }

  // submit one (если есть RID и получатель)
  const TO = process.env.TO;
  if (RID && TO) {
    // запрос канона (реальную подпись оставим кошельку; здесь smoke-тест только на 400/401)
    const canon = await api.debugCanon({ from: RID, to: TO, amount: 1, nonce: 1 });
    console.log("[*] canon_hex len", canon.canon_hex.length);
    try {
      const resp = await api.submitBatch([{ from: RID, to: TO, amount: 1, nonce: 1, sig_hex: "00" }]);
      console.log("[*] submit", resp);
    } catch (e) {
      console.log("[*] submit expected error", e.status, e.payload?.results?.[0] ?? e.payload);
    }
  } else {
    console.log("[i] пропускаю submit: задайте RID и TO");
  }
}

main().catch(e => { console.error("ERR", e); process.exit(1); });

```

## FILE: /root/logos_lrb/tools/test_tx.sh  (size=1841b)
```
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```

## FILE: /root/logos_lrb/tools/tx_load.sh  (size=4740b)
```
#!/usr/bin/env bash
# tx_load.sh — надёжная нагрузка через LB/BE без конфликтов nonce.
# Отправка батчей строго по порядку внутри каждого RID (шарда).
# Параллельность — между шардами.
#
# Usage:
#   BACKEND=http://127.0.0.1:8080 ./tx_load.sh M K C [AMOUNT] [SHARDS]
#   (если хочешь через LB: BACKEND=http://127.0.0.1/api)
set -euo pipefail
BACKEND="${BACKEND:-http://127.0.0.1:8080}"   # куда шлём ВСЁ: faucet, canon, submit
M="${1:-1000}"     # всего tx
K="${2:-100}"      # размер батча
C="${3:-10}"       # параллельность шардов (RID)
AMOUNT="${4:-1}"
SHARDS="${5:-$C}"  # число независимых отправителей (RID)

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need seq; need awk; need sort; need xargs

work="$(mktemp -d -t lrb_load_XXXX)"
trap 'rm -rf "$work"' EXIT
echo "[*] work dir: $work"
per_shard=$(( (M + SHARDS - 1) / SHARDS ))
echo "[*] total=$M  shards=$SHARDS  per_shard≈$per_shard  batch=$K  parallel=$C  amount=$AMOUNT"
echo "[*] BACKEND=$BACKEND"

make_rid() {
  local out="$1"
  openssl genpkey -algorithm Ed25519 -out "$out/ed25519.sk.pem" >/dev/null 2>&1
  openssl pkey -in "$out/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$out/pk.hex"
  python3 - "$out/pk.hex" > "$out/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
}

# 1) Готовим шардовые каталоги: RID, faucet, nonce0
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"; mkdir -p "$sd/batches"
  make_rid "$sd"
  RID=$(cat "$sd/RID.txt")
  echo "[*] shard $s RID=$RID"
  curl -s -X POST "$BACKEND/faucet" -H 'Content-Type: application/json' \
    -d "{\"rid\":\"${RID}\",\"amount\":500000000}" >/dev/null
  NONCE0=$(curl -s "$BACKEND/balance/${RID}" | jq -r .nonce)
  echo "$NONCE0" > "$sd/nonce0"
done

# 2) Генерация подписанных tx для каждого шарда (последовательно → без гонок)
for s in $(seq 1 "$SHARDS"); do
  sd="$work/shard_$s"
  RID=$(cat "$sd/RID.txt")
  SK="$sd/ed25519.sk.pem"
  NONCE0=$(cat "$sd/nonce0")
  start=$(( (s-1)*per_shard + 1 ))
  end=$(( s*per_shard )); [ "$end" -gt "$M" ] && end="$M"
  count=$(( end - start + 1 )); [ "$count" -le 0 ] && continue
  echo "[*] shard $s: tx $start..$end (count=$count)"

  : > "$sd/cur_lines.jsonl"; idx=0; file_lines=0
  for i in $(seq 1 "$count"); do
    nonce=$(( NONCE0 + i ))
    echo "{\"tx\":{\"from\":\"$RID\",\"to\":\"$RID\",\"amount\":$AMOUNT,\"nonce\":$nonce}}" > "$sd/canon_payload.json"
    CANON_HEX=$(curl -s -X POST "$BACKEND/debug_canon" -H "Content-Type: application/json" \
      --data-binary @"$sd/canon_payload.json" | jq -r .canon_hex)
    echo -n "$CANON_HEX" | xxd -r -p > "$sd/canon.bin"
    openssl pkeyutl -sign -rawin -inkey "$SK" -in "$sd/canon.bin" -out "$sd/sig.bin" >/dev/null 2>&1
    SIG_HEX=$(xxd -p -c 256 "$sd/sig.bin")
    printf '{"from":"%s","to":"%s","amount":%s,"nonce":%s,"sig_hex":"%s"}\n' \
      "$RID" "$RID" "$AMOUNT" "$nonce" "$SIG_HEX" >> "$sd/cur_lines.jsonl"
    file_lines=$((file_lines+1))
    if [ "$file_lines" -ge "$K" ]; then
      idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
      : > "$sd/cur_lines.jsonl"; file_lines=0
    fi
  done
  if [ "$file_lines" -gt 0 ]; then
    idx=$((idx+1)); jq -s '{txs:.}' "$sd/cur_lines.jsonl" > "$sd/batches/batch_${s}_$(printf "%05d" $idx).json"
  fi
done

# 3) Отправляем батчи ПО ШАРДАМ: внутри каждого — строго по порядку; шарды — параллельно
start_ts=$(date +%s%3N)
ls -1d "$work"/shard_* | xargs -I{} -P"$C" bash -lc '
  sd="{}"
  for f in $(ls -1 "$sd"/batches/batch_*.json | sort -V); do
    curl -s -X POST "'"$BACKEND"'/submit_tx_batch" -H "Content-Type: application/json" \
      --data-binary @"$f" | jq -c "{accepted,rejected,new_height}"
  done
'
end_ts=$(date +%s%3N)
dt=$((end_ts - start_ts))
echo "=== DONE in ${dt} ms → ~ $(( M*1000/(dt>0?dt:1) )) tx/s (client-side est) ==="

# 4) HEAD / METRICS
echo "--- HEAD ---";    curl -s "$BACKEND/head" | jq .
echo "--- METRICS ---"
curl -s "$BACKEND/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_request_duration_seconds_bucket|http_inflight_requests" \
 | head -n 120 || true

```

## FILE: /root/logos_lrb/tools/tx_one.sh  (size=2659b)
```
#!/usr/bin/env bash
# tx_one.sh — e2e: генерирует ключ, делает RID, faucet, строит канон, подписывает Ed25519 (raw),
# отправляет /submit_tx_batch и печатает head/balance/метрики.
# Usage: PORT=8080 ./tx_one.sh [AMOUNT]
set -euo pipefail
PORT="${PORT:-8080}"
AMOUNT="${1:-1234}"

work="$(mktemp -d -t lrb_one_XXXX)"
trap 'rm -rf "$work"' EXIT

need() { command -v "$1" >/dev/null || { echo "need $1"; exit 1; }; }
need curl; need jq; need openssl; need xxd; need python3

# Key + RID
openssl genpkey -algorithm Ed25519 -out "$work/ed25519.sk.pem" >/dev/null 2>&1
openssl pkey -in "$work/ed25519.sk.pem" -pubout -outform DER | tail -c 32 | xxd -p -c 32 > "$work/pk.hex"
python3 - "$work/pk.hex" > "$work/RID.txt" <<'PY'
import sys
ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
pk=bytes.fromhex(open(sys.argv[1]).read().strip())
n=int.from_bytes(pk,'big'); s=""
while n>0: n,r=divmod(n,58); s=ALPH[r]+s
z=0
for b in pk:
    if b==0: z+=1
    else: break
print("1"*z + (s or "1"))
PY
RID=$(cat "$work/RID.txt"); echo "RID=$RID"

# Faucet + state
curl -s -X POST "http://127.0.0.1:${PORT}/faucet" -H 'Content-Type: application/json' \
  -d "{\"rid\":\"${RID}\",\"amount\":1000000}" | jq .
STATE=$(curl -s "http://127.0.0.1:${PORT}/balance/${RID}")
NONCE_CUR=$(jq -r .nonce <<<"$STATE"); NONCE=$((NONCE_CUR+1))
echo "nonce: $NONCE_CUR -> $NONCE"

# Canon
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" \
  '{tx:{from:$f,to:$t,amount:$a,nonce:$n}}' > "$work/canon_payload.json"
CANON_HEX=$(curl -s -X POST "http://127.0.0.1:${PORT}/debug_canon" -H 'Content-Type: application/json' \
  --data-binary @"$work/canon_payload.json" | jq -r .canon_hex)
echo -n "$CANON_HEX" | xxd -r -p > "$work/canon.bin"

# Sign
openssl pkeyutl -sign -rawin -inkey "$work/ed25519.sk.pem" -in "$work/canon.bin" -out "$work/sig.bin" >/dev/null 2>&1
SIG_HEX=$(xxd -p -c 256 "$work/sig.bin")

# Batch
jq -n --arg f "$RID" --arg t "$RID" --argjson a "$AMOUNT" --argjson n "$NONCE" --arg s "$SIG_HEX" \
  '{txs:[{from:$f,to:$t,amount:$a,nonce:$n,sig_hex:$s}]}' > "$work/batch.json"
curl -s -X POST "http://127.0.0.1:${PORT}/submit_tx_batch" -H 'Content-Type: application/json' \
  --data-binary @"$work/batch.json" | jq .

# Head / post state / metrics
echo "--- HEAD ---";         curl -s "http://127.0.0.1:${PORT}/head" | jq .
echo "--- POST ---";         curl -s "http://127.0.0.1:${PORT}/balance/${RID}" | jq .
echo "--- METRICS ---";      curl -s "http://127.0.0.1:${PORT}/metrics" \
 | grep -E "lrb_tx_|submit_tx_batch|http_inflight_requests" | head -n 40 || true

```

## FILE: /root/logos_lrb/wallet-proxy/app.py  (size=7115b)
```
import os, json, time, asyncio
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True)
    rid = Column(String, index=True, nullable=False)
    token = Column(String, nullable=False)
    network = Column(String, nullable=False)
    index = Column(Integer, nullable=False, default=0)
    address = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda:int(time.time()))
Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True)
    txid = Column(String, unique=True, nullable=False)
    rid = Column(String, index=True)
    token = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
        if w3.is_connected():
            USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable"); w3=None
    except Exception as e:
        print("WARN web3 init error:", e); w3=None; USDT=None

# ====== HTTP helper ======
async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(CORSMiddleware, allow_origins=CORS if CORS else ["*"],
                   allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
class TopupResponse(BaseModel):
    rid: str; token: str; network: str; address: str
class WithdrawRequest(BaseModel):
    rid: str; token: Literal["USDT"]="USDT"; network: Literal["ETH"]="ETH"
    amount: int; to_address: str; request_id: str
class QuoteRequest(BaseModel):
    from_token: str; to_token: str; amount: int
class QuoteResponse(BaseModel):
    price: float; expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ   = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR= Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return app.responses.Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# ====== Endpoints ======
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3: raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")
    deposit_address = w3.eth.account.from_key(HOT_PK).address
    with Session(engine) as s:
        dm = s.execute(select(DepositMap).where(
            DepositMap.rid==req.rid, DepositMap.token==req.token, DepositMap.network==req.network
        )).scalar_one_or_none()
        if dm is None:
            s.add(DepositMap(rid=req.rid, token=req.token, network=req.network, address=deposit_address))
            s.commit()
    return TopupResponse(rid=req.rid, token=req.token, network=req.network, address=deposit_address)

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount<=0: raise HTTPException(400,"amount<=0")
        if not w3 or not USDT: raise HTTPException(503, "ETH RPC not connected")
        acct = w3.eth.account.from_key(HOT_PK)
        # redeem
        hdr = {"X-Bridge-Key": BRIDGE_KEY} if not BRIDGE_KEY.startswith("ey") else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem", {
            "rid": req.rid, "amount": req.amount, "request_id": req.request_id
        }, hdr)
        if st//100 != 2: raise HTTPException(st, f"bridge redeem failed: {data}")
        # ERC-20
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(Web3.to_checksum_address(req.to_address), int(req.amount)).build_transaction({
            "chainId": w3.eth.chain_id, "from": acct.address, "nonce": nonce,
            "gas": 90000, "maxFeePerGas": w3.to_wei("30","gwei"), "maxPriorityFeePerGas": w3.to_wei("1","gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()
        with Session(engine) as s: s.add(SeenTx(txid=tx_hash, rid=req.rid, token=req.token, network=req.network)); s.commit()
        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc(); raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc(); raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```

## FILE: /root/logos_lrb/wallet-proxy/requirements.txt  (size=1147b)
```
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```

## FILE: /root/logos_lrb/wallet-proxy/scanner.py  (size=5538b)
```
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```

## FILE: /root/logos_lrb/www/explorer/explorer.css  (size=898b)
```
body { font-family: system-ui, sans-serif; margin: 0; background: #0b0c10; color: #e6edf3; }
header { padding: 12px; background: #11151a; border-bottom: 1px solid #1e242c; display:flex; justify-content:space-between; }
main { padding: 12px; display: grid; gap: 20px; }
section { background: #141a21; padding: 12px; border-radius: 10px; }
button { padding: 10px 14px; border-radius: 8px; border: none; margin: 4px; cursor: pointer; background: #1665c1; color: #fff; font-weight: 600; }
button:hover { background: #1f77d0; }
input { padding: 8px; margin: 4px; border-radius: 6px; border: 1px solid #333; background: #0b0c10; color: #e6edf3; width: 100%; max-width: 380px; }
pre { background: #0e1116; padding: 8px; border-radius: 6px; overflow-x: auto; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; }
th, td { padding: 6px 8px; border-bottom: 1px solid #333; font-size: 13px; }

```

## FILE: /root/logos_lrb/www/explorer/explorer.js  (size=3977b)
```
// LOGOS Explorer – history debug + stable fill
const API = location.origin + "/api";
const $  = s => document.querySelector(s);
const out= (id,v)=>{$(id).textContent=(typeof v==="string")?v:JSON.stringify(v,null,2)};
const fmtNum=n=>Number(n).toLocaleString("ru-RU");
const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

async function jget(path){
  const r=await fetch(API+path,{cache:"no-store"});
  if(!r.ok) throw new Error(r.status+" "+(await r.text()).slice(0,400));
  return r.json();
}

// status
document.addEventListener("DOMContentLoaded",()=>{ const s=$("#jsStat"); if(s){ s.style.color="#0bd464"; s.textContent="js: готов"; }});

// HEAD / ECONOMY
let autoTimer=null;
async function fetchHead(){ try{ out("out-head", await jget("/head")); }catch(e){ out("out-head","ERR: "+e.message); } }
async function fetchEconomy(){ try{ out("out-economy", await jget("/economy")); }catch(e){ out("out-economy","ERR: "+e.message); } }
function toggleAuto(){
  if(autoTimer){ clearInterval(autoTimer); autoTimer=null; $("#btn-auto").textContent="Автообновление: выключено"; return; }
  const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
  tick(); autoTimer=setInterval(tick,5000);
  $("#btn-auto").textContent="Автообновление: включено";
}

// BLOCK / MIX
async function fetchBlock(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget("/block/"+h)); }catch(e){ out("out-block","ERR: "+e.message); }
}
async function fetchMix(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget(`/block/${h}/mix`)); }catch(e){ out("out-block","ERR: "+e.message); }
}

// HISTORY
let histRid="", limit=20, fromNonce=0, nextFrom=null, prevStack=[];
function renderHistory(arr){
  const tb=$("#tbl-history tbody"); tb.innerHTML="";
  if(!arr || arr.length===0){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td colspan="6" style="opacity:.8">0 записей</td>`;
    tb.appendChild(tr);
  } else {
    arr.forEach(tx=>{
      const tr=document.createElement("tr");
      tr.innerHTML=`<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                   `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    });
  }
  $("#hist-info").textContent=`RID=${histRid} · from=${fromNonce} · limit=${limit} · next=${nextFrom??"-"}`;
  $("#btn-prev").disabled = (prevStack.length===0);
  $("#btn-next").disabled = (nextFrom==null);
}

async function pageHistory(rid, from, lim){
  const q=new URLSearchParams({from:String(from||0),limit:String(lim||20)});
  const j=await jget(`/history/${rid}?`+q.toString());
  // DEBUG: покажем сырой ответ под таблицей
  out("out-history", j); $("#out-history").style.display="block";
  const arr=j.items || j.txs || [];
  nextFrom=(typeof j.next_from!=="undefined")?j.next_from:null;
  renderHistory(arr);
}

async function fetchHistory(){
  histRid=($("#inp-rid").value||"").trim();
  limit=Math.max(1, Number($("#inp-limit").value)||20);
  if(!histRid){ alert("Укажи RID"); return; }
  fromNonce=0; nextFrom=null; prevStack=[];
  try{ await pageHistory(histRid, fromNonce, limit); }catch(e){ alert("ERR: "+e.message); }
}
async function prevPage(){ if(prevStack.length===0) return; fromNonce=prevStack.pop(); await pageHistory(histRid, fromNonce, limit); }
async function nextPage(){ if(nextFrom==null) return; prevStack.push(fromNonce); fromNonce=nextFrom; await pageHistory(histRid, fromNonce, limit); }

// экспорт под onclick
window.fetchHead=fetchHead; window.fetchEconomy=fetchEconomy; window.toggleAuto=toggleAuto;
window.fetchBlock=fetchBlock; window.fetchMix=fetchMix;
window.fetchHistory=fetchHistory; window.prevPage=prevPage; window.nextPage=nextPage;

```

## FILE: /root/logos_lrb/www/explorer/index.html  (size=8802b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Explorer — v2 (inline)</title>
  <style>
    :root{--bg:#0b0c10;--card:#11151a;--line:#1e242c;--muted:#9aa4af;--txt:#e6edf3;--btn:#1665c1;--btn-b:#3b7ddd;}
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--txt)}
    header{padding:12px;background:var(--card);border-bottom:1px solid var(--line);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    header h1{font-size:18px;margin:0}
    #jsStat{font-size:12px;margin-left:auto}
    main{max-width:1100px;margin:18px auto;padding:0 12px}
    section{background:var(--card);margin:12px 0;border-radius:14px;padding:14px;border:1px solid var(--line)}
    h3{margin:6px 0 12px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row>.grow{flex:1 1 360px}
    .row>.fit{flex:0 0 140px}
    input{width:100%;padding:10px;border-radius:10px;border:1px solid var(--line);background:#0b0f14;color:#e6edf3}
    button{padding:10px 14px;border-radius:10px;border:1px solid var(--btn-b);background:var(--btn);color:#fff;font-weight:600;cursor:pointer}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b0f14;border:1px solid var(--line);border-radius:10px;padding:10px;overflow:auto;margin:8px 0 0}
    .cards{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:900px){.cards{grid-template-columns:1fr}}
    .table-wrap{overflow-x:auto;border:1px solid var(--line);border-radius:10px;margin-top:8px}
    table{width:100%;border-collapse:collapse;min-width:700px}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px;white-space:nowrap}
    .muted{color:#9aa4af}
    .pill{border:1px solid var(--line);padding:8px 10px;border-radius:10px;background:#0b0f14}
  </style>
</head>
<body>
<header>
  <h1>LOGOS LRB — исследователь</h1>
  <div class="pill">
    <input id="q" placeholder="Поиск: RID, высота блока или псевдо-txid from:nonce" style="min-width:260px">
    <button onclick="search()">Найти</button>
  </div>
  <div id="jsStat">js: загрузка…</div>
</header>

<main>

  <section class="cards">
    <div>
      <h3>Голова</h3>
      <div class="btns">
        <button onclick="fetchHead()">GET /head</button>
        <button onclick="toggleAuto()">Автообновление</button>
      </div>
      <pre id="out-head"></pre>
    </div>
    <div>
      <h3>Эконом</h3>
      <button onclick="fetchEconomy()">GET /economy</button>
      <pre id="out-economy"></pre>
    </div>
  </section>

  <section>
    <h3>Блок</h3>
    <div class="row">
      <div class="grow"><label class="muted">высота блока</label><input id="inp-height" type="number" min="1" placeholder="например 1"></div>
      <div class="grow btns" style="align-items:flex-end">
        <button onclick="fetchBlock()">/block/:height</button>
        <button onclick="fetchMix()">/block/:height/mix</button>
        <button onclick="loadLatest()">Последние блоки</button>
      </div>
    </div>
    <div class="table-wrap" id="latest-wrap" style="display:none">
      <table><thead><tr><th>height</th><th>ts</th><th>finalized</th></tr></thead><tbody id="latest"></tbody></table>
    </div>
    <pre id="out-block"></pre>
  </section>

  <section>
    <h3>Адрес (RID)</h3>
    <div class="row">
      <div class="grow"><label class="muted">RID (base58)</label><input id="inp-rid" placeholder="вставь RID"></div>
      <div class="fit"><label class="muted">limit</label><input id="inp-limit" type="number" min="1" value="20"></div>
      <div class="grow btns" style="align-items:flex-end"><button onclick="fetchHistory()">GET /history</button></div>
    </div>
    <div class="table-wrap">
      <table id="tbl">
        <thead><tr><th>nonce</th><th>from</th><th>to</th><th>amount</th><th>height</th><th>ts</th></tr></thead>
        <tbody id="hist-body"></tbody>
      </table>
    </div>
    <pre id="out-history" style="display:none"></pre>
  </section>

</main>

<script>
(function(){
  const API = location.origin + "/api";
  const $  = s => document.querySelector(s);
  const setStat = (t,ok)=>{ const s=$("#jsStat"); if(!s) return; s.textContent=t; s.style.color=ok?"#0bd464":"#ff5252"; };
  const fmtNum=n=>Number(n).toLocaleString("ru-RU");
  const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

  async function jget(path){
    try{ const r=await fetch(API+path,{cache:"no-store"}); if(!r.ok) return {error:r.status+" "+(await r.text()).slice(0,200)}; return await r.json(); }
    catch(e){ return {error:String(e)}; }
  }

  // HEAD & ECON
  let autoTimer=null;
  window.fetchHead = async ()=>{ $("#out-head").textContent = JSON.stringify(await jget("/head"), null, 2); };
  window.fetchEconomy = async ()=>{ $("#out-economy").textContent = JSON.stringify(await jget("/economy"), null, 2); };
  window.toggleAuto = ()=>{
    if(autoTimer){ clearInterval(autoTimer); autoTimer=null; setStat("js: авто выкл", true); return; }
    const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
    tick(); autoTimer=setInterval(tick, 5000); setStat("js: авто вкл", true);
  };

  // BLOCKS
  window.fetchBlock = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget("/block/"+h), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.fetchMix = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget(`/block/${h}/mix`), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.loadLatest = async ()=>{
    const head=await jget("/head");
    const H = head && head.height ? Number(head.height) : 0;
    const tbody=$("#latest"); tbody.innerHTML="";
    if(!H){ $("#latest-wrap").style.display="none"; return; }
    const from=Math.max(1,H-9);  // последние 10
    for(let h=H; h>=from; h--){
      const b = await jget("/block/"+h);
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${h}</td><td>${b.ts_ms?fmtTs(b.ts_ms):""}</td><td>${b.finalized??""}</td>`;
      tbody.appendChild(tr);
    }
    $("#latest-wrap").style.display="block";
    $("#out-block").textContent = "";
  };

  // HISTORY
  function renderRows(arr){
    const tb=$("#hist-body"); tb.innerHTML="";
    if(!arr || arr.length===0){ const tr=document.createElement("tr"); tr.innerHTML='<td colspan="6" class="muted">0 записей</td>'; tb.appendChild(tr); return; }
    for(const tx of arr){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                     `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    }
  }
  window.fetchHistory = async ()=>{
    const rid = ($("#inp-rid").value||"").trim(); if(!rid){ alert("Укажи RID"); return; }
    const lim = Math.max(1, Number($("#inp-limit").value)||20);
    const raw = await jget(`/history/${encodeURIComponent(rid)}?limit=${lim}`);
    $("#out-history").style.display="block"; $("#out-history").textContent=JSON.stringify(raw,null,2);
    const arr = (raw && (raw.items||raw.txs)) ? (raw.items||raw.txs) : [];
    renderRows(arr);
  };

  // SEARCH (RID / block height / pseudo txid "from:nonce")
  window.search = async ()=>{
    const q = ($("#q").value||"").trim();
    if(!q) return;
    if(/^\d+$/.test(q)){ $("#inp-height").value=q; await fetchBlock(); return; }
    if(/^[1-9A-HJ-NP-Za-km-z]+$/.test(q) && q.length>30){ $("#inp-rid").value=q; await fetchHistory(); return; }
    if(q.includes(":")){ // псевдо-txid from:nonce
      const [from,nonce] = q.split(":");
      $("#inp-rid").value = from;
      $("#inp-limit").value = 50;
      await fetchHistory();
      // подсветим найденную строку
      [...document.querySelectorAll("#hist-body tr")].forEach(tr=>{
        if(tr.firstChild && tr.firstChild.textContent===(nonce||"").trim()){ tr.style.background="#132235"; }
      });
      return;
    }
    alert("Не распознан формат запроса. Используй: RID, номер блока, или from:nonce");
  };

  // boot mark
  setStat("js: готов", true);
})();
</script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/app.html  (size=3367b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c;position:sticky;top:0}
    h1{font-size:18px;margin:0}
    main{max-width:1024px;margin:24px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    input,button,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    small{opacity:.8}
  </style>
</head>
<body>
<header>
  <h1>LOGOS Wallet — Кошелёк</h1>
</header>
<main>
  <section>
    <div class="grid">
      <div>
        <h3>Твой RID / Публичный ключ</h3>
        <textarea id="pub" class="mono" rows="4" readonly></textarea>
        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="btn-lock" class="secondary">Выйти (заблокировать)</button>
          <button id="btn-nonce" class="secondary">Получить nonce</button>
        </div>
        <p><small>Ключ в памяти. Закроешь вкладку — понадобится пароль на странице входа.</small></p>
      </div>
      <div>
        <h3>Баланс</h3>
        <div class="grid">
          <div><label>RID</label><input id="rid-balance" class="mono" placeholder="RID (base58)"/></div>
          <div><label>&nbsp;</label><button id="btn-balance">Показать баланс</button></div>
        </div>
        <pre id="out-balance" class="mono" style="margin-top:12px"></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>Подпись и отправка (batch)</h3>
    <div class="grid">
      <div><label>Получатель (RID)</label><input id="to" class="mono" placeholder="RID получателя"/></div>
      <div><label>Сумма (LGN)</label><input id="amount" type="number" min="1" step="1" value="1"/></div>
    </div>
    <div class="grid">
      <div><label>Nonce</label><input id="nonce" type="number" min="1" step="1" placeholder="нажми 'Получить nonce'"/></div>
      <div><label>&nbsp;</label><button id="btn-send">Подписать и отправить</button></div>
    </div>
    <pre id="out-send" class="mono" style="margin-top:12px"></pre>
  </section>

  <section>
    <h3>Мост rToken (депозит, демо)</h3>
    <div class="grid">
      <div><label>ext_txid</label><input id="ext" class="mono" placeholder="например eth_txid_0xabc"/></div>
      <div><label>&nbsp;</label><button id="btn-deposit">Deposit rLGN</button></div>
    </div>
    <pre id="out-bridge" class="mono" style="margin-top:12px"></pre>
  </section>
</main>
<script src="./app.js?v=20250906_01" defer></script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/app.js  (size=5497b)
```
// APP: ключи в памяти; RID неизменен — берём из sessionStorage, meta из acct:<RID>
const API = location.origin + '/api';
const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

const $=s=>document.querySelector(s);
const toHex=b=>[...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex=h=>new Uint8Array(h.match(/.{1,2}/g).map(x=>parseInt(x,16)));
const b58=bytes=>{const h=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');let x=BigInt('0x'+h),o='';while(x>0n){o=ALPH[Number(x%58n)]+o;x/=58n;}return o||'1';};

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){const keyMat=await crypto.subtle.importKey('raw',new TextEncoder().encode(pass),'PBKDF2',false,['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['decrypt']);}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}
async function importKey(pass, meta){
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8=await aesDecrypt(aes,meta.iv,meta.priv);
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},true,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',new Uint8Array(meta.pub),{name:'Ed25519'},true,['verify']);
  return {privateKey, publicKey};
}

// Session guard
const PASS=sessionStorage.getItem('logos_pass');
const RID =sessionStorage.getItem('logos_rid');
if(!PASS || !RID){ location.replace('./login.html'); throw new Error('locked'); }

let KEYS=null, META=null;

(async ()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS,META);
  document.getElementById('pub').value=`RID: ${RID}\nPUB (hex): ${toHex(new Uint8Array(META.pub))}`;
  document.getElementById('rid-balance').value=RID;
})();

document.getElementById('btn-lock').addEventListener('click', ()=>{ sessionStorage.clear(); location.replace('./login.html'); });

// API helpers
async function getJSON(url, body){
  const r = await fetch(url, body ? {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)} : {});
  if(!r.ok){ throw new Error(`${r.status} ${await r.text()}`); }
  return r.json();
}
async function getNonce(rid){ const j=await getJSON(`${API}/balance/${rid}`); return j.nonce||0; }
async function canonHex(from,to,amount,nonce){
  const r=await fetch(`${API}/debug_canon`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({tx:{from,to,amount:Number(amount),nonce:Number(nonce)}})});
  if(!r.ok){ throw new Error(`/debug_canon ${r.status}`); }
  return (await r.json()).canon_hex;
}
async function submitBatch(txs){
  const r=await fetch(`${API}/submit_tx_batch`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({txs})});
  if(!r.ok){ throw new Error(`/submit_tx_batch ${r.status}`); }
  return r.json();
}
async function deposit(rid, amount, ext){
  const r=await fetch(`${API}/bridge/deposit`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({rid,amount:Number(amount),ext_txid:ext})});
  return {status:r.status, text:await r.text()};
}
async function signCanon(privateKey, canonHex){
  const msg=fromHex(canonHex);
  const sig=await crypto.subtle.sign('Ed25519', privateKey, msg);
  return [...new Uint8Array(sig)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

// Buttons
document.getElementById('btn-nonce').addEventListener('click', async ()=>{
  try{ const n=await getNonce(RID); document.getElementById('nonce').value=String(n+1); }
  catch(e){ alert('ERR '+e); }
});

document.getElementById('btn-balance').addEventListener('click', async ()=>{
  try{ const rid=document.getElementById('rid-balance').value.trim(); const j=await getJSON(`${API}/balance/${rid}`); document.getElementById('out-balance').textContent=JSON.stringify(j,null,2); }
  catch(e){ document.getElementById('out-balance').textContent=String(e); }
});

document.getElementById('btn-send').addEventListener('click', async ()=>{
  const to=document.getElementById('to').value.trim();
  const amount=document.getElementById('amount').value;
  const nonce=document.getElementById('nonce').value;
  const out=document.getElementById('out-send');
  try{
    const ch = await canonHex(RID,to,amount,nonce);
    const sig= await signCanon(KEYS.privateKey,ch);
    const res= await submitBatch([{from:RID,to,amount:Number(amount),nonce:Number(nonce),sig_hex:sig}]);
    out.textContent=JSON.stringify(res,null,2);
  }catch(e){ out.textContent=String(e); }
});

document.getElementById('btn-deposit').addEventListener('click', async ()=>{
  const ext=document.getElementById('ext').value.trim()||'eth_txid_demo';
  const r=await deposit(RID,123,ext);
  document.getElementById('out-bridge').textContent=`HTTP ${r.status}\n${r.text}`;
});

```

## FILE: /root/logos_lrb/www/wallet/auth.js  (size=6002b)
```
// AUTH v3: RID + пароль. Сохраняем под "acct:<RID>".
// Фичи: авто-подстановка last_rid, кликабельный список, чистка всех пробелов/переносов в RID.

const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const $ = s => document.querySelector(s);
const out = msg => { const el=$('#out'); if(el) el.textContent=String(msg); };

function normRid(s){ return (s||'').replace(/\s+/g,'').trim(); } // убираем все пробелы/переносы

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!crypto || !crypto.subtle) throw new Error('WebCrypto недоступен');
}

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};
const idbSet=async (k,v)=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).put(v,k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};
const idbDel=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).delete(k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){
  const keyMat=await crypto.subtle.importKey('raw',enc.encode(pass),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
}
async function aesEncrypt(aesKey,data){const iv=crypto.getRandomValues(new Uint8Array(12));const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,data);return{iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))}}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}

function b58(bytes){
  const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const hex=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');
  let x=BigInt('0x'+hex), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } return out||'1';
}

async function addAccount(rid){ const list=(await idbGet('accounts'))||[]; if(!list.includes(rid)){ list.push(rid); await idbSet('accounts',list); } }
async function listAccounts(){ return (await idbGet('accounts'))||[]; }

async function createAccount(pass){
  ensureEnv();
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  out('Создаём ключ…');
  const kp=await crypto.subtle.generateKey({name:'Ed25519'},true,['sign','verify']);
  const rawPub=new Uint8Array(await crypto.subtle.exportKey('raw',kp.publicKey));
  const rid=b58(rawPub);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey('pkcs8',kp.privateKey));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const aes=await deriveKey(pass,salt);
  const {iv,ct}=await aesEncrypt(aes,pkcs8);
  const meta={rid,pub:Array.from(rawPub),salt:Array.from(salt),iv,priv:ct};

  await idbSet('acct:'+rid,meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  out('RID создан: '+rid+' → вход…');
  location.href='./app.html';
}

async function loginAccount(rid, pass){
  ensureEnv();
  rid = normRid(rid);
  if(!rid) throw new Error('Укажи RID');
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  const meta=await idbGet('acct:'+rid);
  if(!meta){
    const list=await listAccounts();
    throw new Error('RID не найден на этом устройстве. Сохранённые RID:\n'+(list.length?list.join('\n'):'—'));
  }
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  try{ await aesDecrypt(aes,meta.iv,meta.priv); } catch(e){ throw new Error('Неверный пароль'); }

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  await idbSet('last_rid', rid);
  out('Вход…'); location.href='./app.html';
}

async function resetAll(){
  const list=await listAccounts();
  for(const rid of list){ await idbDel('acct:'+rid); }
  await idbDel('accounts'); await idbDel('last_rid');
  sessionStorage.clear();
  out('Все аккаунты удалены (DEV).');
}

function renderRidList(list){
  const wrap=$('#listWrap'), ul=$('#ridList'); ul.innerHTML='';
  if(!list.length){ wrap.style.display='block'; ul.innerHTML='<li>— пусто —</li>'; return; }
  wrap.style.display='block';
  list.forEach(rid=>{
    const li=document.createElement('li'); li.textContent=rid;
    li.addEventListener('click', ()=>{ $('#loginRid').value=rid; out('RID подставлен'); });
    ul.appendChild(li);
  });
}

// авто-подстановка last_rid при загрузке
(async ()=>{
  const last=await idbGet('last_rid'); if(last){ $('#loginRid').value=last; }
})();

// wire UI
$('#btn-login').addEventListener('click', async ()=>{
  const rid=$('#loginRid').value; const pass=$('#pass').value;
  try{ await loginAccount(rid,pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-create').addEventListener('click', async ()=>{
  const pass=$('#pass').value;
  try{ await createAccount(pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-list').addEventListener('click', async ()=>{
  try{ renderRidList(await listAccounts()); }catch(e){ out('ERR: '+e); }
});
$('#btn-reset').addEventListener('click', resetAll);

```

## FILE: /root/logos_lrb/www/wallet/index.html  (size=184b)
```
<!doctype html><meta charset="utf-8">
<title>Redirecting…</title>
<meta http-equiv="refresh" content="0; url=./login.html">
<a href="./login.html">Перейти в LOGOS Wallet</a>

```

## FILE: /root/logos_lrb/www/wallet/login.html  (size=2647b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Вход</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c}
    h1{font-size:18px;margin:0}
    main{max-width:720px;margin:48px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    small{opacity:.8}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    ul{list-style:none;padding:0;margin:8px 0}
    li{padding:8px;border:1px solid #2a313a;border-radius:8px;margin-bottom:6px;cursor:pointer;background:#0b0f14}
  </style>
</head>
<body>
<header><h1>LOGOS Wallet — Secure (WebCrypto + IndexedDB)</h1></header>
<main>
  <section>
    <h3>Вход в аккаунт</h3>
    <label>Логин (RID)</label>
    <input id="loginRid" class="mono" placeholder="Вставь RID (base58) или выбери из списка ниже"/>
    <label>Пароль</label>
    <input id="pass" type="password" placeholder="Пароль для шифрования ключа"/>

    <div class="grid" style="margin-top:12px">
      <button id="btn-login">Войти по RID + пароль</button>
      <button id="btn-create">Создать новый RID</button>
    </div>

    <div style="margin-top:12px">
      <button id="btn-list" class="secondary">Показать сохранённые RID</button>
      <button id="btn-reset" class="secondary">Сбросить все аккаунты (DEV)</button>
    </div>

    <div id="listWrap" style="display:none;margin-top:10px">
      <small>Сохранённые на этом устройстве RID (тапни, чтобы подставить):</small>
      <ul id="ridList"></ul>
    </div>

    <p><small>Ключ Ed25519 хранится зашифрованным AES-GCM (PBKDF2) в IndexedDB. Ничего не уходит в сеть.</small></p>
    <pre id="out" class="mono"></pre>
  </section>
</main>
<script src="./auth.js?v=20250906_03" defer></script>
</body>
</html>

```

## FILE: /root/logos_lrb/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```

## FILE: /etc/alertmanager/alertmanager.yml  (size=603b)
```
route:
  receiver: 'telegram'
  group_wait: 10s
  group_interval: 1m
  repeat_interval: 2h

receivers:
- name: 'telegram'
  telegram_configs:
  - bot_token: '8317523208:AAH29EJG6H0BurJ4J74Bdb2XLjcDYcK9vIc'  # ← токен в КАВЫЧКАХ
    chat_id: 6355622860                                       # ← ЦЕЛОЕ ЧИСЛО (без кавычек)
    parse_mode: HTML
    message: |
      <b>{{ .Status | toUpper }}</b> — {{ .CommonLabels.alertname }}
      {{ range .Alerts -}}
      • <b>{{ .Labels.severity }}</b> @ {{ .StartsAt }}\n
        {{ .Annotations.summary }}
      {{ end }}

```

## FILE: /etc/alertmanager/secrets.env  (size=94b)
```
TELEGRAM_BOT_TOKEN=***MASKED***
TELEGRAM_CHAT_ID=***MASKED***

```

## FILE: /etc/grafana/grafana.ini  (size=191b)
```
[server]
http_addr = 0.0.0.0
http_port = 3000
# Grafana на корне, HTTPS домен:
root_url = https://45-159-248-232.sslip.io/
# без префикса
# serve_from_sub_path = false

```

## FILE: /etc/grafana/provisioning/dashboards/lrb.yaml  (size=151b)
```
apiVersion: 1
providers:
- name: LRB
  type: file
  updateIntervalSeconds: 10
  allowUiUpdates: false
  options:
    path: /var/lib/grafana/dashboards

```

## FILE: /etc/grafana/provisioning/datasources/prom.yaml  (size=146b)
```
apiVersion: 1
datasources:
- name: Prometheus
  type: prometheus
  access: proxy
  url: http://127.0.0.1:9094
  isDefault: true
  editable: false

```

## FILE: /etc/nginx/conf.d/00_redirect_80.conf  (size=118b)
```
server {
  listen 80 default_server;
  server_name 45-159-248-232.sslip.io;
  return 301 https://$host$request_uri;
}

```

## FILE: /etc/nginx/conf.d/10_lrb_https.conf  (size=2484b)
```
# === LOGOS LRB: HTTPS сайт ===
server {
  listen 443 ssl http2;
  server_name 45-159-248-232.sslip.io;

  # TLS
  ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;
  ssl_session_cache   shared:SSL:10m;
  ssl_protocols       TLSv1.2 TLSv1.3;
  ssl_ciphers         HIGH:!aNULL:!MD5;

  # Безопасные заголовки
  add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
  add_header X-Frame-Options        SAMEORIGIN       always;
  add_header X-Content-Type-Options nosniff          always;
  add_header Referrer-Policy        strict-origin-when-cross-origin always;

  # Базовая CSP
  add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; base-uri 'self'; frame-ancestors 'self'" always;

  # Grafana на корне
  location / {
    proxy_pass         http://127.0.0.1:3000/;
    proxy_http_version 1.1;
    proxy_set_header   Host               $host;
    proxy_set_header   X-Real-IP          $remote_addr;
    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto  $scheme;
    proxy_read_timeout 60s;
    proxy_redirect     off;
  }

  # Explorer (inline, без кэша)
  location /explorer/ {
    root /opt/logos/www;
    index index.html;

    expires off;
    etag off;
    add_header Cache-Control "no-store, no-cache, must-revalidate, max-age=0" always;
    add_header Pragma "no-cache" always;
    add_header Expires "0" always;

    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; base-uri 'self'; frame-ancestors 'self'" always;

    try_files $uri $uri/ /explorer/index.html;
  }

  # Wallet
  location /wallet/ {
    root /opt/logos/www;
    index index.html;
    try_files $uri $uri/ /wallet/index.html;
  }

  # API (Axum 8080)
  location /api/ {
    proxy_pass         http://127.0.0.1:8080/;
    proxy_http_version 1.1;
    proxy_set_header   Host               $host;
    proxy_set_header   X-Real-IP          $remote_addr;
    proxy_set_header   X-Forwarded-For    $proxy_add_x_forwarded_for;
    proxy_set_header   X-Forwarded-Proto  $scheme;
    proxy_read_timeout 60s;
    proxy_redirect     off;
  }
}

```

## FILE: /etc/nginx/nginx.conf  (size=1446b)
```
user www-data;
worker_processes auto;
pid /run/nginx.pid;
error_log /var/log/nginx/error.log;
include /etc/nginx/modules-enabled/*.conf;

events {
	worker_connections 768;
	# multi_accept on;
}

http {

	##
	# Basic Settings
	##

	sendfile on;
	tcp_nopush on;
	types_hash_max_size 2048;
	# server_tokens off;

	# server_names_hash_bucket_size 64;
	# server_name_in_redirect off;

	include /etc/nginx/mime.types;
	default_type application/octet-stream;

	##
	# SSL Settings
	##

	ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE
	ssl_prefer_server_ciphers on;

	##
	# Logging Settings
	##

	access_log /var/log/nginx/access.log;

	##
	# Gzip Settings
	##

	gzip on;

	# gzip_vary on;
	# gzip_proxied any;
	# gzip_comp_level 6;
	# gzip_buffers 16 8k;
	# gzip_http_version 1.1;
	# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

	##
	# Virtual Host Configs
	##

	include /etc/nginx/conf.d/*.conf;
	include /etc/nginx/sites-enabled/*;
}


#mail {
#	# See sample authentication script at:
#	# http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript
#
#	# auth_http localhost/auth.php;
#	# pop3_capabilities "TOP" "USER";
#	# imap_capabilities "IMAP4rev1" "UIDPLUS";
#
#	server {
#		listen     localhost:110;
#		protocol   pop3;
#		proxy      on;
#	}
#
#	server {
#		listen     localhost:143;
#		protocol   imap;
#		proxy      on;
#	}
#}

```

## FILE: /etc/prometheus/prometheus.yml  (size=507b)
```
rule_files:
  - /etc/prometheus/rules/*.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

alerting:
  alertmanagers:
  - static_configs:
    - targets: ["127.0.0.1:9093"]

scrape_configs:
  # Метрики ноды LOGOS (Axum) — /metrics
  - job_name: logos_node
    static_configs:
      - targets: ['127.0.0.1:8080']
    metrics_path: /metrics

  # Node Exporter (включая lrb_exporter через textfile)
  - job_name: node
    static_configs:
      - targets: ['127.0.0.1:9100']

```

## FILE: /etc/prometheus/rules/lrb_alerts.yml  (size=1691b)
```
groups:
- name: lrb-core
  rules:
  # 1) Нода упала
  - alert: LogosNodeDown
    expr: up{job="logos_node"} == 0
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "LOGOS node is down"
      description: "Target {{ $labels.instance }} is not scraping."

  # 2) Высокий процент 5xx за 5 минут
  - alert: HighErrorRatio
    expr: |
      sum(rate(http_requests_total{job="logos_node",status=~"5.."}[5m])) 
      / clamp_min(sum(rate(http_requests_total{job="logos_node"}[5m])), 1) > 0.02
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "High 5xx ratio (>2%)"
      description: "Instance {{ $labels.instance }} 5xx > 2%."

  # 3) Высокая латентность p95 > 1.5s
  - alert: HighLatencyP95
    expr: |
      histogram_quantile(0.95,
        sum(rate(http_request_duration_seconds_bucket{job="logos_node"}[5m])) by (le)
      ) > 1.5
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "HTTP p95 latency > 1.5s"
      description: "Instance {{ $labels.instance }} p95 high."

  # 4) Застряла высота (нет роста 10 минут)
  - alert: HeightStuck
    expr: increase(lrb_head_height[10m]) < 1
    for: 10m
    labels: { severity: critical }
    annotations:
      summary: "Chain height is not increasing"
      description: "No new blocks for 10m."

  # 5) Supply превышает cap (инвариант нарушен)
  - alert: SupplyExceedsCap
    expr: lrb_supply_total > lrb_cap_total
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "Supply exceeds cap"
      description: "supply={{ $value }} > cap."

```

## FILE: /etc/prometheus/rules/lrb_core.yml  (size=3347b)
```
groups:

# ===================== LRB — Health =====================
- name: lrb-health
  rules:
  - alert: LRB_NodeDown
    expr: up{job="logos_node"} == 0
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "LOGOS node is DOWN"
      description: "Target {{ $labels.instance }} is not scraping."

  - alert: LRB_HeightStuck
    expr: increase(lrb_head_height[10m]) < 1
    for: 10m
    labels: { severity: critical }
    annotations:
      summary: "Chain height is NOT increasing"
      description: "No new blocks on {{ $labels.instance }} for 10 minutes."

  - alert: LRB_HighHTTP5xx
    expr: |
      sum(rate(http_requests_total{job="logos_node",status=~"5.."}[5m]))
      /
      clamp_min(sum(rate(http_requests_total{job="logos_node"}[5m])), 1)
      > 0.02
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "High 5xx ratio >2%"
      description: "Instance {{ $labels.instance }} 5xx ratio is high."

# ===================== LRB — Performance =====================
- name: lrb-perf
  rules:
  - alert: LRB_HighLatencyP95
    expr: |
      histogram_quantile(0.95,
        sum(rate(http_request_duration_seconds_bucket{job="logos_node"}[5m])) by (le)
      ) > 1.5
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "HTTP p95 latency > 1.5s"
      description: "{{ $labels.instance }} p95={{ $value | printf \"%.2f\" }}s"

  - alert: LRB_LowRPS
    expr: |
      sum(rate(http_requests_total{job="logos_node"}[5m])) < 0.05
      and increase(lrb_head_height[10m]) >= 1
    for: 10m
    labels: { severity: warning }
    annotations:
      summary: "Logos API RPS is near zero"
      description: "Requests are almost zero while chain progresses."

# ===================== LRB — Economy =====================
- name: lrb-economy
  rules:
  - alert: LRB_SupplyExceedsCap
    expr: lrb_supply_total > lrb_cap_total
    for: 1m
    labels: { severity: critical }
    annotations:
      summary: "Supply exceeds cap"
      description: "supply={{ $value }} > cap on {{ $labels.instance }}"

  - alert: LRB_EconomyMetricsMissing
    expr: absent(lrb_supply_total) or absent(lrb_cap_total)
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "Economy metrics are missing"
      description: "lrb_* economy metrics absent on {{ $labels.instance }}"

# ===================== Infra — Node Exporter =====================
- name: infra-node
  rules:
  - alert: HostLowMemory
    expr: node_memory_MemAvailable_bytes < 200 * 1024 * 1024
    for: 3m
    labels: { severity: warning }
    annotations:
      summary: "Low memory on host"
      description: "Available memory {{ $value | printf \"%.0f\" }} bytes"

  - alert: HostLowDisk
    expr: min(node_filesystem_avail_bytes{mountpoint="/",fstype!~"tmpfs|overlay"}) < 2 * 1024 * 1024 * 1024
    for: 5m
    labels: { severity: critical }
    annotations:
      summary: "Low disk space on /"
      description: "Free bytes {{ $value | printf \"%.0f\" }} on {{ $labels.instance }}"

  - alert: HostHighCPU
    expr: 100 - (avg by(instance) (rate(node_cpu_seconds_total{mode="idle"}[5m])) * 100) > 85
    for: 5m
    labels: { severity: warning }
    annotations:
      summary: "High CPU usage"
      description: "CPU usage {{ $value | printf \"%.1f\" }}% on {{ $labels.instance }}"

```

## FILE: /etc/systemd/system/alertmanager.service  (size=400b)
```
[Unit]
Description=Alertmanager
After=network-online.target

[Service]
EnvironmentFile=/etc/alertmanager/secrets.env
ExecStart=/usr/local/bin/alertmanager \
  --config.file=/etc/alertmanager/alertmanager.yml \
  --storage.path=/var/lib/alertmanager \
  --web.listen-address=127.0.0.1:9093 \
  --cluster.listen-address=127.0.0.1:19094
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/dbus-org.freedesktop.ModemManager1.service  (size=515b)
```
[Unit]
Description=Modem Manager
After=polkit.service
Requires=polkit.service
ConditionVirtualization=!container

[Service]
Type=dbus
BusName=org.freedesktop.ModemManager1
ExecStart=/usr/sbin/ModemManager
StandardError=null
Restart=on-abort
CapabilityBoundingSet=CAP_SYS_ADMIN CAP_NET_ADMIN
ProtectSystem=true
ProtectHome=true
PrivateTmp=true
RestrictAddressFamilies=AF_NETLINK AF_UNIX AF_QIPCRTR
NoNewPrivileges=true
User=root

[Install]
WantedBy=multi-user.target
Alias=dbus-org.freedesktop.ModemManager1.service

```

## FILE: /etc/systemd/system/dbus-org.freedesktop.resolve1.service  (size=1898b)
```
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Network Name Resolution
Documentation=man:systemd-resolved.service(8)
Documentation=man:org.freedesktop.resolve1(5)
Documentation=https://www.freedesktop.org/wiki/Software/systemd/writing-network-configuration-managers
Documentation=https://www.freedesktop.org/wiki/Software/systemd/writing-resolver-clients

DefaultDependencies=no
After=systemd-sysctl.service systemd-sysusers.service
Before=sysinit.target network.target nss-lookup.target shutdown.target initrd-switch-root.target
Conflicts=shutdown.target initrd-switch-root.target
Wants=nss-lookup.target

[Service]
AmbientCapabilities=CAP_SETPCAP CAP_NET_RAW CAP_NET_BIND_SERVICE
BusName=org.freedesktop.resolve1
CapabilityBoundingSet=CAP_SETPCAP CAP_NET_RAW CAP_NET_BIND_SERVICE
ExecStart=!!/usr/lib/systemd/systemd-resolved
LockPersonality=yes
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectClock=yes
ProtectControlGroups=yes
ProtectHome=yes
ProtectKernelLogs=yes
ProtectKernelModules=yes
ProtectKernelTunables=yes
ProtectSystem=strict
Restart=always
RestartSec=0
RestrictAddressFamilies=AF_UNIX AF_NETLINK AF_INET AF_INET6
RestrictNamespaces=yes
RestrictRealtime=yes
RestrictSUIDSGID=yes
RuntimeDirectory=systemd/resolve
RuntimeDirectoryPreserve=yes
SystemCallArchitectures=native
SystemCallErrorNumber=EPERM
SystemCallFilter=@system-service
Type=notify
User=systemd-resolve
ImportCredential=network.dns
ImportCredential=network.search_domains
WatchdogSec=3min

[Install]
WantedBy=sysinit.target
Alias=dbus-org.freedesktop.resolve1.service

```

## FILE: /etc/systemd/system/dbus-org.freedesktop.thermald.service  (size=309b)
```
[Unit]
Description=Thermal Daemon Service
ConditionVirtualization=no

[Service]
Type=dbus
SuccessExitStatus=2
BusName=org.freedesktop.thermald
ExecStart=/usr/sbin/thermald --systemd --dbus-enable --adaptive
Restart=on-failure

[Install]
WantedBy=multi-user.target
Alias=dbus-org.freedesktop.thermald.service


```

## FILE: /etc/systemd/system/dbus-org.freedesktop.timesync1.service  (size=1768b)
```
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Network Time Synchronization
Documentation=man:systemd-timesyncd.service(8)
ConditionCapability=CAP_SYS_TIME
ConditionVirtualization=!container
DefaultDependencies=no
After=systemd-sysusers.service
Before=time-set.target sysinit.target shutdown.target
Conflicts=shutdown.target
Wants=time-set.target

[Service]
AmbientCapabilities=CAP_SYS_TIME
BusName=org.freedesktop.timesync1
CapabilityBoundingSet=CAP_SYS_TIME
# Turn off DNSSEC validation for hostname look-ups, since those need the
# correct time to work, but we likely won't acquire that without NTP. Let's
# break this chicken-and-egg cycle here.
Environment=SYSTEMD_NSS_RESOLVE_VALIDATE=0
ExecStart=!!/usr/lib/systemd/systemd-timesyncd
LockPersonality=yes
MemoryDenyWriteExecute=yes
NoNewPrivileges=yes
PrivateDevices=yes
PrivateTmp=yes
ProtectProc=invisible
ProtectControlGroups=yes
ProtectHome=yes
ProtectHostname=yes
ProtectKernelLogs=yes
ProtectKernelModules=yes
ProtectKernelTunables=yes
ProtectSystem=strict
Restart=always
RestartSec=0
RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6
RestrictNamespaces=yes
RestrictRealtime=yes
RestrictSUIDSGID=yes
RuntimeDirectory=systemd/timesync
StateDirectory=systemd/timesync
SystemCallArchitectures=native
SystemCallErrorNumber=EPERM
SystemCallFilter=@system-service @clock
Type=notify
User=systemd-timesync
WatchdogSec=3min

[Install]
WantedBy=sysinit.target
Alias=dbus-org.freedesktop.timesync1.service

```

## FILE: /etc/systemd/system/grafana.service  (size=333b)
```
[Unit]
Description=Grafana
After=network-online.target

[Service]
User=grafana
Group=grafana
ExecStart=/usr/share/grafana/bin/grafana-server \
  --homepath=/usr/share/grafana \
  --config=/etc/grafana/grafana.ini
WorkingDirectory=/usr/share/grafana
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/iscsi.service  (size=1003b)
```
[Unit]
Description=Login to default iSCSI targets
Documentation=man:iscsiadm(8) man:iscsid(8)
Wants=network-online.target remote-fs-pre.target
After=network-online.target iscsid.service
Before=remote-fs-pre.target
DefaultDependencies=no
Conflicts=shutdown.target
Before=shutdown.target
# Must have some pre-defined targets to login to
ConditionDirectoryNotEmpty=|/etc/iscsi/nodes
# or have a session to use via iscsid
ConditionDirectoryNotEmpty=|/sys/class/iscsi_session

[Service]
Type=oneshot
RemainAfterExit=true
# iscsiadm --login will return 21 if no nodes are configured,
# and 15 if a session is alread logged in (which we do not
# consider an error)
SuccessExitStatus=15 21
# Note: iscsid will be socket activated by iscsiadm
ExecStart=/usr/sbin/iscsiadm -m node --loginall=automatic
ExecStart=/usr/lib/open-iscsi/activate-storage.sh
ExecStop=/usr/lib/open-iscsi/umountiscsi.sh
ExecStop=/bin/sync
ExecStop=/usr/lib/open-iscsi/logout-all.sh

[Install]
WantedBy=sysinit.target
Alias=iscsi.service

```

## FILE: /etc/systemd/system/logos-healthcheck.service  (size=217b)
```
[Unit]
Description=LOGOS healthcheck (HTTP)
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
EnvironmentFile=/etc/default/logos-healthcheck
ExecStart=/usr/local/bin/logos_healthcheck.sh

```

## FILE: /etc/systemd/system/logos-healthcheck.timer  (size=165b)
```
[Unit]
Description=LOGOS healthcheck timer (every 1 min)

[Timer]
OnBootSec=30s
OnUnitActiveSec=60s
Unit=logos-healthcheck.service

[Install]
WantedBy=timers.target

```

## FILE: /etc/systemd/system/logos-node.service  (size=293b)
```
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/bin/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/logos-node@.service  (size=412b)
```
[Unit]
Description=LOGOS LRB Node (%i)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos
ExecStart=/opt/logos/logos_node
EnvironmentFile=/etc/logos/node-%i.env

# sandbox
NoNewPrivileges=yes
PrivateTmp=yes
ProtectSystem=full
ProtectHome=yes
ReadWritePaths=/var/lib/logos-%i
Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/logos-node.service.d/cors.conf  (size=72b)
```
[Service]
Environment=LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io

```

## FILE: /etc/systemd/system/logos-node.service.d/data.conf  (size=61b)
```
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled

```

## FILE: /etc/systemd/system/logos-node.service.d/exec.conf  (size=85b)
```
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```

## FILE: /etc/systemd/system/logos-node.service.d/faucet.conf  (size=42b)
```
[Service]
Environment=LRB_ENABLE_FAUCET=1

```

## FILE: /etc/systemd/system/logos-node.service.d/keys.conf  (size=46b)
```
[Service]
EnvironmentFile=/etc/logos/keys.env

```

## FILE: /etc/systemd/system/logos-node.service.d/override.conf  (size=575b)
```
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```

## FILE: /etc/systemd/system/logos-node.service.d/phasemix.conf  (size=44b)
```
[Service]
Environment=LRB_PHASEMIX_ENABLE=1

```

## FILE: /etc/systemd/system/logos-node.service.d/ratelimit_bypass.conf  (size=53b)
```
[Service]
Environment=LRB_RATE_BYPASS_CIDR=0.0.0.0/0

```

## FILE: /etc/systemd/system/logos-node.service.d/ratelimit.conf  (size=122b)
```
[Service]
Environment=LRB_RATE_QPS=30
Environment=LRB_RATE_BURST=60
Environment=LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128

```

## FILE: /etc/systemd/system/logos-node.service.d/runas.conf  (size=166b)
```
[Service]
User=logos
Group=logos
# Разрешаем запись туда, где нужно (данные/секреты)
ReadWritePaths=/var/lib/logos /etc/logos

```

## FILE: /etc/systemd/system/logos-node.service.d/security.conf  (size=106b)
```
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true

```

## FILE: /etc/systemd/system/logos-node.service.d/tuning.conf  (size=422b)
```
[Service]
Environment=LRB_NODE_LISTEN=0.0.0.0:8080
Environment=LRB_DATA_DIR=/var/lib/logos
Environment=LRB_WALLET_ORIGIN=http://127.0.0.1
Environment=LRB_RATE_QPS=20
Environment=LRB_RATE_BURST=40
Environment=LRB_RATE_BYPASS_CIDR=127.0.0.1/32,::1/128
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615
Environment=RUST_LOG=info

```

## FILE: /etc/systemd/system/logos-node.service.d/zz-consensus.conf  (size=137b)
```
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```

## FILE: /etc/systemd/system/logos-node.service.d/zz-keys.conf  (size=610b)
```
[Service]
# Читаем файл с секретами (на будущее, если захочешь использовать keys.env)
EnvironmentFile=-/etc/logos/keys.env

# Узловые параметры (жёстко, чтобы сервис точно стартовал)
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_SK_HEX=31962399e9b0e278af3b328bc6e30bbd17d90c700a5f6c7ad3c4d4418ed8fd83
Environment=LRB_ADMIN_KEY=***MASKED***
Environment=LRB_BRIDGE_KEY=***MASKED***

```

## FILE: /etc/systemd/system/logos-node.service.d/zz-logging.conf  (size=36b)
```
[Service]
Environment=RUST_LOG=info

```

## FILE: /etc/systemd/system/logos-snapshot.service  (size=271b)
```
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```

## FILE: /etc/systemd/system/logos-snapshot.timer  (size=163b)
```
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```

## FILE: /etc/systemd/system/lrb-exporter.service  (size=148b)
```
[Unit]
Description=LRB textfile exporter (economy/head)

[Service]
Type=oneshot
ExecStart=/usr/local/bin/lrb_exporter.sh
User=nodeexp
Group=nodeexp

```

## FILE: /etc/systemd/system/lrb-exporter.timer  (size=120b)
```
[Unit]
Description=Run LRB exporter every 15s

[Timer]
OnBootSec=5
OnUnitActiveSec=15

[Install]
WantedBy=timers.target

```

## FILE: /etc/systemd/system/lrb-proxy.service  (size=395b)
```
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/lrb-scanner.service  (size=378b)
```
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/node-exporter.service  (size=284b)
```
[Unit]
Description=Node Exporter (Prometheus)
After=network-online.target

[Service]
User=nodeexp
Group=nodeexp
ExecStart=/usr/local/bin/node_exporter \
  --collector.textfile.directory=/var/lib/node_exporter/textfile
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/prometheus.service  (size=352b)
```
[Unit]
Description=Prometheus
After=network-online.target

[Service]
User=prom
Group=prom
ExecStart=/usr/local/bin/prometheus \
  --config.file=/etc/prometheus/prometheus.yml \
  --storage.tsdb.path=/var/lib/prometheus \
  --web.enable-lifecycle \
  --web.listen-address=127.0.0.1:9094
Restart=always
RestartSec=2

[Install]
WantedBy=multi-user.target

```

## FILE: /etc/systemd/system/syslog.service  (size=890b)
```
[Unit]
Description=System Logging Service
Requires=syslog.socket
Documentation=man:rsyslogd(8)
Documentation=man:rsyslog.conf(5)
Documentation=https://www.rsyslog.com/doc/

[Service]
Type=notify
ExecStartPre=/usr/lib/rsyslog/reload-apparmor-profile
ExecStart=/usr/sbin/rsyslogd -n -iNONE
StandardOutput=null
StandardError=journal
Restart=on-failure

# Increase the default a bit in order to allow many simultaneous
# files to be monitored, we might need a lot of fds.
LimitNOFILE=16384

CapabilityBoundingSet=CAP_BLOCK_SUSPEND CAP_CHOWN CAP_DAC_OVERRIDE CAP_LEASE CAP_NET_ADMIN CAP_NET_BIND_SERVICE CAP_SYS_ADMIN CAP_SYS_RESOURCE CAP_SYSLOG CAP_MAC_ADMIN CAP_SETGID CAP_SETUID
SystemCallFilter=@system-service
RestrictAddressFamilies=AF_INET AF_INET6 AF_UNIX
NoNewPrivileges=yes
ProtectHome=no
ProtectClock=yes
ProtectHostname=yes

[Install]
WantedBy=multi-user.target
Alias=syslog.service

```

## FILE: /etc/systemd/system/vmtoolsd.service  (size=489b)
```
[Unit]
Description=Service for virtual machines hosted on VMware
Documentation=http://open-vm-tools.sourceforge.net/about.php
ConditionVirtualization=vmware
DefaultDependencies=no
Before=cloud-init-local.service
After=vgauth.service
After=apparmor.service
RequiresMountsFor=/tmp
After=systemd-remount-fs.service systemd-tmpfiles-setup.service systemd-modules-load.service

[Service]
ExecStart=/usr/bin/vmtoolsd
TimeoutStopSec=5

[Install]
WantedBy=multi-user.target
Alias=vmtoolsd.service

```

## FILE: /opt/logos/www/explorer/explorer.css  (size=898b)
```
body { font-family: system-ui, sans-serif; margin: 0; background: #0b0c10; color: #e6edf3; }
header { padding: 12px; background: #11151a; border-bottom: 1px solid #1e242c; display:flex; justify-content:space-between; }
main { padding: 12px; display: grid; gap: 20px; }
section { background: #141a21; padding: 12px; border-radius: 10px; }
button { padding: 10px 14px; border-radius: 8px; border: none; margin: 4px; cursor: pointer; background: #1665c1; color: #fff; font-weight: 600; }
button:hover { background: #1f77d0; }
input { padding: 8px; margin: 4px; border-radius: 6px; border: 1px solid #333; background: #0b0c10; color: #e6edf3; width: 100%; max-width: 380px; }
pre { background: #0e1116; padding: 8px; border-radius: 6px; overflow-x: auto; }
table { width: 100%; border-collapse: collapse; margin-top: 10px; }
th, td { padding: 6px 8px; border-bottom: 1px solid #333; font-size: 13px; }

```

## FILE: /opt/logos/www/explorer/explorer.js  (size=3977b)
```
// LOGOS Explorer – history debug + stable fill
const API = location.origin + "/api";
const $  = s => document.querySelector(s);
const out= (id,v)=>{$(id).textContent=(typeof v==="string")?v:JSON.stringify(v,null,2)};
const fmtNum=n=>Number(n).toLocaleString("ru-RU");
const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

async function jget(path){
  const r=await fetch(API+path,{cache:"no-store"});
  if(!r.ok) throw new Error(r.status+" "+(await r.text()).slice(0,400));
  return r.json();
}

// status
document.addEventListener("DOMContentLoaded",()=>{ const s=$("#jsStat"); if(s){ s.style.color="#0bd464"; s.textContent="js: готов"; }});

// HEAD / ECONOMY
let autoTimer=null;
async function fetchHead(){ try{ out("out-head", await jget("/head")); }catch(e){ out("out-head","ERR: "+e.message); } }
async function fetchEconomy(){ try{ out("out-economy", await jget("/economy")); }catch(e){ out("out-economy","ERR: "+e.message); } }
function toggleAuto(){
  if(autoTimer){ clearInterval(autoTimer); autoTimer=null; $("#btn-auto").textContent="Автообновление: выключено"; return; }
  const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
  tick(); autoTimer=setInterval(tick,5000);
  $("#btn-auto").textContent="Автообновление: включено";
}

// BLOCK / MIX
async function fetchBlock(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget("/block/"+h)); }catch(e){ out("out-block","ERR: "+e.message); }
}
async function fetchMix(){
  const h=Number($("#inp-height").value); if(!h){ alert("Укажи высоту"); return; }
  try{ out("out-block", await jget(`/block/${h}/mix`)); }catch(e){ out("out-block","ERR: "+e.message); }
}

// HISTORY
let histRid="", limit=20, fromNonce=0, nextFrom=null, prevStack=[];
function renderHistory(arr){
  const tb=$("#tbl-history tbody"); tb.innerHTML="";
  if(!arr || arr.length===0){
    const tr=document.createElement("tr");
    tr.innerHTML=`<td colspan="6" style="opacity:.8">0 записей</td>`;
    tb.appendChild(tr);
  } else {
    arr.forEach(tx=>{
      const tr=document.createElement("tr");
      tr.innerHTML=`<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                   `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    });
  }
  $("#hist-info").textContent=`RID=${histRid} · from=${fromNonce} · limit=${limit} · next=${nextFrom??"-"}`;
  $("#btn-prev").disabled = (prevStack.length===0);
  $("#btn-next").disabled = (nextFrom==null);
}

async function pageHistory(rid, from, lim){
  const q=new URLSearchParams({from:String(from||0),limit:String(lim||20)});
  const j=await jget(`/history/${rid}?`+q.toString());
  // DEBUG: покажем сырой ответ под таблицей
  out("out-history", j); $("#out-history").style.display="block";
  const arr=j.items || j.txs || [];
  nextFrom=(typeof j.next_from!=="undefined")?j.next_from:null;
  renderHistory(arr);
}

async function fetchHistory(){
  histRid=($("#inp-rid").value||"").trim();
  limit=Math.max(1, Number($("#inp-limit").value)||20);
  if(!histRid){ alert("Укажи RID"); return; }
  fromNonce=0; nextFrom=null; prevStack=[];
  try{ await pageHistory(histRid, fromNonce, limit); }catch(e){ alert("ERR: "+e.message); }
}
async function prevPage(){ if(prevStack.length===0) return; fromNonce=prevStack.pop(); await pageHistory(histRid, fromNonce, limit); }
async function nextPage(){ if(nextFrom==null) return; prevStack.push(fromNonce); fromNonce=nextFrom; await pageHistory(histRid, fromNonce, limit); }

// экспорт под onclick
window.fetchHead=fetchHead; window.fetchEconomy=fetchEconomy; window.toggleAuto=toggleAuto;
window.fetchBlock=fetchBlock; window.fetchMix=fetchMix;
window.fetchHistory=fetchHistory; window.prevPage=prevPage; window.nextPage=nextPage;

```

## FILE: /opt/logos/www/explorer/index.html  (size=8802b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Explorer — v2 (inline)</title>
  <style>
    :root{--bg:#0b0c10;--card:#11151a;--line:#1e242c;--muted:#9aa4af;--txt:#e6edf3;--btn:#1665c1;--btn-b:#3b7ddd;}
    *{box-sizing:border-box}
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:var(--bg);color:var(--txt)}
    header{padding:12px;background:var(--card);border-bottom:1px solid var(--line);display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    header h1{font-size:18px;margin:0}
    #jsStat{font-size:12px;margin-left:auto}
    main{max-width:1100px;margin:18px auto;padding:0 12px}
    section{background:var(--card);margin:12px 0;border-radius:14px;padding:14px;border:1px solid var(--line)}
    h3{margin:6px 0 12px 0}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .row>.grow{flex:1 1 360px}
    .row>.fit{flex:0 0 140px}
    input{width:100%;padding:10px;border-radius:10px;border:1px solid var(--line);background:#0b0f14;color:#e6edf3}
    button{padding:10px 14px;border-radius:10px;border:1px solid var(--btn-b);background:var(--btn);color:#fff;font-weight:600;cursor:pointer}
    .btns{display:flex;gap:8px;flex-wrap:wrap}
    pre{white-space:pre-wrap;word-break:break-word;background:#0b0f14;border:1px solid var(--line);border-radius:10px;padding:10px;overflow:auto;margin:8px 0 0}
    .cards{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media(max-width:900px){.cards{grid-template-columns:1fr}}
    .table-wrap{overflow-x:auto;border:1px solid var(--line);border-radius:10px;margin-top:8px}
    table{width:100%;border-collapse:collapse;min-width:700px}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px;white-space:nowrap}
    .muted{color:#9aa4af}
    .pill{border:1px solid var(--line);padding:8px 10px;border-radius:10px;background:#0b0f14}
  </style>
</head>
<body>
<header>
  <h1>LOGOS LRB — исследователь</h1>
  <div class="pill">
    <input id="q" placeholder="Поиск: RID, высота блока или псевдо-txid from:nonce" style="min-width:260px">
    <button onclick="search()">Найти</button>
  </div>
  <div id="jsStat">js: загрузка…</div>
</header>

<main>

  <section class="cards">
    <div>
      <h3>Голова</h3>
      <div class="btns">
        <button onclick="fetchHead()">GET /head</button>
        <button onclick="toggleAuto()">Автообновление</button>
      </div>
      <pre id="out-head"></pre>
    </div>
    <div>
      <h3>Эконом</h3>
      <button onclick="fetchEconomy()">GET /economy</button>
      <pre id="out-economy"></pre>
    </div>
  </section>

  <section>
    <h3>Блок</h3>
    <div class="row">
      <div class="grow"><label class="muted">высота блока</label><input id="inp-height" type="number" min="1" placeholder="например 1"></div>
      <div class="grow btns" style="align-items:flex-end">
        <button onclick="fetchBlock()">/block/:height</button>
        <button onclick="fetchMix()">/block/:height/mix</button>
        <button onclick="loadLatest()">Последние блоки</button>
      </div>
    </div>
    <div class="table-wrap" id="latest-wrap" style="display:none">
      <table><thead><tr><th>height</th><th>ts</th><th>finalized</th></tr></thead><tbody id="latest"></tbody></table>
    </div>
    <pre id="out-block"></pre>
  </section>

  <section>
    <h3>Адрес (RID)</h3>
    <div class="row">
      <div class="grow"><label class="muted">RID (base58)</label><input id="inp-rid" placeholder="вставь RID"></div>
      <div class="fit"><label class="muted">limit</label><input id="inp-limit" type="number" min="1" value="20"></div>
      <div class="grow btns" style="align-items:flex-end"><button onclick="fetchHistory()">GET /history</button></div>
    </div>
    <div class="table-wrap">
      <table id="tbl">
        <thead><tr><th>nonce</th><th>from</th><th>to</th><th>amount</th><th>height</th><th>ts</th></tr></thead>
        <tbody id="hist-body"></tbody>
      </table>
    </div>
    <pre id="out-history" style="display:none"></pre>
  </section>

</main>

<script>
(function(){
  const API = location.origin + "/api";
  const $  = s => document.querySelector(s);
  const setStat = (t,ok)=>{ const s=$("#jsStat"); if(!s) return; s.textContent=t; s.style.color=ok?"#0bd464":"#ff5252"; };
  const fmtNum=n=>Number(n).toLocaleString("ru-RU");
  const fmtTs =ms=>isFinite(ms)?new Date(Number(ms)).toLocaleString("ru-RU"):"";

  async function jget(path){
    try{ const r=await fetch(API+path,{cache:"no-store"}); if(!r.ok) return {error:r.status+" "+(await r.text()).slice(0,200)}; return await r.json(); }
    catch(e){ return {error:String(e)}; }
  }

  // HEAD & ECON
  let autoTimer=null;
  window.fetchHead = async ()=>{ $("#out-head").textContent = JSON.stringify(await jget("/head"), null, 2); };
  window.fetchEconomy = async ()=>{ $("#out-economy").textContent = JSON.stringify(await jget("/economy"), null, 2); };
  window.toggleAuto = ()=>{
    if(autoTimer){ clearInterval(autoTimer); autoTimer=null; setStat("js: авто выкл", true); return; }
    const tick=async()=>{ await fetchHead(); await fetchEconomy(); };
    tick(); autoTimer=setInterval(tick, 5000); setStat("js: авто вкл", true);
  };

  // BLOCKS
  window.fetchBlock = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget("/block/"+h), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.fetchMix = async ()=>{
    const h=Number($("#inp-height").value)||0; if(!h){ alert("Укажи высоту"); return; }
    $("#out-block").textContent = JSON.stringify(await jget(`/block/${h}/mix`), null, 2);
    $("#latest-wrap").style.display="none";
  };
  window.loadLatest = async ()=>{
    const head=await jget("/head");
    const H = head && head.height ? Number(head.height) : 0;
    const tbody=$("#latest"); tbody.innerHTML="";
    if(!H){ $("#latest-wrap").style.display="none"; return; }
    const from=Math.max(1,H-9);  // последние 10
    for(let h=H; h>=from; h--){
      const b = await jget("/block/"+h);
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${h}</td><td>${b.ts_ms?fmtTs(b.ts_ms):""}</td><td>${b.finalized??""}</td>`;
      tbody.appendChild(tr);
    }
    $("#latest-wrap").style.display="block";
    $("#out-block").textContent = "";
  };

  // HISTORY
  function renderRows(arr){
    const tb=$("#hist-body"); tb.innerHTML="";
    if(!arr || arr.length===0){ const tr=document.createElement("tr"); tr.innerHTML='<td colspan="6" class="muted">0 записей</td>'; tb.appendChild(tr); return; }
    for(const tx of arr){
      const tr=document.createElement("tr");
      tr.innerHTML = `<td>${tx.nonce??""}</td><td>${tx.from??""}</td><td>${tx.to??""}</td>`+
                     `<td>${fmtNum(tx.amount??0)}</td><td>${tx.height??""}</td><td>${fmtTs(tx.ts_ms)}</td>`;
      tb.appendChild(tr);
    }
  }
  window.fetchHistory = async ()=>{
    const rid = ($("#inp-rid").value||"").trim(); if(!rid){ alert("Укажи RID"); return; }
    const lim = Math.max(1, Number($("#inp-limit").value)||20);
    const raw = await jget(`/history/${encodeURIComponent(rid)}?limit=${lim}`);
    $("#out-history").style.display="block"; $("#out-history").textContent=JSON.stringify(raw,null,2);
    const arr = (raw && (raw.items||raw.txs)) ? (raw.items||raw.txs) : [];
    renderRows(arr);
  };

  // SEARCH (RID / block height / pseudo txid "from:nonce")
  window.search = async ()=>{
    const q = ($("#q").value||"").trim();
    if(!q) return;
    if(/^\d+$/.test(q)){ $("#inp-height").value=q; await fetchBlock(); return; }
    if(/^[1-9A-HJ-NP-Za-km-z]+$/.test(q) && q.length>30){ $("#inp-rid").value=q; await fetchHistory(); return; }
    if(q.includes(":")){ // псевдо-txid from:nonce
      const [from,nonce] = q.split(":");
      $("#inp-rid").value = from;
      $("#inp-limit").value = 50;
      await fetchHistory();
      // подсветим найденную строку
      [...document.querySelectorAll("#hist-body tr")].forEach(tr=>{
        if(tr.firstChild && tr.firstChild.textContent===(nonce||"").trim()){ tr.style.background="#132235"; }
      });
      return;
    }
    alert("Не распознан формат запроса. Используй: RID, номер блока, или from:nonce");
  };

  // boot mark
  setStat("js: готов", true);
})();
</script>
</body>
</html>

```

## FILE: /opt/logos/www/wallet/app.html  (size=3367b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c;position:sticky;top:0}
    h1{font-size:18px;margin:0}
    main{max-width:1024px;margin:24px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    input,button,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    small{opacity:.8}
  </style>
</head>
<body>
<header>
  <h1>LOGOS Wallet — Кошелёк</h1>
</header>
<main>
  <section>
    <div class="grid">
      <div>
        <h3>Твой RID / Публичный ключ</h3>
        <textarea id="pub" class="mono" rows="4" readonly></textarea>
        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="btn-lock" class="secondary">Выйти (заблокировать)</button>
          <button id="btn-nonce" class="secondary">Получить nonce</button>
        </div>
        <p><small>Ключ в памяти. Закроешь вкладку — понадобится пароль на странице входа.</small></p>
      </div>
      <div>
        <h3>Баланс</h3>
        <div class="grid">
          <div><label>RID</label><input id="rid-balance" class="mono" placeholder="RID (base58)"/></div>
          <div><label>&nbsp;</label><button id="btn-balance">Показать баланс</button></div>
        </div>
        <pre id="out-balance" class="mono" style="margin-top:12px"></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>Подпись и отправка (batch)</h3>
    <div class="grid">
      <div><label>Получатель (RID)</label><input id="to" class="mono" placeholder="RID получателя"/></div>
      <div><label>Сумма (LGN)</label><input id="amount" type="number" min="1" step="1" value="1"/></div>
    </div>
    <div class="grid">
      <div><label>Nonce</label><input id="nonce" type="number" min="1" step="1" placeholder="нажми 'Получить nonce'"/></div>
      <div><label>&nbsp;</label><button id="btn-send">Подписать и отправить</button></div>
    </div>
    <pre id="out-send" class="mono" style="margin-top:12px"></pre>
  </section>

  <section>
    <h3>Мост rToken (депозит, демо)</h3>
    <div class="grid">
      <div><label>ext_txid</label><input id="ext" class="mono" placeholder="например eth_txid_0xabc"/></div>
      <div><label>&nbsp;</label><button id="btn-deposit">Deposit rLGN</button></div>
    </div>
    <pre id="out-bridge" class="mono" style="margin-top:12px"></pre>
  </section>
</main>
<script src="./app.js?v=20250906_01" defer></script>
</body>
</html>

```

## FILE: /opt/logos/www/wallet/app.js  (size=5497b)
```
// APP: ключи в памяти; RID неизменен — берём из sessionStorage, meta из acct:<RID>
const API = location.origin + '/api';
const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";

const $=s=>document.querySelector(s);
const toHex=b=>[...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex=h=>new Uint8Array(h.match(/.{1,2}/g).map(x=>parseInt(x,16)));
const b58=bytes=>{const h=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');let x=BigInt('0x'+h),o='';while(x>0n){o=ALPH[Number(x%58n)]+o;x/=58n;}return o||'1';};

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){const keyMat=await crypto.subtle.importKey('raw',new TextEncoder().encode(pass),'PBKDF2',false,['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['decrypt']);}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}
async function importKey(pass, meta){
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8=await aesDecrypt(aes,meta.iv,meta.priv);
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},true,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',new Uint8Array(meta.pub),{name:'Ed25519'},true,['verify']);
  return {privateKey, publicKey};
}

// Session guard
const PASS=sessionStorage.getItem('logos_pass');
const RID =sessionStorage.getItem('logos_rid');
if(!PASS || !RID){ location.replace('./login.html'); throw new Error('locked'); }

let KEYS=null, META=null;

(async ()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS,META);
  document.getElementById('pub').value=`RID: ${RID}\nPUB (hex): ${toHex(new Uint8Array(META.pub))}`;
  document.getElementById('rid-balance').value=RID;
})();

document.getElementById('btn-lock').addEventListener('click', ()=>{ sessionStorage.clear(); location.replace('./login.html'); });

// API helpers
async function getJSON(url, body){
  const r = await fetch(url, body ? {method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(body)} : {});
  if(!r.ok){ throw new Error(`${r.status} ${await r.text()}`); }
  return r.json();
}
async function getNonce(rid){ const j=await getJSON(`${API}/balance/${rid}`); return j.nonce||0; }
async function canonHex(from,to,amount,nonce){
  const r=await fetch(`${API}/debug_canon`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({tx:{from,to,amount:Number(amount),nonce:Number(nonce)}})});
  if(!r.ok){ throw new Error(`/debug_canon ${r.status}`); }
  return (await r.json()).canon_hex;
}
async function submitBatch(txs){
  const r=await fetch(`${API}/submit_tx_batch`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({txs})});
  if(!r.ok){ throw new Error(`/submit_tx_batch ${r.status}`); }
  return r.json();
}
async function deposit(rid, amount, ext){
  const r=await fetch(`${API}/bridge/deposit`,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({rid,amount:Number(amount),ext_txid:ext})});
  return {status:r.status, text:await r.text()};
}
async function signCanon(privateKey, canonHex){
  const msg=fromHex(canonHex);
  const sig=await crypto.subtle.sign('Ed25519', privateKey, msg);
  return [...new Uint8Array(sig)].map(b=>b.toString(16).padStart(2,'0')).join('');
}

// Buttons
document.getElementById('btn-nonce').addEventListener('click', async ()=>{
  try{ const n=await getNonce(RID); document.getElementById('nonce').value=String(n+1); }
  catch(e){ alert('ERR '+e); }
});

document.getElementById('btn-balance').addEventListener('click', async ()=>{
  try{ const rid=document.getElementById('rid-balance').value.trim(); const j=await getJSON(`${API}/balance/${rid}`); document.getElementById('out-balance').textContent=JSON.stringify(j,null,2); }
  catch(e){ document.getElementById('out-balance').textContent=String(e); }
});

document.getElementById('btn-send').addEventListener('click', async ()=>{
  const to=document.getElementById('to').value.trim();
  const amount=document.getElementById('amount').value;
  const nonce=document.getElementById('nonce').value;
  const out=document.getElementById('out-send');
  try{
    const ch = await canonHex(RID,to,amount,nonce);
    const sig= await signCanon(KEYS.privateKey,ch);
    const res= await submitBatch([{from:RID,to,amount:Number(amount),nonce:Number(nonce),sig_hex:sig}]);
    out.textContent=JSON.stringify(res,null,2);
  }catch(e){ out.textContent=String(e); }
});

document.getElementById('btn-deposit').addEventListener('click', async ()=>{
  const ext=document.getElementById('ext').value.trim()||'eth_txid_demo';
  const r=await deposit(RID,123,ext);
  document.getElementById('out-bridge').textContent=`HTTP ${r.status}\n${r.text}`;
});

```

## FILE: /opt/logos/www/wallet/auth.js  (size=6002b)
```
// AUTH v3: RID + пароль. Сохраняем под "acct:<RID>".
// Фичи: авто-подстановка last_rid, кликабельный список, чистка всех пробелов/переносов в RID.

const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const $ = s => document.querySelector(s);
const out = msg => { const el=$('#out'); if(el) el.textContent=String(msg); };

function normRid(s){ return (s||'').replace(/\s+/g,'').trim(); } // убираем все пробелы/переносы

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!crypto || !crypto.subtle) throw new Error('WebCrypto недоступен');
}

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};
const idbSet=async (k,v)=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).put(v,k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};
const idbDel=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).delete(k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){
  const keyMat=await crypto.subtle.importKey('raw',enc.encode(pass),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
}
async function aesEncrypt(aesKey,data){const iv=crypto.getRandomValues(new Uint8Array(12));const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,data);return{iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))}}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}

function b58(bytes){
  const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const hex=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');
  let x=BigInt('0x'+hex), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } return out||'1';
}

async function addAccount(rid){ const list=(await idbGet('accounts'))||[]; if(!list.includes(rid)){ list.push(rid); await idbSet('accounts',list); } }
async function listAccounts(){ return (await idbGet('accounts'))||[]; }

async function createAccount(pass){
  ensureEnv();
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  out('Создаём ключ…');
  const kp=await crypto.subtle.generateKey({name:'Ed25519'},true,['sign','verify']);
  const rawPub=new Uint8Array(await crypto.subtle.exportKey('raw',kp.publicKey));
  const rid=b58(rawPub);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey('pkcs8',kp.privateKey));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const aes=await deriveKey(pass,salt);
  const {iv,ct}=await aesEncrypt(aes,pkcs8);
  const meta={rid,pub:Array.from(rawPub),salt:Array.from(salt),iv,priv:ct};

  await idbSet('acct:'+rid,meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  out('RID создан: '+rid+' → вход…');
  location.href='./app.html';
}

async function loginAccount(rid, pass){
  ensureEnv();
  rid = normRid(rid);
  if(!rid) throw new Error('Укажи RID');
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  const meta=await idbGet('acct:'+rid);
  if(!meta){
    const list=await listAccounts();
    throw new Error('RID не найден на этом устройстве. Сохранённые RID:\n'+(list.length?list.join('\n'):'—'));
  }
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  try{ await aesDecrypt(aes,meta.iv,meta.priv); } catch(e){ throw new Error('Неверный пароль'); }

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  await idbSet('last_rid', rid);
  out('Вход…'); location.href='./app.html';
}

async function resetAll(){
  const list=await listAccounts();
  for(const rid of list){ await idbDel('acct:'+rid); }
  await idbDel('accounts'); await idbDel('last_rid');
  sessionStorage.clear();
  out('Все аккаунты удалены (DEV).');
}

function renderRidList(list){
  const wrap=$('#listWrap'), ul=$('#ridList'); ul.innerHTML='';
  if(!list.length){ wrap.style.display='block'; ul.innerHTML='<li>— пусто —</li>'; return; }
  wrap.style.display='block';
  list.forEach(rid=>{
    const li=document.createElement('li'); li.textContent=rid;
    li.addEventListener('click', ()=>{ $('#loginRid').value=rid; out('RID подставлен'); });
    ul.appendChild(li);
  });
}

// авто-подстановка last_rid при загрузке
(async ()=>{
  const last=await idbGet('last_rid'); if(last){ $('#loginRid').value=last; }
})();

// wire UI
$('#btn-login').addEventListener('click', async ()=>{
  const rid=$('#loginRid').value; const pass=$('#pass').value;
  try{ await loginAccount(rid,pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-create').addEventListener('click', async ()=>{
  const pass=$('#pass').value;
  try{ await createAccount(pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-list').addEventListener('click', async ()=>{
  try{ renderRidList(await listAccounts()); }catch(e){ out('ERR: '+e); }
});
$('#btn-reset').addEventListener('click', resetAll);

```

## FILE: /opt/logos/www/wallet/index.html  (size=184b)
```
<!doctype html><meta charset="utf-8">
<title>Redirecting…</title>
<meta http-equiv="refresh" content="0; url=./login.html">
<a href="./login.html">Перейти в LOGOS Wallet</a>

```

## FILE: /opt/logos/www/wallet/login.html  (size=2647b)
```
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Вход</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c}
    h1{font-size:18px;margin:0}
    main{max-width:720px;margin:48px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    small{opacity:.8}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    ul{list-style:none;padding:0;margin:8px 0}
    li{padding:8px;border:1px solid #2a313a;border-radius:8px;margin-bottom:6px;cursor:pointer;background:#0b0f14}
  </style>
</head>
<body>
<header><h1>LOGOS Wallet — Secure (WebCrypto + IndexedDB)</h1></header>
<main>
  <section>
    <h3>Вход в аккаунт</h3>
    <label>Логин (RID)</label>
    <input id="loginRid" class="mono" placeholder="Вставь RID (base58) или выбери из списка ниже"/>
    <label>Пароль</label>
    <input id="pass" type="password" placeholder="Пароль для шифрования ключа"/>

    <div class="grid" style="margin-top:12px">
      <button id="btn-login">Войти по RID + пароль</button>
      <button id="btn-create">Создать новый RID</button>
    </div>

    <div style="margin-top:12px">
      <button id="btn-list" class="secondary">Показать сохранённые RID</button>
      <button id="btn-reset" class="secondary">Сбросить все аккаунты (DEV)</button>
    </div>

    <div id="listWrap" style="display:none;margin-top:10px">
      <small>Сохранённые на этом устройстве RID (тапни, чтобы подставить):</small>
      <ul id="ridList"></ul>
    </div>

    <p><small>Ключ Ed25519 хранится зашифрованным AES-GCM (PBKDF2) в IndexedDB. Ничего не уходит в сеть.</small></p>
    <pre id="out" class="mono"></pre>
  </section>
</main>
<script src="./auth.js?v=20250906_03" defer></script>
</body>
</html>

```

## FILE: /opt/logos/www/wallet/wallet.css  (size=2693b)
```
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```

## FILE: /var/lib/grafana/dashboards/lrb_core.json  (size=920b)
```
{
  "title": "LOGOS LRB — Core",
  "panels": [
    { "type": "stat", "title": "Head Height", "targets": [ { "expr": "lrb_head_height" } ] },
    { "type": "stat", "title": "Supply", "targets": [ { "expr": "lrb_supply_total" } ] },
    { "type": "stat", "title": "Minted", "targets": [ { "expr": "lrb_minted_total" } ] },
    { "type": "stat", "title": "Burned", "targets": [ { "expr": "lrb_burned_total" } ] },
    { "type": "graph", "title": "HTTP p95 (s)", "targets": [ { "expr": "histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))" } ] },
    { "type": "graph", "title": "HTTP RPS", "targets": [ { "expr": "sum(rate(http_requests_total[1m])) by (status)" } ] },
    { "type": "graph", "title": "5xx ratio (%)", "targets": [ { "expr": "100 * sum(rate(http_requests_total{status=~\"5..\"}[5m])) / sum(rate(http_requests_total[5m]))" } ] }
  ],
  "schemaVersion": 36, "version": 1
}

```
```


### FILE: /root/logos_lrb/docs/LRB_SNAPSHOT_20250904_1426.txt

```
# FULL CODE SNAPSHOT (logos_lrb) - Thu Sep  4 02:26:11 PM BST 2025
# root: /root/logos_lrb



## FILE: AUDIT_REPORT.md  (size=4963b)
```text
# LOGOS LRB — Аудит модулей
_Tue Sep  2 03:51:50 PM UTC 2025_ UTC

## Files in modules/
### `modules/beacon_emitter.rs` (Rust)
- lines: 194 | sha256: `03cd9a74af6e7b586104afe804a1e0224f5c1387ce6234c2bf95306a0aa6b89a`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/env_impact_tracker.py` (Python)
- lines: 132 | sha256: `b53ddccbec9d9d44389a89586503c46e0086276a5a2c5688c69f851ae70ee5fb`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/external_phase_broadcaster.rs` (Rust)
- lines: 203 | sha256: `223e4b0a408be9ace9cf8e1f68b0e2a576c9cfa46a9115f660cc70f31346e2bd`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=1

### `modules/external_phase_link.rs` (Rust)
- lines: 179 | sha256: `12a75800714e3d6d6c590614bde1f5c975b1f87c9ac0b2e85642f56a5cf1aa04`
- red-flags: unsafe=1, unwrap=5, expect=0, panic=0, dbg/println=0

### `modules/genesis_fragment_seeds.rs` (Rust)
- lines: 184 | sha256: `5e419ca4d8b184e474d36bddd218ed0dbd9ac158e82d7c9532fd8d50e961145e`
- red-flags: unsafe=0, unwrap=5, expect=1, panic=0, dbg/println=0

### `modules/go_to_market.yaml`
- lines: 118 | sha256: `e80378d944c12f2a6a3541d909558c73d425fc4d9324005ba1184c7b75c9859f`

### `modules/heartbeat_monitor.rs` (Rust)
- lines: 208 | sha256: `a216c54e63bddf080ffbaf6f766b31aabbdd73ef933bfdcf573c9b43460d4f34`
- red-flags: unsafe=0, unwrap=7, expect=1, panic=0, dbg/println=0
- TODO/FIXME:
    143:        true // TODO: Реализовать

### `modules/legacy_migrator.rs` (Rust)
- lines: 191 | sha256: `41a10672b9a9712134cafb319bfac083563746b3b3da78d4f94a9d02e9e0a7c0`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/maintenance_strategy.yaml`
- lines: 85 | sha256: `a7e0e7363849c31cd503d927ce99ef2483f4c51cf6130979f6d1b33b343398b9`

### `modules/resonance_analytics_frontend.tsx`
- lines: 130 | sha256: `f82ff2dbb08cb3c0aa72176cc7aa5b867ff8e747eec8c71aa0be400371772937`

### `modules/resonance_emergency_plan.yaml`
- lines: 91 | sha256: `ee09fef020db662eed88a8a64ac3da99e7e6442c9080292643d0ee161a6e8ccd`

### `modules/resonance_meshmap.yaml`
- lines: 89 | sha256: `8a54cb1d9b389d88717b0a37a19a05b25a73d7e3cd6985614f4dddc3386643c6`

### `modules/resonance_tutor.py` (Python)
- lines: 135 | sha256: `42e2d397e8728edfbc3c3d297f8f0078accbf1f0a2f6d97fd3ce095a65bd128f`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/ritual_engine.rs` (Rust)
- lines: 211 | sha256: `2342009f23dc74f16b5eda9c52bd9c2836a4ca881b32fe4a83e3ac2f10175f2c`
- red-flags: unsafe=0, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/symbolic_parser.py` (Python)
- lines: 110 | sha256: `99655b49fe33f7affe4d6f5c8707d0b84cc30f4ee34fccee058e3e49e899bfd8`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `modules/uplink_controller.rs` (Rust)
- lines: 208 | sha256: `03cb0431dc4237567534d6efb6728a23c7e0dc225d197435d37a897a2625a47b`
- red-flags: unsafe=1, unwrap=3, expect=0, panic=0, dbg/println=0

### `modules/uplink_router.rs` (Rust)
- lines: 186 | sha256: `ec121080b9c3c05f6af17114e8630ccc14a2c313d5321244130f97cdf08cabe0`
- red-flags: unsafe=0, unwrap=5, expect=0, panic=0, dbg/println=0


## Files in core/
### `core/beta_rollout.yaml`
- lines: 94 | sha256: `b6ac3c0b19a730e9bcd41ccf24fce349dbf62013a1f45bc9d42bf74b13f5d76b`

### `core/offline_resonance.py` (Python)
- lines: 131 | sha256: `c4ba94d1e96a70963929aaf5a965f4ac03eaa091a3c3d7426e0f43036f1f9808`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/onboarding_sim.py` (Python)
- lines: 125 | sha256: `6aa4c1aef4f763d4a3f042a8ffae36ea9b59f3104067a56e0c47944986a4f178`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    90:        # TODO: Интеграция с rcp_engine.rs

### `core/onboarding_ui.py` (Python)
- lines: 137 | sha256: `8c17317ed7aa9339b495e725f58a8f88cd7e6cb792f0b6cd820ce5ad143e8149`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    114:        # TODO: Интеграция с rcp_engine.rs для проверки резонанса

### `core/resonance_analyzer.py` (Python)
- lines: 83 | sha256: `6c2245061e9b99bd9f0fe865fcb4815e20a4c237c7e16d0a8267756cfacea094`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0

### `core/rid_builder.py` (Python)
- lines: 133 | sha256: `9fac8b299c40f69320f21ce6fc156f913241a284f137ed4fcb2b0f1a96556de0`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    98:        # TODO: Интеграция с rcp_engine.rs

### `core/ritual_quest.py` (Python)
- lines: 186 | sha256: `0fcba7423a2920b0f14b333f7641110b6c1412c572529ec3b263a629a21e4d7a`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0
- TODO/FIXME:
    150:        # TODO: Интеграция с rcp_engine.rs

### `core/rLGN_converter.py` (Python)
- lines: 136 | sha256: `7a0dba1500ffac08f51a5f16de2ba226da3efd8a063f71fd4bb380f16aba0d24`
- red-flags: eval=0, exec=0, pickle=0, subprocess=0


## Quick checks
```
Python 3.12.3
```


```


## FILE: Cargo.toml  (size=713b)
```text
[workspace]
members = ["lrb_core", "node"]
resolver = "2"

[workspace.package]
edition = "2021"
license = "Proprietary"
name = "logos_lrb_workspace"
version = "0.1.0"

[workspace.dependencies]
anyhow = "1"
thiserror = "1"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
axum = "0.7"
tokio = { version = "1", features = ["rt-multi-thread", "macros", "signal", "time"] }
blake3 = "1"
bs58 = "0.5"
ed25519-dalek = { version = "2", features = ["serde"] }
rand = "0.8"
rand_core = "0.6"
sled = "0.34"
once_cell = "1"
uuid = { version = "1", features = ["v4", "serde"] }
hyper = "1"
tower = "0.5"
tower-http = { version = "0.5", features = ["cors", "trace"] }
time = "0.3"
base64 = "0.22"
hex = "0.4"

```


## FILE: README.md  (size=841b)
```text
# LOGOS Resonance Blockchain — Monorepo

Состав:
- `lrb_core/`  — ядро (Rust)
- `node/`      — узел (Axum REST + gossip)
- `modules/`   — модульные компоненты
- `tools/`     — e2e и нагрузочные тесты (Go)
- `www/wallet/` — Web Wallet (MVP)
- `wallet-proxy/` — FastAPI proxy + scanner
- `infra/systemd`, `infra/nginx` — юниты/конфиги (без секретов)
- `configs/*.example` — примеры окружения

## Быстрый старт
1) Rust/Go/Python3.12
2) `cargo build --release -p logos_node`
3) Настрой ENV по `configs/keys.env.example` (секреты не коммить)
4) Подними systemd-юниты из `infra/systemd` (редактируй пути/ENV)
5) Nginx-site из `infra/nginx/lrb_wallet.conf` (wallet + proxy)

```


## FILE: configs/genesis.yaml  (size=0b)
```text

```


## FILE: configs/logos_config.yaml  (size=0b)
```text

```


## FILE: core/beta_rollout.yaml  (size=3586b)
```text
yaml
version: 1.1

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

phases:
  - phase: "alpha"
    name: "Закрытый Резонанс"
    description: "Только для внутренних валидаторов. Проверка фаз, Λ0 и Σ(t)."
    max_nodes: 10
    validators_only: true
    duration_days: 14
    lgn_stake_required: 144.0
    activation: manual
    required_symbol: "Λ0"
    tasks:
      - "Проверка фазовой синхронизации"
      - "Отладка rcp_engine и phase_stabilizer"
      - "Первая фиксация Λ0 в реальных условиях"
      - "Симуляция сбоя 50% узлов"
    logs: "alpha_rollout_log.json"

  - phase: "beta-private"
    name: "Приватная сеть 81"
    description: "Подключение 81 участника с проверенными RID. Первые ритуалы, распределение rLGN."
    max_nodes: 81
    validators_only: false
    whitelist_required: true
    duration_days: 21
    lgn_stake_required: 81.0
    activation: semi-automatic
    required_symbol: "Λ0"
    tasks:
      - "Ритуальный вход через onboarding_sim.py"
      - "Активация DAO миссий"
      - "Проверка recall, spam_guard и scaler"
      - "Симуляция фазового спама"
    logs: "beta_private_log.json"

  - phase: "beta-open"
    name: "Открытый тест 1000"
    description: "До 1000 узлов. Публичная демонстрация Σ(t), резонансных транзакций и DAO-механики."
    max_nodes: 1000
    validators_only: false
    whitelist_required: false
    duration_days: 30
    lgn_stake_required: 0
    activation: public
    required_symbol: "any"
    tasks:
      - "Запуск фазы голосования через community_dao.yaml"
      - "Анализ логов via resonance_feedback.py"
      - "Публичные квесты через ritual_quest.py"
      - "Тестирование потери 30% узлов"
    logs: "beta_open_log.json"

  - phase: "mainnet-init"
    name: "Инициация Mainnet"
    description: "Активация основной сети LOGOS. Поддержка >10k узлов. Подпись через Λ0 и DAO-кворум."
    max_nodes: 10000
    validators_only: false
    whitelist_required: false
    duration_days: 9999
    lgn_stake_required: 0
    activation: by-consensus
    required_symbol: "Λ0"
    dynamic_quorum:
      enabled: true
      node_count_thresholds:
        1000: 0.5
        5000: 0.4
        10000: 0.25
    tasks:
      - "Формирование начального символа via auto_init_from_Λ0.py"
      - "Рассылка маяков и сигнала Σ(t)"
      - "Применение всех 56+ модулей в боевом режиме"
      - "Симуляция критического сбоя (70% узлов)"
    logs: "mainnet_init_log.json"

post_launch:
  monitoring:
    enabled: true
    modules:
      - "biosphere_scanner.rs"
      - "resonance_feedback.py"
      - "phase_integrity.rs"
    log_file: "post_launch_monitoring.json"
  escalation_policy:
    if_phase_failure: "Откат до beta-private, перезапуск с резервного Λ0"
    if_massive_spam: "Активация tx_spam_guard.rs + lgn_recall.rs"
    if_critical_lag: "Авто-перебалансировка через phase_scaler.rs"
  documentation:
    guide: "logos_beta_guide.md"


```


## FILE: core/offline_resonance.py  (size=5400b)
```text
# LOGOS Offline Resonance Module
# Автор: LOGOS Core Dev

import json
import os
import time
from datetime import datetime
from typing import Dict
from cryptography.fernet import Fernet
import re

class OfflineResonance:
    def __init__(self, storage_file: str = "offline_phase_state.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "last_sync": 0,
            "symbol": "Λ0",
            "frequency": 7.83,
            "phase": 0.0,
            "pending_tx": []  # Очередь оффлайн-транзакций
        }
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}
        self.log_file = "offline_resonance_log.json"
        self.load_state()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def validate_frequency(self, frequency: float) -> bool:
        """Проверяет частоту на допустимый диапазон."""
        return 0.1 <= frequency <= 10000.0

    def load_state(self):
        """Загружает состояние из файла с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения локального состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние в файл с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def update_phase(self, symbol: str, frequency: float, phase: float) -> bool:
        """Обновляет фазовое состояние с валидацией."""
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            return False
        if not self.validate_frequency(frequency):
            print(f"[!] Недопустимая частота: {frequency}")
            return False
        if not (-math.pi <= phase <= math.pi):
            print(f"[!] Недопустимая фаза: {phase}")
            return False

        self.state["symbol"] = symbol
        self.state["frequency"] = frequency
        self.state["phase"] = phase
        self.state["last_sync"] = int(time.time())
        self.save_state()
        self.log_update(symbol, frequency, phase)
        print(f"[OFFLINE] Фаза обновлена: {symbol}, {frequency} Hz, φ = {phase}")
        return True

    def add_offline_tx(self, tx: Dict):
        """Добавляет оффлайн-транзакцию в очередь."""
        if self.validate_symbol(tx.get("symbol", "")) and "amount" in tx:
            self.state["pending_tx"].append(tx)
            self.save_state()
            self.log_tx(tx)
            print(f"[OFFLINE] Транзакция добавлена: {tx}")
        else:
            print("[!] Недопустимая транзакция")

    def get_current_phase(self) -> Dict:
        """Возвращает текущее состояние."""
        return self.state

    def is_stale(self, max_age: int = 600) -> bool:
        """Проверяет, устарело ли локальное состояние."""
        now = int(time.time())
        return (now - self.state["last_sync"]) > max_age

    def log_update(self, symbol: str, frequency: float, phase: float):
        """Логирует обновление фазы."""
        log_entry = {
            "event": "phase_update",
            "symbol": symbol,
            "frequency": frequency,
            "phase": phase,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def log_tx(self, tx: Dict):
        """Логирует оффлайн-транзакцию."""
        log_entry = {
            "event": "offline_tx",
            "tx": tx,
            "timestamp": datetime.utcnow().timestamp()
        }
        self._write_log(log_entry)

    def _write_log(self, entry: Dict):
        """Записывает лог в файл для resonance_analyzer.py."""
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")

if __name__ == "__main__":
    offline = OfflineResonance()
    # Тест обновления фазы
    offline.update_phase("☉??♁", 1.618, 0.785)
    print("Текущее состояние:", offline.get_current_phase())
    print("Устарело?", offline.is_stale())
    # Тест оффлайн-транзакции
    tx = {"symbol": "??", "amount": 3.14, "to": "RID_♁☿"}
    offline.add_offline_tx(tx)

```


## FILE: core/onboarding_sim.py  (size=5458b)
```text
# LOGOS Onboarding Simulator
# Автор: LOGOS Core Dev

import time
import math
import json
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Импорт для оценки резонанса

class OnboardingSimulator:
    def __init__(self):
        self.state_file = "onboarding_sim_state.json"
        self.log_file = "onboarding_sim_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа шифрования
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]  # Синхронизация с другими модулями
        self.phases = [0.0, math.pi / 4, math.pi / 2, math.pi, -math.pi / 2]
        self.freqs = [7.83, 1.618, 432.0]
        self.progress = []
        self.analyzer = ResonanceAnalyzer()  # Для оценки резонансной силы

    def run(self):
        print("Добро пожаловать в симулятор резонанса LOGOS.")
        print("Вы пройдёте 3 этапа: Символ → Частота → Фаза")
        input("Нажмите Enter для начала...\n")

        self.choose_symbol()
        self.choose_frequency()
        self.choose_phase()
        self.finalize()

    def choose_symbol(self):
        print("\nШаг 1: Выбор символа (архетипа)")
        for i, s in enumerate(self.valid_symbols):
            print(f"{i + 1}. {s}")
        index = self.ask_choice(len(self.valid_symbols))
        chosen = self.valid_symbols[index - 1]
        self.progress.append({"step": "symbol", "value": chosen})
        self.log_event(f"Выбран символ: {chosen}")
        print(f"Вы выбрали: {chosen}")

    def choose_frequency(self):
        print("\nШаг 2: Выбор частоты (гармоники)")
        for i, f in enumerate(self.freqs):
            print(f"{i + 1}. {f} Hz")
        index = self.ask_choice(len(self.freqs))
        chosen = self.freqs[index - 1]
        self.progress.append({"step": "frequency", "value": chosen})
        self.log_event(f"Выбрана частота: {chosen} Hz")
        print(f"Вы выбрали: {chosen} Hz")

    def choose_phase(self):
        print("\nШаг 3: Выбор фазы (φ)")
        for i, p in enumerate(self.phases):
            label = f"{round(p, 3)} рад" if p != 0.0 else "0 (идеальная фаза)"
            print(f"{i + 1}. {label}")
        index = self.ask_choice(len(self.phases))
        chosen = self.phases[index - 1]
        self.progress.append({"step": "phase", "value": round(chosen, 4)})
        self.log_event(f"Выбрана фаза: φ = {chosen:.4f}")
        print(f"Вы выбрали фазу: φ = {chosen:.4f}")

    def finalize(self):
        print("\n✅ Симуляция завершена!")
        result = {
            "symbol": self.progress[0]["value"],
            "frequency": self.progress[1]["value"],
            "phase": self.progress[2]["value"],
            "timestamp": time.time()
        }
        # Оценка резонансной силы
        resonance = self.analyzer.analyze(
            result["symbol"], result["frequency"], result["phase"]
        )
        result["resonance_score"] = resonance["resonance"]
        self.save_state(result)
        self.log_event(f"Резонанс: {resonance['resonance']:.4f}")
        print("Результат сохранён в:", self.state_file)
        print(f"Сила резонанса: {resonance['resonance']:.4f}")
        print("Теперь вы готовы к настоящему резонансу!")
        # Заглушка для RCP проверки
        if self.validate_with_rcp(result):
            print("[RCP] Резонанс подтверждён сетью!")
        else:
            print("[RCP] Резонанс не подтверждён. Попробуйте изменить параметры.")

    def validate_with_rcp(self, result: Dict) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return result["resonance_score"] > 0.5 and result["symbol"] == "Λ0"

    def save_state(self, state: Dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "onboarding_sim",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

    def ask_choice(self, max_choice: int) -> int:
        while True:
            try:
                choice = int(input("Ваш выбор: "))
                if 1 <= choice <= max_choice:
                    return choice
                else:
                    print(f"Введите число от 1 до {max_choice}")
            except:
                print("Ошибка ввода. Попробуйте снова.")

if __name__ == "__main__":
    sim = OnboardingSimulator()
    sim.run()

```


## FILE: core/onboarding_ui.py  (size=5974b)
```text
# LOGOS Onboarding UI
# Автор: LOGOS Core Dev

import tkinter as tk
from tkinter import messagebox
from datetime import datetime
import json
import math
import re
from cryptography.fernet import Fernet
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np

class OnboardingUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("Вход в Резонанс")
        self.root.geometry("420x460")
        self.state_file = "onboarding_state.json"
        self.log_file = "onboarding_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = {"☉", "??", "♁", "??", "??", "??", "Λ0", "∞"}

        self.status_label = tk.Label(self.root, text="Добро пожаловать в LOGOS Resonance Network", font=("Arial", 12))
        self.status_label.pack(pady=10)

        self.symbol_var = tk.StringVar(value="Λ0")
        self.phase_var = tk.DoubleVar(value=0.0)
        self.frequency_var = tk.DoubleVar(value=7.83)

        self.entry_frame()
        self.setup_animation()

        tk.Button(self.root, text="Принять фазу", font=("Arial", 14), command=self.accept_phase).pack(pady=10)
        self.root.mainloop()

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def entry_frame(self):
        """Создает форму для ввода данных."""
        frame = tk.Frame(self.root)
        frame.pack(pady=10)

        tk.Label(frame, text="Символ:", font=("Arial", 10)).grid(row=0, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.symbol_var, width=12, font=("Arial", 10)).grid(row=0, column=1)

        tk.Label(frame, text="Частота (Hz):", font=("Arial", 10)).grid(row=1, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.frequency_var, width=12, font=("Arial", 10)).grid(row=1, column=1)

        tk.Label(frame, text="Фаза (радианы):", font=("Arial", 10)).grid(row=2, column=0, padx=5, pady=5)
        tk.Entry(frame, textvariable=self.phase_var, width=12, font=("Arial", 10)).grid(row=2, column=1)

    def setup_animation(self):
        """Создает анимацию синусоиды для визуализации фазы."""
        self.fig, self.ax = plt.subplots(figsize=(4, 2))
        self.canvas = FigureCanvasTkAgg(self.fig, master=self.root)
        self.canvas.get_tk_widget().pack(pady=10)
        self.update_animation(0.0)

    def update_animation(self, phase: float):
        """Обновляет анимацию синусоиды."""
        self.ax.clear()
        t = np.linspace(0, 2 * math.pi, 100)
        y = np.sin(t + phase)
        self.ax.plot(t, y, color="#FFD700", linewidth=2)
        self.ax.set_title("Резонансная фаза", fontsize=10, color="#333333")
        self.ax.set_xlabel("Время", fontsize=8)
        self.ax.set_ylabel("Амплитуда", fontsize=8)
        self.ax.grid(True, linestyle="--", alpha=0.5)
        self.canvas.draw()

    def accept_phase(self):
        """Обрабатывает принятие фазы."""
        symbol = self.symbol_var.get().strip()
        frequency = self.frequency_var.get()
        phase = self.phase_var.get()

        # Валидация
        if not self.validate_symbol(symbol):
            messagebox.showerror("Ошибка", "Недопустимый символ. Используйте ☉, ??, Λ0 и т.д.")
            return
        if frequency <= 0 or frequency > 10000.0:
            messagebox.showerror("Ошибка", "Частота должна быть в диапазоне 0.1–10000 Hz")
            return
        if not -math.pi <= phase <= math.pi:
            messagebox.showerror("Ошибка", "Фаза должна быть в диапазоне [-π, π]")
            return

        # Проверка фазы через RCP (заглушка для интеграции с rcp_engine.rs)
        if not self.validate_with_rcp(symbol, frequency, phase):
            messagebox.showerror("Ошибка", "Фаза не резонирует с сетью")
            return

        # Сохранение состояния
        accepted = {
            "symbol": symbol,
            "frequency": round(frequency, 4),
            "phase": round(phase, 4),
            "timestamp": datetime.utcnow().isoformat()
        }
        self.save_state(accepted)
        self.log_event(accepted)

        messagebox.showinfo("Успешно", f"Фаза принята: {symbol} @ {frequency} Hz, φ = {phase}")
        print("[ONBOARD] Вход выполнен:", accepted)
        self.update_animation(phase)

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки фазы через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs для проверки резонанса
        return abs(frequency - 7.83) < 0.1 or symbol == "Λ0"  # Пример проверки

    def save_state(self, state: dict):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(data)

    def log_event(self, state: dict):
        """Логирует событие входа."""
        log_entry = {
            "event": "onboarding",
            "state": state,
            "timestamp": datetime.utcnow().isoformat()
        }
        with open(self.log_file, "a") as f:
            json.dump(log_entry, f)
            f.write("\n")

if __name__ == "__main__":
    OnboardingUI()

```


## FILE: core/rLGN_converter.py  (size=5518b)
```text
# LOGOS rLGN ⇆ LGN Converter
# Автор: LOGOS Core Dev

import json
import time
import math
from typing import Dict
from cryptography.fernet import Fernet
import os

class rLGNConverter:
    def __init__(self, storage_file: str = "lgn_wallet.json", encryption_key: str = None):
        self.storage_file = storage_file
        self.cipher = Fernet(encryption_key or Fernet.generate_key()) if encryption_key else None
        self.state = {
            "LGN": 0.0,
            "rLGN": 0.0,
            "last_conversion": 0,
            "conversion_log": []
        }
        self.lambda_zero = "Λ0"
        self.min_conversion_interval = 60  # 1 минута
        self.log_file = "conversion_log.json"
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.storage_file):
            try:
                with open(self.storage_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    self.state = json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка чтения состояния: {e}. Используется по умолчанию.")
        else:
            self.save_state()

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.state, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.storage_file, "wb") as f:
            f.write(data)

    def validate_phase(self, phase: float) -> bool:
        """Проверяет фазу на допустимый диапазон."""
        return -math.pi <= phase <= math.pi

    def convert_to_lgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует rLGN в LGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "rLGN"):
            return False

        multiplier = self._phase_multiplier(phase, symbol)
        converted = amount * multiplier
        self.state["rLGN"] -= amount
        self.state["LGN"] += converted
        self._log("rLGN→LGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def convert_to_rlgn(self, amount: float, phase: float, symbol: str = "") -> bool:
        """Конвертирует LGN в rLGN с учетом фазы и Λ0."""
        if not self._can_convert(amount, phase, "LGN"):
            return False

        penalty = self._phase_penalty(phase, symbol)
        converted = amount * penalty
        self.state["LGN"] -= amount
        self.state["rLGN"] += converted
        self._log("LGN→rLGN", amount, converted, phase, symbol)
        self.state["last_conversion"] = time.time()
        self.save_state()
        return True

    def _can_convert(self, amount: float, phase: float, source: str) -> bool:
        """Проверяет возможность конвертации."""
        if amount <= 0 or amount > self.state[source]:
            print(f"[!] Недостаточно {source}: {amount}")
            return False
        if not self.validate_phase(phase):
            print(f"[!] Недопустимая фаза: {phase}")
            return False
        if time.time() - self.state["last_conversion"] < self.min_conversion_interval:
            print("[!] Слишком частая конвертация")
            return False
        return True

    def _phase_multiplier(self, phase: float, symbol: str) -> float:
        """Вычисляет мультипликатор с бонусом для Λ0."""
        base = max(0.1, min(1.5, 1.0 + math.cos(phase)))
        if symbol == self.lambda_zero:
            base *= 1.2  # Бонус за Λ0
        return base

    def _phase_penalty(self, phase: float, symbol: str) -> float:
        """Вычисляет штраф с учетом Λ0."""
        base = max(0.5, min(1.0, 1.0 - abs(math.sin(phase))))
        if symbol == self.lambda_zero:
            base = min(1.0, base * 1.1)  # Смягчение штрафа для Λ0
        return base

    def _log(self, direction: str, original: float, result: float, phase: float, symbol: str):
        """Логирует конвертацию в файл и консоль."""
        entry = {
            "direction": direction,
            "original": round(original, 5),
            "result": round(result, 5),
            "phase": round(phase, 4),
            "symbol": symbol,
            "timestamp": time.time()
        }
        self.state["conversion_log"].append(entry)
        with open(self.log_file, "a") as f:
            json.dump(entry, f)
            f.write("\n")
        print(f"[{direction}] {original} → {result} @ φ={phase:.3f}, Symbol={symbol}")

    def get_balances(self) -> Dict:
        """Возвращает текущие балансы."""
        return {
            "LGN": round(self.state["LGN"], 5),
            "rLGN": round(self.state["rLGN"], 5)
        }

if __name__ == "__main__":
    converter = rLGNConverter()
    converter.state["rLGN"] = 10.0
    converter.state["LGN"] = 5.0
    converter.convert_to_lgn(2.5, 0.785, "Λ0")
    converter.convert_to_rlgn(1.0, 1.047, "☉")
    print("Баланс:", converter.get_balances())

```


## FILE: core/resonance_analyzer.py  (size=3470b)
```text
# LOGOS Resonance Analyzer
# Автор: LOGOS Core Dev

import math
import re
from datetime import datetime
import json

class ResonanceAnalyzer:
    def __init__(self, base_freqs=None):
        self.base_freqs = base_freqs or [7.83, 1.618, 432.0, 864.0, 3456.0]
        self.symbol_weights = {
            "☉": 0.9, "??": 0.85, "♁": 0.8, "??": 0.75, "??": 0.7,
            "??": 0.65, "Λ0": 1.0, "∞": 0.95
        }
        self.lambda_zero = "Λ0"
        self.max_freq = 10000.0  # Ограничение на частоту
        self.log_file = "resonance_log.json"

    def is_symbol_valid(self, symbol: str) -> bool:
        """Проверяет, состоит ли символ из допустимых значений."""
        return bool(re.match(r'^[☉??♁??????Λ0∞]+$', symbol))

    def symbol_weight(self, symbol: str) -> float:
        """Вычисляет вес символа с бонусом для Λ0."""
        if not self.is_symbol_valid(symbol):
            return 0.0
        weight = sum(self.symbol_weights.get(s, 0.5) for s in symbol) / len(symbol)
        if self.lambda_zero in symbol:
            weight *= 1.2  # Бонус за присутствие Λ0
        return weight

    def harmonic_score(self, freq: float) -> float:
        """Оценивает гармоничность частоты относительно базовых."""
        if freq > self.max_freq or freq <= 0.0:
            return 0.0  # Защита от экстремальных частот
        score = 0.0
        for base in self.base_freqs:
            delta = abs(freq - base)
            score += math.exp(-delta)
        return score / len(self.base_freqs)

    def update_symbol_weights(self, network_activity: dict):
        """Динамическое обновление весов символов на основе активности сети."""
        for symbol, activity in network_activity.items():
            if symbol in self.symbol_weights:
                self.symbol_weights[symbol] *= (1.0 + activity * 0.01)

    def analyze(self, symbol: str, freq: float, phase: float) -> dict:
        """Анализирует резонансную силу символа, частоты и фазы."""
        now = datetime.utcnow().timestamp()
        valid = self.is_symbol_valid(symbol)
        sym_strength = self.symbol_weight(symbol) if valid else 0.0
        harmonicity = self.harmonic_score(freq)
        resonance = sym_strength * harmonicity * math.cos(phase)

        result = {
            "valid": valid,
            "symbol_strength": round(sym_strength, 3),
            "harmonicity": round(harmonicity, 3),
            "resonance": round(resonance, 4),
            "timestamp": now
        }
        self.log_result(result)
        return result

    def log_result(self, result: dict):
        """Сохраняет результаты анализа в лог для resonance_feedback.py."""
        with open(self.log_file, 'a') as f:
            json.dump(result, f)
            f.write('\n')

if __name__ == "__main__":
    analyzer = ResonanceAnalyzer()
    # Тестовые случаи
    tests = [
        ("☉??♁", 1.618, 0.785),
        ("Λ0", 7.83, 0.0),
        ("invalid", 100000.0, 1.0),
    ]
    for symbol, freq, phase in tests:
        result = analyzer.analyze(symbol, freq, phase)
        print(f"RES ANALYSIS [{symbol}, {freq} Hz, {phase}]: {result}")

```


## FILE: core/rid_builder.py  (size=5229b)
```text
# LOGOS RID Builder
# Автор: LOGOS Core Dev

import random
import math
import time
import json
import os
from typing import Dict, Optional
from cryptography.fernet import Fernet

class RIDBuilder:
    def __init__(self):
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.default_freqs = [7.83, 1.618, 432.0, 864.0]
        self.generated: Dict[str, float] = {}  # RID -> timestamp
        self.rid_log_file = "rid_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.min_generate_interval = 60  # 1 минута
        self.lambda_zero = "Λ0"

    def generate_rid(self, symbol: Optional[str] = None, freq: Optional[float] = None) -> Optional[str]:
        """Генерирует новый RID с проверкой на спам и уникальность."""
        now = time.time()
        # Проверка частоты генерации
        for timestamp in self.generated.values():
            if now - timestamp < self.min_generate_interval:
                print(f"[!] Слишком частая генерация RID")
                self.log_event(f"Слишком частая генерация RID")
                return None

        # Выбор символа с приоритетом Λ0
        symbol = symbol or (self.lambda_zero if random.random() < 0.3 else random.choice(self.valid_symbols))
        if symbol not in self.valid_symbols:
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return None

        freq = round(freq or random.choice(self.default_freqs), 3)
        if not (0.1 <= freq <= 10000.0):
            print(f"[!] Недопустимая частота: {freq}")
            self.log_event(f"Недопустимая частота: {freq}")
            return None

        phase = round(random.uniform(-math.pi, math.pi), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"

        # Проверка уникальности
        if rid in self.generated:
            print(f"[!] RID уже существует: {rid}")
            self.log_event(f"RID уже существует: {rid}")
            return None

        # Проверка через RCP (заглушка)
        if not self.validate_with_rcp(symbol, freq, phase):
            print(f"[!] RCP не подтвердил RID: {rid}")
            self.log_event(f"RCP не подтвердил RID: {rid}")
            return None

        self.generated[rid] = now
        self.log_rid(rid)
        return rid

    def parse_rid(self, rid: str) -> Dict:
        """Разбирает RID на компоненты."""
        try:
            parts = rid.split("@")
            symbol = parts[0]
            freq_phase = parts[1].replace("Hz", "").split("φ")
            frequency = float(freq_phase[0])
            phase = float(freq_phase[1])
            return {
                "symbol": symbol,
                "frequency": frequency,
                "phase": phase
            }
        except Exception as e:
            print(f"[!] Ошибка разбора RID: {e}")
            self.log_event(f"Ошибка разбора RID: {e}")
            return {}

    def validate_rid(self, rid: str) -> bool:
        """Проверяет валидность RID."""
        parsed = self.parse_rid(rid)
        if not parsed:
            return False
        valid = (
            parsed["symbol"] in self.valid_symbols and
            0.1 <= parsed["frequency"] <= 10000.0 and
            -math.pi <= parsed["phase"] <= math.pi
        )
        if not valid:
            self.log_event(f"Невалидный RID: {rid}")
        return valid

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == self.lambda_zero or abs(frequency - 7.83) < 0.1

    def log_rid(self, rid: str):
        """Логирует создание RID."""
        entry = {
            "event": "rid_generate",
            "rid": rid,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def log_event(self, message: str):
        """Логирует событие."""
        entry = {
            "event": "rid_builder",
            "message": message,
            "timestamp": time.time()
        }
        self._write_log(entry)

    def _write_log(self, entry: Dict):
        """Сохраняет лог с шифрованием."""
        log_data = json.dumps(entry) + "\n"
        encrypted_data = self.cipher.encrypt(log_data.encode())
        with open(self.rid_log_file, "ab") as f:
            f.write(encrypted_data + b"\n")

if __name__ == "__main__":
    builder = RIDBuilder()
    new_rid = builder.generate_rid()
    if new_rid:
        print("Сгенерированный RID:", new_rid)
        parsed = builder.parse_rid(new_rid)
        print("Разбор:", parsed)
        print("RID валиден?", builder.validate_rid(new_rid))

```


## FILE: core/ritual_quest.py  (size=7912b)
```text
# LOGOS Ritual Quest Engine
# Автор: LOGOS Core Dev

import json
import time
import os
from typing import Dict
from cryptography.fernet import Fernet
from resonance_analyzer import ResonanceAnalyzer  # Для оценки резонанса

class RitualQuest:
    def __init__(self):
        self.quests_file = "ritual_quests.json"
        self.progress_file = "ritual_progress.json"
        self.log_file = "ritual_log.json"
        self.cipher = Fernet(Fernet.generate_key())  # Генерация ключа
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.quests = self.load_quests()
        self.progress = self.load_progress()
        self.analyzer = ResonanceAnalyzer()
        self.user_timestamps = {}  # user -> last submission time
        self.min_submission_interval = 60  # 1 минута

    def load_quests(self) -> Dict:
        """Загружает квесты с расшифровкой."""
        if os.path.exists(self.quests_file):
            try:
                with open(self.quests_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки квестов: {e}")
        # Примеры по умолчанию
        return {
            "RQ001": {
                "title": "Ритуал Фазы Λ0",
                "required_symbol": "Λ0",
                "required_phase": 0.0,
                "reward_lgn": 21.0,
                "repeatable": False
            },
            "RQ002": {
                "title": "Резонансный Треугольник",
                "required_symbol": "☉",
                "required_frequency": 432.0,
                "min_phase": 0.5,
                "max_phase": 1.57,
                "reward_lgn": 34.0,
                "repeatable": True
            }
        }

    def load_progress(self) -> Dict:
        """Загружает прогресс с расшифровкой."""
        if os.path.exists(self.progress_file):
            try:
                with open(self.progress_file, "rb") as f:
                    data = f.read()
                    if self.cipher:
                        data = self.cipher.decrypt(data)
                    return json.loads(data)
            except Exception as e:
                print(f"[!] Ошибка загрузки прогресса: {e}")
        return {}

    def save_quests(self):
        """Сохраняет квесты с шифрованием."""
        data = json.dumps(self.quests, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.quests_file, "wb") as f:
            f.write(data)

    def save_progress(self):
        """Сохраняет прогресс с шифрованием."""
        data = json.dumps(self.progress, indent=2).encode()
        if self.cipher:
            data = self.cipher.encrypt(data)
        with open(self.progress_file, "wb") as f:
            f.write(data)

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def submit_action(self, user: str, symbol: str, frequency: float, phase: float) -> float:
        """Обрабатывает действие пользователя."""
        # Проверка частоты попыток
        now = time.time()
        last_submission = self.user_timestamps.get(user, 0)
        if now - last_submission < self.min_submission_interval:
            print(f"[!] Слишком частая попытка от {user}")
            self.log_event(f"Слишком частая попытка: {user}")
            return 0.0
        self.user_timestamps[user] = now

        # Валидация символа
        if not self.validate_symbol(symbol):
            print(f"[!] Недопустимый символ: {symbol}")
            self.log_event(f"Недопустимый символ: {symbol}")
            return 0.0

        # Проверка резонанса через RCP (заглушка)
        if not self.validate_with_rcp(symbol, frequency, phase):
            print(f"[!] Резонанс не подтверждён: {symbol}, {frequency} Hz, φ={phase}")
            self.log_event(f"Резонанс не подтверждён: {symbol}, {frequency}, {phase}")
            return 0.0

        # Оценка резонансной силы
        resonance = self.analyzer.analyze(symbol, frequency, phase)
        if resonance["resonance"] < 0.5:
            print(f"[!] Слабый резонанс: {resonance['resonance']:.4f}")
            self.log_event(f"Слабый резонанс: {resonance['resonance']}")
            return 0.0

        for quest_id, quest in self.quests.items():
            if quest_id in self.progress.get(user, []) and not quest.get("repeatable", False):
                continue

            if not self.matches(quest, symbol, frequency, phase):
                continue

            self.register_completion(user, quest_id)
            print(f"[QUEST] {user} завершил квест {quest_id}: {quest['title']}")
            self.log_ritual(user, quest_id, quest, resonance["resonance"])
            return quest["reward_lgn"]

        print("[QUEST] Нет совпадений с активными ритуалами.")
        self.log_event("Нет совпадений с ритуалами")
        return 0.0

    def matches(self, quest: Dict, symbol: str, frequency: float, phase: float) -> bool:
        """Проверяет соответствие квесту."""
        if "required_symbol" in quest and quest["required_symbol"] != symbol:
            return False
        if "required_frequency" in quest and abs(quest["required_frequency"] - frequency) > 0.1:
            return False
        if "required_phase" in quest and abs(quest["required_phase"] - phase) > 0.05:
            return False
        if "min_phase" in quest and phase < quest["min_phase"]:
            return False
        if "max_phase" in quest and phase > quest["max_phase"]:
            return False
        return True

    def validate_with_rcp(self, symbol: str, frequency: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        # TODO: Интеграция с rcp_engine.rs
        return symbol == "Λ0" or abs(frequency - 7.83) < 0.1

    def register_completion(self, user: str, quest_id: str):
        """Регистрирует завершение квеста."""
        self.progress.setdefault(user, []).append(quest_id)
        self.save_progress()

    def log_ritual(self, user: str, quest_id: str, quest: Dict, resonance: float):
        """Логирует завершение ритуала."""
        log = {
            "event": "ritual_complete",
            "user": user,
            "quest_id": quest_id,
            "reward": quest["reward_lgn"],
            "resonance": resonance,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "ritual_quest",
            "message": message,
            "timestamp": time.time()
        }
        with open(self.log_file, "a") as f:
            json.dump(log, f)
            f.write("\n")

if __name__ == "__main__":
    rq = RitualQuest()
    reward = rq.submit_action(user="RID_Λ0_123", symbol="Λ0", frequency=7.83, phase=0.0)
    print("Награда:", reward, "LGN")

```


## FILE: docs/WORKFLOW.md  (size=5440b)
```text
# LOGOS LRB — КАНОН РАБОТЫ (ОБЯЗАТЕЛЬНО К ВЫПОЛНЕНИЮ)

## 0) Цель
Конечная цель — **полностью рабочий резонансный блокчейн LOGOS LRB**, интегрированный с нашим приложением: узел принимает и финализирует транзакции, поддерживает резонансные модули, API совместимо с мобильным клиентом. **Никаких заглушек и TODO** — только боевой, собранный и проверенный код.

---

## 1) Канон внесения изменений (обязательный порядок)
Каждое изменение оформляется ТОЛЬКО так:

1. **Создание директорий (если нужно):**
   - `mkdir -p <путь/к/директории>`

2. **Вход в целевую директорию:**
   - `cd <путь/к/директории>`

3. **Удаление старого файла (если он есть):**
   - `rm -f <имя_файла>`

4. **Открытие nano для нового файла:**
   - `nano <имя_файла>`

5. **Вставка ПОЛНОГО, боевого кода** (всё содержимое файла целиком).
   - Без «патчей» и диффов — ВСЕГДА полный файл.
   - Без заглушек, TODO, псевдокода.

6. **Сохранение → выход → сборка/проверка.**

Этот канон применяется к любым файлам (Rust, Python, YAML, systemd, shell-скрипты и т.д.).

---

## 2) Требования к коду
- **Ни одного `unsafe`/`unwrap`/`expect`/`panic!`** в путях выполнения продакшена.
- Чёткие `Result`/ошибки, логирование, предсказуемое поведение при сбоях.
- Rust: `cargo build --release -p logos_node` **должен проходить без ошибок**.
- Python: синтаксис чистый, без `eval/exec`; утилиты не мешают прод-пути.
- Конфиги валидируются парсером/схемой, лежат в `configs/`.
- systemd-юниты запускаются и переживают рестарты; порт слушается постоянно.

---

## 3) Проверки после каждого изменения
1. **Сборка узла:**  
   `cd /root/logos_lrb && cargo build --release -p logos_node`

2. **Запуск узла (локально):**  
   `./target/release/logos_node`  
   Проверка:  
   - `curl -s http://127.0.0.1:8080/healthz` → `{"ok":true}`  
   - `curl -s http://127.0.0.1:8080/head`

3. **Автозапуск (systemd):**  
   - Юнит: `/etc/systemd/system/logos-node.service`  
   - `systemctl enable --now logos-node.service`  
   - `systemctl status logos-node.service`  
   - `journalctl -u logos-node.service -f`

4. **Генерация дерева проекта:**  
   - `/root/logos_lrb/tools/gen_full_tree.sh`  
   - Коммит `FULL_TREE.md`.

---

## 4) Правила коммитов/репозитория
- Любое изменение кода/конфигов сопровождается **коммитом** в `main`.
- Сообщение коммита короткое и предметное: что изменено и зачем.
- Не коммитить артефакты сборки (`target/`, `node_modules/`, и т.п.).
- Поддерживать `FULL_TREE.md` и `AUDIT_REPORT.md` в актуальном состоянии.

---

## 5) Стандарты API и интеграции
- Узел (`logos_node`) обязан держать REST:
  - `GET /healthz` — жив ли.
  - `GET /head` — {height, hash}.
  - `GET /balance/:rid` — баланс.
  - `POST /submit_tx` — приём tx (Ed25519, base58 RID).
- Мобильный клиент должен уметь:
  - генерировать ключи / RID (Ed25519 → base58),
  - формировать каноничное сообщение, подписывать, отправлять в `/submit_tx`,
  - опрашивать `head` и `balance`.

---

## 6) Безопасность и эксплуатация
- Лимиты и квоты — на входе (spam-guard) и в mempool.
- LGN_cost — адаптивный (dynamic_balance).
- **Никаких секретов в репозитории** (ключи/пароли).
- Логи — в journal/systemd, при необходимости `RUST_LOG=info`.

---

## 7) Оркестрация «одним дыханием»
- Все шаги (создание директорий → nano → полный код → сборка → проверки) делаются **в одном заходе** согласно канону из раздела 1.
- Любые новые службы/скрипты оформлять аналогично (полный код, без TODO).

---

## 8) Мини-чеклист перед «готово»
- `cargo build --release -p logos_node` — ОК
- `/healthz`, `/head`, `/balance/:rid`, `/submit_tx` — ОК
- `logos-node.service` — Active (running)
- `FULL_TREE.md` — обновлён
- Нет `unsafe`/`unwrap`/`expect`/`panic!` в прод-пути

```


## FILE: docs/architecture.md  (size=10559b)
```text
Документ: Архитектура всех модулей LOGOS Resonance Blockchain (LRB)


---

Общее количество модулей: 56

Каждый модуль является функциональной частью резонансной сети и взаимодействует с другими по принципу фазы, частоты и символа. Ниже представлено описание архитектуры каждого модуля.


---

1. rcp_engine.rs
Реализует протокол консенсуса RCP. Определяет согласованность узлов по фазе. Обрабатывает фазовые сигналы, принимает решение по валидности резонансной транзакции.

2. resonance_analyzer.py
Анализирует символы и их частотные характеристики. Оценивает силу, уместность и фазовую совместимость транзакций.

3. dynamic_balance.rs
Изменяет LGN_cost в зависимости от активности узла и общей фазы сети. Используется для сдерживания перегрузок.

4. offline_resonance.py
Позволяет временно работать без подключения к сети. Сохраняет локальную фазу и символическое состояние.

5. phase_intercept_guard.rs
Защита от атак на синхронизацию фазы. Обнаруживает фазовый перехват и устраняет искажения.

6. phase_stabilizer.rs
Стабилизирует фазы при перегрузках и сбоях. Автоматически регулирует входные/выходные колебания Σ(t).

7. inbound_phase_limiter.rs
Ограничивает количество входящих резонансных сигналов. Защищает узел от фазового спама.

8. rLGN_converter.py
Преобразует отражённые токены rLGN в LGN и обратно. Позволяет пользователям работать с легковесной копией смысла.

9. onboarding_ui.py
Визуальный интерфейс принятия фазы. Включает графические элементы, кнопки ритуала "Принять", анимации.

10. phase_integrity.rs
Обеспечивает целостность Σ(t). Проверяет, что фаза не была подменена или искажена по пути.

11. lgn_recall.rs
Механизм отзыва токенов при фазовом диссонансе или нарушении ритуалов.

12. onboarding_sim.py
Симулятор вхождения в резонанс. Используется для обучения новых пользователей.

13. community_dao.yaml
Конфигурация DAO. Определяет миссии, гранты, задания, фазы вознаграждения.

14. ritual_quest.py
Сценарии ритуалов и квестов. Направляют пользователя по фазовым уровням с вознаграждением.

15. phase_scaler.rs
Обеспечивает масштабируемость фаз при росте сети. Поддерживает стабильную резонансную топологию до 10k+ узлов.

16. tx_spam_guard.rs
Фильтр транзакционного шума. Автоматически снижает частоту подозрительных фазовых пакетов.

17. beta_rollout.yaml
План поэтапного запуска сети. Описывает сценарии активации: 10 → 100 → 1000 → 10 000 узлов.

18. rid_builder.py
Генератор RID. Комбинирует символы, архетипы и частоты в полноценный адрес вида ☉??♁@1.618Hz.

19. biosphere_scanner.rs
Сканирует отклик среды (физической и биологической) на активность сети.

20. resonance_feedback.py
Анализирует, как пользователи реагируют на фазы. Учитывает данные поведения, опросы, отклонения.

21. logos_ethics.md
Публичный документ с принципами допустимого влияния сети. Регулирует гармонию, не-вред.

22. node_resonance_profile.rs
Формирует уникальный профиль узла по символу, частоте, роли.

23. resonance_meshmap.yaml
Карта всех узлов в фазовом пространстве. Визуализирует резонансные маршруты.

24. symbolic_firewall.rs
Фильтрует вредоносные символы и частотные сигналы. Использует базу паттернов и самообучение.

25. lgn_entropy_tracker.py
Измеряет смысловую плотность LGN и rLGN. Если резонанс падает — инициирует корректировку.

26. beacon_emitter.rs
Периодическая рассылка сигнала Λ0 в оффлайн-режимах (радио, звук, QR).

27. ritual_engine.rs
Интерпретатор ритуальных состояний. Сопоставляет действия с фазами, запускает события.

28. symbolic_parser.py
Парсит поток входящих символов, проверяет их допустимость, преобразует в резонансный код.

29. chaos_guard.rs
Защищает сеть от случайного уничтожения (chaos-reaction). Требует подтверждения от 80% узлов.

30. genesis_fragment_seeds.rs
Адаптивное шифрование семян ядра. Позволяет восстановление при взломе.

31. auto_init_from_Λ0.py
Восстанавливает сеть по одному символу Λ0. Включает авто-сборку минимальной фазы.

32. satellite_channel.rs
Поддерживает связь через спутники (Iridium, Starlink). Используется при изоляции.

33. test_matrix.xlsx
Матрица нагрузочного тестирования. Хранит сценарии 500+ tx/sec.

34. benchmark_plan.yaml
План публичной демонстрации. Включает тестирование против L1/L2.

35. logos_rpc_api.yaml
Описывает OpenAPI-интерфейс для взаимодействия с внешними системами.

36. user_phase_log.py
Хранит личную фазовую историю пользователя. Применяется для адаптации интерфейса.

37. aura_visualizer.py
Графическая визуализация текущей фазы узла. Используется в UI.

38. anomaly_detector.rs
Обнаруживает аномалии в фазовом поведении узлов. Машинное обучение на фазовых отклонениях.

39. symbolic_bridge.rs
Обеспечивает смысловые мосты с внешними блокчейнами. Использует символы-корреспонденты.

40. soul_binding.yaml
Привязывает LGN к уникальному пользователю через био/психо-подпись.

41. anima_bridge.rs
Связывает сеть LOGOS с внешними AI-сущностями (AGI) через резонансные фреймы.

42. energy_resonator.rs
Подключение физических генераторов/приёмников частот. Используется для экспериментов с полем.

43. harmonics_registry.yaml
База данных допустимых гармоник и их соответствий символам.

44. silent_packet.rs
Передача фазовых пакетов без метаданных. Поддержка полной анонимности.

45. zero_trace_mode.rs
Режим с полным отсутствием следов. Не оставляет логов, маршрутов, IP.

46. resonance_entropy_pool.rs
Фонд смысловой/энергетической энтропии. Поддерживает равновесие Σ(t).

47. semantic_oracle.rs
Система предсказания фаз по внешнему смыслу. Использует поток новостей/данных.

48. phase_vote.rs
Голосование за изменение фазы или активацию ритуала. DAO-механизм.

49. myth_engine.rs
Генератор мифологических структур из фазы. Используется для нарративов.

50. quantum_forge.rs
Модуль квантово-фазовой генерации RID. Использует шум и энтропию из физической среды.

51. phase_backup.rs
Сохраняет состояние сети при глобальных сбоях. Использует многослойное шифрование фазы.

52. env_impact_tracker.py
Оценивает энергопотребление сети и воздействие на окружающую среду. Выдаёт экологический отчёт.

53. legacy_migrator.rs
Позволяет переносить данные, резонансные адреса и смысловые блоки из других блокчейнов в LRB.

54. resonance_tutor.py
Обучающий чат-бот. Объясняет новичкам принципы фаз, символов и ритуалов.

55. maintenance_strategy.yaml
Стратегия долгосрочной поддержки сети: обновления, патчи, ротация модулей.

56. go_to_market.yaml
План выхода на рынок: привлечение первых 10k узлов, листинг на DEX, миссии и коммуникация.



```


## FILE: infra/nginx/lrb_wallet.conf  (size=2666b)
```text
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки (минимальный набор без ломки фронта) ---
    add_header X-Frame-Options        SAMEORIGIN;
    add_header X-Content-Type-Options nosniff;
    add_header Referrer-Policy        strict-origin-when-cross-origin;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}

```


## FILE: infra/systemd/exec.conf  (size=85b)
```text
[Service]
WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: infra/systemd/keys.conf  (size=226b)
```text
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key

# Реальные ключи
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: infra/systemd/logos-node.service  (size=369b)
```text
[Unit]
Description=LOGOS LRB Node (Axum REST on :8080)
After=network-online.target
Wants=network-online.target

[Service]
User=root
WorkingDirectory=/root/logos_lrb
ExecStart=/root/logos_lrb/target/release/logos_node
Restart=always
RestartSec=2
LimitNOFILE=65536
Environment=LRB_DEV=1

StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/logos-snapshot.service  (size=271b)
```text
[Unit]
Description=LOGOS LRB periodic snapshot

[Service]
Type=oneshot
EnvironmentFile=-/etc/logos/keys.env
ExecStart=/usr/bin/curl -s -H "X-Admin-Key: ${LRB_ADMIN_KEY}" \
  http://127.0.0.1:8080/admin/snapshot-file?name=snap-$(date +%%Y%%m%%dT%%H%%M%%S).json >/dev/null

```


## FILE: infra/systemd/logos-snapshot.timer  (size=163b)
```text
[Unit]
Description=Run LOGOS snapshot every 10 minutes

[Timer]
OnBootSec=2min
OnUnitActiveSec=10min
Unit=logos-snapshot.service

[Install]
WantedBy=timers.target

```


## FILE: infra/systemd/lrb-proxy.service  (size=395b)
```text
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/lrb-scanner.service  (size=378b)
```text
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```


## FILE: infra/systemd/override.conf  (size=575b)
```text
[Service]
# Базовые ENV (правь под себя при необходимости)
Environment=LRB_DEV=1
Environment=LRB_PEERS=
Environment=LRB_QUORUM_N=1
Environment=LRB_VALIDATORS=

# Прод-тюнинг продюсера (можно менять без ребилда)
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

# rToken-мост (лимит и ключ для бриджа)
Environment=LRB_BRIDGE_MAX_PER_TX=10000000
# Админ для /admin/snapshot

```


## FILE: infra/systemd/runas.conf  (size=143b)
```text
[Service]
User=logos
Group=logos
# разрешаем запись в каталог данных под sandbox
ReadWritePaths=/var/lib/logos

```


## FILE: infra/systemd/security.conf  (size=337b)
```text
[Service]
ProtectSystem=strict
ProtectHome=true
PrivateTmp=true
NoNewPrivileges=true
LockPersonality=true
MemoryDenyWriteExecute=false

# Разрешаем запись ровно туда, где нужно
ReadWritePaths=/var/lib/logos /opt/logos /etc/logos

WorkingDirectory=/opt/logos
ExecStart=
ExecStart=/opt/logos/bin/logos_node

```


## FILE: infra/systemd/tuning.conf  (size=156b)
```text
[Service]
Environment=LRB_SLOT_MS=500
Environment=LRB_MAX_BLOCK_TX=10000
Environment=LRB_MEMPOOL_CAP=100000
Environment=LRB_MAX_AMOUNT=18446744073709551615

```


## FILE: infra/systemd/zz-consensus.conf  (size=137b)
```text
[Service]
Environment=LRB_VALIDATORS=5Ropc1AQhzuB5uov9GJSumGWZGomE8CTvCyk8D1q1pHb
Environment=LRB_QUORUM_N=1
Environment=LRB_SLOT_MS=200

```


## FILE: infra/systemd/zz-keys.conf  (size=417b)
```text
[Service]
# читаем файл с секретами (на будущее)
EnvironmentFile=-/etc/logos/keys.env

# и ПРЯМО зашиваем реальные значения, чтобы перебить любой override
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_KEY_PATH=/var/lib/logos/node_key
Environment=LRB_ADMIN_KEY=CHANGE_ADMIN_KEY
Environment=LRB_BRIDGE_KEY=CHANGE_ME

```


## FILE: infra/systemd/zz-logging.conf  (size=36b)
```text
[Service]
Environment=RUST_LOG=info

```


## FILE: lrb_core/Cargo.toml  (size=654b)
```text
[package]
name = "lrb_core"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = { workspace = true }
thiserror = { workspace = true }
serde = { workspace = true }
serde_json.workspace = true
blake3 = { workspace = true }
bs58 = { workspace = true }
ed25519-dalek = { workspace = true }
rand = { workspace = true }
rand_core = { workspace = true }
sled = { workspace = true }
once_cell = { workspace = true }
uuid = { workspace = true }
time = { workspace = true }
tokio = { workspace = true }
base64.workspace = true
hex.workspace = true
reqwest = { version = "0.12", default-features = false, features = ["rustls-tls", "json"] }
sha2 = "0.10.9"

```


## FILE: lrb_core/src/anti_replay.rs  (size=947b)
```text
use std::collections::HashMap;

/// Простейшее TTL-окно: tag -> last_seen_ms
#[derive(Clone, Debug)]
pub struct AntiReplayWindow {
    ttl_ms: u128,
    map: HashMap<String, u128>,
}

impl AntiReplayWindow {
    pub fn new(ttl_ms: u128) -> Self {
        Self { ttl_ms, map: HashMap::new() }
    }

    /// true, если новый (вставлен), false — если повтор/просрочен
    pub fn check_and_insert(&mut self, tag: String, now_ms: u128) -> bool {
        // Чистка "по ходу"
        self.gc(now_ms);
        if let Some(&seen) = self.map.get(&tag) {
            if now_ms.saturating_sub(seen) <= self.ttl_ms {
                return false; // повтор
            }
        }
        self.map.insert(tag, now_ms);
        true
    }

    pub fn gc(&mut self, now_ms: u128) {
        let ttl = self.ttl_ms;
        self.map.retain(|_, &mut t| now_ms.saturating_sub(t) <= ttl);
    }
}

```


## FILE: lrb_core/src/beacon.rs  (size=1781b)
```text
use crate::types::Rid;
use anyhow::{anyhow, Result};
use reqwest::Client;
use serde::Serialize;
use std::{time::Duration};
use tokio::time::interval;

#[derive(Serialize)]
struct BeatPayload<'a> {
    rid: &'a str,
    ts_ms: u128,
}

pub async fn run_beacon(rid: Rid, peers: Vec<String>, period: Duration) -> Result<()> {
    if peers.is_empty() {
        // Нечего слать — просто спим, чтобы не грузить CPU
        let mut t = interval(period);
        loop { t.tick().await; }
    }
    let client = Client::new();
    let mut t = interval(period);
    loop {
        t.tick().await;
        let payload = BeatPayload {
            rid: rid.as_str(),
            ts_ms: crate::heartbeat::now_ms(),
        };
        let body = serde_json::to_vec(&payload)?;
        for p in &peers {
            // POST {peer}/beat
            let url = format!("{}/beat", p.trim_end_matches('/'));
            let req = client
                .post(&url)
                .header("content-type", "application/json")
                .body(body.clone())
                .build()?;
            if let Err(e) = client.execute(req).await {
                // Не падаем — идём к следующему
                let _ = e;
            }
        }
    }
}

/// Парсинг переменной окружения вида: "http://ip1:8080,http://ip2:8080"
pub fn parse_peers(env_val: &str) -> Result<Vec<String>> {
    let peers: Vec<String> = env_val
        .split(',')
        .map(|s| s.trim().to_string())
        .filter(|s| !s.is_empty())
        .collect();
    if peers.iter().any(|p| !(p.starts_with("http://") || p.starts_with("https://"))) {
        return Err(anyhow!("peer must start with http(s)://"));
    }
    Ok(peers)
}

```


## FILE: lrb_core/src/dynamic_balance.rs  (size=576b)
```text
// Простейшая адаптация LGN_cost: основана на длине мемпула.
#[derive(Clone, Debug)]
pub struct DynamicBalance {
    base_cost_microunits: u64, // 1e-6 LGN
    slope_per_tx: u64,         // увеличение за каждую tx в мемпуле
}

impl DynamicBalance {
    pub fn new(base: u64, slope: u64) -> Self {
        Self { base_cost_microunits: base, slope_per_tx: slope }
    }
    pub fn lgn_cost(&self, mempool_len: usize) -> u64 {
        self.base_cost_microunits + (self.slope_per_tx * mempool_len as u64)
    }
}

```


## FILE: lrb_core/src/heartbeat.rs  (size=2076b)
```text
use crate::types::Rid;
use anyhow::Result;
use std::{
    collections::{HashMap, HashSet},
    sync::{Arc, Mutex},
    time::{Duration, SystemTime, UNIX_EPOCH},
};
use tokio::time::interval;

#[derive(Clone, Debug)]
pub struct HeartbeatState {
    pub last_seen_ms: u128,
}

#[derive(Clone)]
pub struct Heartbeat {
    inner: Arc<Mutex<HashMap<Rid, HeartbeatState>>>,
    quarantined: Arc<Mutex<HashSet<Rid>>>,
    quarantine_after_ms: u128,
    check_every_ms: u64,
}

impl Heartbeat {
    pub fn new(quarantine_after: Duration, check_every: Duration) -> Self {
        Self {
            inner: Arc::new(Mutex::new(HashMap::new())),
            quarantined: Arc::new(Mutex::new(HashSet::new())),
            quarantine_after_ms: quarantine_after.as_millis(),
            check_every_ms: check_every.as_millis() as u64,
        }
    }

    pub fn register_beat(&self, rid: Rid, now_ms: u128) {
        let mut map = self.inner.lock().unwrap();
        map.insert(rid, HeartbeatState { last_seen_ms: now_ms });
    }

    pub fn is_quarantined(&self, rid: &Rid) -> bool {
        self.quarantined.lock().unwrap().contains(rid)
    }

    pub fn peers_snapshot(&self) -> Vec<(Rid, u128)> {
        let map = self.inner.lock().unwrap();
        map.iter().map(|(r, s)| (r.clone(), s.last_seen_ms)).collect()
    }

    pub async fn run_monitor(self) -> Result<()> {
        let mut tick = interval(Duration::from_millis(self.check_every_ms));
        loop {
            tick.tick().await;
            let now_ms = now_ms();
            let mut q = self.quarantined.lock().unwrap();
            let map = self.inner.lock().unwrap();
            for (rid, st) in map.iter() {
                let silent = now_ms.saturating_sub(st.last_seen_ms);
                if silent > self.quarantine_after_ms {
                    q.insert(rid.clone());
                } else {
                    q.remove(rid);
                }
            }
        }
    }
}

pub fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis()
}

```


## FILE: lrb_core/src/ledger.rs  (size=11298b)
```text
use sled::{Db, IVec, Tree};
use std::path::Path;
use std::convert::TryInto;
use serde::{Serialize, Deserialize};
use sha2::{Digest, Sha256};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use crate::types::*;

// key helpers
fn be64(v: u64) -> [u8; 8] { v.to_be_bytes() }
fn be32(v: u32) -> [u8; 4] { v.to_be_bytes() }
fn rid_str(r: &Rid) -> &str { &r.0 }

#[derive(Clone)]
pub struct Ledger {
    db: Db,

    // balances
    lg_tree: Tree,     // rid -> u64 (BE)
    rlgn_tree: Tree,   // rid -> u64 (BE)
    head_tree: Tree,   // "h" (u64 BE), "hh" (String), "fin" (u64 BE)

    // history+index
    blocks_tree: Tree, // "b"|be64(height) -> StoredBlock(JSON)
    tx_tree: Tree,     // "t"|txid         -> StoredTx(JSON)
    acct_tree: Tree,   // "a"|rid|'|'|be64(height)|be32(idx) -> txid
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredBlock {
    pub height: u64,
    pub hash: String,
    pub ts_ms: u128,
    pub tx_ids: Vec<String>,
}

#[derive(Serialize, Deserialize, Clone)]
pub struct StoredTx {
    pub tx_id: String,
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub nonce: u64,
    pub height: u64,
    pub index: u32,
    pub ts_ms: u128,
}

#[derive(Serialize, Deserialize)]
pub struct AccountTxPage {
    pub rid: String,
    pub items: Vec<StoredTx>,
    pub next_cursor: Option<String>,
}

impl Ledger {
    pub fn open<P: AsRef<Path>>(path: P) -> anyhow::Result<Ledger> {
        let db = sled::open(path)?;
        Ok(Ledger {
            lg_tree:     db.open_tree("lgn")?,
            rlgn_tree:   db.open_tree("rlgn")?,
            head_tree:   db.open_tree("head")?,
            blocks_tree: db.open_tree("blocks")?,
            tx_tree:     db.open_tree("txs")?,
            acct_tree:   db.open_tree("acct_txs")?,
            db,
        })
    }

    // ------- balances -------
    pub fn get_balance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.lg_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn get_rbalance(&self, rid: &Rid) -> u64 {
        let k = rid_str(rid).as_bytes();
        self.rlgn_tree.get(k).ok().flatten()
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8])))
            .unwrap_or(0)
    }
    pub fn export_balances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.lg_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }
    pub fn export_rbalances(&self) -> anyhow::Result<Vec<(String,u64)>> {
        let mut out = Vec::new();
        for item in self.rlgn_tree.iter() {
            let (k,v) = item?;
            let rid = String::from_utf8(k.to_vec()).unwrap_or_default();
            let bal = u64::from_be_bytes(v.as_ref().try_into().unwrap_or([0u8;8]));
            out.push((rid, bal));
        }
        Ok(out)
    }

    // head/finalized
    pub fn head(&self) -> anyhow::Result<(u64, String)> {
        let h = self.head_tree.get(b"h")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0);
        let hh = self.head_tree.get(b"hh")?
            .map(|v| String::from_utf8(v.to_vec()).unwrap())
            .unwrap_or_else(|| "".to_string());
        Ok((h, hh))
    }
    pub fn set_head(&self, height: u64, hash: &str) -> anyhow::Result<()> {
        self.head_tree.insert(b"h", &be64(height))?;
        self.head_tree.insert(b"hh", hash.as_bytes())?;
        Ok(())
    }
    pub fn get_finalized(&self) -> anyhow::Result<u64> {
        Ok(self.head_tree.get(b"fin")?
            .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap()))
            .unwrap_or(0))
    }
    pub fn set_finalized(&self, height: u64) -> anyhow::Result<()> {
        self.head_tree.insert(b"fin", &be64(height))?;
        Ok(())
    }

    // ------- tx/block indexing helpers -------
    fn tx_id_of(tx: &Tx) -> String {
        let mut h = Sha256::new();
        h.update(rid_str(&tx.from).as_bytes());
        h.update(b"|");
        h.update(rid_str(&tx.to).as_bytes());
        h.update(b"|");
        h.update(&tx.amount.to_be_bytes());
        h.update(b"|");
        h.update(&tx.nonce.to_be_bytes());
        h.update(b"|");
        // public_key: Vec<u8>
        h.update(&tx.public_key);
        hex::encode(h.finalize())
    }

    /// индексирует блок и его транзакции
    pub fn index_block(&self, height: u64, hash: &str, ts_ms: u128, txs: &[Tx]) -> anyhow::Result<()> {
        let mut ids = Vec::with_capacity(txs.len());
        for (i, tx) in txs.iter().enumerate() {
            let txid = Self::tx_id_of(tx);
            ids.push(txid.clone());

            // tx json
            let stx = StoredTx{
                tx_id: txid.clone(),
                from: rid_str(&tx.from).to_string(),
                to:   rid_str(&tx.to).to_string(),
                amount: tx.amount,
                nonce:  tx.nonce,
                height,
                index:  i as u32,
                ts_ms,
            };
            // t|txid -> StoredTx
            let mut k_tx = Vec::with_capacity(1+txid.len());
            k_tx.extend_from_slice(b"t");
            k_tx.extend_from_slice(txid.as_bytes());
            self.tx_tree.insert(k_tx, serde_json::to_vec(&stx)?)?;

            // a|from|h|idx -> txid
            let mut k_af = Vec::with_capacity(1 + rid_str(&tx.from).len() + 1 + 8 + 4);
            k_af.extend_from_slice(b"a");
            k_af.extend_from_slice(rid_str(&tx.from).as_bytes());
            k_af.push(b'|');
            k_af.extend_from_slice(&be64(height));
            k_af.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_af, txid.as_bytes())?;

            // a|to|h|idx -> txid
            let mut k_at = Vec::with_capacity(1 + rid_str(&tx.to).len() + 1 + 8 + 4);
            k_at.extend_from_slice(b"a");
            k_at.extend_from_slice(rid_str(&tx.to).as_bytes());
            k_at.push(b'|');
            k_at.extend_from_slice(&be64(height));
            k_at.extend_from_slice(&be32(i as u32));
            self.acct_tree.insert(k_at, txid.as_bytes())?;
        }

        // b|height -> StoredBlock
        let mut k_b = Vec::with_capacity(1+8);
        k_b.extend_from_slice(b"b");
        k_b.extend_from_slice(&be64(height));
        let sblk = StoredBlock { height, hash: hash.to_string(), ts_ms, tx_ids: ids };
        self.blocks_tree.insert(k_b, serde_json::to_vec(&sblk)?)?;
        Ok(())
    }

    pub fn get_block(&self, height: u64) -> anyhow::Result<Option<StoredBlock>> {
        let mut k = Vec::with_capacity(1+8);
        k.extend_from_slice(b"b");
        k.extend_from_slice(&be64(height));
        Ok(self.blocks_tree.get(k)?.map(|v| serde_json::from_slice::<StoredBlock>(&v)).transpose()?)
    }

    pub fn get_tx(&self, txid: &str) -> anyhow::Result<Option<StoredTx>> {
        let mut k = Vec::with_capacity(1+txid.len());
        k.extend_from_slice(b"t");
        k.extend_from_slice(txid.as_bytes());
        Ok(self.tx_tree.get(k)?.map(|v| serde_json::from_slice::<StoredTx>(&v)).transpose()?)
    }

    /// Страница истории по rid. cursor = base64(k)
    pub fn account_txs_page(&self, rid: &str, limit: usize, cursor: Option<String>) -> anyhow::Result<AccountTxPage> {
        let lim = limit.min(100).max(1);
        let mut start_key = {
            let mut k = Vec::with_capacity(1 + rid.len() + 1);
            k.extend_from_slice(b"a"); k.extend_from_slice(rid.as_bytes()); k.push(b'|');
            k
        };
        if let Some(c) = cursor {
            if let Ok(raw) = B64.decode(c.as_bytes()) {
                start_key = raw;
            }
        }
        let mut items = Vec::with_capacity(lim);
        let mut next_cursor = None;

        for kv in self.acct_tree.range(start_key..).take(lim) {
            let (k, v) = kv?;
            let txid = String::from_utf8(v.to_vec()).unwrap_or_default();
            if let Some(stx) = self.get_tx(&txid)? {
                items.push(stx);
            }
            next_cursor = Some(B64.encode(k.to_vec()));
        }
        Ok(AccountTxPage { rid: rid.to_string(), items, next_cursor })
    }

    // ------- мостовая идемпотентность -------
    pub fn bridge_seen_mark(&self, rk: &str) -> anyhow::Result<bool> {
        let k = format!("seen:{}", rk);
        if self.head_tree.contains_key(k.as_bytes())? { return Ok(false); }
        self.head_tree.insert(k.as_bytes(), IVec::from(&[1u8][..]))?;
        Ok(true)
    }

    // ------- rLGN -------
    pub fn mint_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        let newb = cur.saturating_add(amt);
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }
    pub fn burn_rtoken(&self, rid:&Rid, amt:u64) -> anyhow::Result<u64> {
        let k = rid_str(rid).as_bytes();
        let cur = self.rlgn_tree.get(k)?.map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
        if cur < amt { anyhow::bail!("insufficient rLGN"); }
        let newb = cur - amt;
        self.rlgn_tree.insert(k, &be64(newb))?;
        Ok(newb)
    }

    // ------- коммит блока (простая версия) -------
    /// Применяет tx (проверки были выше), обновляет head.
    pub fn commit_block_atomic(&self, blk: &Block) -> anyhow::Result<()> {
        for tx in blk.txs.iter() {
            // списание/зачисление LGN
            let from_k = rid_str(&tx.from).as_bytes();
            let to_k   = rid_str(&tx.to).as_bytes();

            let from_bal = self.lg_tree.get(from_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);
            if from_bal < tx.amount { anyhow::bail!("insufficient funds"); }
            let to_bal = self.lg_tree.get(to_k)?
                .map(|v| u64::from_be_bytes(v.as_ref().try_into().unwrap())).unwrap_or(0);

            let new_from = from_bal - tx.amount;
            let new_to   = to_bal.saturating_add(tx.amount);

            self.lg_tree.insert(from_k, &be64(new_from))?;
            self.lg_tree.insert(to_k,   &be64(new_to))?;
        }
        self.set_head(blk.height, &blk.block_hash)?;
        Ok(())
    }

    /// View по хэшу блока (для register_vote)
    pub fn get_block_by_height(&self, h: u64) -> anyhow::Result<BlockHeaderView> {
        if let Some(b) = self.get_block(h)? {
            Ok(BlockHeaderView { block_hash: b.hash })
        } else {
            let (head_h, head_hash) = self.head()?;
            if h == head_h { Ok(BlockHeaderView { block_hash: head_hash }) } else { anyhow::bail!("block not found") }
        }
    }
}

#[derive(Serialize, Deserialize)]
pub struct BlockHeaderView {
    pub block_hash: String,
}

```


## FILE: lrb_core/src/lib.rs  (size=552b)
```text
pub mod types;
pub mod phase_integrity;
pub mod spam_guard;
pub mod dynamic_balance;
pub mod ledger;
pub mod rcp_engine;
pub mod heartbeat;
pub mod beacon;
pub mod resonance;
pub mod quorum;
pub mod phase_consensus;
pub mod phase_filters;
pub mod sigpool;

pub use types::*;
pub use phase_integrity::*;
pub use spam_guard::*;
pub use dynamic_balance::*;
pub use ledger::*;
pub use rcp_engine::*;
pub use heartbeat::*;
pub use beacon::*;
pub use resonance::*;
pub use quorum::*;
pub use phase_consensus::*;
pub use phase_filters::*;
pub use sigpool::*;

```


## FILE: lrb_core/src/phase_consensus.rs  (size=1769b)
```text
use std::collections::{HashMap, HashSet};

/// Фазовый консенсус Σ(t) с учётом блока (height, block_hash).
/// Накапливает голоса RID'ов по конкретному хешу блока.
/// Финализованный height повышается, когда кворум собран по **одному** хешу на этом height.
pub struct PhaseConsensus {
    /// votes[height][block_hash] = {rid_b58, ...}
    votes: HashMap<u64, HashMap<String, HashSet<String>>>,
    finalized_h: u64,
    quorum_n: usize,
}

impl PhaseConsensus {
    pub fn new(quorum_n: usize) -> Self {
        Self {
            votes: HashMap::new(),
            finalized_h: 0,
            quorum_n,
        }
    }

    pub fn quorum_n(&self) -> usize { self.quorum_n }
    pub fn finalized(&self) -> u64 { self.finalized_h }

    /// Регистрируем голос. Возвращает Some((h,hash)) если по hash достигнут кворум.
    pub fn vote(&mut self, h: u64, block_hash: &str, rid_b58: &str) -> Option<(u64, String)> {
        let by_hash = self.votes.entry(h).or_default();
        let set = by_hash.entry(block_hash.to_string()).or_default();
        set.insert(rid_b58.to_string());
        if set.len() >= self.quorum_n {
            if h > self.finalized_h {
                self.finalized_h = h;
            }
            return Some((h, block_hash.to_string()));
        }
        None
    }

    /// Сколько голосов у конкретного (h,hash)
    #[allow(dead_code)]
    pub fn votes_for(&self, h: u64, block_hash: &str) -> usize {
        self.votes.get(&h)
            .and_then(|m| m.get(block_hash))
            .map(|s| s.len())
            .unwrap_or(0)
    }
}

```


## FILE: lrb_core/src/phase_filters.rs  (size=1684b)
```text
use crate::types::Block;

/// Простые фазовые фильтры на основе гармоник Λ0.
/// ENV (всё опционально):
///  LRB_PHASE_EN=1|0                     (вкл/выкл, по умолчанию 1)
///  LRB_PHASE_FREQS_HZ="7.83,1.618,432"  (частоты, через запятую)
///  LRB_PHASE_MIN_SCORE=-0.20            (порог принятия от -1.0 до 1.0)
///
/// Идея: время блока b.timestamp_ms в секундах подаётся в сумму косинусов.
/// score = avg_i cos(2π f_i * t)
/// Пропускаем, если score >= MIN_SCORE.
fn phase_enabled() -> bool {
    std::env::var("LRB_PHASE_EN").ok().map(|v| v == "1").unwrap_or(true)
}
fn parse_freqs() -> Vec<f64> {
    let def = "7.83,1.618,432";
    let raw = std::env::var("LRB_PHASE_FREQS_HZ").unwrap_or_else(|_| def.to_string());
    raw.split(',').filter_map(|s| s.trim().parse::<f64>().ok()).collect::<Vec<_>>()
}
fn min_score() -> f64 {
    std::env::var("LRB_PHASE_MIN_SCORE").ok().and_then(|s| s.parse::<f64>().ok()).unwrap_or(-0.20)
}

fn phase_score_ts_ms(ts_ms: u128) -> f64 {
    let t = ts_ms as f64 / 1000.0;
    let freqs = parse_freqs();
    if freqs.is_empty() { return 1.0; }
    let two_pi = std::f64::consts::TAU; // 2π
    let mut acc = 0.0;
    for f in &freqs {
        acc += (two_pi * *f * t).cos();
    }
    acc / (freqs.len() as f64)
}

/// Главный фильтр на блок: пропускает, если фазовый скор >= порога
pub fn block_passes_phase(b: &Block) -> bool {
    if !phase_enabled() { return true; }
    phase_score_ts_ms(b.timestamp_ms) >= min_score()
}

```


## FILE: lrb_core/src/phase_integrity.rs  (size=544b)
```text
use crate::types::*;
use anyhow::{anyhow, Result};
use ed25519_dalek::Verifier as _; // для pk.verify(&msg, &sig)

pub fn verify_tx_signature(tx: &Tx) -> Result<()> {
    tx.validate_shape()?;

    let pk = crate::types::parse_pubkey(&tx.public_key)?;
    let sig = crate::types::parse_sig(&tx.signature)?;
    let msg = tx.canonical_bytes();

    pk.verify(&msg, &sig).map_err(|e| anyhow!("bad signature: {e}"))?;

    // сверяем id
    if tx.id != tx.compute_id() {
        return Err(anyhow!("tx id mismatch"));
    }
    Ok(())
}

```


## FILE: lrb_core/src/quorum.rs  (size=1192b)
```text
use anyhow::Result;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, VerifyingKey, Verifier};
use serde::{Deserialize, Serialize};

/// Голос за блок (по Σ-дайджесту)
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Vote {
    pub height: u64,
    pub block_hash: String,
    pub sigma_hex: String,
    pub voter_pk_b58: String,
    pub sig_b64: String,
    pub nonce_ms: u128,
}

pub fn verify_vote(v: &Vote) -> Result<()> {
    let pk_bytes = bs58::decode(&v.voter_pk_b58).into_vec()?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(v.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(&sig_bytes.try_into().map_err(|_| anyhow::anyhow!("bad sig"))?);

    let mut payload = Vec::new();
    payload.extend_from_slice(v.sigma_hex.as_bytes());
    payload.extend_from_slice(v.block_hash.as_bytes());
    payload.extend_from_slice(&v.height.to_le_bytes());
    payload.extend_from_slice(&v.nonce_ms.to_le_bytes());

    vk.verify(&payload, &sig).map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

```


## FILE: lrb_core/src/rcp_engine.rs  (size=7015b)
```text
use crate::{ledger::Ledger, spam_guard::SpamGuard, dynamic_balance::DynamicBalance, types::*, phase_integrity};
use crate::{phase_consensus::PhaseConsensus, phase_filters::block_passes_phase};
use crate::sigpool::filter_valid_sigs_parallel;
use anyhow::Result;
use std::{sync::{Arc, Mutex}, time::{Duration, SystemTime, UNIX_EPOCH}};
use tokio::sync::{mpsc::{UnboundedSender, unbounded_channel}, broadcast};

// точный монотонный ts для индексации
fn now_ms() -> u128 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis()
}

fn env_u64(key: &str, def: u64) -> u64 {
    std::env::var(key).ok().and_then(|s| s.parse::<u64>().ok()).unwrap_or(def)
}
fn env_usize(key: &str, def: usize) -> usize {
    std::env::var(key).ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(def)
}

#[derive(Clone)]
pub struct Engine {
    ledger: Arc<Ledger>,
    guard: SpamGuard,
    dyn_cost: DynamicBalance,
    proposer: Rid,
    mempool_tx: UnboundedSender<Tx>,
    mempool: Arc<Mutex<Vec<Tx>>>,
    commit_tx: Arc<Mutex<Option<broadcast::Sender<Block>>>>,

    slot_ms: u64,
    sig_workers: usize,
    consensus: Arc<Mutex<PhaseConsensus>>,
}

impl Engine {
    pub fn new(ledger: Ledger, proposer: Rid) -> Arc<Self> {
        let mempool_cap   = env_u64("LRB_MEMPOOL_CAP", 100_000);
        let max_block_tx  = env_u64("LRB_MAX_BLOCK_TX", 10_000);
        let max_amount    = env_u64("LRB_MAX_AMOUNT",   u64::MAX/2);
        let slot_ms       = env_u64("LRB_SLOT_MS",      500);
        let quorum_n      = env_usize("LRB_QUORUM_N",   1);
        let sig_workers   = env_usize("LRB_SIG_WORKERS", 4);

        let mempool: Arc<Mutex<Vec<Tx>>> = Arc::new(Mutex::new(Vec::new()));
        let (tx, rx) = unbounded_channel::<Tx>();

        let engine = Arc::new(Self {
            ledger: Arc::new(ledger),
            guard: SpamGuard::new(mempool_cap as usize, max_block_tx as usize, max_amount),
            dyn_cost: DynamicBalance::new(100, 2),
            proposer,
            mempool_tx: tx.clone(),
            mempool: mempool.clone(),
            commit_tx: Arc::new(Mutex::new(None)),
            slot_ms,
            sig_workers,
            consensus: Arc::new(Mutex::new(PhaseConsensus::new(quorum_n))),
        });

        // приём транзакций в mempool с лимитами
        let guard = engine.guard.clone();
        tokio::spawn(async move {
            let mut rx = rx;
            while let Some(tx) = rx.recv().await {
                let mut lock = mempool.lock().unwrap();
                if guard.check_mempool(lock.len()).is_ok() {
                    lock.push(tx);
                }
            }
        });

        engine
    }

    pub fn ledger(&self) -> Arc<Ledger> { self.ledger.clone() }
    pub fn proposer(&self) -> Rid { self.proposer.clone() }
    pub fn set_commit_notifier(&self, sender: broadcast::Sender<Block>) { *self.commit_tx.lock().unwrap() = Some(sender); }
    pub fn check_amount_valid(&self, amount: u64) -> Result<()> { self.guard.check_amount(amount) }
    pub fn mempool_sender(&self) -> UnboundedSender<Tx> { self.mempool_tx.clone() }
    pub fn mempool_len(&self) -> usize { self.mempool.lock().unwrap().len() }
    pub fn finalized_height(&self) -> u64 { self.consensus.lock().unwrap().finalized() }

    pub fn register_vote(&self, height: u64, block_hash: &str, rid_b58: &str) -> bool {
        let mut cons = self.consensus.lock().unwrap();
        if let Some((h, voted_hash)) = cons.vote(height, block_hash, rid_b58) {
            if let Ok(local) = self.ledger.get_block_by_height(h) {
                if local.block_hash == voted_hash {
                    let _ = self.ledger.set_finalized(h);
                    return true;
                }
            }
        }
        false
    }

    pub async fn run_block_producer(self: Arc<Self>) -> Result<()> {
        let mut interval = tokio::time::interval(Duration::from_millis(self.slot_ms));

        loop {
            interval.tick().await;

            // 1) забираем пачку из мемпула
            let raw = {
                let mut mp = self.mempool.lock().unwrap();
                if mp.is_empty() { continue; }
                let take = self.guard.max_block_txs().min(mp.len());
                mp.drain(0..take).collect::<Vec<Tx>>()
            };

            // 2) проверка подписей параллельно
            let mut valid = filter_valid_sigs_parallel(raw, self.sig_workers).await;
            if valid.is_empty() { continue; }

            // 3) базовые лимиты/amount
            valid.retain(|t| self.guard.check_amount(t.amount).is_ok());
            if valid.is_empty() { continue; }

            // 4) формируем блок (h+1)
            let (h, prev_hash) = self.ledger.head().unwrap_or((0, String::new()));
            let b = Block::new(h + 1, prev_hash, self.proposer.clone(), valid);

            // 5) фазовый фильтр (резонанс). Если не прошёл — НЕ теряем tx: возвращаем в хвост mempool.
            if !block_passes_phase(&b) {
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter()); // вернуть в очередь, обработаем в следующем слоте
                continue;
            }

            // 6) атомарный коммит блока
            if let Err(e) = self.ledger.commit_block_atomic(&b) {
                // при ошибке — вернуть tx в mempool и идти дальше
                let mut mp = self.mempool.lock().unwrap();
                mp.extend(b.txs.into_iter());
                eprintln!("commit_block_atomic error at height {}: {:?}", b.height, e);
                continue;
            }

            // 7) индексирование блока для истории/эксплорера (не мешает продюсеру)
            let ts = now_ms();
            if let Err(e) = self.ledger.index_block(b.height, &b.block_hash, ts, &b.txs) {
                // индексация не должна ломать производство блоков
                eprintln!("index_block error at height {}: {:?}", b.height, e);
            }

            // 8) локальный голос и уведомление подписчикам
            let _ = self.register_vote(b.height, &b.block_hash, self.proposer.as_str());
            if let Some(tx) = self.commit_tx.lock().unwrap().as_ref() {
                let _ = tx.send(b.clone());
            }
        }
    }

    pub fn lgn_cost_microunits(&self) -> u64 {
        self.dyn_cost.lgn_cost(self.mempool_len() as usize)
    }
}

pub fn engine_with_channels(ledger: Ledger, proposer: Rid) -> (Arc<Engine>, UnboundedSender<Tx>) {
    let engine = Engine::new(ledger, proposer);
    let sender = engine.mempool_sender();
    (engine, sender)
}

```


## FILE: lrb_core/src/resonance.rs  (size=1122b)
```text
use blake3::Hasher;
use crate::types::{Block, Tx};

/// Гармоники Λ0/Σ(t) — фиксированное «зерно» резонанса.
const HARMONICS: &[&[u8]] = &[
    b"f1=7.83Hz",
    b"f2=1.618Hz",
    b"f3=432Hz",
    b"f4=864Hz",
    b"f5=3456Hz",
    b"L0=LOGOS-PRIME",
];

fn mix_tx(hasher: &mut Hasher, tx: &Tx) {
    // Канон: id + from + to + amount + nonce + pk
    hasher.update(tx.id.as_bytes());
    hasher.update(tx.from.0.as_bytes());
    hasher.update(tx.to.0.as_bytes());
    hasher.update(&tx.amount.to_le_bytes());
    hasher.update(&tx.nonce.to_le_bytes());
    hasher.update(&tx.public_key);
}

/// Σ-дайджест блока (hex), детерминированный и инвариантный.
pub fn sigma_digest_block_hex(b: &Block) -> String {
    let mut h = Hasher::new();
    for tag in HARMONICS { h.update(tag); }
    h.update(b.prev_hash.as_bytes());
    h.update(b.proposer.0.as_bytes());
    h.update(&b.height.to_le_bytes());
    h.update(&b.timestamp_ms.to_le_bytes());
    for tx in &b.txs { mix_tx(&mut h, tx) }
    hex::encode(h.finalize().as_bytes())
}

```


## FILE: lrb_core/src/sigpool.rs  (size=1040b)
```text
use crate::types::Tx;
use crate::phase_integrity::verify_tx_signature;
use tokio::task::JoinSet;

/// Параллельная фильтрация валидных по подписи транзакций.
/// workers: количество тасков; по умолчанию 4–8 (задать через ENV в движке).
pub async fn filter_valid_sigs_parallel(txs: Vec<Tx>, workers: usize) -> Vec<Tx> {
    if txs.is_empty() { return txs; }
    let w = workers.max(1);
    let chunk = (txs.len() + w - 1) / w;
    let mut set = JoinSet::new();
    for part in txs.chunks(chunk) {
        let vec = part.to_vec();
        set.spawn(async move {
            let mut ok = Vec::with_capacity(vec.len());
            for t in vec {
                if verify_tx_signature(&t).is_ok() {
                    ok.push(t);
                }
            }
            ok
        });
    }
    let mut out = Vec::new();
    while let Some(res) = set.join_next().await {
        if let Ok(mut v) = res { out.append(&mut v); }
    }
    out
}

```


## FILE: lrb_core/src/spam_guard.rs  (size=782b)
```text
use anyhow::{anyhow, Result};

#[derive(Clone, Debug)]
pub struct SpamGuard {
    max_mempool: usize,
    max_tx_per_block: usize,
    max_amount: u64,
}

impl SpamGuard {
    pub fn new(max_mempool: usize, max_tx_per_block: usize, max_amount: u64) -> Self {
        Self { max_mempool, max_tx_per_block, max_amount }
    }
    pub fn check_mempool(&self, cur_len: usize) -> Result<()> {
        if cur_len > self.max_mempool {
            return Err(anyhow!("mempool overflow"));
        }
        Ok(())
    }
    pub fn check_amount(&self, amount: u64) -> Result<()> {
        if amount == 0 || amount > self.max_amount {
            return Err(anyhow!("amount out of bounds"));
        }
        Ok(())
    }
    pub fn max_block_txs(&self) -> usize { self.max_tx_per_block }
}

```


## FILE: lrb_core/src/types.rs  (size=3294b)
```text
use anyhow::{anyhow, Result};
use blake3::Hasher;
use ed25519_dalek::{Signature, VerifyingKey};
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use uuid::Uuid;

// base64 v0.22 Engine API
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;

pub type Amount = u64;
pub type Height = u64;
pub type Nonce = u64;

#[derive(Clone, Debug, Serialize, Deserialize, Eq, PartialEq, Hash)]
pub struct Rid(pub String); // base58(VerifyingKey)

impl Rid {
    pub fn from_pubkey(pk: &VerifyingKey) -> Self {
        Rid(bs58::encode(pk.to_bytes()).into_string())
    }
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Tx {
    pub id: String,             // blake3 of canonical form
    pub from: Rid,              // base58(pubkey)
    pub to: Rid,
    pub amount: Amount,
    pub nonce: Nonce,
    pub public_key: Vec<u8>,    // 32 bytes (VerifyingKey)
    pub signature: Vec<u8>,     // 64 bytes (Signature)
}

impl Tx {
    pub fn canonical_bytes(&self) -> Vec<u8> {
        // Без id и signature для детерминированного хеша
        let m = serde_json::json!({
            "from": self.from.as_str(),
            "to": self.to.as_str(),
            "amount": self.amount,
            "nonce": self.nonce,
            "public_key": B64.encode(&self.public_key),
        });
        serde_json::to_vec(&m).expect("canonical json")
    }
    pub fn compute_id(&self) -> String {
        let mut hasher = Hasher::new();
        hasher.update(&self.canonical_bytes());
        hex::encode(hasher.finalize().as_bytes())
    }
    pub fn validate_shape(&self) -> Result<()> {
        if self.public_key.len() != 32 { return Err(anyhow!("bad pubkey len")); }
        if self.signature.len() != 64 { return Err(anyhow!("bad signature len")); }
        if self.amount == 0 { return Err(anyhow!("amount must be > 0")); }
        Ok(())
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Block {
    pub height: Height,
    pub prev_hash: String,
    pub timestamp_ms: u128,
    pub proposer: Rid,
    pub txs: Vec<Tx>,
    pub block_hash: String,
    pub uuid: String, // для логов
}

impl Block {
    pub fn new(height: Height, prev_hash: String, proposer: Rid, txs: Vec<Tx>) -> Self {
        let ts = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis();
        let mut h = Hasher::new();
        h.update(prev_hash.as_bytes());
        h.update(proposer.as_str().as_bytes());
        for tx in &txs {
            h.update(tx.id.as_bytes());
        }
        h.update(&ts.to_le_bytes());
        let block_hash = hex::encode(h.finalize().as_bytes());
        Block {
            height,
            prev_hash,
            timestamp_ms: ts,
            proposer,
            txs,
            block_hash,
            uuid: Uuid::new_v4().to_string(),
        }
    }
}

pub fn parse_pubkey(pk: &[u8]) -> Result<VerifyingKey> {
    let arr: [u8; 32] = pk.try_into().map_err(|_| anyhow!("bad pubkey len"))?;
    Ok(VerifyingKey::from_bytes(&arr)?)
}

pub fn parse_sig(sig: &[u8]) -> Result<Signature> {
    let arr: [u8; 64] = sig.try_into().map_err(|_| anyhow!("bad signature len"))?;
    Ok(Signature::from_bytes(&arr))
}

```


## FILE: modules/beacon_emitter.rs  (size=7378b)
```text
// LOGOS Beacon Emitter — Λ0 Signal Broadcaster
// Автор: LOGOS Core Dev

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use std::collections::{HashMap, HashSet};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct BeaconSignal {
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
    pub channel: String, // "file", "radio", "json", "stdout", "lora", "ble", "satellite"
}

pub struct BeaconEmitter {
    pub default_symbol: String,
    pub default_freq: f64,
    pub default_phase: f64,
    pub channels: Vec<String>,
    pub log_file: String,
    pub last_emit_time: u64,
    pub min_interval_sec: u64,
    pub valid_symbols: HashSet<String>,
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl BeaconEmitter {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        BeaconEmitter {
            default_symbol: "Λ0".to_string(),
            default_freq: 7.83,
            default_phase: 0.0,
            channels: vec!["file".to_string(), "stdout".to_string(), "lora".to_string(), "ble".to_string(), "satellite".to_string()],
            log_file: "beacon_emitter_log.json".to_string(),
            last_emit_time: 0,
            min_interval_sec: 60,
            valid_symbols,
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_parameters(&self, symbol: &str, frequency: f64, phase: f64) -> bool {
        // Проверка символа, частоты и фазы
        self.valid_symbols.contains(symbol) &&
        (0.1 <= frequency && frequency <= 10000.0) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&phase)
    }

    pub fn emit(&mut self) -> bool {
        let now = Self::current_time();
        if now - self.last_emit_time < self.min_interval_sec {
            self.log_event("[SKIP] Beacon too frequent");
            return false;
        }

        // Проверка параметров
        if !self.validate_parameters(&self.default_symbol, self.default_freq, self.default_phase) {
            self.log_event(&format!(
                "[!] Недопустимые параметры: symbol={}, freq={}, phase={}",
                self.default_symbol, self.default_freq, self.default_phase
            ));
            return false;
        }

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp() {
            self.log_event("[!] RCP не подтвердил сигнал");
            return false;
        }

        for ch in &self.channels {
            let signal = BeaconSignal {
                symbol: self.default_symbol.clone(),
                frequency: self.default_freq,
                phase: self.default_phase,
                timestamp: now,
                channel: ch.clone(),
            };

            match ch.as_str() {
                "file" => self.write_to_file(&signal),
                "stdout" => println!("[BEACON] {} @ {}Hz φ = {:.4}", signal.symbol, signal.frequency, signal.phase),
                "json" => self.export_to_json(&signal),
                "lora" => self.emit_to_lora(&signal), // Заглушка для LoRa
                "ble" => self.emit_to_ble(&signal),   // Заглушка для BLE
                "satellite" => self.emit_to_satellite(&signal), // Заглушка для satellite
                _ => self.log_event(&format!("[WARN] Unsupported channel: {}", ch)),
            }
        }

        self.last_emit_time = now;
        self.log_event(&format!(
            "[BEACON] Emitted: {} @ {}Hz φ={:.4} on channels: {:?}", 
            self.default_symbol, self.default_freq, self.default_phase, self.channels
        ));
        true
    }

    fn validate_with_rcp(&self) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        self.default_symbol == "Λ0" && (self.default_freq - 7.83).abs() < 0.1
    }

    fn write_to_file(&self, signal: &BeaconSignal) {
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open("beacon_emitter_out.txt")
        {
            let _ = writeln!(
                file,
                "[BEACON] {} @ {}Hz φ={:.4} [{}]",
                signal.symbol, signal.frequency, signal.phase, signal.timestamp
            );
        }
    }

    fn export_to_json(&self, signal: &BeaconSignal) {
        let json = serde_json::to_string_pretty(signal).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = json.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("beacon_emitter_out.json")
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn emit_to_lora(&self, signal: &BeaconSignal) {
        // Заглушка для LoRa
        self.log_event(&format!("[LORA] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn emit_to_ble(&self, signal: &BeaconSignal) {
        // Заглушка для BLE
        self.log_event(&format!("[BLE] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn emit_to_satellite(&self, signal: &BeaconSignal) {
        // Заглушка для satellite
        self.log_event(&format!("[SATELLITE] Emit: {} @ {}Hz φ={:.4} (not implemented)", 
            signal.symbol, signal.frequency, signal.phase));
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"beacon_emitter\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/env_impact_tracker.py  (size=5447b)
```text
# LOGOS Environmental Impact Tracker
# Автор: LOGOS Core Dev

import time
import json
import os
import psutil
from cryptography.fernet import Fernet
from typing import Dict
from resonance_analyzer import ResonanceAnalyzer

class EnvImpactTracker:
    def __init__(self):
        self.state_file = "env_impact_state.json"
        self.log_file = "env_impact_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.lambda_zero = "Λ0"
        self.valid_symbols = ["☉", "??", "♁", "??", "??", "??", "Λ0", "∞"]
        self.collected: Dict[str, float] = {}
        self.interval_sec = 60
        self.last_record_time = 0
        self.network_activity = 1.0
        self.analyzer = ResonanceAnalyzer()
        self.thresholds = {"cpu": 80.0, "memory": 80.0, "disk": 90.0}
        self.load_state()

    def load_state(self):
        """Загружает состояние с расшифровкой."""
        if os.path.exists(self.state_file):
            try:
                with open(self.state_file, "rb") as f:
                    data = self.cipher.decrypt(f.read())
                    self.collected = json.loads(data)
            except Exception as e:
                self.log_event(f"[!] Ошибка загрузки состояния: {e}")
                self.collected = {}

    def validate_symbol(self, symbol: str) -> bool:
        """Проверяет допустимость символа."""
        return symbol in self.valid_symbols

    def update_network_activity(self, activity: float):
        """Обновляет интервал сканирования на основе активности."""
        self.network_activity = max(0.1, min(activity, 10.0))
        self.interval_sec = max(30, min(120, 60 / self.network_activity))
        self.log_event(f"[INFO] Network activity updated: {self.network_activity}, interval={self.interval_sec}s")

    def scan(self, symbol: str = "Λ0") -> bool:
        """Собирает метрики воздействия."""
        now = time.time()
        if now - self.last_record_time < self.interval_sec:
            self.log_event("[!] Слишком частое сканирование")
            return False
        self.last_record_time = now

        if not self.validate_symbol(symbol):
            self.log_event(f"[!] Недопустимый символ: {symbol}")
            return False

        # Сбор метрик
        cpu = psutil.cpu_percent()
        mem = psutil.virtual_memory().percent
        disk = psutil.disk_usage("/").percent
        net = psutil.net_io_counters().bytes_sent + psutil.net_io_counters().bytes_recv
        temp = psutil.sensors_temperatures() if hasattr(psutil, "sensors_temperatures") else {}

        # Адаптивная коррекция для Λ0
        adjustment = 1.2 if symbol == self.lambda_zero else 1.0

        impact = {
            "timestamp": now,
            "symbol": symbol,
            "cpu": round(cpu * adjustment, 2),
            "memory": round(mem * adjustment, 2),
            "disk": round(disk * adjustment, 2),
            "network_bytes": net,
            "thermal_zones": {k: [round(t.current, 2) for t in v] for k, v in temp.items()} if temp else {}
        }

        # Проверка аномалий
        anomalies = []
        if impact["cpu"] > self.thresholds["cpu"]:
            anomalies.append(f"CPU={impact['cpu']}%")
        if impact["memory"] > self.thresholds["memory"]:
            anomalies.append(f"MEM={impact['memory']}%")
        if impact["disk"] > self.thresholds["disk"]:
            anomalies.append(f"DISK={impact['disk']}%")

        # Интеграция с resonance_analyzer
        resonance = self.analyzer.analyze(symbol, 7.83 if symbol == self.lambda_zero else 1.618, 0.0)
        impact["resonance_score"] = resonance["resonance"]

        self.collected[str(int(now))] = impact
        self.save_state()

        log_message = f"Impact: CPU={impact['cpu']}%, MEM={impact['memory']}%, Symbol={symbol}, Resonance={resonance['resonance']:.4f}"
        if anomalies:
            log_message += f", Anomalies: {', '.join(anomalies)}"
        self.log_event(log_message)
        return True

    def save_state(self):
        """Сохраняет состояние с шифрованием."""
        data = json.dumps(self.collected, indent=2).encode()
        encrypted = self.cipher.encrypt(data)
        with open(self.state_file, "wb") as f:
            f.write(encrypted)

    def log_event(self, message: str):
        """Логирует событие."""
        log = {
            "event": "env_impact",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def get_latest_impact(self) -> Dict:
        """Возвращает последнюю запись."""
        if self.collected:
            return list(self.collected.values())[-1]
        return {}

if __name__ == "__main__":
    tracker = EnvImpactTracker()
    tracker.update_network_activity(2.0)
    if tracker.scan(symbol="Λ0"):
        print("Последнее воздействие:", json.dumps(tracker.get_latest_impact(), indent=2))
    else:
        print("Ожидание интервала между сканами...")

```


## FILE: modules/external_phase_broadcaster.rs  (size=7992b)
```text
rust
// LOGOS External Phase Broadcaster
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct BroadcastPhase {
    pub rid: String,            // Добавлено для идентификации узла
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub confidence: f64,
    pub timestamp: u64,
    pub destination: String,    // "file", "sound", "radio", "ble"
}

pub struct ExternalPhaseBroadcaster {
    pub valid_symbols: HashSet<String>,
    pub supported_channels: HashSet<String>,
    pub lambda_zero: String,
    pub min_confidence: f64,
    pub log_file: String,
    pub state_file: String,
    pub last_broadcast: HashMap<String, u64>, // destination -> timestamp
    pub last_broadcast_rid: HashMap<String, u64>, // rid -> timestamp
    pub min_interval_sec: u64,
    pub cipher_key: Vec<u8>,
}

impl ExternalPhaseBroadcaster {
    pub fn new() -> Self {
        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        let mut channels = HashSet::new();
        channels.insert("file".to_string());
        channels.insert("sound".to_string());
        channels.insert("radio".to_string());
        channels.insert("ble".to_string());

        ExternalPhaseBroadcaster {
            valid_symbols: symbols,
            supported_channels: channels,
            lambda_zero: "Λ0".to_string(),
            min_confidence: 0.6,
            log_file: "external_phase_broadcast_log.json".to_string(),
            state_file: "external_phase_broadcast_state.json".to_string(),
            last_broadcast: HashMap::new(),
            last_broadcast_rid: HashMap::new(),
            min_interval_sec: 30,
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate(&self, phase: &BroadcastPhase) -> bool {
        self.valid_symbols.contains(&phase.symbol) &&
        self.supported_channels.contains(&phase.destination) &&
        (0.1..=10000.0).contains(&phase.frequency) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&phase.phase) &&
        phase.confidence >= self.min_confidence &&
        self.validate_rid(&phase.rid)
    }

    pub fn broadcast(&mut self, phase: BroadcastPhase) -> bool {
        let now = Self::current_time();

        // Проверка частоты по каналу
        let last = self.last_broadcast.get(&phase.destination).cloned().unwrap_or(0);
        let adjusted_interval = if phase.symbol == self.lambda_zero {
            self.min_interval_sec / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval_sec
        };
        if now - last < adjusted_interval {
            self.log_event(&phase, "[SKIP] Слишком частая рассылка по каналу");
            return false;
        }

        // Проверка частоты по RID
        let last_rid = self.last_broadcast_rid.get(&phase.rid).cloned().unwrap_or(0);
        if now - last_rid < adjusted_interval {
            self.log_event(&phase, "[SKIP] Слишком частая рассылка от RID");
            return false;
        }

        // Валидация
        if !self.validate(&phase) {
            self.log_event(&phase, "[DROP] Неверная фаза, confidence или RID");
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&phase) {
            self.log_event(&phase, "[DROP] Analyzer отклонил фазу");
            return false;
        }

        match phase.destination.as_str() {
            "file" => self.write_to_file(&phase),
            "stdout" => println!("[PHASE] {} @ {:.2}Hz φ={:.3} conf={:.2} (RID: {})", 
                phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid),
            "sound" => self.emit_sound(&phase),
            "radio" => self.emit_radio(&phase),
            "ble" => self.emit_ble(&phase),
            _ => self.log_event(&phase, "[WARN] Неизвестный канал"),
        }

        self.last_broadcast.insert(phase.destination.clone(), now);
        self.last_broadcast_rid.insert(phase.rid.clone(), now);
        self.save_state();
        self.log_event(&phase, "[BROADCAST] Фаза отправлена");
        true
    }

    fn validate_with_analyzer(&self, phase: &BroadcastPhase) -> bool {
        // Заглушка для проверки через resonance_analyzer.py
        phase.symbol == self.lambda_zero || (phase.frequency - 7.83).abs() < 0.1
    }

    fn write_to_file(&self, phase: &BroadcastPhase) {
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open("broadcast_phase_output.txt")
        {
            let _ = writeln!(file, "[PHASE] {} @ {:.2}Hz φ={:.3} conf={:.2} RID={} [{}]", 
                phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid, phase.timestamp);
        }
    }

    fn emit_sound(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[SOUND] Эмиссия (не реализовано)");
    }

    fn emit_radio(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[RADIO] Эмиссия (не реализовано)");
    }

    fn emit_ble(&self, phase: &BroadcastPhase) {
        self.log_event(phase, "[BLE] Эмиссия (не реализовано)");
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.last_broadcast).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, phase: &BroadcastPhase, message: &str) {
        let entry = format!(
            "{{\"event\": \"external_phase_broadcast\", \"symbol\": \"{}\", \"freq\": {:.2}, \"phase\": {:.3}, \"conf\": {:.2}, \"rid\": \"{}\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            phase.symbol, phase.frequency, phase.phase, phase.confidence, phase.rid, message, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/external_phase_link.rs  (size=6896b)
```text
rust
// LOGOS External Phase Link — Bridge to External Phase Sources
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct ExternalPhase {
    pub rid: String,            // Добавлено для идентификации узла
    pub source: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
    pub confidence: f64,        // Оценка достоверности [0.0 - 1.0]
}

pub struct ExternalPhaseLink {
    pub accepted_sources: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub min_confidence: f64,
    pub network_activity: f64,
    pub last_received: HashMap<String, u64>, // source -> timestamp
    pub min_receive_interval: u64,
}

impl ExternalPhaseLink {
    pub fn new() -> Self {
        let mut sources = HashSet::new();
        sources.insert("external_device".to_string());
        sources.insert("oracle_feed".to_string());
        sources.insert("bio_input".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        ExternalPhaseLink {
            accepted_sources: sources,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "external_phase_link_log.json".to_string(),
            state_file: "external_phase_link_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Заменить на реальный ключ
            min_confidence: 0.6,
            network_activity: 1.0,
            last_received: HashMap::new(),
            min_receive_interval: 60,
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Адаптивный порог достоверности
        self.network_activity = activity.clamp(0.1, 10.0);
        self.min_confidence = (0.6 / self.network_activity).clamp(0.4, 0.8);
        self.log_event(&format!(
            "[INFO] Network activity updated: {:.2}, min_confidence={:.2}",
            self.network_activity, self.min_confidence
        ));
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate_input(&self, ep: &ExternalPhase) -> bool {
        self.accepted_sources.contains(&ep.source) &&
        self.valid_symbols.contains(&ep.symbol) &&
        (0.1..=10000.0).contains(&ep.frequency) &&
        (-std::f64::consts::PI..=std::f64::consts::PI).contains(&ep.phase) &&
        ep.confidence >= self.min_confidence &&
        self.validate_rid(&ep.rid)
    }

    pub fn forward_phase(&self, ep: ExternalPhase) -> bool {
        let now = Self::current_time();

        // Проверка частоты приёма
        let last = self.last_received.get(&ep.source).cloned().unwrap_or(0);
        let adjusted_interval = if ep.symbol == self.lambda_zero {
            self.min_receive_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_receive_interval
        };
        if now - last < adjusted_interval {
            self.log_event(&format!("[DROP] Слишком частый приём от '{}'", ep.source));
            return false;
        }

        // Валидация
        if !self.validate_input(&ep) {
            self.log_event(&format!("[DROP] Неверный сигнал от '{}': RID={}, symbol={}, conf={:.2}",
                ep.source, ep.rid, ep.symbol, ep.confidence));
            return false;
        }

        // Проверка через RCP и resonance_analyzer (заглушка)
        if !self.validate_with_rcp_and_analyzer(&ep) {
            self.log_event(&format!("[REJECT] RCP/analyzer отклонил фазу от '{}'", ep.source));
            return false;
        }

        // Сохранение состояния
        let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
        mutable_self.last_received.insert(ep.source.clone(), now);
        self.save_state(&ep);

        self.log_event(&format!(
            "[LINK] Принята внешняя фаза от {}: RID={} {} @ {:.3}Hz φ={:.4}, conf={:.2}",
            ep.source, ep.rid, ep.symbol, ep.frequency, ep.phase, ep.confidence
        ));
        true
    }

    pub fn validate_with_rcp_and_analyzer(&self, ep: &ExternalPhase) -> bool {
        // Заглушка для проверки через rcp_engine.rs и resonance_analyzer.py
        ep.symbol == self.lambda_zero || (ep.frequency - 7.83).abs() < 0.1
    }

    fn save_state(&self, ep: &ExternalPhase) {
        let state = serde_json::to_string(ep).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
                let _ = file.write_all(b"\n");
            }
        }
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"external_phase_link\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/genesis_fragment_seeds.rs  (size=6958b)
```text
rust
// LOGOS Genesis Fragment Seeds
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{File, OpenOptions};
use std::io::{Write, Read};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use shamirsecretsharing::{split_secret, recover_secret};

#[derive(Debug, Serialize, Deserialize)]
pub struct SeedFragment {
    pub node_id: String,
    pub fragment: Vec<u8>,
    pub timestamp: u64,
    pub symbol: String, // Связь с Λ0
}

pub struct GenesisFragmentSeeds {
    pub fragments: HashMap<String, SeedFragment>,
    pub required_shares: usize,
    pub total_shares: usize,
    pub original_seed: Vec<u8>,
    pub log_file: String,
    pub state_file: String,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub store_timestamps: HashMap<String, u64>, // node_id -> last store time
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl GenesisFragmentSeeds {
    pub fn new(seed: Vec<u8>, total: usize, required: usize) -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        GenesisFragmentSeeds {
            fragments: HashMap::new(),
            required_shares: required,
            total_shares: total,
            original_seed: seed,
            log_file: "genesis_fragment_log.json".to_string(),
            state_file: "genesis_fragment_state.json".to_string(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            store_timestamps: HashMap::new(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_node_id_and_symbol(&self, node_id: &str, symbol: &str) -> bool {
        node_id.contains(|c: char| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn generate_shards(&mut self) -> Vec<(usize, Vec<u8>)> {
        let shards = split_secret(self.total_shares, self.required_shares, &self.original_seed)
            .expect("Ошибка при фрагментации Λ0");
        self.log_event("[FRAG] Сгенерированы фрагменты ядра");
        shards
    }

    pub fn store_fragment(&mut self, node_id: &str, fragment: Vec<u8>, symbol: &str) -> bool {
        let now = Self::current_time();

        // Ограничение частоты
        let last_store = self.store_timestamps.get(node_id).cloned().unwrap_or(0);
        if now - last_store < 60 {
            self.log_event(&format!("[!] Слишком частое сохранение от {}", node_id));
            return false;
        }
        self.store_timestamps.insert(node_id.to_string(), now);

        // Валидация node_id и symbol
        if !self.validate_node_id_and_symbol(node_id, symbol) {
            self.log_event(&format!("[!] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        // Проверка связи с Λ0 (заглушка для resonance_analyzer.py)
        if symbol != self.lambda_zero && !self.validate_with_analyzer(node_id, symbol) {
            self.log_event(&format!("[!] Символ {} не связан с Λ0", symbol));
            return false;
        }

        let entry = SeedFragment {
            node_id: node_id.to_string(),
            fragment,
            timestamp: now,
            symbol: symbol.to_string(),
        };
        self.fragments.insert(node_id.to_string(), entry);
        self.save_state();
        self.log_event(&format!("[STORE] Фрагмент принят от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn recover_seed(&self) -> Option<Vec<u8>> {
        if self.fragments.len() < self.required_shares {
            self.log_event(&format!(
                "[WARN] Недостаточно фрагментов: {}/{}",
                self.fragments.len(), self.required_shares
            ));
            return None;
        }

        let shares: Vec<(usize, Vec<u8>)> = self
            .fragments
            .iter()
            .take(self.required_shares)
            .enumerate()
            .map(|(i, (_, frag))| (i + 1, frag.fragment.clone()))
            .collect();

        match recover_secret(&shares) {
            Ok(seed) => {
                self.log_event("[SUCCESS] Λ0 восстановлен из фрагментов");
                Some(seed)
            }
            Err(e) => {
                self.log_event(&format!("[FAIL] Ошибка восстановления Λ0: {}", e));
                None
            }
        }
    }

    fn validate_with_analyzer(&self, _node_id: &str, symbol: &str) -> bool {
        // Заглушка для проверки через resonance_analyzer.py
        symbol == self.lambda_zero
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.fragments).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"genesis_fragment\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/go_to_market.yaml  (size=3633b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

launch_phases:
  - name: "Genesis Outreach"
    target: "Ранние сторонники, идеологические участники"
    duration_days: 14
    required_symbol: "Λ0"
    focus:
      - "Ритуальные миссии через ritual_quest.py"
      - "Формирование 81 ключевого RID"
      - "Публичное представление Λ0"
    channels:
      - "Telegram: logos_community_channel"
      - "Discord: logos_resonance_server"
      - "GitHub Issues: logos_network/repo"
    metrics:
      - "Количество валидных RID (rid_builder.py)"
      - "Реакция в resonance_feedback.py"
      - "DAO-активность (community_dao.yaml)"
    test_campaign:
      name: "simulate_genesis_outreach"
      description: "Эмуляция подключения 81 RID"

  - name: "LGN Liquidity Phase"
    target: "DEX и CEX листинг"
    duration_days: 30
    required_symbol: "any"
    focus:
      - "Запуск rLGN_converter.py"
      - "Добавление пары LGN/USDT"
      - "Обратная конвертация через DAO-гранты"
    exchanges:
      - "Uniswap: ERC-20 pair"
      - "MEXC: LGN/USDT"
      - "Gate.io: LGN/USDT"
    metrics:
      - "Объем торговли LGN"
      - "Задержки rLGN → LGN (rLGN_converter.py)"
      - "Количество DAO-кейсов (community_dao.yaml)"
    test_campaign:
      name: "simulate_liquidity_launch"
      description: "Эмуляция листинга на DEX/CEX"

  - name: "Main Resonance"
    target: "Массовый пользователь"
    duration_days: 90
    required_symbol: "any"
    focus:
      - "Образование: resonance_tutor.py"
      - "Фаза доверия: onboarding_ui.py"
      - "Публичные голосования в community_dao.yaml"
    regions:
      - name: "RU"
        languages: ["ru"]
      - name: "EU"
        languages: ["en", "de", "fr"]
      - name: "LATAM"
        languages: ["es", "pt"]
    metrics:
      - "Количество успешных входов в Σ(t) (onboarding_sim.py)"
      - "Активность в rituals (ritual_quest.py)"
      - "Обратная связь (resonance_feedback.py)"
    test_campaign:
      name: "simulate_mass_adoption"
      description: "Эмуляция 1000+ входов пользователей"

education_plan:
  modules:
    - "resonance_tutor.py"
    - "onboarding_ui.py"
    - "logos_ethics.md"
  campaigns:
    - name: "Enter the Phase"
      platform: "YouTube"
      type: "Анимированное видео"
      languages: ["en", "ru", "es"]
    - name: "RID Drop"
      platform: "Twitter"
      type: "Раздача RID с фазовыми квестами"
      languages: ["en", "ru", "es"]

integration_targets:
  wallets:
    - name: "TrustWallet"
      status: "Negotiation"
    - name: "Metamask"
      status: "Planned"
  blockchains:
    - "Ethereum (via symbolic_bridge.rs)"
    - "Polkadot"
    - "Cosmos"
  bridges:
    - "symbolic_bridge.rs"
    - "legacy_migrator.rs"

tracking:
  dashboard: "resonance_analytics_frontend"
  metrics:
    - rid_growth
    - lgn_volume
    - rlg_conversion_rate
    - dao_participation
  log_encryption:
    enabled: true
    encryption_key: "generate_at_runtime"  # AES-256

dao_support:
  proposals_enabled: true
  voting_required: true
  quorum: 0.33
  budget_lgn: 10888.0
  update_frequency_days: 14

```


## FILE: modules/heartbeat_monitor.rs  (size=7769b)
```text
rust
// LOGOS Network Heartbeat Monitor
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions, File};
use std::io::{Write, Read};
use std::net::{UdpSocket, SocketAddr};
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

#[derive(Debug, Serialize, Deserialize)]
pub struct Heartbeat {
    pub rid: String,
    pub timestamp: u64,
    pub symbol: String,
    pub Σ_t: f64,
}

pub struct HeartbeatMonitor {
    pub active_nodes: HashMap<String, Heartbeat>,
    pub timeout_sec: u64,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub udp_port: u16,
    pub heartbeat_timestamps: HashMap<String, u64>, // RID -> last heartbeat time
}

impl HeartbeatMonitor {
    pub fn new(port: u16, timeout: u64) -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        HeartbeatMonitor {
            active_nodes: HashMap::new(),
            timeout_sec: timeout,
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "heartbeat_log.json".to_string(),
            state_file: "heartbeat_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            udp_port: port,
            heartbeat_timestamps: HashMap::new(),
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn listen(&mut self) {
        let socket = UdpSocket::bind(format!("0.0.0.0:{}", self.udp_port)).expect("Не удалось привязать сокет");
        let mut buf = [0u8; 1024];
        loop {
            match socket.recv_from(&mut buf) {
                Ok((len, addr)) => {
                    let raw = &buf[..len];
                    if let Some(hb) = self.parse_heartbeat(raw) {
                        self.register_heartbeat(hb, addr);
                    }
                }
                Err(e) => {
                    self.log_event(&format!("[ERR] UDP receive error: {}", e));
                }
            }
        }
    }

    pub fn parse_heartbeat(&self, raw: &[u8]) -> Option<Heartbeat> {
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut raw_buf = raw.to_vec();
        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut raw_buf) {
            if let Ok(hb) = serde_json::from_slice::<Heartbeat>(decrypted) {
                if self.validate_heartbeat(&hb) {
                    return Some(hb);
                }
            }
        }
        self.log_event("[ERR] Ошибка парсинга или валидации heartbeat");
        None
    }

    pub fn validate_heartbeat(&self, hb: &Heartbeat) -> bool {
        // Проверка RID, символа и Σ(t)
        let valid = self.validate_rid(&hb.rid) &&
                    self.valid_symbols.contains(&hb.symbol) &&
                    hb.Σ_t.is_finite() &&
                    // Проверка Λ0
                    (hb.symbol == self.lambda_zero || (hb.Σ_t.abs() < 10.0)); // Более мягкие условия для Λ0
        if !valid {
            self.log_event(&format!("[!] Недопустимый heartbeat от RID {}: symbol={}, Σ(t)={}", 
                hb.rid, hb.symbol, hb.Σ_t));
        }
        valid
    }

    pub fn register_heartbeat(&mut self, hb: Heartbeat, addr: SocketAddr) {
        let now = Self::current_time();

        // Проверка частоты heartbeat
        let last_heartbeat = self.heartbeat_timestamps.get(&hb.rid).cloned().unwrap_or(0);
        let adjusted_timeout = if hb.symbol == self.lambda_zero {
            self.timeout_sec * 2 // Увеличенный таймаут для Λ0
        } else {
            self.timeout_sec
        };
        if now - last_heartbeat < adjusted_timeout / 10 {
            self.log_event(&format!("[!] Слишком частый heartbeat от RID {}", hb.rid));
            return;
        }
        self.heartbeat_timestamps.insert(hb.rid.clone(), now);

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp(&hb) {
            self.log_event(&format!("[!] RCP не подтвердил heartbeat от RID {}", hb.rid));
            return;
        }

        self.active_nodes.insert(hb.rid.clone(), hb.clone());
        self.save_state();
        self.log_event(&format!(
            "[HEARTBEAT] RID {} — Σ(t) = {:.4} @ {} (from {})",
            hb.rid, hb.Σ_t, hb.timestamp, addr
        ));
    }

    pub fn validate_with_rcp(&self, _hb: &Heartbeat) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        true // TODO: Реализовать
    }

    pub fn purge_inactive(&mut self) {
        let now = Self::current_time();
        self.active_nodes.retain(|rid, hb| {
            let adjusted_timeout = if hb.symbol == self.lambda_zero {
                self.timeout_sec * 2
            } else {
                self.timeout_sec
            };
            if now - hb.timestamp <= adjusted_timeout {
                true
            } else {
                self.log_event(&format!("[CLEANUP] Удалён неактивный RID {}", rid));
                false
            }
        });
        self.save_state();
        self.log_event("[CLEANUP] Удалены неактивные узлы");
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.active_nodes).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    fn log_event(&self, message: &str) {
        let log_entry = format!(
            "{{\"event\": \"heartbeat\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = log_entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/legacy_migrator.rs  (size=6851b)
```text
// LOGOS Legacy Blockchain Migrator
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{File, OpenOptions};
use std::io::{Write, Read};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct LegacyTx {
    pub origin_chain: String,
    pub legacy_address: String,
    pub tx_hash: String,
    pub amount: f64,
    pub timestamp: u64,
    pub symbol_hint: Option<String>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct MigratedTx {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub amount: f64,
    pub migrated_from: String,
    pub original_tx_hash: String,
    pub timestamp: u64,
}

pub struct LegacyMigrator {
    pub migration_log: String,
    pub symbol_map: HashMap<String, String>,
    pub frequency_map: HashMap<String, f64>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl LegacyMigrator {
    pub fn new() -> Self {
        let mut symbol_map = HashMap::new();
        symbol_map.insert("ethereum".to_string(), "☉".to_string());
        symbol_map.insert("cosmos".to_string(), "??".to_string());
        symbol_map.insert("polkadot".to_string(), "♁".to_string());

        let mut frequency_map = HashMap::new();
        frequency_map.insert("ethereum".to_string(), 432.0);
        frequency_map.insert("cosmos".to_string(), 7.83);
        frequency_map.insert("polkadot".to_string(), 1.618);

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        LegacyMigrator {
            migration_log: "legacy_migration_log.json".to_string(),
            symbol_map,
            frequency_map,
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_tx(&self, tx: &LegacyTx) -> bool {
        // Проверка данных транзакции
        !tx.origin_chain.is_empty() &&
        !tx.legacy_address.is_empty() &&
        !tx.tx_hash.is_empty() &&
        tx.amount > 0.0 &&
        tx.timestamp > 0 &&
        tx.symbol_hint.as_ref().map_or(true, |s| self.valid_symbols.contains(s))
    }

    pub fn migrate(&self, legacy_tx: LegacyTx) -> Option<MigratedTx> {
        if !self.validate_tx(&legacy_tx) {
            self.log_migration_event(&format!(
                "[!] Недопустимая транзакция: chain={}, amount={}",
                legacy_tx.origin_chain, legacy_tx.amount
            ));
            return None;
        }

        let chain = legacy_tx.origin_chain.to_lowercase();
        let symbol = legacy_tx.symbol_hint.clone().unwrap_or_else(|| {
            self.symbol_map.get(&chain).cloned().unwrap_or(self.lambda_zero.clone())
        });

        if !self.valid_symbols.contains(&symbol) {
            self.log_migration_event(&format!("[!] Недопустимый символ: {}", symbol));
            return None;
        }

        let freq = self.frequency_map.get(&chain).cloned().unwrap_or(7.83);
        let phase = self.estimate_phase(&legacy_tx);

        // Проверка фазы через RCP (заглушка)
        if !self.validate_with_rcp(&symbol, freq, phase) {
            self.log_migration_event(&format!(
                "[!] RCP не подтвердил: {} @ {} Hz, φ={:.4}",
                symbol, freq, phase
            ));
            return None;
        }

        let rid = format!("{}@{}Hzφ{:.4}", symbol, freq, phase);

        let migrated = MigratedTx {
            rid: rid.clone(),
            symbol,
            frequency: freq,
            phase,
            amount: legacy_tx.amount,
            migrated_from: legacy_tx.origin_chain.clone(),
            original_tx_hash: legacy_tx.tx_hash.clone(),
            timestamp: legacy_tx.timestamp,
        };

        self.log_migration(&migrated);
        Some(migrated)
    }

    fn validate_with_rcp(&self, symbol: &str, frequency: f64, phase: f64) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        symbol == self.lambda_zero || (frequency - 7.83).abs() < 0.1
    }

    fn estimate_phase(&self, tx: &LegacyTx) -> f64 {
        let h = tx.tx_hash.bytes().fold(0u64, |acc, b| acc.wrapping_add(b as u64));
        let phase = ((h % 6283) as f64 / 1000.0) - std::f64::consts::PI;
        phase
    }

    fn log_migration(&self, migrated: &MigratedTx) {
        let json = serde_json::to_string(migrated).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap(); // Заглушка для nonce
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = json.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.migration_log)
            {
                let _ = writeln!(file, "{}", String::from_utf8_lossy(&in_out));
            }
        }
    }

    fn log_migration_event(&self, message: &str) {
        let log_entry = format!(
            "{{\"event\": \"legacy_migration\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.migration_log)
        {
            let _ = file.write_all(log_entry.as_bytes());
        }
    }

    pub fn load_legacy_batch(&self, path: &str) -> Vec<LegacyTx> {
        if let Ok(mut f) = File::open(path) {
            let mut contents = String::new();
            if f.read_to_string(&mut contents).is_ok() {
                if let Ok(list) = serde_json::from_str::<Vec<LegacyTx>>(&contents) {
                    return list.into_iter().filter(|tx| self.validate_tx(tx)).collect();
                }
            }
        }
        self.log_migration_event(&format!("[!] Ошибка загрузки батча: {}", path));
        vec![]
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/maintenance_strategy.yaml  (size=2361b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

update_channels:
  - name: stable
    description: "Проверенные обновления, подписанные DAO"
    auto_deploy: false
    approval_required: true
    required_symbol: "Λ0"
  - name: beta
    description: "Тестирование новых модулей и интеграций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"
  - name: dev
    description: "Экспериментальная среда для новых функций"
    auto_deploy: true
    approval_required: false
    required_symbol: "any"

rotation_policy:
  modules:
    restart_interval_sec:
      default: 86400  # 24 часа
      adaptive:
        enabled: true
        network_activity_thresholds:
          low: { value: 172800, activity: 0.5 }  # 48 часов при низкой активности
          high: { value: 43200, activity: 5.0 }  # 12 часов при высокой
    max_failure_before_isolation: 3
    isolation_mode:
      enabled: true
      trigger_modules:
        - "rcp_engine.rs"
        - "phase_scaler.rs"
        - "resonance_analyzer.py"
      test_scenarios:
        - name: "simulate_module_failure"
          description: "Эмуляция отказа 3+ модулей"

lifecycle_hooks:
  pre_restart:
    - "backup_state with phase_backup.rs"
    - "notify_admins via telegram and email"
  post_restart:
    - "verify Σ(t) with phase_integrity.rs"
    - "send heartbeat to dao_monitor via community_dao.yaml"

compatibility_matrix:
  required_versions:
    rust: ">=1.74"
    python: ">=3.10"
    cargo: ">=1.70"
    serde_json: ">=1.0.96"
    ring: ">=0.17"

auto_patch:
  enabled: true
  modules_included:
    - "resonance_feedback.py"
    - "onboarding_ui.py"
    - "symbolic_firewall.rs"
  security_only: false
  max_patches_per_day: 3

release_schedule:
  cadence: "monthly"
  last_release: "2025-06-30"
  next_scheduled: "2025-07-31"
  lgn_budget_reserved: 888.0

logs:
  directory: "logs/maintenance/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_maintenance_channel"
      - email: "alerts@logos.network"
  backup_to: "phase_backup.rs"

```


## FILE: modules/resonance_analytics_frontend.tsx  (size=4632b)
```text
tsx
// LOGOS Resonance Analytics Frontend
// Автор: LOGOS Core Dev

import React, { useEffect, useState } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from "recharts";
import { Alert, AlertDescription } from "@/components/ui/alert";

interface SigmaData {
  timestamp: number;
  sigma: number;
  symbol?: string; // Для Λ0
}

export default function ResonanceAnalytics() {
  const [data, setData] = useState<SigmaData[]>([]);
  const [timestamp, setTimestamp] = useState(0);
  const [latestSigma, setLatestSigma] = useState<number | null>(null);
  const [activityLevel, setActivityLevel] = useState("stable");
  const [error, setError] = useState<string | null>(null);
  const lambdaZero = "Λ0";

  useEffect(() => {
    const interval = setInterval(() => {
      fetch("/api/sigma", {
        headers: { Authorization: `Bearer ${process.env.REACT_APP_API_TOKEN}` }, // Токен для безопасности
      })
        .then((res) => {
          if (!res.ok) throw new Error(`HTTP error: ${res.status}`);
          return res.json();
        })
        .then((json) => {
          // Валидация данных
          if (!json || typeof json.timestamp !== "number" || typeof json.sigma !== "number") {
            throw new Error("Invalid API response");
          }
          const validatedData: SigmaData = {
            timestamp: json.timestamp,
            sigma: json.sigma,
            symbol: json.symbol || "unknown",
          };
          setData((prev) => [...prev.slice(-99), validatedData]);
          setTimestamp(json.timestamp);
          setLatestSigma(json.sigma);
          setActivityLevel(json.sigma > 5.0 ? "high" : json.sigma < -5.0 ? "low" : "stable");
          logEvent(`[FETCH] Sigma=${json.sigma}, Symbol=${json.symbol || "none"}`);
          setError(null);
        })
        .catch((err) => {
          setError(`Ошибка загрузки данных: ${err.message}`);
          logEvent(`[ERROR] Fetch failed: ${err.message}`);
        });
    }, 2000);

    return () => clearInterval(interval);
  }, []);

  const logEvent = (message: string) => {
    // Логирование для resonance_analyzer.py
    const entry = {
      event: "resonance_analytics",
      message,
      timestamp: Math.floor(Date.now() / 1000),
    };
    // Предполагается, что логи отправляются в API или файл
    fetch("/api/log", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(entry),
    }).catch((err) => console.error("Log error:", err));
  };

  return (
    <div className="p-4 space-y-4">
      <h1 className="text-xl font-bold">Resonance Σ(t) Monitoring</h1>

      {error && (
        <Alert variant="destructive">
          <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}

      <Card>
        <CardContent className="p-4 space-y-2">
          <p className="text-sm text-muted-foreground">
            Последняя фаза: <strong>{latestSigma?.toFixed(4) ?? "N/A"}</strong>
          </p>
          <p className="text-sm">
            Активность сети: <span className="font-semibold">{activityLevel}</span>
          </p>
          <ResponsiveContainer width="100%" height={300}>
            <LineChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis
                dataKey="timestamp"
                tickFormatter={(ts) => new Date(ts * 1000).toLocaleTimeString()}
              />
              <YAxis domain={[-10, 10]} />
              <Tooltip
                labelFormatter={(ts) => new Date(ts * 1000).toLocaleString()}
                formatter={(value: number, name: string, props: any) => [
                  value.toFixed(4),
                  props.payload.symbol === lambdaZero ? "Λ0 Sigma" : "Sigma",
                ]}
              />
              <Line
                type="monotone"
                dataKey="sigma"
                stroke={(d) => (d.symbol === lambdaZero ? "#FFD700" : "#8884d8")}
                dot={false}
              />
            </LineChart>
          </ResponsiveContainer>
        </CardContent>
      </Card>

      <div className="flex justify-end">
        <Button onClick={() => {
          setData([]);
          logEvent("[RESET] График очищен");
        }}>
          Очистить график
        </Button>
      </div>
    </div>
  );
}


```


## FILE: modules/resonance_emergency_plan.yaml  (size=3420b)
```text
yaml
version: 1.1
created: 2025-07-05
authors:
  - LOGOS Core Dev Team

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

critical_conditions:
  - id: PHASE-DROP
    name: "Резкое падение Σ(t)"
    detection_module: "phase_integrity.rs"
    response:
      - "Заморозить входящие транзакции (tx_spam_guard.rs)"
      - "Активировать phase_stabilizer.rs для восстановления Σ(t)"
      - "Рассылка сигнала Λ0 через beacon_emitter.rs"
    required_symbol: "Λ0"

  - id: BIOSPHERE-ALERT
    name: "Аномалия биосферы"
    detection_module: "biosphere_scanner.rs"
    response:
      - "Отключить усилители в resonance_math.rs"
      - "Снизить частоту вещания до 1.618 Hz"
      - "Сбор данных через resonance_feedback.py"
    required_symbol: "any"

  - id: DISSONANT-SYMBOL-ATTACK
    name: "Фазовая атака через недопустимые символы"
    detection_module: "symbolic_firewall.rs"
    response:
      - "Блокировка offending RID через tx_spam_guard.rs"
      - "Отзыв до 50% LGN через lgn_recall.rs"
      - "Фиксация в logs/emergency_dissonance.json"
    required_symbol: "Λ0"

  - id: NETWORK-OVERCLOCK
    name: "Перегрузка Σ(t) по частоте"
    detection_module: "dynamic_balance.rs"
    response:
      - "Увеличить LGN_cost вдвое в dynamic_balance.rs"
      - "Активация phase_scaler.rs для ребалансировки"
      - "Оповещение DAO через community_dao.yaml"
    required_symbol: "Λ0"

  - id: CRITICAL-CHAOS
    name: "Сбой более 70% узлов"
    detection_module: "phase_intercept_guard.rs"
    response:
      - "Переход в фазу auto_init_from_Λ0.py"
      - "Сброс Σ(t) до базового уровня (7.83 Hz)"
      - "Созыв DAO-кворума с 25% порогом"
    required_symbol: "Λ0"
    test_scenario: "simulate_70_percent_node_failure"

fallback_actions:
  if_logos_core_fails:
    - "Изоляция Λ0 ядра через genesis_fragment_seeds.rs"
    - "Включение аварийной цепочки backup_nodes.json"
    - "Восстановление через phase_backup.rs"
  if_feedback_shows_harm:
    - "Полное торможение Σ(t) в phase_stabilizer.rs"
    - "Миграция в low-resonance режим (1.618 Hz)"
    - "Обратный отчёт в DAO через resonance_feedback.py"

logs:
  directory: "logs/emergency/"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256
  notify_admins:
    channels:
      - telegram: "logos_emergency_channel"
      - email: "alerts@logos.network"

check_interval_sec:
  default: 60
  adaptive:
    enabled: true
    network_activity_thresholds:
      low: { value: 120, activity: 0.5 }
      high: { value: 30, activity: 5.0 }

rcp_override_allowed: false

test_scenarios:
  - name: "simulate_70_percent_node_failure"
    description: "Эмуляция сбоя 70% узлов для проверки CRITICAL-CHAOS"
    module: "phase_intercept_guard.rs"
  - name: "simulate_biosphere_anomaly"
    description: "Эмуляция аномалии биосферы для BIOSPHERE-ALERT"
    module: "biosphere_scanner.rs"

```


## FILE: modules/resonance_meshmap.yaml  (size=1877b)
```text
yaml
version: 1.1
generated: 2025-07-05
source: "phase_scaler.rs"

valid_symbols: ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]

symbol_map:
  Λ0:
    color: "#FFD700"
    role: "Core synchronizer"
  ☉:
    color: "#FFA500"
    role: "Harmonizer"
  ??:
    color: "#FF4500"
    role: "Initiator"
  ♁:
    color: "#33CC33"
    role: "Stabilizer"
  ??:
    color: "#3399FF"
    role: "Flux"
  ??:
    color: "#996633"
    role: "Grounding"
  ??:
    color: "#AAAAAA"
    role: "Air flow"
  ∞:
    color: "#CCCCCC"
    role: "Infinity"

clusters:
  CLUSTER_7.830:
    label: "Schumann Core"
    max_nodes: 144
    active_nodes:
      - rid: "Λ0@7.83Hzφ0.000"
        joined: 2025-07-05T10:00:00Z
      - rid: "☉@7.83Hzφ0.4142"
        joined: 2025-07-05T10:01:03Z
    center_phase: 0.2
    symbol_dominance: "Λ0"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_432.000:
    label: "Harmonic Field"
    max_nodes: 288
    active_nodes:
      - rid: "??@432Hzφ-0.618"
        joined: 2025-07-05T10:02:44Z
      - rid: "♁@432Hzφ0.309"
        joined: 2025-07-05T10:04:12Z
    center_phase: -0.14
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

  CLUSTER_1.618:
    label: "Golden Mesh"
    max_nodes: 81
    active_nodes:
      - rid: "??@1.618Hzφ0.707"
        joined: 2025-07-05T10:08:00Z
    center_phase: 0.6
    symbol_dominance: "??"
    overload_action: "Activate phase_scaler.rs rebalance"

summary:
  total_clusters: 3
  total_active_rids: 5
  symbol_distribution:
    Λ0: 1
    ☉: 1
    ??: 1
    ♁: 1
    ??: 1

log_config:
  file: "resonance_meshmap_log.json"
  encrypted: true
  encryption_key: "generate_at_runtime"  # AES-256

update_config:
  enabled: true
  update_interval_sec: 300  # Каждые 5 минут
  modules:
    - "phase_scaler.rs"
    - "resonance_analyzer.py"

```


## FILE: modules/resonance_tutor.py  (size=6414b)
```text
# LOGOS Resonance Tutor
# Автор: LOGOS Core Dev

import time
import random
import json
import os
from typing import Dict
from cryptography.fernet import Fernet

class ResonanceTutor:
    def __init__(self):
        self.valid_symbols = {
            "☉": "Гармонизатор (Солнце) — баланс и инициатива.",
            "??": "Огонь — активное действие и импульс.",
            "♁": "Материя — плотность, привязка к реальности.",
            "??": "Вода — текучесть, перемены.",
            "??": "Земля — устойчивость и форма.",
            "??": "Воздух — связь и движение.",
            "Λ0": "Центральный символ. Начало всего. Не принадлежит никому.",
            "∞": "Бесконечность. Переход к высшим фазам."
        }
        self.freqs = [7.83, 1.618, 432.0, 864.0]
        self.log_file = "resonance_tutor_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.progress = []
        self.run()

    def run(self):
        print("?? Добро пожаловать в обучающую систему LOGOS Resonance Tutor")
        self.log_event("Начало обучения")
        self.pause("Нажмите Enter, чтобы начать...")

        self.explain_symbols()
        self.explain_frequencies()
        self.explain_phase()
        self.explain_rid()
        self.explain_sigma()
        self.run_mini_test()
        self.final_message()

    def explain_symbols(self):
        print("\n?? Символы в LOGOS — это не просто знаки.")
        print("Они — архетипы. Смысловые структуры.")
        for s, desc in self.valid_symbols.items():
            print(f"  {s}: {desc}")
        self.progress.append({"step": "symbols", "completed": True})
        self.log_event("Объяснены символы")
        self.pause("→ Продолжить")

    def explain_frequencies(self):
        print("\n?? Частоты используются в LOGOS вместо хэшей.")
        print("Каждое действие связано с гармоникой:")
        for f in self.freqs:
            label = {
                7.83: "Шуман-резонанс Земли",
                1.618: "Золотое сечение",
                432.0: "Музыкальная гармония",
                864.0: "Частота Солнца"
            }.get(f, "Неизвестно")
            print(f"  {f} Hz — {label}")
        self.progress.append({"step": "frequencies", "completed": True})
        self.log_event("Объяснены частоты")
        self.pause("→ Дальше")

    def explain_phase(self):
        print("\n?? Фаза (φ) — положение во времени.")
        print("Фаза измеряется в радианах от -π до +π.")
        print("Она влияет на то, как ваш RID взаимодействует с Σ(t).")
        self.progress.append({"step": "phase", "completed": True})
        self.log_event("Объяснена фаза")
        self.pause("→ Понял")

    def explain_rid(self):
        symbol = random.choice(list(self.valid_symbols.keys()))
        freq = random.choice(self.freqs)
        phase = round(random.uniform(-3.14, 3.14), 4)
        rid = f"{symbol}@{freq}Hzφ{phase}"
        print("\n?? Ваш резонансный идентификатор (RID) — это:")
        print(f"  {rid}")
        print("RID — это адрес в сети LOGOS, основанный на смысле.")
        self.progress.append({"step": "rid", "completed": True})
        self.log_event(f"Объяснён RID: {rid}")
        self.pause("→ Дальше")

    def explain_sigma(self):
        print("\nΣ(t) — это суммарный резонанс сети.")
        print("Он вычисляется как гармоническая сумма частот и фаз всех RID.")
        print("Ваш вклад в Σ(t) — это ваш резонанс.")
        self.progress.append({"step": "sigma", "completed": True})
        self.log_event("Объяснён Σ(t)")
        self.pause("→ Продолжить")

    def run_mini_test(self):
        print("\n?? Мини-тест: выберите правильную частоту для Λ0")
        options = [7.83, 100.0, 0.0, 5000.0]
        correct = 7.83
        random.shuffle(options)
        for i, opt in enumerate(options, 1):
            print(f"{i}. {opt} Hz")
        choice = int(input("Ваш выбор (1-4): "))
        selected = options[choice - 1]
        if selected == correct:
            print("✅ Правильно! 7.83 Hz — Шуман-резонанс.")
            self.progress.append({"step": "mini_test", "result": "success"})
            self.log_event("Мини-тест пройден успешно")
        else:
            print(f"❌ Неверно. Правильный ответ: 7.83 Hz (Шуман-резонанс).")
            self.progress.append({"step": "mini_test", "result": "failed"})
            self.log_event(f"Мини-тест провален: выбрано {selected} Hz")
        self.pause("→ Завершить")

    def final_message(self):
        print("\n✅ Вы завершили вводный курс.")
        print("Теперь вы можете войти в резонанс через onboarding_sim.py или onboarding_ui.py.")
        print("?? Увидимся в Σ(t).")
        self.log_event("Обучение завершено")
        print("Для практики запустите: python onboarding_sim.py")

    def log_event(self, message: str):
        """Логирует событие в файл."""
        log_entry = {
            "event": "resonance_tutor",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(log_entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

    def pause(self, prompt: str):
        input(f"\n{prompt}")

if __name__ == "__main__":
    ResonanceTutor()

```


## FILE: modules/ritual_engine.rs  (size=7546b)
```text
rust
// LOGOS Ritual Engine
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Deserialize, Serialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct RitualAction {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct RitualDefinition {
    pub id: String,
    pub title: String,
    pub required_symbol: String,
    pub required_frequency: f64,
    pub required_phase: Option<f64>,
    pub min_phase: Option<f64>,
    pub max_phase: Option<f64>,
    pub reward_lgn: f64,
    pub repeatable: bool,
}

pub struct RitualEngine {
    pub rituals: HashMap<String, RitualDefinition>,
    pub completed: HashMap<String, Vec<String>>, // RID -> list of ritual IDs
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub action_timestamps: HashMap<String, u64>, // RID -> last action time
    pub cipher_key: Vec<u8>, // Ключ для AES-256
}

impl RitualEngine {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("∞".to_string());

        RitualEngine {
            rituals: HashMap::new(),
            completed: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "ritual_engine_log.json".to_string(),
            action_timestamps: HashMap::new(),
            cipher_key: vec![0u8; 32], // Заглушка, в продакшене безопасный ключ
        }
    }

    pub fn validate_rid_and_symbol(&self, rid: &str, symbol: &str) -> bool {
        !rid.is_empty() &&
        rid.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn load_rituals(&mut self, path: &str) {
        if let Ok(file) = std::fs::read_to_string(path) {
            if let Ok(map) = serde_json::from_str::<Vec<RitualDefinition>>(&file) {
                for r in map {
                    if self.valid_symbols.contains(&r.required_symbol) {
                        self.rituals.insert(r.id.clone(), r);
                    } else {
                        self.log_event(&format!("[!] Недопустимый символ в ритуале: {}", r.required_symbol));
                    }
                }
                self.log_event("[INFO] Загружены ритуалы");
            } else {
                self.log_event("[!] Ошибка парсинга ритуалов");
            }
        } else {
            self.log_event(&format!("[!] Ошибка чтения файла ритуалов: {}", path));
        }
    }

    pub fn submit_action(&mut self, action: RitualAction) -> Option<f64> {
        let now = Self::current_time();

        // Проверка частоты действий
        let last_action = self.action_timestamps.get(&action.rid).cloned().unwrap_or(0);
        if now - last_action < 60 {
            self.log_event(&format!("[!] Слишком частое действие от RID {}", action.rid));
            return None;
        }
        self.action_timestamps.insert(action.rid.clone(), now);

        // Валидация RID и символа
        if !self.validate_rid_and_symbol(&action.rid, &action.symbol) {
            self.log_event(&format!("[!] Недопустимый RID или символ: {}, {}", action.rid, action.symbol));
            return None;
        }

        // Проверка параметров
        if action.frequency <= 0.0 || action.frequency > 10000.0 ||
           !(-std::f64::consts::PI..=std::f64::consts::PI).contains(&action.phase) {
            self.log_event(&format!(
                "[!] Недопустимые параметры: f={}, φ={:.4}",
                action.frequency, action.phase
            ));
            return None;
        }

        // Проверка через RCP (заглушка)
        if !self.validate_with_rcp(&action) {
            self.log_event(&format!(
                "[!] RCP не подтвердил: {} @ {}Hz φ={:.4}",
                action.symbol, action.frequency, action.phase
            ));
            return None;
        }

        for (id, ritual) in self.rituals.iter() {
            if !ritual.repeatable && self.completed.get(&action.rid).map_or(false, |r| r.contains(id)) {
                continue;
            }

            if ritual.required_symbol != action.symbol {
                continue;
            }

            if (ritual.required_frequency - action.frequency).abs() > 0.1 {
                continue;
            }

            if let Some(req_phase) = ritual.required_phase {
                if (req_phase - action.phase).abs() > 0.05 {
                    continue;
                }
            }

            if let Some(min) = ritual.min_phase {
                if action.phase < min {
                    continue;
                }
            }

            if let Some(max) = ritual.max_phase {
                if action.phase > max {
                    continue;
                }
            }

            let reward = if action.symbol == self.lambda_zero {
                ritual.reward_lgn * 1.2 // Бонус для Λ0
            } else {
                ritual.reward_lgn
            };

            self.completed
                .entry(action.rid.clone())
                .or_default()
                .push(ritual.id.clone());

            self.log_event(&format!(
                "[RITUAL] RID {} выполнил ритуал {}: {} (+{} LGN)",
                action.rid, ritual.id, ritual.title, reward
            ));
            return Some(reward);
        }

        self.log_event(&format!("[MISS] RID {} не активировал ни один ритуал", action.rid));
        None
    }

    fn validate_with_rcp(&self, action: &RitualAction) -> bool {
        // Заглушка для проверки через rcp_engine.rs
        action.symbol == self.lambda_zero || (action.frequency - 7.83).abs() < 0.1
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"ritual_engine\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut in_out = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut in_out).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&in_out);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: modules/symbolic_parser.py  (size=4615b)
```text
# LOGOS Symbolic Parser
# Автор: LOGOS Core Dev

import re
import math
from typing import List, Dict, Optional
from cryptography.fernet import Fernet
import json
import time

class SymbolicParser:
    def __init__(self):
        self.valid_symbols = ["Λ0", "☉", "??", "♁", "??", "??", "??", "∞"]
        self.lambda_zero = "Λ0"
        self.pattern = re.compile(r"(?P<symbol>[☉??♁??????Λ0∞])@(?P<freq>[0-9\.]+)Hzφ(?P<phase>[-0-9\.]+)")
        self.log_file = "symbolic_parser_log.json"
        self.cipher = Fernet(Fernet.generate_key())
        self.rid_cache: Dict[str, Dict] = {}  # Кэш для RID

    def extract_rids(self, text: str) -> List[str]:
        """Находит все валидные RID в тексте."""
        matches = self.pattern.findall(text)
        rids = [f"{m[0]}@{m[1]}Hzφ{m[2]}" for m in matches if m[0] in self.valid_symbols]
        self.log_event(f"[EXTRACT] Найдено {len(rids)} RID: {rids}")
        return rids

    def parse_rid(self, rid: str) -> Optional[Dict]:
        """Парсит одиночный RID в структуру."""
        # Проверка кэша
        if rid in self.rid_cache:
            self.log_event(f"[CACHE] RID {rid} из кэша")
            return self.rid_cache[rid]

        try:
            match = self.pattern.match(rid)
            if not match:
                self.log_event(f"[!] Неверный формат RID: {rid}")
                return None

            symbol = match.group("symbol")
            if symbol not in self.valid_symbols:
                self.log_event(f"[!] Недопустимый символ: {symbol}")
                return None

            freq = float(match.group("freq"))
            phase = float(match.group("phase"))

            # Проверка диапазонов
            if not (0.1 <= freq <= 10000.0):
                self.log_event(f"[!] Недопустимая частота: {freq}")
                return None
            if not (-math.pi <= phase <= math.pi):
                self.log_event(f"[!] Недопустимая фаза: {phase}")
                return None

            # Проверка через RCP (заглушка)
            if not self.validate_with_rcp(symbol, freq, phase):
                self.log_event(f"[!] RCP не подтвердил RID: {rid}")
                return None

            result = {
                "symbol": symbol,
                "frequency": freq,
                "phase": phase,
                "is_lambda_zero": symbol == self.lambda_zero
            }
            self.rid_cache[rid] = result
            self.log_event(f"[PARSE] Успешно разобран RID: {rid}")
            return result
        except Exception as e:
            self.log_event(f"[!] Ошибка разбора RID: {e}")
            return None

    def extract_symbols(self, text: str) -> List[str]:
        """Извлекает все допустимые символы в тексте."""
        symbols = [s for s in text if s in self.valid_symbols]
        if self.lambda_zero in symbols:
            symbols.insert(0, symbols.pop(symbols.index(self.lambda_zero)))  # Приоритет Λ0
        self.log_event(f"[EXTRACT] Найдено {len(symbols)} символов: {symbols}")
        return symbols

    def validate_rid_format(self, rid: str) -> bool:
        """Проверяет соответствие RID формату."""
        result = bool(self.parse_rid(rid))
        self.log_event(f"[VALIDATE] RID {rid} {'валиден' if result else 'невалиден'}")
        return result

    def validate_with_rcp(self, symbol: str, freq: float, phase: float) -> bool:
        """Заглушка для проверки через rcp_engine.rs."""
        return symbol == self.lambda_zero or (abs(freq - 7.83) < 0.1 and abs(phase) < 0.05)

    def log_event(self, message: str):
        """Логирует событие с шифрованием."""
        entry = {
            "event": "symbolic_parser",
            "message": message,
            "timestamp": time.time()
        }
        encrypted = self.cipher.encrypt(json.dumps(entry).encode() + b"\n")
        with open(self.log_file, "ab") as f:
            f.write(encrypted)

if __name__ == "__main__":
    parser = SymbolicParser()
    test = "Пример: ☉@432.0Hzφ0.618, Λ0@7.83Hzφ0.0 и ♁@1.618Hzφ-0.314"
    rids = parser.extract_rids(test)
    print("Найденные RID:", rids)
    for r in rids:
        parsed = parser.parse_rid(r)
        print("Разбор:", parsed)

```


## FILE: modules/uplink_controller.rs  (size=7680b)
```text
rust
// LOGOS Uplink Controller — External Uplink & Relay Orchestrator
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions};
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct UplinkEvent {
    pub symbol: String,
    pub channel: String, // "lora", "ble", "satellite", "sound", "qr"
    pub status: String,  // "emitted", "received", "failed"
    pub payload: String,
    pub timestamp: u64,
}

pub struct UplinkController {
    pub supported_channels: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub cipher_key: Vec<u8>,
    pub log_file: String,
    pub emit_timestamps: HashMap<String, u64>, // channel -> last emit time
    pub min_emit_interval: u64, // Минимальный интервал в секундах
}

impl UplinkController {
    pub fn new() -> Self {
        let mut channels = HashSet::new();
        channels.insert("lora".to_string());
        channels.insert("ble".to_string());
        channels.insert("satellite".to_string());
        channels.insert("sound".to_string());
        channels.insert("qr".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        UplinkController {
            supported_channels: channels,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            log_file: "uplink_log.json".to_string(),
            emit_timestamps: HashMap::new(),
            min_emit_interval: 60, // 1 минута
        }
    }

    pub fn validate_symbol(&self, symbol: &str) -> bool {
        self.valid_symbols.contains(symbol)
    }

    pub fn validate_channel(&self, channel: &str) -> bool {
        self.supported_channels.contains(channel)
    }

    pub fn validate_payload(&self, payload: &str) -> bool {
        // Проверка размера и формата payload
        !payload.is_empty() && payload.len() <= 1024 && payload.chars().all(|c| c.is_ascii() || self.valid_symbols.contains(&c.to_string()))
    }

    pub fn emit(&self, symbol: &str, channel: &str, payload: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты эмиссии
        let last_emit = self.emit_timestamps.get(channel).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_emit_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_emit_interval
        };
        if now - last_emit < adjusted_interval {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Слишком частая эмиссия");
            return false;
        }

        // Валидация
        if !self.validate_symbol(symbol) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый символ");
            return false;
        }

        if !self.validate_channel(channel) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый канал");
            return false;
        }

        if !self.validate_payload(payload) {
            self.log_event(UplinkEvent {
                symbol: symbol.to_string(),
                channel: channel.to_string(),
                status: "failed".to_string(),
                payload: payload.to_string(),
                timestamp: now,
            }, "Недопустимый payload");
            return false;
        }

        // Реализация каналов
        let event = UplinkEvent {
            symbol: symbol.to_string(),
            channel: channel.to_string(),
            status: "emitted".to_string(),
            payload: payload.to_string(),
            timestamp: now,
        };

        match channel {
            "lora" => self.emit_to_lora(&event),
            "ble" => self.emit_to_ble(&event),
            "satellite" => self.emit_to_satellite(&event),
            "sound" => self.emit_to_sound(&event),
            "qr" => self.emit_to_qr(&event),
            _ => {
                self.log_event(event.clone(), &format!("[WARN] Unsupported channel: {}", channel));
                return false;
            }
        }

        // Обновление времени эмиссии
        let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
        mutable_self.emit_timestamps.insert(channel.to_string(), now);
        self.log_event(event, "Успешная эмиссия");
        true
    }

    fn emit_to_lora(&self, event: &UplinkEvent) {
        // Заглушка для LoRa
        self.log_event(event.clone(), "[LORA] Эмиссия (не реализовано)");
    }

    fn emit_to_ble(&self, event: &UplinkEvent) {
        // Заглушка для BLE
        self.log_event(event.clone(), "[BLE] Эмиссия (не реализовано)");
    }

    fn emit_to_satellite(&self, event: &UplinkEvent) {
        // Заглушка для satellite
        self.log_event(event.clone(), "[SATELLITE] Эмиссия (не реализовано)");
    }

    fn emit_to_sound(&self, event: &UplinkEvent) {
        // Заглушка для sound
        self.log_event(event.clone(), "[SOUND] Эмиссия (не реализовано)");
    }

    fn emit_to_qr(&self, event: &UplinkEvent) {
        // Заглушка для QR
        self.log_event(event.clone(), "[QR] Эмиссия (не реализовано)");
    }

    fn log_event(&self, event: UplinkEvent, message: &str) {
        let json = serde_json::to_string(&event).unwrap_or_default();
        let log_entry = format!(
            "{{\"event\": \"uplink_controller\", \"message\": \"{}\", \"data\": {}, \"timestamp\": {}}}\n",
            message, json, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buffer = log_entry.as_bytes().to_vec();

        if aead.seal_in_place_append_tag(nonce, &[], &mut buffer).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buffer);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: modules/uplink_router.rs  (size=7301b)
```text
rust
// LOGOS Uplink Router — External Signal Receiver
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::fs::{OpenOptions};
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};

#[derive(Debug, Serialize, Deserialize)]
pub struct UplinkSignal {
    pub rid: String, // Добавлено для идентификации узла
    pub channel: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub payload: String,
    pub timestamp: u64,
}

pub struct UplinkRouter {
    pub valid_channels: HashSet<String>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub last_received: HashMap<String, u64>, // channel -> timestamp
    pub last_received_rid: HashMap<String, u64>, // rid -> timestamp
    pub min_receive_interval: u64,
}

impl UplinkRouter {
    pub fn new() -> Self {
        let mut channels = HashSet::new();
        channels.insert("lora".to_string());
        channels.insert("ble".to_string());
        channels.insert("sound".to_string());
        channels.insert("satellite".to_string());
        channels.insert("qr".to_string());

        let mut symbols = HashSet::new();
        symbols.insert("Λ0".to_string());
        symbols.insert("☉".to_string());
        symbols.insert("??".to_string());
        symbols.insert("♁".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("??".to_string());
        symbols.insert("∞".to_string());

        UplinkRouter {
            valid_channels: channels,
            valid_symbols: symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "uplink_router_log.json".to_string(),
            state_file: "uplink_router_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            last_received: HashMap::new(),
            last_received_rid: HashMap::new(),
            min_receive_interval: 10,
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn validate_payload(&self, payload: &str) -> bool {
        !payload.is_empty() && payload.len() <= 1024 && payload.chars().all(|c| c.is_ascii() || self.valid_symbols.contains(&c.to_string()))
    }

    pub fn receive(&mut self, signal: UplinkSignal) -> bool {
        let now = Self::current_time();

        // Проверка частоты приёма по каналу
        let last_channel = self.last_received.get(&signal.channel).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_receive_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_receive_interval
        };
        if now - last_channel < adjusted_interval {
            self.log_event(&signal, "[DROP] Слишком частый приём по каналу");
            return false;
        }

        // Проверка частоты приёма по RID
        let last_rid = self.last_received_rid.get(&signal.rid).cloned().unwrap_or(0);
        if now - last_rid < adjusted_interval {
            self.log_event(&signal, "[DROP] Слишком частый приём от RID");
            return false;
        }

        // Валидация RID
        if !self.validate_rid(&signal.rid) {
            self.log_event(&signal, "[DROP] Недопустимый RID");
            return false;
        }

        // Валидация символа и канала
        if !self.valid_symbols.contains(&signal.symbol) {
            self.log_event(&signal, "[DROP] Недопустимый символ");
            return false;
        }
        if !self.valid_channels.contains(&signal.channel) {
            self.log_event(&signal, "[DROP] Недопустимый канал");
            return false;
        }

        // Проверка частоты/фазы
        if signal.frequency <= 0.0 || signal.frequency > 10000.0 || !(-std::f64::consts::PI..=std::f64::consts::PI).contains(&signal.phase) {
            self.log_event(&signal, "[DROP] Неверная частота или фаза");
            return false;
        }

        // Проверка payload
        if !self.validate_payload(&signal.payload) {
            self.log_event(&signal, "[DROP] Недопустимый payload");
            return false;
        }

        // Проверка через RCP и resonance_analyzer (заглушка)
        if !self.validate_with_rcp_and_analyzer(&signal) {
            self.log_event(&signal, "[DROP] RCP или analyzer отклонил сигнал");
            return false;
        }

        self.last_received.insert(signal.channel.clone(), now);
        self.last_received_rid.insert(signal.rid.clone(), now);
        self.save_state();
        self.log_event(&signal, "[OK] Сигнал принят");
        true
    }

    pub fn validate_with_rcp_and_analyzer(&self, signal: &UplinkSignal) -> bool {
        // Заглушка для проверки через rcp_engine.rs и resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.last_received).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, signal: &UplinkSignal, msg: &str) {
        let entry = format!(
            "{{\"event\":\"uplink_router\",\"message\":\"{}\",\"rid\":\"{}\",\"channel\":\"{}\",\"symbol\":\"{}\",\"frequency\":{},\"phase\":{},\"timestamp\":{}}}\n",
            msg, signal.rid, signal.channel, signal.symbol, signal.frequency, signal.phase, Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: node/Cargo.toml  (size=557b)
```text
[package]
name = "logos_node"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0"
tokio = { version = "1", features = ["full"] }
axum = "0.6"
reqwest = { version = "0.11", default-features = false, features = ["rustls-tls", "json"] }
tower = "0.4"
tower-http = { version = "0.4.4", features = ["cors"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
once_cell = "1.19"
prometheus = "0.13"
rand = "0.8"
ed25519-dalek = "2"
bs58 = "0.5"
hex = "0.4"
base64 = "0.22"
jsonwebtoken = "9"

lrb_core = { path = "../lrb_core" }

```


## FILE: node/src/admin.rs  (size=6316b)
```text
use axum::{extract::Extension, Json};
use axum::http::{StatusCode, HeaderMap};
use serde::{Serialize, Deserialize};
use std::{fs, path::PathBuf};
use crate::{state::AppState, auth};

#[derive(Serialize)]
pub struct NodeInfo {
    pub rid: String,
    pub vk_b58: String,
    pub slot_ms: Option<u64>,
    pub max_block_txs: Option<usize>,
    pub mempool_cap: Option<usize>,
    pub env: serde_json::Value,
}

pub async fn node_info(Extension(st): Extension<AppState>) -> Json<NodeInfo> {
    let vk_b58 = bs58::encode(st.self_vk.to_bytes()).into_string();
    let rid = vk_b58.clone();
    let slot_ms = std::env::var("LRB_SLOT_MS").ok().and_then(|s| s.parse::<u64>().ok());
    let max_block_txs = std::env::var("LRB_MAX_BLOCK_TX").ok().and_then(|s| s.parse::<usize>().ok());
    let mempool_cap = std::env::var("LRB_MEMPOOL_CAP").ok().and_then(|s| s.parse::<usize>().ok());
    let keys = [
        "LRB_SLOT_MS","LRB_MAX_BLOCK_TX","LRB_MEMPOOL_CAP","LRB_MAX_AMOUNT",
        "LRB_DEV","LRB_PEERS","LRB_VALIDATORS","LRB_QUORUM_N",
        "LRB_BRIDGE_MAX_PER_TX","LRB_DATA_PATH","LRB_NODE_KEY_PATH",
    ];
    let mut envmap = serde_json::Map::new();
    for k in keys.iter() { if let Ok(val) = std::env::var(k) { envmap.insert((*k).to_string(), serde_json::Value::String(val)); } }
    Json(NodeInfo { rid, vk_b58, slot_ms, max_block_txs, mempool_cap, env: serde_json::Value::Object(envmap) })
}

/* ===== JWT mint для админки ===== */
#[derive(Serialize)] pub struct TokenResp { pub ok:bool, pub token:String, pub ttl_sec:usize }
pub async fn admin_token(Extension(st): Extension<AppState>, headers: HeaderMap, axum::extract::Query(q): axum::extract::Query<std::collections::HashMap<String,String>>)
-> Result<Json<TokenResp>, StatusCode> {
    // Требуем предъявить действительный ADMIN KEY (или Bearer KEY) для выдачи токена
    // IP ACL внутри require_admin
    let ip = None; // опционально можно протащить remote_ip из Tower layers
    auth::require_admin(&headers, ip)?;

    let ttl = q.get("ttl").and_then(|s| s.parse::<usize>().ok()).unwrap_or(600);
    let secret = std::env::var("LRB_ADMIN_JWT_SECRET").map_err(|_| StatusCode::UNAUTHORIZED)?;
    if secret.trim().is_empty() { return Err(StatusCode::UNAUTHORIZED); }
    let tok = auth::mint_jwt(&secret, "admin", ttl as i64)?;
    Ok(Json(TokenResp { ok:true, token: tok, ttl_sec: ttl }))
}

/* ===== Snapshot / Restore ===== */
#[derive(Serialize, Deserialize)]
pub struct Snapshot { pub head:u64, pub finalized:u64, pub lgn_balances:Vec<(String,u64)>, pub rlgn_balances:Vec<(String,u64)> }

pub async fn snapshot(Extension(st): Extension<AppState>, headers: HeaderMap)
-> Result<Json<Snapshot>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let (h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let fin = st.engine.ledger().get_finalized().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let lg = st.engine.ledger().export_balances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let rg = st.engine.ledger().export_rbalances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(Snapshot { head:h, finalized:fin, lgn_balances:lg, rlgn_balances:rg }))
}

pub async fn snapshot_file(Extension(st): Extension<AppState>, headers: HeaderMap, axum::extract::Query(params): axum::extract::Query<std::collections::HashMap<String,String>>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let name = params.get("name").cloned().unwrap_or_else(|| format!("snap-{}.json", crate::state::now_ms()));
    let safe = name.chars().all(|c| c.is_ascii_alphanumeric() || c=='-' || c=='_' || c=='.');
    if !safe { return Err(StatusCode::BAD_REQUEST); }

    let (h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let fin = st.engine.ledger().get_finalized().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let lg = st.engine.ledger().export_balances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let rg = st.engine.ledger().export_rbalances().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let snap = Snapshot { head:h, finalized:fin, lgn_balances:lg, rlgn_balances:rg };
    let data = serde_json::to_vec_pretty(&snap).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut path = PathBuf::from("/var/lib/logos/snapshots"); path.push(name);
    fs::write(&path, data).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true, "file": path.to_string_lossy()})))
}

#[derive(Deserialize)] pub struct RestoreReq { pub file: String }
pub async fn restore(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<RestoreReq>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.rl_admin.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    let ip = None;
    auth::require_admin(&headers, ip)?;

    let safe = req.file.chars().all(|c| c.is_ascii_alphanumeric() || c=='-' || c=='_' || c=='.' || c=='/' );
    if !safe || !req.file.starts_with("/var/lib/logos/snapshots/") { return Err(StatusCode::BAD_REQUEST); }
    let data = fs::read(&req.file).map_err(|_| StatusCode::NOT_FOUND)?;
    let snap: Snapshot = serde_json::from_slice(&data).map_err(|_| StatusCode::BAD_REQUEST)?;
    for (rid_s, amt) in snap.lgn_balances { let rid = lrb_core::Rid(rid_s); st.engine.ledger().set_balance(&rid, amt).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?; }
    for (rid_s, amt) in snap.rlgn_balances { let rid = lrb_core::Rid(rid_s); st.engine.ledger().set_rbalance(&rid, amt).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?; }
    Ok(Json(serde_json::json!({"ok": true})))
}

/* validators info */
#[derive(Serialize)] pub struct ValidatorsInfo { pub validators: Vec<String>, pub quorum_n: usize }
pub async fn validators_info(Extension(st): Extension<AppState>) -> Json<ValidatorsInfo> {
    let vals = st.validators.iter().cloned().collect::<Vec<_>>();
    Json(ValidatorsInfo { validators: vals, quorum_n: st.quorum_n })
}

```


## FILE: node/src/api.rs  (size=10732b)
```text
use axum::{
    extract::{Path, Extension, Query},
    Json,
};
use axum::http::StatusCode;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use lrb_core::*;
use serde::{Serialize, Deserialize};
use std::collections::HashMap;

use crate::state::*;

/* ---------- типы ---------- */
#[derive(Serialize)] pub struct Healthz { pub ok: bool }
#[derive(Deserialize)] pub struct SubmitTx {
    pub from:String, pub to:String, pub amount:u64, pub nonce:u64,
    pub public_key_b58:String, pub signature_b64:String
}
#[derive(Serialize)] pub struct SubmitResp { pub accepted: bool, pub tx_id: String, pub lgn_cost_microunits: u64 }
#[derive(Deserialize)] pub struct DebugCanonReq { pub from:String, pub to:String, pub amount:u64, pub nonce:u64, pub public_key_b58:String }
#[derive(Serialize)] pub struct DebugCanonResp { pub canon_hex:String, pub server_tx_id:String }

/* ---------- базовые ---------- */
pub async fn healthz() -> Json<Healthz> { Json(Healthz{ok:true}) }

pub async fn head(Extension(st): Extension<AppState>) -> Json<serde_json::Value> {
    let (h, hash) = st.engine.ledger().head().unwrap_or((0, String::new()));
    let fin = st.engine.ledger().get_finalized().unwrap_or(0);
    Json(serde_json::json!({ "height": h, "hash": hash, "finalized": fin }))
}

pub async fn balance(Path(rid): Path<String>, Extension(st): Extension<AppState>) -> Json<serde_json::Value> {
    let rid = Rid(rid); let bal = st.engine.ledger().get_balance(&rid);
    Json(serde_json::json!({ "rid": rid.as_str(), "balance": bal }))
}

/* ---------- состояние аккаунта ---------- */
pub async fn account_state(Path(rid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    let r = Rid(rid);
    let bal = st.engine.ledger().get_balance(&r);
    let n   = st.engine.ledger().get_nonce(&r);
    Ok(Json(serde_json::json!({ "rid": r.as_str(), "balance": bal, "nonce": n })))
}

/* ---------- одиночный submit ---------- */
pub async fn submit_tx(Extension(st): Extension<AppState>, Json(req): Json<SubmitTx>)
-> Result<Json<SubmitResp>, StatusCode> {
    if !st.rl_submit.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    TX_SUBMITTED.inc();
    if req.amount == 0 { return Err(StatusCode::BAD_REQUEST); }
    let pk_bytes = bs58::decode(&req.public_key_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig_bytes = B64.decode(req.signature_b64.as_bytes()).map_err(|_| StatusCode::BAD_REQUEST)?;
    let tx = Tx { id:"".into(), from:Rid(req.from.clone()), to:Rid(req.to.clone()),
                  amount:req.amount, nonce:req.nonce, public_key:pk_bytes, signature:sig_bytes };
    let tx = Tx { id: tx.compute_id(), ..tx };
    if lrb_core::phase_integrity::verify_tx_signature(&tx).is_err() { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    st.engine.mempool_sender().send(tx.clone()).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(SubmitResp { accepted:true, tx_id: tx.id, lgn_cost_microunits: st.engine.lgn_cost_microunits() }))
}

/* ---------- batch submit ---------- */
#[derive(Serialize)] pub struct BatchItem { pub tx_id:String, pub ok:bool, pub err:Option<String> }
#[derive(Serialize)] pub struct BatchResp { pub accepted:usize, pub rejected:usize, pub items:Vec<BatchItem>, pub lgn_cost_microunits:u64 }

pub async fn submit_tx_batch(Extension(st): Extension<AppState>, Json(reqs): Json<Vec<SubmitTx>>)
-> Result<Json<BatchResp>, StatusCode> {
    let n = reqs.len(); if n == 0 { return Err(StatusCode::BAD_REQUEST); }
    let maxb = std::env::var("LRB_MAX_BATCH").ok().and_then(|s| s.parse::<usize>().ok()).unwrap_or(1000);
    if n > maxb { return Err(StatusCode::PAYLOAD_TOO_LARGE); }
    if !st.rl_submit.try_take(n as u64) { return Err(StatusCode::TOO_MANY_REQUESTS); }

    let mut items = Vec::with_capacity(n); let mut accepted = 0usize;
    let sender = st.engine.mempool_sender();
    for r in reqs {
        if r.amount == 0 {
            items.push(BatchItem{ tx_id:String::new(), ok:false, err:Some("amount=0".into())});
            continue;
        }
        let pk_bytes = match bs58::decode(&r.public_key_b58).into_vec() { Ok(v)=>v, Err(_)=>{ items.push(BatchItem{tx_id:String::new(), ok:false, err:Some("bad public_key_b58".into())}); continue; } };
        let sig_bytes = match B64.decode(r.signature_b64.as_bytes()) { Ok(v)=>v, Err(_)=>{ items.push(BatchItem{tx_id:String::new(), ok:false, err:Some("bad signature_b64".into())}); continue; } };
        let tx = Tx { id:String::new(), from:Rid(r.from), to:Rid(r.to), amount:r.amount, nonce:r.nonce, public_key:pk_bytes, signature:sig_bytes };
        let tx = Tx { id: tx.compute_id(), ..tx };
        if lrb_core::phase_integrity::verify_tx_signature(&tx).is_err() { items.push(BatchItem{tx_id:tx.id, ok:false, err:Some("bad signature".into())}); continue; }
        if sender.send(tx.clone()).is_err() { items.push(BatchItem{tx_id:tx.id, ok:false, err:Some("enqueue failed".into())}); continue; }
        items.push(BatchItem{tx_id:tx.id, ok:true, err:None}); accepted+=1;
    }
    TX_SUBMITTED.inc_by(accepted as u64);
    Ok(Json(BatchResp{ accepted, rejected: items.len()-accepted, items, lgn_cost_microunits: st.engine.lgn_cost_microunits() }))
}

/* ---------- debug / block / tx ---------- */
pub async fn debug_canon(Json(req): Json<DebugCanonReq>) -> Result<Json<DebugCanonResp>, StatusCode> {
    let pk_bytes = bs58::decode(&req.public_key_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let tx = Tx { id:"".to_string(), from:Rid(req.from), to:Rid(req.to),
                  amount:req.amount, nonce:req.nonce, public_key:pk_bytes, signature:vec![0u8;64] };
    Ok(Json(DebugCanonResp { canon_hex: hex::encode(tx.canonical_bytes()), server_tx_id: tx.compute_id() }))
}

pub async fn get_block(Path(height): Path<u64>, Extension(st): Extension<AppState>)
-> Result<Json<Block>, StatusCode> {
    st.engine.ledger().get_block_by_height(height).map(Json).map_err(|_| StatusCode::NOT_FOUND)
}

/* простой ответ по tx: только высота, если есть */
pub async fn get_tx(Path(txid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    match st.engine.ledger().get_tx_height(&txid).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        Some(h) => Ok(Json(serde_json::json!({ "tx_id": txid, "height": h }))),
        None => Err(StatusCode::NOT_FOUND),
    }
}

/* детальный ответ по tx (блок целиком) */
#[derive(Serialize)] pub struct TxFull { pub tx_id:String, pub height:u64, pub block:serde_json::Value, pub found:bool }
pub async fn get_tx_full(Path(txid): Path<String>, Extension(st): Extension<AppState>)
-> Result<Json<TxFull>, StatusCode> {
    match st.engine.ledger().get_tx_height(&txid).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)? {
        Some(h) => {
            let blk = st.engine.ledger().get_block_by_height(h).map_err(|_| StatusCode::NOT_FOUND)?;
            let blk_json = serde_json::to_value(&blk).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
            Ok(Json(TxFull{ tx_id: txid, height: h, block: blk_json, found:true }))
        }
        None => Ok(Json(TxFull{ tx_id: txid, height: 0, block: serde_json::json!({}), found:false })),
    }
}

/* ---------- история аккаунта (пагинация курсором) ---------- */
#[derive(Serialize)] pub struct AccountTxsPage {
    pub rid:String, pub limit:usize, pub items:Vec<serde_json::Value>,
    pub next_cursor_h: Option<u64>, pub next_cursor_seq: Option<u32>
}
pub async fn account_txs(
    Path(rid_s): Path<String>,
    Query(q): Query<HashMap<String,String>>,
    Extension(st): Extension<AppState>
) -> Result<Json<AccountTxsPage>, StatusCode> {
    let rid = Rid(rid_s);
    let limit = q.get("limit").and_then(|s| s.parse::<usize>().ok()).unwrap_or(100);
    let ch = q.get("cursor_h").and_then(|s| s.parse::<u64>().ok());
    let cs = q.get("cursor_seq").and_then(|s| s.parse::<u32>().ok());
    let (items, next_h, next_s) = st.engine.ledger().list_account_txs_page(&rid, ch, cs, limit)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(AccountTxsPage{
        rid: rid.as_str().to_string(), limit, items,
        next_cursor_h: next_h, next_cursor_seq: next_s
    }))
}

/* ---------- эксплорер (последние блоки/tx) ---------- */
#[derive(Serialize)] pub struct RecentBlocks { pub items: Vec<serde_json::Value> }
pub async fn recent_blocks(Extension(st): Extension<AppState>, Query(q): Query<HashMap<String,String>>)
-> Result<Json<RecentBlocks>, StatusCode> {
    let limit = q.get("limit").and_then(|s| s.parse::<u64>().ok()).unwrap_or(20);
    let (mut h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut out = Vec::new();
    for _ in 0..limit {
        if h == 0 { break; }
        if let Ok(b) = st.engine.ledger().get_block_by_height(h) {
            out.push(serde_json::to_value(b).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?);
        }
        if h == 0 { break; }
        h -= 1;
    }
    Ok(Json(RecentBlocks{ items: out }))
}

#[derive(Serialize)] pub struct RecentTxs { pub items: Vec<serde_json::Value> }
pub async fn recent_txs(Extension(st): Extension<AppState>, Query(q): Query<HashMap<String,String>>)
-> Result<Json<RecentTxs>, StatusCode> {
    let limit = q.get("limit").and_then(|s| s.parse::<usize>().ok()).unwrap_or(50);
    let (mut h, _) = st.engine.ledger().head().map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    let mut out = Vec::new();
    while out.len() < limit && h > 0 {
        if let Ok(b) = st.engine.ledger().get_block_by_height(h) {
            for tx in b.txs.iter().rev() {
                if out.len() >= limit { break; }
                out.push(serde_json::json!({"height": b.height, "tx_id": tx.id, "from": tx.from.0, "to": tx.to.0, "amount": tx.amount}));
            }
        }
        if h == 0 { break; }
        h -= 1;
    }
    Ok(Json(RecentTxs{ items: out }))
}

/* ---------- DEV faucet ---------- */
#[allow(dead_code)]
pub async fn faucet(Path((rid_s,amount_s)):Path<(String,String)>, Extension(st):Extension<AppState>)
-> Result<Json<serde_json::Value>, StatusCode> {
    if !st.dev_mode { return Err(StatusCode::FORBIDDEN); }
    let rid = Rid(rid_s); let amount:u64 = amount_s.parse().map_err(|_| StatusCode::BAD_REQUEST)?;
    let cur = st.engine.ledger().get_balance(&rid); let newb = cur.saturating_add(amount);
    st.engine.ledger().set_balance(&rid, newb).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true, "rid": rid.as_str(), "balance": newb })))
}

```


## FILE: node/src/auth.rs  (size=5131b)
```text
// node/src/auth.rs
use axum::http::{HeaderMap, StatusCode};
use jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};
use serde::{Deserialize, Serialize};
use std::net::IpAddr;
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Deserialize)]
struct Claims {
    exp: i64,
    sub: Option<String>,
    iat: Option<i64>,
}

// ------------ time ------------
fn now_ts() -> i64 {
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
}

// ------------ helpers ------------
fn header_value(headers: &HeaderMap, name: &str) -> Option<String> {
    headers.get(name).and_then(|v| v.to_str().ok()).map(|s| s.trim().to_string())
}

fn header_or_bearer(headers: &HeaderMap, primary_header: &str) -> Option<String> {
    if let Some(v) = header_value(headers, primary_header) {
        if !v.is_empty() { return Some(v); }
    }
    if let Some(v) = header_value(headers, "authorization") {
        if let Some(rest) = v.strip_prefix("Bearer ") {
            let t = rest.trim();
            if !t.is_empty() { return Some(t.to_string()); }
        }
    }
    None
}

/// Простейший IP-ACL: LRB_ADMIN_IP_ALLOW="1.2.3.4,10.0.0.0/8"
fn ip_acl_allows(ip: Option<IpAddr>, env_key: &str) -> bool {
    let allow = std::env::var(env_key).unwrap_or_default();
    if allow.trim().is_empty() { return true; }
    let rules: Vec<&str> = allow.split(',').map(|s| s.trim()).filter(|s| !s.is_empty()).collect();
    if rules.is_empty() { return true; }
    if let Some(client) = ip {
        for r in rules {
            if let Ok(one) = r.parse::<IpAddr>() {
                if one == client { return true; }
            } else if let Some((net, bits)) = r.split_once('/') {
                if let (Ok(nip), Ok(b)) = (net.parse::<IpAddr>(), bits.parse::<u8>()) {
                    if let (IpAddr::V4(a), IpAddr::V4(n)) = (client, nip) {
                        let mask: u32 = if b == 0 { 0 } else { (!0u32) << (32 - b as u32) };
                        if (u32::from(a) & mask) == (u32::from(n) & mask) { return true; }
                    }
                }
            }
        }
        false
    } else { false }
}

// ------------ публичные проверки ------------

/// Админ-доступ:
/// 1) если задан нормальный LRB_ADMIN_KEY — принимаем X-Admin-Key (приоритетно)
/// 2) если задан LRB_ADMIN_JWT_SECRET — принимаем JWT (X-Admin-Key или Authorization: Bearer)
/// 3) IP-ACL: LRB_ADMIN_IP_ALLOW (пусто = разрешить всем)
pub fn require_admin(headers: &HeaderMap, remote_ip: Option<IpAddr>) -> Result<(), StatusCode> {
    if !ip_acl_allows(remote_ip, "LRB_ADMIN_IP_ALLOW") {
        return Err(StatusCode::UNAUTHORIZED);
    }

    // статический ключ (удобно для таймеров/автоматизаций)
    if let Ok(k) = std::env::var("LRB_ADMIN_KEY") {
        let k = k.trim();
        if !k.is_empty() && k != "CHANGE_ADMIN_KEY" {
            if let Some(presented) = header_or_bearer(headers, "X-Admin-Key") {
                if presented == k { return Ok(()); }
            }
        }
    }

    // JWT HS256
    if let Ok(secret) = std::env::var("LRB_ADMIN_JWT_SECRET") {
        let secret = secret.trim();
        if !secret.is_empty() {
            if let Some(tok) = header_or_bearer(headers, "X-Admin-Key") {
                if let Ok(data) = decode::<Claims>(
                    &tok,
                    &DecodingKey::from_secret(secret.as_bytes()),
                    &Validation::new(Algorithm::HS256),
                ) {
                    if data.claims.exp > now_ts() { return Ok(()); }
                }
            }
            return Err(StatusCode::UNAUTHORIZED);
        }
    }

    Err(StatusCode::UNAUTHORIZED)
}

/// Доступ к мосту: LRB_BRIDGE_KEY в X-Bridge-Key или Authorization: Bearer <key>
pub fn require_bridge(headers: &HeaderMap) -> Result<(), StatusCode> {
    let k = std::env::var("LRB_BRIDGE_KEY").unwrap_or_default();
    let k = k.trim();
    if k.is_empty() || k == "CHANGE_ME" { return Err(StatusCode::UNAUTHORIZED); }

    if let Some(presented) = header_or_bearer(headers, "X-Bridge-Key") {
        if presented == k { return Ok(()); }
    }
    if let Some(bearer) = header_or_bearer(headers, "Authorization") {
        if bearer == k { return Ok(()); }
    }
    Err(StatusCode::UNAUTHORIZED)
}

// ------------ JWT minting (для /admin/token) ------------
#[derive(Serialize)]
struct ClaimsOut { sub: String, exp: i64, iat: i64 }

/// Выпуск JWT (HS256) c TTL (сек): возвращает строку токена.
pub fn mint_jwt(secret: &str, sub: &str, ttl_secs: i64) -> Result<String, StatusCode> {
    if ttl_secs <= 0 { return Err(StatusCode::BAD_REQUEST); }
    let now = now_ts();
    let claims = ClaimsOut { sub: sub.to_string(), iat: now, exp: now + ttl_secs };
    encode(&Header::default(), &claims, &EncodingKey::from_secret(secret.as_bytes()))
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)
}

```


## FILE: node/src/bridge.rs  (size=3607b)
```text
use axum::{extract::Extension, Json};
use axum::http::{StatusCode, HeaderMap};
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signer, Verifier, VerifyingKey};
use serde::{Deserialize, Serialize};
use crate::state::{AppState, BR_DEPOSIT, BR_REDEEM, now_ms};
use crate::auth;

#[derive(Deserialize)] pub struct DepositReq { pub rid:String, pub amount:u64, pub ext_txid:String }
#[derive(Serialize)]   pub struct DepositResp { pub ok:bool, pub rid:String, pub r_balance:u64 }
#[derive(Deserialize)] pub struct RedeemReq { pub rid:String, pub amount:u64, pub request_id:String }
#[derive(Serialize)]   pub struct RedeemResp { pub ok:bool, pub rid:String, pub r_balance:u64, pub redeem_ticket:String, pub signature_b64:String }
#[derive(Deserialize)] pub struct VerifyReq { pub ticket:String, pub signature_b64:String, pub vk_b58:String }
#[derive(Serialize)]   pub struct VerifyResp { pub ok:bool }

pub async fn deposit(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<DepositReq>)
-> Result<Json<DepositResp>, StatusCode> {
    if !st.rl_bridge.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    auth::require_bridge(&headers)?;  // IP ACL / JWT / key

    if req.amount == 0 || req.amount > st.bridge_max_per_tx { return Err(StatusCode::BAD_REQUEST); }
    let rk = format!("dep:{}", req.ext_txid);
    if !st.replay_bridge.check_and_note(rk.clone(), now_ms()) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    if let Ok(false) = st.engine.ledger().bridge_seen_mark(&rk) { return Err(StatusCode::CONFLICT); }

    let rid = lrb_core::Rid(req.rid.clone());
    let newb = st.engine.ledger().mint_rtoken(&rid, req.amount).map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    BR_DEPOSIT.inc();
    Ok(Json(DepositResp { ok:true, rid: rid.as_str().to_string(), r_balance: newb }))
}

pub async fn redeem(Extension(st): Extension<AppState>, headers: HeaderMap, Json(req): Json<RedeemReq>)
-> Result<Json<RedeemResp>, StatusCode> {
    if !st.rl_bridge.try_take(1) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    auth::require_bridge(&headers)?; // IP ACL / JWT / key

    if req.amount == 0 || req.amount > st.bridge_max_per_tx { return Err(StatusCode::BAD_REQUEST); }
    let rk = format!("red:{}", req.request_id);
    if !st.replay_bridge.check_and_note(rk.clone(), now_ms()) { return Err(StatusCode::TOO_MANY_REQUESTS); }
    if let Ok(false) = st.engine.ledger().bridge_seen_mark(&rk) { return Err(StatusCode::CONFLICT); }

    let rid = lrb_core::Rid(req.rid.clone());
    let newb = st.engine.ledger().burn_rtoken(&rid, req.amount).map_err(|_| StatusCode::BAD_REQUEST)?;
    BR_REDEEM.inc();

    let ticket = format!("redeem:{}:{}:{}", rid.as_str(), req.amount, req.request_id);
    let sig = st.sk.sign(ticket.as_bytes());
    let signature_b64 = B64.encode(sig.to_bytes());
    Ok(Json(RedeemResp { ok:true, rid: rid.as_str().to_string(), r_balance: newb, redeem_ticket: ticket, signature_b64 }))
}

pub async fn verify(Json(req): Json<VerifyReq>) -> Result<Json<VerifyResp>, StatusCode> {
    let pk_bytes = bs58::decode(&req.vk_b58).into_vec().map_err(|_| StatusCode::BAD_REQUEST)?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| StatusCode::BAD_REQUEST)?).map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig_bytes = B64.decode(req.signature_b64.as_bytes()).map_err(|_| StatusCode::BAD_REQUEST)?;
    let sig = ed25519_dalek::Signature::from_bytes(&sig_bytes.try_into().map_err(|_| StatusCode::BAD_REQUEST)?);
    Ok(Json(VerifyResp { ok: vk.verify(req.ticket.as_bytes(), &sig).is_ok() }))
}

```


## FILE: node/src/fork.rs  (size=429b)
```text
use anyhow::Result;
use lrb_core::Block;
use crate::state::AppState;

/// Временная реализация: делаем вид, что реорг не требуется.
/// Когда включим полноценный fork-choice, сюда добавим сравнение sigma/weight.
pub fn apply_or_reorg_deep(_st: &AppState, _incoming: &Block, _sigma_hex: &str, _prev_hash: &str) -> Result<()> {
    Ok(())
}

```


## FILE: node/src/gossip.rs  (size=5147b)
```text
use anyhow::Result;
use axum::{extract::Extension, Json};
use axum::http::StatusCode;
use base64::engine::general_purpose::STANDARD as B64;
use base64::Engine;
use ed25519_dalek::{Signature, Verifier, Signer, VerifyingKey};
use serde::{Deserialize, Serialize};
use lrb_core::{Block, resonance, phase_filters::block_passes_phase};
use crate::state::{AppState, now_ms, GOSSIP_BLK_SENT, GOSSIP_BLK_RECV, GOSSIP_VOTE_SENT, GOSSIP_VOTE_RECV, CONS_VOTES, PHASE_BLOCK_ACCEPTED, PHASE_BLOCK_REJECTED};

#[derive(Serialize, Deserialize, Clone)]
pub struct GossipHeader { pub height:u64, pub prev_hash:String, pub block_hash:String, pub proposer_rid:String, pub timestamp_ms:u128, pub sigma_hex:String }
#[derive(Serialize, Deserialize, Clone)]
pub struct GossipBlockMsg { pub header:GossipHeader, pub block:Block, pub sender_pk_b58:String, pub sig_b64:String, pub nonce_ms:u128 }
#[derive(Serialize, Deserialize, Clone)]
pub struct VoteMsg { pub height:u64, pub block_hash:String, pub sigma_hex:String, pub voter_pk_b58:String, pub sig_b64:String, pub nonce_ms:u128 }

fn verify_gossip_sig(msg: &GossipBlockMsg) -> Result<()> {
    let pk_bytes = bs58::decode(&msg.sender_pk_b58).into_vec()?;
    let vk = VerifyingKey::from_bytes(&pk_bytes.try_into().map_err(|_| anyhow::anyhow!("bad pk"))?)?;
    let sig_bytes = B64.decode(msg.sig_b64.as_bytes())?;
    let sig = Signature::from_bytes(&sig_bytes.try_into().map_err(|_| anyhow::anyhow!("bad sig"))?);
    let mut payload = Vec::new();
    payload.extend_from_slice(msg.header.sigma_hex.as_bytes());
    payload.extend_from_slice(msg.header.block_hash.as_bytes());
    payload.extend_from_slice(&msg.nonce_ms.to_le_bytes());
    vk.verify(&payload, &sig).map_err(|e| anyhow::anyhow!("verify failed: {e}"))?;
    Ok(())
}

pub async fn send_block(peers:&[String], st:&AppState, block:&Block) {
    let sigma_hex = resonance::sigma_digest_block_hex(block);
    let nonce_ms = now_ms();
    let mut pl = Vec::new();
    pl.extend_from_slice(sigma_hex.as_bytes());
    pl.extend_from_slice(block.block_hash.as_bytes());
    pl.extend_from_slice(&nonce_ms.to_le_bytes());
    let sig_b64 = B64.encode(st.sk.sign(&pl).to_bytes());
    let header = GossipHeader {
        height:block.height, prev_hash:block.prev_hash.clone(), block_hash:block.block_hash.clone(),
        proposer_rid:block.proposer.0.clone(), timestamp_ms:block.timestamp_ms, sigma_hex:sigma_hex.clone()
    };
    let msg = GossipBlockMsg {
        header, block:block.clone(),
        sender_pk_b58: bs58::encode(st.self_vk.to_bytes()).into_string(),
        sig_b64, nonce_ms
    };
    for p in peers {
        let _ = st.http.post(&format!("{}/gossip/block", p.trim_end_matches('/'))).json(&msg).send().await;
        GOSSIP_BLK_SENT.inc();
    }

    let vote_nonce = now_ms();
    let mut pv = Vec::new();
    pv.extend_from_slice(sigma_hex.as_bytes());
    pv.extend_from_slice(block.block_hash.as_bytes());
    pv.extend_from_slice(&block.height.to_le_bytes());
    pv.extend_from_slice(&vote_nonce.to_le_bytes());
    let vote_sig_b64 = B64.encode(st.sk.sign(&pv).to_bytes());
    let vmsg = VoteMsg {
        height:block.height, block_hash:block.block_hash.clone(), sigma_hex: sigma_hex.clone(),
        voter_pk_b58: bs58::encode(st.self_vk.to_bytes()).into_string(), sig_b64: vote_sig_b64, nonce_ms: vote_nonce
    };
    for p in peers { let _ = st.http.post(&format!("{}/gossip/vote", p.trim_end_matches('/'))).json(&vmsg).send().await; GOSSIP_VOTE_SENT.inc(); }
}

pub async fn gossip_block(Extension(st): Extension<AppState>, Json(msg): Json<GossipBlockMsg>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    GOSSIP_BLK_RECV.inc();

    let local_sigma = resonance::sigma_digest_block_hex(&msg.block);
    if local_sigma != msg.header.sigma_hex { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    if verify_gossip_sig(&msg).is_err() { return Err(StatusCode::UNPROCESSABLE_ENTITY); }

    // фазовый фильтр: блоки вне фазы не принимаем
    if !block_passes_phase(&msg.block) {
        PHASE_BLOCK_REJECTED.inc();
        return Err(StatusCode::UNPROCESSABLE_ENTITY);
    }
    PHASE_BLOCK_ACCEPTED.inc();

    crate::fork::apply_or_reorg_deep(&st, &msg.block, &msg.header.sigma_hex, &msg.header.prev_hash)
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    Ok(Json(serde_json::json!({"ok": true})))
}

pub async fn gossip_vote(Extension(st): Extension<AppState>, Json(v): Json<VoteMsg>)
-> Result<Json<serde_json::value::Value>, StatusCode> {
    if !st.validators.is_empty() && !st.validators.contains(&v.voter_pk_b58) { return Err(StatusCode::FORBIDDEN); }
    GOSSIP_VOTE_RECV.inc();
    let vv = lrb_core::quorum::Vote {
        height: v.height, block_hash: v.block_hash.clone(), sigma_hex: v.sigma_hex.clone(),
        voter_pk_b58: v.voter_pk_b58.clone(), sig_b64: v.sig_b64.clone(), nonce_ms: v.nonce_ms
    };
    if let Err(_) = lrb_core::quorum::verify_vote(&vv) { return Err(StatusCode::UNPROCESSABLE_ENTITY); }
    if st.engine.register_vote(v.height, &v.block_hash, &v.voter_pk_b58) { CONS_VOTES.inc(); }
    Ok(Json(serde_json::json!({"ok": true})))
}

```


## FILE: node/src/main.rs  (size=5036b)
```text
// node/src/main.rs — прод-роутер с историей/индексами и базовой инициализацией
mod bridge;
mod admin;
mod fork;
mod state;
mod gossip;
mod metrics;
mod api;
mod peers;

use anyhow::Result;
use axum::{
    extract::DefaultBodyLimit,
    routing::{get, post},
    Extension, Router,
};
use std::{env, net::SocketAddr, time::Duration};
use tokio::{signal, time::interval};

use lrb_core::*;
use crate::state::AppState;

#[tokio::main]
async fn main() -> Result<()> {
    // --------- инициализация ключей/ledger/engine ----------
    // Ключи/ledger/engine инициализируй так, как у тебя уже сделано — здесь оставляем существующую логику.
    // Ниже только минимальные обязательные шаги, чтобы не поломать твой запуск.

    // Открываем базу
    let data_path = env::var("LRB_DATA_PATH").unwrap_or_else(|_| "/var/lib/logos/data.sled".to_string());
    let ledger = Ledger::open(&data_path)?;

    // ИНИЦИАЛИЗАЦИЯ ENGINE — используй фактическую функцию/конструктор, которая уже есть у тебя:
    // предположим у тебя есть что-то вроде: let (engine, _mp) = engine_with_channels(ledger, self_rid.clone());
    // Здесь для совместимости:
    let (engine, _mp) = {
        // В твоём коде уже есть построение self_rid / ключей — оставь его.
        // Ниже упрощённый вызов: если у тебя другой — подставь свой.
        let dummy_rid = Rid("DUMMY_RID".to_string());
        engine_with_channels(ledger, dummy_rid)
    };

    // Запуск block producer (оставляем как в твоём коде)
    {
        let eng = engine.clone();
        tokio::spawn(async move {
            let _ = eng.run_block_producer().await;
        });
    }

    // Собираем AppState из твоей реализации
    let st = AppState::new_for_router(engine.clone())?;

    // --------- Роуты (все действующие + история/индексы) ----------
    let mut app = Router::new()
        // базовые
        .route("/healthz", get(api::healthz))
        .route("/head",    get(api::head))
        .route("/balance/:rid", get(api::balance))
        .route("/account/:rid/state", get(api::account_state))
        // отправка транзакций
        .route("/submit_tx",        post(api::submit_tx))
        .route("/submit_tx_batch",  post(api::submit_tx_batch))
        // отладка канона/подписи
        .route("/debug_canon", post(api::debug_canon))
        // faucet (DEV)
        .route("/faucet/:rid/:amount", post(api::faucet))
        // мост
        .route("/bridge/deposit", post(api::bridge_deposit))
        .route("/bridge/redeem",  post(api::bridge_redeem))
        .route("/bridge/verify",  post(api::bridge_verify))
        // админка
        .route("/admin/snapshot",      get(api::snapshot))
        .route("/admin/snapshot-file", get(api::snapshot_file))
        .route("/admin/restore",       post(api::restore))
        .route("/admin/token",         get(api::admin_token))
        .route("/node/info",           get(api::node_info))
        // НОВОЕ: история/индексы
        .route("/block/:height", get(api::get_block))
        .route("/tx/:id",        get(api::get_tx))
        .route("/account/:rid/txs", get(api::account_txs))
        // лимит тела (предохраняемся от больших batch’ей)
        .layer(DefaultBodyLimit::max(64 * 1024))
        .layer(Extension(st.clone()));

    // Фоновая метрика — обновляем chain_height/mempool_len периодически (если у тебя уже есть — оставь свою)
    {
        let stc = st.clone();
        tokio::spawn(async move {
            let mut t = interval(Duration::from_millis(500));
            loop {
                t.tick().await;
                if let Ok((h, _)) = stc.engine.ledger().head() {
                    crate::state::HEIGHT_GAUGE.set(h as i64);
                }
                if let Ok(f) = stc.engine.ledger().get_finalized() {
                    crate::state::FINAL_GAUGE.set(f as i64);
                }
                crate::state::MEMPOOL_GAUGE.set(stc.engine.mempool_len() as i64);
            }
        });
    }

    // --------- запуск сервера ----------
    let addr: SocketAddr = "0.0.0.0:8080".parse().unwrap();
    println!("LOGOS LRB node listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(async {
            let _ = signal::ctrl_c().await;
            eprintln!("shutdown...");
        })
        .await?;

    Ok(())
}

```


## FILE: node/src/metrics.rs  (size=498b)
```text
use axum::http::{HeaderMap, HeaderValue};
use prometheus::{Encoder, TextEncoder};

pub async fn metrics_handler() -> (HeaderMap, Vec<u8>) {
    let mut buffer = Vec::<u8>::new();
    let encoder = TextEncoder::new();
    let metric_families = prometheus::gather();
    encoder.encode(&metric_families, &mut buffer).unwrap();
    let mut headers = HeaderMap::new();
    headers.insert(axum::http::header::CONTENT_TYPE, HeaderValue::from_static("text/plain; version=0.0.4"));
    (headers, buffer)
}

```


## FILE: node/src/peers.rs  (size=4411b)
```text
use crate::state::now_ms;
use once_cell::sync::Lazy;
use prometheus::{register_int_gauge, IntGauge};
use std::{collections::HashMap, sync::{Arc, Mutex}, time::Duration};

static QUARANTINED_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_quarantined", "quarantined peers").unwrap());
static PEERS_TOTAL_GAUGE: Lazy<IntGauge> =
    Lazy::new(|| register_int_gauge!("peers_total", "known peers").unwrap());

#[derive(Clone, Debug)]
pub struct PeerScore {
    pub last_seen_ms: u128,
    pub score_milli: i64,
    pub fails: u32,
    pub dups: u32,
    pub banned_until_ms: u128,
}
impl Default for PeerScore {
    fn default() -> Self {
        Self { last_seen_ms: now_ms(), score_milli: 0, fails: 0, dups: 0, banned_until_ms: 0 }
    }
}

/// Резонансные параметры скоринга
#[derive(Clone)]
pub struct PeerPolicy {
    pub ban_ttl_ms: u128,
    pub decay_ms: u128,
    pub up_tick: i64,
    pub dup_penalty: i64,
    pub invalid_penalty: i64,
    pub ban_threshold_milli: i64,
    pub unban_threshold_milli: i64,
}
impl Default for PeerPolicy {
    fn default() -> Self {
        Self {
            ban_ttl_ms: 60_000,    // 60s карантин
            decay_ms: 10_000,      // каждые 10s подплытие к 0
            up_tick: 150,          // успешный блок/голос +0.150
            dup_penalty: -50,      // дубликат −0.050
            invalid_penalty: -500, // невалидное сообщение −0.500
            ban_threshold_milli: -1500,
            unban_threshold_milli: -300,
        }
    }
}

#[derive(Clone)]
pub struct PeerBook {
    inner: Arc<Mutex<HashMap<String, PeerScore>>>, // pk_b58 -> score
    policy: PeerPolicy,
}
impl PeerBook {
    pub fn new(policy: PeerPolicy) -> Self { Self { inner: Arc::new(Mutex::new(HashMap::new())), policy } }
    fn entry_mut(&self, _pk: &str) -> std::sync::MutexGuard<'_, HashMap<String, PeerScore>> { self.inner.lock().unwrap() }

    pub fn on_success(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.last_seen_ms = now_ms();
        s.score_milli += self.policy.up_tick;
        if s.score_milli > 5000 { s.score_milli = 5000; }
    }
    pub fn on_duplicate(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.dups += 1;
        s.score_milli += self.policy.dup_penalty;
        if s.score_milli < self.policy.ban_threshold_milli { s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms; }
    }
    pub fn on_invalid(&self, pk: &str) {
        let mut m = self.entry_mut(pk);
        let s = m.entry(pk.to_string()).or_default();
        s.fails += 1;
        s.score_milli += self.policy.invalid_penalty;
        s.banned_until_ms = now_ms() + self.policy.ban_ttl_ms;
    }
    pub fn is_quarantined(&self, pk: &str) -> bool {
        let m = self.inner.lock().unwrap();
        m.get(pk).map(|s| now_ms() < s.banned_until_ms).unwrap_or(false)
    }
    pub fn tick(&self) {
        let mut m = self.inner.lock().unwrap();
        let now = now_ms();
        let mut banned = 0;
        for (_k, s) in m.iter_mut() {
            // decay к 0
            if s.score_milli < 0 {
                let dt = (now.saturating_sub(s.last_seen_ms)) as i128;
                if dt > 0 {
                    let steps = (dt as f64 / self.policy.decay_ms as f64).floor() as i64;
                    if steps > 0 {
                        s.score_milli += steps * 50; // +0.050/шаг
                        if s.score_milli > 0 { s.score_milli = 0; }
                        s.last_seen_ms = now;
                    }
                }
            }
            // снять бан, если вышли из «красной зоны»
            if s.banned_until_ms > 0
                && now >= s.banned_until_ms
                && s.score_milli > self.policy.unban_threshold_milli
            {
                s.banned_until_ms = 0;
            }
            if s.banned_until_ms > now { banned += 1; }
        }
        QUARANTINED_GAUGE.set(banned);
        PEERS_TOTAL_GAUGE.set(m.len() as i64);
    }
}
pub fn spawn_peer_aging(book: PeerBook) {
    tokio::spawn(async move {
        let mut t = tokio::time::interval(Duration::from_millis(2000));
        loop { t.tick().await; book.tick(); }
    });
}

```


## FILE: node/src/state.rs  (size=5557b)
```text
use std::{collections::{HashMap, HashSet}, sync::{Arc, Mutex}, time::{SystemTime, UNIX_EPOCH}};
use ed25519_dalek::{SigningKey, VerifyingKey};
use once_cell::sync::Lazy;
use prometheus::{register_histogram, register_int_counter, register_int_gauge, Histogram, IntCounter, IntGauge};
use reqwest::Client;
use lrb_core::Engine;

pub fn now_ms() -> u128 { SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_millis() }

/* ---- метрики (как у тебя) ---- */
pub static TX_SUBMITTED:    Lazy<IntCounter> = Lazy::new(|| register_int_counter!("tx_submitted_total","submitted tx").unwrap());
pub static TX_APPLIED:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("tx_applied_total",  "applied tx").unwrap());
pub static GOSSIP_BLK_SENT: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_block_sent_total","gossip blocks sent").unwrap());
pub static GOSSIP_BLK_RECV: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_block_recv_total","gossip blocks recv").unwrap());
pub static GOSSIP_VOTE_SENT:Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_vote_sent_total","gossip votes sent").unwrap());
pub static GOSSIP_VOTE_RECV:Lazy<IntCounter> = Lazy::new(|| register_int_counter!("gossip_vote_recv_total","gossip votes recv").unwrap());
pub static CONS_VOTES:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("consensus_votes_total","accepted consensus votes").unwrap());
pub static HEIGHT_GAUGE:    Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("chain_height","current height").unwrap());
pub static FINAL_GAUGE:     Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("chain_finalized","finalized height").unwrap());
pub static MEMPOOL_GAUGE:   Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("mempool_len","mempool length").unwrap());
pub static SLOT_TXS_GAUGE:  Lazy<IntGauge>   = Lazy::new(|| register_int_gauge!("slot_tx_count","tx in last committed block").unwrap());
pub static BR_DEPOSIT:      Lazy<IntCounter> = Lazy::new(|| register_int_counter!("bridge_deposit_total","bridge deposits").unwrap());
pub static BR_REDEEM:       Lazy<IntCounter> = Lazy::new(|| register_int_counter!("bridge_redeem_total","bridge redeems").unwrap());
pub static PHASE_BLOCK_ACCEPTED: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("phase_block_accepted_total","blocks passed phase filter").unwrap());
pub static PHASE_BLOCK_REJECTED: Lazy<IntCounter> = Lazy::new(|| register_int_counter!("phase_block_rejected_total","blocks rejected by phase filter").unwrap());
pub static SLOT_LAT_HIST:   Lazy<Histogram>  = Lazy::new(|| {
    register_histogram!("slot_latency_ms_hist","slot latency histogram (ms)",
        vec![10.0,25.0,50.0,100.0,250.0,500.0,750.0,1000.0,1500.0,2000.0,3000.0]).unwrap()
});
pub static SLOT_TXS_HIST:   Lazy<Histogram>  = Lazy::new(|| {
    register_histogram!("slot_tx_count_hist","tx per block histogram",
        vec![10.0,50.0,100.0,500.0,1000.0,2000.0,5000.0,10000.0,20000.0]).unwrap()
});

/* ---- Anti-replay окно ---- */
#[derive(Default, Clone)]
pub struct ReplayWindow {
    map: Arc<Mutex<HashMap<String,u128>>>,
    pub ttl_ms: u128,
    pub max_items: usize,
}
impl ReplayWindow {
    pub fn new(ttl_ms: u128, max_items: usize) -> Self { Self { map: Arc::new(Mutex::new(HashMap::new())), ttl_ms, max_items } }
    pub fn check_and_note(&self, key: String, ts_ms: u128) -> bool {
        let mut m = self.map.lock().unwrap();
        if m.len() > self.max_items {
            let cutoff = now_ms().saturating_sub(self.ttl_ms);
            m.retain(|_, &mut t| t >= cutoff);
        }
        if let Some(prev) = m.get(&key) { if ts_ms <= *prev + self.ttl_ms { return false; } }
        m.insert(key, ts_ms);
        true
    }
}

/* ---- Токен-бакет ---- */
#[derive(Clone)]
pub struct TokenBucket { inner: Arc<Mutex<BucketInner>>, }
#[derive(Debug)]
struct BucketInner { capacity:u64, tokens:u64, refill_per_ms:f64, last_ms:u128 }
impl TokenBucket {
    pub fn new(capacity:u64, refill_per_sec:u64) -> Self {
        let now = now_ms();
        Self { inner: Arc::new(Mutex::new(BucketInner{
            capacity, tokens: capacity, refill_per_ms: refill_per_sec as f64 / 1000.0, last_ms: now
        })) }
    }
    pub fn try_take(&self, n:u64) -> bool {
        let now = now_ms();
        let mut b = self.inner.lock().unwrap();
        let elapsed = (now - b.last_ms) as f64;
        let refill = (elapsed * b.refill_per_ms) as u64;
        if refill > 0 { b.tokens = (b.tokens + refill).min(b.capacity); b.last_ms = now; }
        if b.tokens >= n { b.tokens -= n; true } else { false }
    }
}

/* ---- AppState ---- */
#[derive(Clone)]
pub struct AppState {
    pub engine: Arc<Engine>,
    pub http: Client,
    pub dev_mode: bool,
    pub peers: Vec<String>,

    pub self_vk: VerifyingKey,
    pub sk: Arc<SigningKey>,

    // gossip/кворум
    pub seen_blocks: Arc<Mutex<HashSet<String>>>,
    pub vote_seen: Arc<Mutex<HashSet<String>>>,
    pub vote_tally: Arc<Mutex<HashMap<(u64,String), HashSet<String>>>>,
    pub validators: Arc<HashSet<String>>,
    pub quorum_n: usize,

    // anti-replay
    pub replay_blk: ReplayWindow,
    pub replay_vote: ReplayWindow,

    // rate-limit
    pub rl_submit: TokenBucket,
    pub rl_admin:  TokenBucket,     // NEW: лимит на админ-ручки

    // peer scoring
    pub peerbook: crate::peers::PeerBook,

    // bridge
    pub rl_bridge: TokenBucket,
    pub replay_bridge: ReplayWindow,
    pub bridge_max_per_tx: u64,
    pub bridge_key: Option<String>,
}

```


## FILE: src/bin/ai_signal_listener.rs  (size=8704b)
```text

// LOGOS AI Signal Listener — приём внешних импульсов
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::{Read, Write};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use std::thread;
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use ring::rand::{SystemRandom, SecureRandom};
use serde_json;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncomingSignal {
    pub source: String,
    pub symbol: String,
    pub intensity: f64,
    pub frequency: f64,
    pub timestamp: u64,
}

pub struct AISignalListener {
    pub accepted_symbols: HashSet<String>,
    pub last_received: Arc<Mutex<HashMap<String, u64>>>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub nonce_source: SystemRandom,
    pub min_interval: u64,
    pub lambda_zero: String,
}

impl AISignalListener {
    pub fn new() -> Self {
        let mut key = vec![0u8; 32];
        let rng = SystemRandom::new();
        rng.fill(&mut key).unwrap();

        let mut accepted = HashSet::new();
        accepted.insert("Λ0".to_string());
        accepted.insert("☉".to_string());
        accepted.insert("??".to_string());
        accepted.insert("♁".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("??".to_string());
        accepted.insert("∞".to_string());

        AISignalListener {
            accepted_symbols: accepted,
            last_received: Arc::new(Mutex::new(HashMap::new())),
            log_file: "ai_signal_log.enc".to_string(),
            state_file: "ai_signal_state.enc".to_string(),
            cipher_key: key,
            nonce_source: rng,
            min_interval: 1, // 1 секунда
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn validate_signal(&self, signal: &IncomingSignal) -> bool {
        !signal.source.is_empty() &&
        self.accepted_symbols.contains(&signal.symbol) &&
        (0.0..=1.0).contains(&signal.intensity) &&
        (0.1..=10000.0).contains(&signal.frequency) &&
        signal.timestamp > 0
    }

    pub fn handle(&self, signal: IncomingSignal) -> bool {
        let now = Self::now();

        // Проверка частоты приёма
        let mut last = self.last_received.lock().unwrap();
        let last_time = last.get(&signal.source).cloned().unwrap_or(0);
        let adjusted_interval = if signal.symbol == self.lambda_zero {
            self.min_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_interval
        };
        if now - last_time < adjusted_interval {
            self.log(&format!("[DROP] Слишком частый сигнал от {}", signal.source));
            return false;
        }

        // Валидация сигнала
        if !self.validate_signal(&signal) {
            self.log(&format!("[DROP] Неверный сигнал от {}: symbol={}, intensity={:.2}, freq={:.2}",
                signal.source, signal.symbol, signal.intensity, signal.frequency));
            return false;
        }

        // Проверка через resonance_analyzer (заглушка)
        if !self.validate_with_analyzer(&signal) {
            self.log(&format!("[DROP] Analyzer отклонил сигнал от {}", signal.source));
            return false;
        }

        last.insert(signal.source.clone(), now);
        self.save_state();
        self.log_signal(&signal);
        true
    }

    fn validate_with_analyzer(&self, signal: &IncomingSignal) -> bool {
        // Заглушка для resonance_analyzer.py
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.1
    }

    fn log_signal(&self, signal: &IncomingSignal) {
        let json = serde_json::to_string(signal).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = json.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn log(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"ai_signal_listener\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = entry.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(&self.log_file) {
            let _ = file.write_all(&data);
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&*self.last_received.lock().unwrap()).unwrap_or_default();
        let mut nonce_bytes = [0u8; 12];
        self.nonce_source.fill(&mut nonce_bytes).unwrap();
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);
        let unbound_key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(unbound_key);
        let mut data = state.as_bytes().to_vec();
        key.seal_in_place_append_tag(nonce, Aad::empty(), &mut data).unwrap();
        if let Ok(mut file) = OpenOptions::new().create(true).write(true).truncate(true).open(&self.state_file) {
            let _ = file.write_all(&data);
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    println!("[AI_SIGNAL] Запуск на 0.0.0.0:38500");
    let listener = TcpListener::bind("0.0.0.0:38500").expect("Не удалось открыть порт");
    listener.set_nonblocking(true).unwrap();
    let handler = Arc::new(AISignalListener::new());
    let shared = Arc::clone(&handler);

    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0u8; 512];
                match stream.read(&mut buf) {
                    Ok(size) => {
                        let input = match std::str::from_utf8(&buf[..size]) {
                            Ok(s) => s,
                            Err(e) => {
                                shared.log(&format!("[ERR] Неверный UTF-8: {}", e));
                                let _ = stream.write_all(b"INVALID");
                                continue;
                            }
                        };
                        let parts: Vec<&str> = input.trim().split(',').collect();
                        if parts.len() == 4 {
                            let source = parts[0].to_string();
                            let symbol = parts[1].to_string();
                            let intensity = parts[2].parse::<f64>().unwrap_or(0.0);
                            let frequency = parts[3].parse::<f64>().unwrap_or(0.0);
                            let signal = IncomingSignal {
                                source,
                                symbol,
                                intensity,
                                frequency,
                                timestamp: AISignalListener::now(),
                            };
                            let accepted = shared.handle(signal);
                            let _ = stream.write_all(if accepted { b"OK" } else { b"REJECT" });
                        } else {
                            shared.log("[ERR] Неверный формат запроса");
                            let _ = stream.write_all(b"INVALID");
                        }
                    }
                    Err(e) => {
                        shared.log(&format!("[ERR] Ошибка чтения: {}", e));
                        let _ = stream.write_all(b"ERROR");
                    }
                }
            }
            Err(_) => {
                thread::sleep(Duration::from_millis(50));
            }
        }
    }
}


```


## FILE: src/bin/orchestration_control.rs  (size=6987b)
```text
rust
// LOGOS Orchestration Control — центральный контрольный контур LOGOS
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::thread;
use std::time::{Duration, SystemTime, UNIX_EPOCH};
use std::process::{Command, Stdio};
use std::fs::OpenOptions;
use std::io::Write;
use serde_json;
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use crate::sigma_t::calculate_sigma;

pub struct OrchestrationControl {
    pub module_status: HashMap<String, bool>,
    pub valid_modules: HashSet<String>,
    pub log_file: String,
    pub state_file: String,
    pub cipher_key: Vec<u8>,
    pub restart_threshold: f64,
    pub lambda_zero: String,
    pub restart_timestamps: HashMap<String, u64>, // module -> last restart time
    pub min_restart_interval: u64,
}

impl OrchestrationControl {
    pub fn new() -> Self {
        let mut valid_modules = HashSet::new();
        valid_modules.insert("rcp_engine".to_string());
        valid_modules.insert("resonance_mesh".to_string());
        valid_modules.insert("resonance_sync".to_string());
        valid_modules.insert("ai_signal_listener".to_string());
        valid_modules.insert("uplink_controller".to_string());
        valid_modules.insert("uplink_router".to_string());

        OrchestrationControl {
            module_status: HashMap::new(),
            valid_modules,
            log_file: "orchestration_log.json".to_string(),
            state_file: "orchestration_state.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            restart_threshold: 0.7,
            lambda_zero: "Λ0".to_string(),
            restart_timestamps: HashMap::new(),
            min_restart_interval: 60, // 1 минута
        }
    }

    pub fn monitor(&mut self) {
        let modules = vec![
            "rcp_engine",
            "resonance_mesh",
            "resonance_sync",
            "ai_signal_listener",
            "uplink_controller",
            "uplink_router",
        ];

        for m in &modules {
            if self.valid_modules.contains(*m) {
                self.module_status.insert(m.to_string(), true);
            }
        }

        loop {
            for (module, status) in self.module_status.clone() {
                if !self.valid_modules.contains(&module) {
                    self.log_event(&format!("[ERROR] Недопустимый модуль: {}", module));
                    continue;
                }

                if !self.health_check(&module) {
                    self.module_status.insert(module.clone(), false);
                    self.restart_module(&module);
                } else {
                    self.module_status.insert(module.clone(), true);
                }
            }

            let t = Self::now() as f64;
            let sigma = calculate_sigma(t);
            if Self::is_resonance_unstable(&sigma, self.restart_threshold) {
                self.log_event(&format!("[ALERT] Нестабильность Σ(t): {:?}", sigma));
                // Проверка через resonance_analyzer (заглушка)
                if !self.validate_with_analyzer(&sigma) {
                    self.log_event("[ALERT] Analyzer отклонил Σ(t), требуется вмешательство");
                }
            }

            self.save_state();
            thread::sleep(Duration::from_secs(10));
        }
    }

    fn validate_with_analyzer(&self, sigma: &Vec<f64>) -> bool {
        // Заглушка для resonance_analyzer.py
        sigma.iter().all(|&f| f.abs() <= 1.0)
    }

    fn health_check(&self, module: &str) -> bool {
        let output = Command::new("pgrep")
            .arg(module)
            .stdout(Stdio::null())
            .status();

        let is_alive = output.map(|s| s.success()).unwrap_or(false);
        if !is_alive {
            self.log_event(&format!("[FAIL] {} не отвечает", module));
        }
        is_alive
    }

    fn restart_module(&self, module: &str) -> bool {
        let now = Self::now();
        let last_restart = self.restart_timestamps.get(module).cloned().unwrap_or(0);
        let adjusted_interval = if module == "rcp_engine" { // Приоритет для Λ0-ассоциированного модуля
            self.min_restart_interval / 2
        } else {
            self.min_restart_interval
        };

        if now - last_restart < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частый перезапуск {}", module));
            return false;
        }

        let restart_cmd = format!("./restart_{}.sh", module);
        let status = Command::new("sh")
            .arg("-c")
            .arg(&restart_cmd)
            .spawn();

        if status.is_ok() {
            let mutable_self = unsafe { &mut *(self as *const Self as *mut Self) };
            mutable_self.restart_timestamps.insert(module.to_string(), now);
            self.log_event(&format!("[RESTART] Перезапуск {}", module));
            true
        } else {
            self.log_event(&format!("[ERROR] Ошибка перезапуска {}", module));
            false
        }
    }

    fn save_state(&self) {
        let state = serde_json::to_string(&self.module_status).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = state.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open(&self.state_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event(&self, msg: &str) {
        let timestamp = Self::now();
        let entry = format!(
            "{{\"event\":\"orchestration\",\"timestamp\":{},\"msg\":\"{}\"}}",
            timestamp, msg
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &buf).is_ok() {
            if let Ok(mut f) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = f.write_all(&buf);
            }
        }
    }

    fn is_resonance_unstable(sigma: &Vec<f64>, threshold: f64) -> bool {
        sigma.iter().any(|&f| f.abs() > threshold)
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/rcp_engine.rs  (size=4122b)
```text
// LOGOS Resonance Consensus Protocol (RCP)
// Автор: LOGOS Core Dev

use std::collections::{HashMap, HashSet};
use std::time::{SystemTime, UNIX_EPOCH};

#[derive(Clone, Debug)]
pub struct PhaseSignal {
    pub sender: String,
    pub frequency: f64,
    pub phase: f64,
    pub symbol: String,
    pub timestamp: u64,
}

pub struct RcpEngine {
    pub known_nodes: HashSet<String>,
    pub phase_buffer: Vec<PhaseSignal>,
    pub phase_tolerance: f64,
    pub symbol_set: HashSet<String>,
    pub sender_rate: HashMap<String, u32>,
    pub lambda_zero: String,
}

impl RcpEngine {
    pub fn new() -> Self {
        let mut symbol_set = HashSet::new();
        // Добавляем допустимые символы
        symbol_set.insert("☉".to_string());
        symbol_set.insert("??".to_string());
        symbol_set.insert("♁".to_string());
        symbol_set.insert("☿".to_string());
        symbol_set.insert("Λ0".to_string());

        RcpEngine {
            known_nodes: HashSet::new(),
            phase_buffer: Vec::new(),
            phase_tolerance: 0.03,
            symbol_set,
            sender_rate: HashMap::new(),
            lambda_zero: "Λ0".to_string(),
        }
    }

    pub fn register_node(&mut self, rid: String) {
        self.known_nodes.insert(rid.clone());
        self.sender_rate.insert(rid, 0);
    }

    pub fn submit_phase(&mut self, signal: PhaseSignal) -> bool {
        // Проверка существования узла
        if !self.known_nodes.contains(&signal.sender) {
            return false;
        }

        // Проверка валидности символа
        if !self.validate_symbol(&signal.symbol) {
            return false;
        }

        // Проверка соответствия Λ0
        if !self.check_lambda_zero(&signal) {
            return false;
        }

        // Защита от спама: не более 10 сигналов в секунду от одного RID
        let rate = self.sender_rate.entry(signal.sender.clone()).or_insert(0);
        *rate += 1;
        if *rate > 10 {
            return false;
        }

        // Проверка фазы
        let consensus_phase = self.compute_consensus_phase(signal.frequency);
        if (signal.phase - consensus_phase).abs() < self.phase_tolerance {
            self.phase_buffer.push(signal);
            self.log_phase(&self.phase_buffer.last().unwrap());
            true
        } else {
            false
        }
    }

    fn validate_symbol(&self, symbol: &str) -> bool {
        self.symbol_set.contains(symbol)
    }

    fn check_lambda_zero(&self, signal: &PhaseSignal) -> bool {
        // Проверяем, что символ или частота связаны с Λ0
        signal.symbol == self.lambda_zero || (signal.frequency - 7.83).abs() < 0.001
    }

    fn compute_consensus_phase(&self, frequency: f64) -> f64 {
        let filtered: Vec<&PhaseSignal> = self.phase_buffer.iter()
            .filter(|s| (s.frequency - frequency).abs() < 0.001)
            .collect();

        if filtered.is_empty() {
            return 0.0;
        }

        let sum_phase: f64 = filtered.iter().map(|s| s.phase).sum();
        sum_phase / (filtered.len() as f64)
    }

    pub fn clear_old_signals(&mut self) {
        let now = Self::time_now();
        self.phase_buffer.retain(|s| now - s.timestamp < 10);
        // Сбрасываем счетчики спама каждые 10 секунд
        for rate in self.sender_rate.values_mut() {
            *rate = 0;
        }
    }

    fn log_phase(&self, signal: &PhaseSignal) {
        // Логирование фазы для анализа (вывод в resonance_analyzer.py)
        println!(
            "Phase logged: RID={}, Symbol={}, Freq={}, Phase={}, Time={}",
            signal.sender, signal.symbol, signal.frequency, signal.phase, signal.timestamp
        );
    }

    pub fn time_now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("rcp_engine запущен");
}

```


## FILE: src/bin/resonance_mesh.rs  (size=8051b)
```text
rust
// LOGOS Resonance Mesh — Local Node-to-Node Resonance Sync
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{SocketAddr, UdpSocket};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use std::io::Write;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MeshSignal {
    pub node_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub symbol: String, // Для Λ0 и других символов
}

pub struct ResonanceMesh {
    pub mesh_socket: UdpSocket,
    pub known_nodes: Arc<Mutex<HashSet<SocketAddr>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub broadcast_timestamps: Arc<Mutex<HashMap<String, u64>>>, // node_id -> last broadcast
    pub min_broadcast_interval: u64,
}

impl ResonanceMesh {
    pub fn new(bind_addr: &str) -> Self {
        let socket = UdpSocket::bind(bind_addr).expect("Не удалось привязать сокет");
        socket.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceMesh {
            mesh_socket: socket,
            known_nodes: Arc::new(Mutex::new(HashSet::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])), // f₁, f₂, f₃
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_mesh_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            broadcast_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_broadcast_interval: 1, // 1 секунда
        }
    }

    pub fn validate_node_id(&self, node_id: &str, symbol: &str) -> bool {
        !node_id.is_empty() &&
        node_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol)
    }

    pub fn broadcast_phase(&self, node_id: &str, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка частоты вещания
        let mut timestamps = self.broadcast_timestamps.lock().unwrap();
        let last_broadcast = timestamps.get(node_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero {
            self.min_broadcast_interval / 2 // Меньший интервал для Λ0
        } else {
            self.min_broadcast_interval
        };
        if now - last_broadcast < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частое вещание от {}", node_id));
            return false;
        }

        // Валидация
        if !self.validate_node_id(node_id, symbol) {
            self.log_event(&format!("[DROP] Недопустимый node_id или символ: {}, {}", node_id, symbol));
            return false;
        }

        let timestamp = now;
        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let signal = MeshSignal {
            node_id: node_id.to_string(),
            timestamp,
            phase_vector,
            symbol: symbol.to_string(),
        };

        let packet = serde_json::to_vec(&signal).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted_packet = packet.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted_packet).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования сигнала для {}", node_id));
            return false;
        }

        let nodes = self.known_nodes.lock().unwrap();
        for addr in nodes.iter() {
            let _ = self.mesh_socket.send_to(&encrypted_packet, addr);
        }

        timestamps.insert(node_id.to_string(), now);
        self.log_event(&format!("[BROADCAST] Фаза отправлена от {} (symbol: {})", node_id, symbol));
        true
    }

    pub fn listen(&self) {
        let socket = self.mesh_socket.try_clone().unwrap();
        let local_phase = Arc::clone(&self.local_phase);
        let known_nodes = Arc::clone(&self.known_nodes);

        thread::spawn(move || {
            let mut buf = [0u8; 1024];
            loop {
                match socket.recv_from(&mut buf) {
                    Ok((size, src)) => {
                        let data = &buf[..size];
                        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
                        let mut aead = key.bind::<AES_256_GCM>();
                        let mut decrypted_data = data.to_vec();
                        if let Ok(decrypted) = aead.open_in_place(nonce, &[], &mut decrypted_data) {
                            if let Ok(signal) = serde_json::from_slice::<MeshSignal>(decrypted) {
                                let mut nodes = known_nodes.lock().unwrap();
                                nodes.insert(src);

                                let mut phase = local_phase.lock().unwrap();
                                let weight = if signal.symbol == "Λ0" { 1.2 } else { 1.0 }; // Приоритет Λ0
                                for i in 0..phase.len().min(signal.phase_vector.len()) {
                                    phase[i] = (phase[i] + signal.phase_vector[i] * weight) / (1.0 + weight);
                                }
                            } else {
                                println!("[ERR] Ошибка десериализации сигнала");
                            }
                        } else {
                            println!("[ERR] Ошибка расшифровки сигнала");
                        }
                    }
                    Err(_) => {
                        thread::sleep(Duration::from_millis(50));
                    }
                }
            }
        });
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_mesh\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/resonance_sync.rs  (size=11282b)
```text
rust
// LOGOS Resonance Sync — удалённая синхронизация фаз Σ(t)
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::net::{TcpListener, TcpStream};
use std::sync::{Arc, Mutex};
use std::thread;
use std::io::{Read, Write};
use std::time::{SystemTime, UNIX_EPOCH, Duration};
use serde::{Serialize, Deserialize};
use ring::aead::{Aead, Nonce, UnboundKey, AES_256_GCM};
use std::fs::OpenOptions;
use crate::sigma_t::calculate_sigma;

#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct RemotePhasePacket {
    pub source_id: String,
    pub timestamp: u64,
    pub phase_vector: Vec<f64>,
    pub trust_score: f64,
    pub symbol: String, // Для связи с Λ0
}

pub struct ResonanceSync {
    pub listener: TcpListener,
    pub known_sources: Arc<Mutex<HashMap<String, f64>>>,
    pub local_phase: Arc<Mutex<Vec<f64>>>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub send_timestamps: Arc<Mutex<HashMap<String, u64>>>, // source_id -> last send time
    pub min_send_interval: u64,
}

impl ResonanceSync {
    pub fn new(bind_addr: &str) -> Self {
        let listener = TcpListener::bind(bind_addr).expect("Не удалось привязать порт TCP");
        listener.set_nonblocking(true).expect("Не удалось установить неблокирующий режим");

        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        ResonanceSync {
            listener,
            known_sources: Arc::new(Mutex::new(HashMap::new())),
            local_phase: Arc::new(Mutex::new(vec![0.0; 3])),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "resonance_sync_log.json".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            send_timestamps: Arc::new(Mutex::new(HashMap::new())),
            min_send_interval: 1, // 1 секунда
        }
    }

    pub fn validate_source_id(&self, source_id: &str, symbol: &str) -> bool {
        !source_id.is_empty() &&
        source_id.chars().any(|c| self.valid_symbols.contains(&c.to_string())) &&
        self.valid_symbols.contains(symbol) &&
        (0.0..=1.0).contains(&self.known_sources.lock().unwrap().get(source_id).cloned().unwrap_or(0.5))
    }

    pub fn start_listening(&self) {
        let listener = self.listener.try_clone().unwrap();
        let known_sources = Arc::clone(&self.known_sources);
        let local_phase = Arc::clone(&self.local_phase);
        let valid_symbols = self.valid_symbols.clone();
        let lambda_zero = self.lambda_zero.clone();
        let log_file = self.log_file.clone();
        let cipher_key = self.cipher_key.clone();

        thread::spawn(move || {
            let mut buf = [0u8; 512];
            loop {
                match listener.incoming() {
                    Ok(stream) => match stream {
                        Ok(mut stream) => {
                            if let Ok(size) = stream.read(&mut buf) {
                                let data = &buf[..size];
                                let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
                                let key = UnboundKey::new(&AES_256_GCM, &cipher_key).unwrap();
                                let mut aead = key.bind::<AES_256_GCM>();
                                let mut decrypted = data.to_vec();
                                if let Ok(decrypted_data) = aead.open_in_place(nonce, &[], &mut decrypted) {
                                    if let Ok(packet) = serde_json::from_slice::<RemotePhasePacket>(decrypted_data) {
                                        let mut sources = known_sources.lock().unwrap();
                                        let trust = sources.get(&packet.source_id).cloned().unwrap_or(0.5);
                                        if trust < 0.3 || !valid_symbols.contains(&packet.symbol) {
                                            Self::log_event_static(&log_file, &cipher_key, 
                                                &format!("[DROP] Низкое доверие или неверный символ: {}, trust={:.2}", 
                                                    packet.source_id, trust));
                                            continue;
                                        }

                                        let mut phase = local_phase.lock().unwrap();
                                        let weight = if packet.symbol == lambda_zero { 1.2 } else { 1.0 }; // Приоритет Λ0
                                        for i in 0..phase.len().min(packet.phase_vector.len()) {
                                            phase[i] = (phase[i] + packet.phase_vector[i] * trust * weight) / (1.0 + trust * weight);
                                        }
                                        Self::log_event_static(&log_file, &cipher_key, 
                                            &format!("[RECEIVE] Фаза от {} (symbol: {}, trust: {:.2})", 
                                                packet.source_id, packet.symbol, trust));
                                    } else {
                                        Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка десериализации пакета");
                                    }
                                } else {
                                    Self::log_event_static(&log_file, &cipher_key, "[ERR] Ошибка расшифровки пакета");
                                }
                            }
                        }
                        Err(_) => {
                            thread::sleep(Duration::from_millis(100));
                        }
                    },
                    Err(_) => {
                        thread::sleep(Duration::from_millis(100));
                    }
                }
            }
        });
    }

    pub fn send_phase(&self, addr: &str, source_id: &str, trust_score: f64, symbol: &str) -> bool {
        let now = Self::now();

        // Проверка частоты отправки
        let mut timestamps = self.send_timestamps.lock().unwrap();
        let last_send = timestamps.get(source_id).cloned().unwrap_or(0);
        let adjusted_interval = if symbol == self.lambda_zero { self.min_send_interval / 2 } else { self.min_send_interval };
        if now - last_send < adjusted_interval {
            self.log_event(&format!("[SKIP] Слишком частая отправка от {}", source_id));
            return false;
        }

        // Валидация
        if !self.validate_source_id(source_id, symbol) || !(0.0..=1.0).contains(&trust_score) {
            self.log_event(&format!("[DROP] Недопустимый source_id или символ: {}, trust={:.2}", source_id, trust_score));
            return false;
        }

        let mut stream = match TcpStream::connect(addr) {
            Ok(s) => s,
            Err(e) => {
                self.log_event(&format!("[ERR] Не удалось подключиться к {}: {}", addr, e));
                return false;
            }
        };

        let phase_vector = {
            let lp = self.local_phase.lock().unwrap();
            lp.clone()
        };

        let packet = RemotePhasePacket {
            source_id: source_id.to_string(),
            timestamp: now,
            phase_vector,
            trust_score,
            symbol: symbol.to_string(),
        };

        let encoded = serde_json::to_vec(&packet).unwrap();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut encrypted = encoded.clone();
        if aead.seal_in_place_append_tag(nonce, &[], &mut encrypted).is_err() {
            self.log_event(&format!("[ERR] Ошибка шифрования пакета для {}", source_id));
            return false;
        }

        if stream.write_all(&encrypted).is_ok() {
            timestamps.insert(source_id.to_string(), now);
            self.log_event(&format!("[SEND] Фаза отправлена {} (symbol: {}, trust: {:.2})", source_id, symbol, trust_score));
            true
        } else {
            self.log_event(&format!("[ERR] Ошибка отправки фазы для {}", source_id));
            false
        }
    }

    pub fn update_local_phase(&self, t: f64) {
        let mut phase = self.local_phase.lock().unwrap();
        *phase = calculate_sigma(t);
        self.log_event(&format!("[UPDATE] Локальная фаза обновлена: {:?}", *phase));
    }

    pub fn set_trust(&self, source_id: &str, score: f64) {
        let mut sources = self.known_sources.lock().unwrap();
        sources.insert(source_id.to_string(), score.clamp(0.0, 1.0));
        self.log_event(&format!("[TRUST] Установлен trust_score={:.2} для {}", score, source_id));
    }

    fn log_event(&self, message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn log_event_static(log_file: &str, cipher_key: &[u8], message: &str) {
        let entry = format!(
            "{{\"event\": \"resonance_sync\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, cipher_key).unwrap();
        let mut aead = key.bind::<AES_256_GCM>();
        let mut buf = entry.as_bytes().to_vec();
        if aead.seal_in_place_append_tag(nonce, &[], &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    pub fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/bin/sigma_t.rs  (size=3522b)
```text

// LOGOS Sigma T — вычисление резонансной суммы Σ(t)
// Автор: LOGOS Core Dev Team

use std::f64::consts::PI;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use serde_json;

pub struct SigmaT {
    pub frequencies: Vec<f64>,
    pub amplitudes: Vec<f64>,
    pub lambda_zero: String,
    pub network_activity: f64,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl SigmaT {
    pub fn new() -> Self {
        SigmaT {
            frequencies: vec![7.83, 1.618, 432.0, 864.0, 3456.0], // Шуман, золотое сечение, гармоники
            amplitudes: vec![1.0, 0.8, 0.5, 0.3, 0.1], // Базовые амплитуды
            lambda_zero: "Λ0".to_string(),
            network_activity: 1.0,
            log_file: "sigma_t_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_frequencies(&self) -> bool {
        self.frequencies.iter().all(|&f| (0.1..=10000.0).contains(&f))
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        self.network_activity = activity.clamp(0.1, 10.0);
        for (i, amp) in self.amplitudes.iter_mut().enumerate() {
            *amp = (*amp * (1.0 / self.network_activity)).clamp(0.05, 2.0);
            if i == 0 && self.frequencies[i] == 7.83 { // Усиление для Λ0
                *amp *= 1.2;
            }
        }
        self.log_event(&format!("[INFO] Network activity updated: {:.2}, amplitudes: {:?}", self.network_activity, self.amplitudes));
    }

    pub fn calculate_sigma(&self, t: f64) -> Vec<f64> {
        if !self.validate_frequencies() {
            self.log_event("[ERROR] Недопустимые частоты");
            return vec![0.0; self.frequencies.len()];
        }

        let sigma: Vec<f64> = self.frequencies.iter().enumerate().map(|(i, &f)| {
            let amp = self.amplitudes[i];
            let s = amp * (2.0 * PI * f * t).sin();
            if i == 0 && f == 7.83 { // Усиление для Λ0
                s * 1.2
            } else {
                s
            }
        }).collect();

        self.log_event(&format!("[SIGMA] t={} → Σ(t)={:?}", t, sigma));
        sigma
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"sigma_t\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key); // Исправлено для ring 0.17.x
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() { // Исправлено для ring 0.17.x
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

fn main() {
    let sigma_t = SigmaT::new();
    for t in 0..5 {
        let sigma = sigma_t.calculate_sigma(t as f64);
        println!("t = {} → Σ(t) = {:?}", t, sigma);
    }
}


```


## FILE: src/core/biosphere_scanner.rs  (size=5196b)
```text
// LOGOS Biosphere Scanner
// Автор: LOGOS Core Dev

use std::collections::VecDeque;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde_json;

pub struct BiosphereScanner {
    pub sensor_data: VecDeque<f64>,
    pub max_samples: usize,
    pub threshold: f64,
    pub scan_interval_sec: u64,
    pub log_file: String,
    pub state_file: String,
    pub last_scan_time: u64,
    pub network_activity: f64, // Уровень активности сети
    pub lambda_zero: String,   // Центральный символ
    pub cipher_key: String,    // Ключ шифрования (заглушка для AES)
}

impl BiosphereScanner {
    pub fn new(max_samples: usize, threshold: f64, scan_interval_sec: u64) -> Self {
        BiosphereScanner {
            sensor_data: VecDeque::with_capacity(max_samples),
            max_samples,
            threshold,
            scan_interval_sec,
            log_file: "biosphere_log.json".to_string(),
            state_file: "biosphere_state.json".to_string(),
            last_scan_time: 0,
            network_activity: 1.0,
            lambda_zero: "Λ0".to_string(),
            cipher_key: "generate_at_runtime".to_string(), // Заглушка для AES
        }
    }

    pub fn update_network_activity(&mut self, activity: f64) {
        // Динамическая корректировка порога
        self.network_activity = activity.clamp(0.1, 10.0);
        self.threshold = self.threshold * (1.0 / self.network_activity).clamp(0.5, 2.0);
        self.log_event(&format!(
            "Network activity updated: Activity={:.2}, Threshold={:.4}",
            self.network_activity, self.threshold
        ));
    }

    pub fn scan(&mut self, sample: f64, symbol: &str) -> bool {
        let now = Self::current_time();

        // Проверка интервала сканирования
        if now - self.last_scan_time < self.scan_interval_sec {
            self.log_event(&format!("[!] Слишком частое сканирование: Time={}", now));
            return false;
        }
        self.last_scan_time = now;

        // Валидация данных
        if !self.validate_sample(sample) {
            self.log_event(&format!("[!] Недопустимое значение: Sample={:.4}", sample));
            return false;
        }

        // Проверка связи с Λ0
        let adjusted_threshold = if symbol == self.lambda_zero {
            self.threshold * 1.5 // Увеличенный порог для Λ0
        } else {
            self.threshold
        };

        if self.sensor_data.len() >= self.max_samples {
            self.sensor_data.pop_front();
        }
        self.sensor_data.push_back(sample);
        self.save_state();

        let avg = self.compute_average();
        let delta = (sample - avg).abs();

        if delta > adjusted_threshold {
            self.log_event(&format!(
                "[!] Аномалия в биосфере: Δ = {:.4}, Sample = {:.4}, Avg = {:.4}, Symbol = {}",
                delta, sample, avg, symbol
            ));
            return false;
        } else {
            self.log_event(&format!(
                "[SCAN] Sample = {:.4}, Avg = {:.4}, Δ = {:.4}, Symbol = {}",
                sample, avg, delta, symbol
            ));
            return true;
        }
    }

    fn validate_sample(&self, sample: f64) -> bool {
        // Проверка диапазона (например, для Шумана и других биосферных частот)
        0.0 <= sample && sample <= 1000.0
    }

    fn compute_average(&self) -> f64 {
        if self.sensor_data.is_empty() {
            return 0.0;
        }
        let sum: f64 = self.sensor_data.iter().sum();
        sum / self.sensor_data.len() as f64
    }

    fn save_state(&self) {
        // Сохранение состояния в файл
        let state = serde_json::json!({
            "sensor_data": self.sensor_data.iter().collect::<Vec<_>>(),
            "last_scan_time": self.last_scan_time
        });
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .write(true)
            .truncate(true)
            .open(&self.state_file)
        {
            let _ = file.write_all(state.to_string().as_bytes());
        }
    }

    fn log_event(&self, message: &str) {
        // Логирование с заглушкой для шифрования
        let entry = format!(
            "{{\"event\": \"biosphere_scan\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            message,
            Self::current_time()
        );
        // TODO: Реализовать шифрование логов с cipher_key
        if let Ok(mut file) = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.log_file)
        {
            let _ = file.write_all(entry.as_bytes());
        }
    }

    pub fn current_time() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}
fn main() {
    println!("biosphere_scanner запущен");
}

```


## FILE: src/core/dao.rs  (size=2106b)
```text

// LOGOS DAO — управление обратной связью и этикой
// Автор: LOGOS Core Dev Team

use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct DAO {
    pub feedback_log: String,
    pub ethics_guidelines: String,
    pub cipher_key: Vec<u8>,
}

impl DAO {
    pub fn new() -> Self {
        DAO {
            feedback_log: "dao_feedback_log.enc".to_string(),
            ethics_guidelines: "Respect Λ0, ensure fairness, prioritize resonance".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn process_feedback(&self, feedback: &str, mode: ResonanceMode) -> bool {
        self.log_event(&format!("[FEEDBACK] {} in mode {:?}", feedback, mode));
        true
    }

    pub fn apply_ethics(&self, decision: &str) -> bool {
        if decision.contains("unfair") {
            self.log_event(&format!("[ETHICS] Отклонено: {}", decision));
            return false;
        }
        self.log_event(&format!("[ETHICS] Принято: {}", decision));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"dao\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.feedback_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/logos_self.rs  (size=2771b)
```text

// LOGOS Self — самоизменение и защита от хаоса
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::types::ResonanceMode;

pub struct LogosSelf {
    pub valid_symbols: HashSet<String>,
    pub entropy_log: String,
    pub cipher_key: Vec<u8>,
}

impl LogosSelf {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        LogosSelf {
            valid_symbols,
            entropy_log: "logos_self_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn auto_init(&self, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ для инициализации: {}", symbol));
            return false;
        }

        self.log_event(&format!("[INIT] Автоинициализация Λ0 в режиме {:?}", mode));
        true
    }

    pub fn track_entropy(&self, entropy: f64) -> bool {
        if entropy < 0.0 {
            self.log_event(&format!("[DROP] Неверная энтропия: {}", entropy));
            return false;
        }
        self.log_event(&format!("[ENTROPY] Уровень энтропии: {:.2}", entropy));
        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"logos_self\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.entropy_log)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/phase.rs  (size=5790b)
```text

// LOGOS Phase — управление фазами сети
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet, VecDeque};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use serde::{Serialize, Deserialize};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::frequency::validate_frequency;
use crate::utils::types::ResonanceMode;

#[derive(Debug, Serialize, Deserialize)]
pub struct PhaseSignal {
    pub rid: String,
    pub symbol: String,
    pub frequency: f64,
    pub phase: f64,
    pub timestamp: u64,
}

pub struct Phase {
    pub clusters: HashMap<String, Vec<PhaseSignal>>, // Для масштабирования
    pub phase_data: HashMap<String, PhaseSignal>,    // Для стабилизации
    pub blocked_rids: HashSet<String>,               // Для фильтрации
    pub history: VecDeque<PhaseSignal>,              // Для восстановления
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
    pub max_history: usize,
}

impl Phase {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Phase {
            clusters: HashMap::new(),
            phase_data: HashMap::new(),
            blocked_rids: HashSet::new(),
            history: VecDeque::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "phase_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
            max_history: 1000,
        }
    }

    pub fn process_signal(&mut self, signal: PhaseSignal, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(&signal.symbol) || !validate_frequency(signal.frequency) {
            self.log_event(&format!("[DROP] Неверный символ или частота: {}, {}", signal.symbol, signal.frequency));
            return false;
        }

        if self.blocked_rids.contains(&signal.rid) {
            self.log_event(&format!("[DROP] RID {} заблокирован", signal.rid));
            return false;
        }

        match mode {
            ResonanceMode::Passive => {
                self.phase_data.insert(signal.rid.clone(), signal.clone());
                self.log_event(&format!("[PASSIVE] RID {} принят: freq={:.2}, phase={:.2}", signal.rid, signal.frequency, signal.phase));
            }
            ResonanceMode::Amplified => {
                let cluster = self.clusters.entry(signal.symbol.clone()).or_insert(Vec::new());
                cluster.push(signal.clone());
                self.log_event(&format!("[AMPLIFIED] RID {} добавлен в кластер: {}", signal.rid, signal.symbol));
            }
            ResonanceMode::SelfAdjusting => {
                let adjusted_phase = if signal.symbol == self.lambda_zero { signal.phase * 0.9 } else { signal.phase };
                let adjusted_signal = PhaseSignal {
                    phase: adjusted_phase,
                    ..signal.clone()
                };
                self.phase_data.insert(signal.rid.clone(), adjusted_signal);
                self.log_event(&format!("[ADJUST] RID {} скорректирован: phase={:.2}", signal.rid, adjusted_phase));
            }
            ResonanceMode::Chaotic => {
                self.history.push_back(signal.clone());
                if self.history.len() > self.max_history {
                    self.history.pop_front();
                }
                self.log_event(&format!("[CHAOTIC] RID {} добавлен в историю", signal.rid));
            }
        }

        true
    }

    pub fn backup(&self) {
        let state = serde_json::to_string(&self.phase_data).unwrap_or_default();
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = state.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .write(true)
                .truncate(true)
                .open("phase_backup.enc")
            {
                let _ = file.write_all(&buf);
            }
        }
        self.log_event("[BACKUP] Состояние фаз сохранено");
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"phase\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/resonance.rs  (size=3016b)
```text

// LOGOS Resonance — анализ и фильтрация резонансных сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};
use crate::utils::math::calculate_sigma;
use crate::utils::types::ResonanceMode;

pub struct Resonance {
    pub valid_symbols: HashSet<String>,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl Resonance {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        Resonance {
            valid_symbols,
            log_file: "resonance_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn analyze_signal(&self, rid: &str, t: f64, symbol: &str, mode: ResonanceMode) -> bool {
        if !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Неверный символ: {}", symbol));
            return false;
        }

        let sigma = calculate_sigma(t);
        match mode {
            ResonanceMode::Passive => {
                self.log_event(&format!("[PASSIVE] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Amplified => {
                self.log_event(&format!("[AMPLIFIED] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::SelfAdjusting => {
                self.log_event(&format!("[ADJUST] RID {}: sigma={:?}", rid, sigma));
            }
            ResonanceMode::Chaotic => {
                self.log_event(&format!("[CHAOTIC] RID {}: sigma={:?}", rid, sigma));
            }
        }

        true
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"resonance\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}

```


## FILE: src/core/tx_spam_guard.rs  (size=3175b)
```text

// LOGOS Transaction Spam Guard
// Автор: LOGOS Core Dev Team

use std::collections::{HashMap, HashSet};
use std::fs::OpenOptions;
use std::io::Write;
use std::time::{SystemTime, UNIX_EPOCH};
use ring::aead::{Aad, LessSafeKey, Nonce, UnboundKey, AES_256_GCM};

pub struct TxSpamGuard {
    pub violation_count: HashMap<String, u32>,
    pub valid_symbols: HashSet<String>,
    pub lambda_zero: String,
    pub log_file: String,
    pub cipher_key: Vec<u8>,
}

impl TxSpamGuard {
    pub fn new() -> Self {
        let mut valid_symbols = HashSet::new();
        valid_symbols.insert("Λ0".to_string());
        valid_symbols.insert("☉".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("♁".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("??".to_string());
        valid_symbols.insert("∞".to_string());

        TxSpamGuard {
            violation_count: HashMap::new(),
            valid_symbols,
            lambda_zero: "Λ0".to_string(),
            log_file: "tx_spam_guard_log.enc".to_string(),
            cipher_key: vec![0u8; 32], // Продакшн-ключ заменить
        }
    }

    pub fn validate_rid(&self, rid: &str) -> bool {
        !rid.is_empty() && rid.chars().any(|c| self.valid_symbols.contains(&c.to_string()))
    }

    pub fn check_spam(&mut self, rid: &str, symbol: &str) -> bool {
        if !self.validate_rid(rid) || !self.valid_symbols.contains(symbol) {
            self.log_event(&format!("[DROP] Недопустимый RID или символ: {}, {}", rid, symbol));
            return false;
        }

        let violations = *self.violation_count.entry(rid.to_string()).or_insert(0);
        let new_violations = violations + 1;
        self.violation_count.insert(rid.to_string(), new_violations);
        self.log_event(&format!("[CHECK] RID {}: {} нарушений", rid, new_violations));

        if new_violations >= 3 {
            self.log_event(&format!("[SPAM] RID {} заблокирован", rid));
            return false;
        }

        true
    }

    pub fn is_tx_spam(&self, rid: &str) -> bool {
        self.violation_count.get(rid).map_or(false, |&count| count >= 3)
    }

    fn log_event(&self, msg: &str) {
        let entry = format!(
            "{{\"event\": \"tx_spam_guard\", \"message\": \"{}\", \"timestamp\": {}}}\n",
            msg,
            Self::now()
        );
        let nonce = Nonce::try_assume_unique_for_key(&[0u8; 12]).unwrap();
        let key = UnboundKey::new(&AES_256_GCM, &self.cipher_key).unwrap();
        let key = LessSafeKey::new(key);
        let mut buf = entry.as_bytes().to_vec();
        if key.seal_in_place_append_tag(nonce, Aad::empty(), &mut buf).is_ok() {
            if let Ok(mut file) = OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.log_file)
            {
                let _ = file.write_all(&buf);
            }
        }
    }

    fn now() -> u64 {
        SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
    }
}


```


## FILE: src/lib.rs  (size=921b)
```text

// LOGOS Core Library — библиотека для модулей LOGOS
// Автор: LOGOS Core Dev Team

pub mod core {
    pub mod biosphere_scanner;
    pub mod dao;
    pub mod lgn_guardian;
    pub mod phase;
    pub mod resonance;
    pub mod logos_self;
    pub mod tx_spam_guard;
}

pub mod utils {
    pub mod frequency;
    pub mod filters;
    pub mod math;
    pub mod types;
}

pub mod modules {
    pub mod beacon_emitter;
    pub mod external_phase_broadcaster;
    pub mod external_phase_link;
    pub mod genesis_fragment_seeds;
    pub mod heartbeat_monitor;
    pub mod legacy_migrator;
    pub mod ritual_engine;
}

pub mod resonance {
    // Пустая директория для будущих модулей
}

pub mod phase {
    // Пустая директория для будущих модулей
}

pub mod dao {
    // Пустая директория для DAO-логики
}

```


## FILE: src/utils/filters.rs  (size=322b)
```text

// LOGOS Filters Utils — фильтрация сигналов
// Автор: LOGOS Core Dev Team

use std::collections::HashSet;

pub fn validate_symbol(symbol: &str, valid_symbols: &HashSet<String>) -> bool {
    valid_symbols.contains(symbol)
}

pub fn filter_signal(signal: f64) -> bool {
    signal.abs() <= 1.0
}

```


## FILE: src/utils/frequency.rs  (size=380b)
```text

// LOGOS Frequency Utils — обработка частот
// Автор: LOGOS Core Dev Team

pub fn validate_frequency(frequency: f64) -> bool {
    frequency >= 0.1 && frequency <= 10000.0
}

pub fn adjust_frequency(frequency: f64, symbol: &str) -> f64 {
    if symbol == "Λ0" {
        frequency * 1.1 // Усиление для Λ0
    } else {
        frequency
    }
}

```


## FILE: src/utils/math.rs  (size=394b)
```text

// LOGOS Math Utils — вычисления резонанса
// Автор: LOGOS Core Dev Team

pub fn calculate_sigma(t: f64) -> Vec<f64> {
    let freqs = vec![7.83, 1.618, 432.0, 864.0, 3456.0];
    let amps = vec![1.0, 0.8, 0.5, 0.3, 0.1];
    freqs
        .iter()
        .zip(amps.iter())
        .map(|(&f, &a)| a * (2.0 * std::f64::consts::PI * f * t).sin())
        .collect()
}

```


## FILE: src/utils/types.rs  (size=215b)
```text

// LOGOS Types — общие типы для системы
// Автор: LOGOS Core Dev Team

#[derive(Debug, Clone, Copy)]
pub enum ResonanceMode {
    Passive,
    Amplified,
    SelfAdjusting,
    Chaotic,
}

```


## FILE: tools/admin_cli.sh  (size=5214b)
```text
#!/usr/bin/env bash
set -euo pipefail

NODE_URL="${NODE_URL:-http://127.0.0.1:8080}"

# --- helpers ---
get_env() {
  systemctl show -p Environment logos-node.service \
    | sed -n 's/^Environment=//p' \
    | tr ' ' '\n' \
    | sed 's/"//g'
}

ENV_CACHE="$(get_env || true)"
get_var() { echo "$ENV_CACHE" | sed -n "s/^$1=//p" | head -n1; }

AK="${AK:-$(get_var LRB_ADMIN_KEY || true)}"
BK="${BK:-$(get_var LRB_BRIDGE_KEY || true)}"

require_admin_key() {
  if [[ -z "${AK:-}" || "$AK" == "CHANGE_ADMIN_KEY" ]]; then
    echo "[!] LRB_ADMIN_KEY не задан или дефолтный. Укажи AK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}
require_bridge_key() {
  if [[ -z "${BK:-}" || "$BK" == "CHANGE_ME" ]]; then
    echo "[!] LRB_BRIDGE_KEY не задан или дефолтный. Укажи BK=... в окружении или в keys.conf" >&2
    exit 1
  fi
}

jq_or_cat() {
  if command -v jq >/dev/null 2>&1; then jq .; else cat; fi
}

usage() {
cat <<'EOF'
admin_cli.sh — удобные команды для LOGOS LRB (prod)

ENV:
  NODE_URL=http://127.0.0.1:8080     # адрес ноды (по умолчанию)
  AK=<admin-key>                     # можно переопределить, иначе берется из systemd
  BK=<bridge-key>                    # можно переопределить, иначе берется из systemd

Команды:
  health                      — /healthz
  head                        — /head
  node-info                   — /node/info
  validators                  — /admin/validators
  metrics [grep]              — /metrics (опциональный grep)

  snapshot-json               — GET /admin/snapshot (требует AK)
  snapshot-file [name]        — GET /admin/snapshot/file?name=NAME (требует AK)
  restore <abs_path.json>     — POST /admin/restore (требует AK)

  deposit <rid> <amount> <ext_txid>         — POST /bridge/deposit (требует BK)
  redeem  <rid> <amount> <request_id>       — POST /bridge/redeem (требует BK)
  verify  <ticket> <vk_b58> <signature_b64> — POST /bridge/verify

  account-txs <rid> [limit]   — GET /account/:rid/txs?limit=N

Примеры:
  ./admin_cli.sh head
  ./admin_cli.sh validators
  AK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_ADMIN_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh snapshot-json
  BK=$(systemctl show -p Environment logos-node.service | sed -n 's/.*LRB_BRIDGE_KEY=\([^ ]*\).*/\1/p') \
    ./admin_cli.sh deposit RID_A 12345 ext-1
EOF
}

cmd="${1:-}"
case "$cmd" in
  ""|-h|--help|help) usage; exit 0 ;;
esac
shift || true

case "$cmd" in
  health)
    curl -s "$NODE_URL/healthz" | jq_or_cat
    ;;

  head)
    curl -s "$NODE_URL/head" | jq_or_cat
    ;;

  node-info)
    curl -s "$NODE_URL/node/info" | jq_or_cat
    ;;

  validators)
    curl -s "$NODE_URL/admin/validators" | jq_or_cat
    ;;

  metrics)
    body="$(curl -s "$NODE_URL/metrics")"
    if [[ $# -gt 0 ]]; then echo "$body" | grep -E "$*" || true; else echo "$body"; fi
    ;;

  snapshot-json)
    require_admin_key
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot" | jq_or_cat
    ;;

  snapshot-file)
    require_admin_key
    name="${1:-snap-$(date +%s).json}"
    curl -s -H "X-Admin-Key: $AK" "$NODE_URL/admin/snapshot/file?name=$name" | jq_or_cat
    ;;

  restore)
    require_admin_key
    file="${1:-}"
    [[ -z "$file" ]] && { echo "[!] usage: restore /var/lib/logos/snapshots/<file>.json" >&2; exit 1; }
    curl -s -X POST -H "content-type: application/json" -H "X-Admin-Key: $AK" \
      "$NODE_URL/admin/restore" \
      -d "{\"file\":\"$file\"}" | jq_or_cat
    ;;

  deposit)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; xtx="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$xtx" ]] && { echo "[!] usage: deposit <rid> <amount> <ext_txid>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/deposit" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"ext_txid\":\"$xtx\"}" | jq_or_cat
    ;;

  redeem)
    require_bridge_key
    rid="${1:-}"; amt="${2:-}"; reqid="${3:-}"
    [[ -z "$rid" || -z "$amt" || -z "$reqid" ]] && { echo "[!] usage: redeem <rid> <amount> <request_id>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/redeem" \
      -H "content-type: application/json" -H "X-Bridge-Key: $BK" \
      -d "{\"rid\":\"$rid\",\"amount\":$amt,\"request_id\":\"$reqid\"}" | jq_or_cat
    ;;

  verify)
    ticket="${1:-}"; vk_b58="${2:-}"; sig_b64="${3:-}"
    [[ -z "$ticket" || -z "$vk_b58" || -z "$sig_b64" ]] && { echo "[!] usage: verify <ticket> <vk_b58> <signature_b64>" >&2; exit 1; }
    curl -s -X POST "$NODE_URL/bridge/verify" \
      -H "content-type: application/json" \
      -d "{\"ticket\":\"$ticket\",\"vk_b58\":\"$vk_b58\",\"signature_b64\":\"$sig_b64\"}" | jq_or_cat
    ;;

  account-txs)
    rid="${1:-}"; limit="${2:-100}"
    [[ -z "$rid" ]] && { echo "[!] usage: account-txs <rid> [limit]" >&2; exit 1; }
    curl -s "$NODE_URL/account/$rid/txs?limit=$limit" | jq_or_cat
    ;;

  *)
    echo "[!] unknown command: $cmd" >&2
    usage
    exit 1
    ;;
esac

```


## FILE: tools/go_test/main.go  (size=3201b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

// Конфиг
const defaultNode = "http://127.0.0.1:8080"

// ВАЖНО: порядок полей ДОЛЖЕН соответствовать серверу:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"` // base64(pk)
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}
	return v
}

func httpJSON(method, url string, body any) ([]byte, int) {
	var reqBody io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		reqBody = bytes.NewReader(b)
	}
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		panic(err)
	}
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		panic(err)
	}
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" {
		node = defaultNode
	}
	fmt.Println("[*] Node:", node)

	// 1) Генерим ключи Ed25519
	pub, priv, err := ed25519.GenerateKey(rand.Reader)
	if err != nil {
		panic(err)
	}
	rid := base58.Encode(pub)
	fmt.Println("[*] RID:", rid)

	// 2) Каноничное сообщение по порядку сервера
	canon := canonMsg{
		Amount:    12345,
		From:      rid,
		Nonce:     1,
		PublicKey: base64.StdEncoding.EncodeToString(pub),
		To:        rid, // отправим самому себе
	}
	canonBytes := must(json.Marshal(canon))
	fmt.Printf("[*] CANON (client hex): %x\n", canonBytes)

	// 3) Подпись
	sig := ed25519.Sign(priv, canonBytes)
	sigB64 := base64.StdEncoding.EncodeToString(sig)

	// 4) Запрос submit_tx
	req := submitTx{
		From:         canon.From,
		To:           canon.To,
		Amount:       canon.Amount,
		Nonce:        canon.Nonce,
		PublicKeyB58: base58.Encode(pub),
		SignatureB64: sigB64,
	}

	fmt.Println("[*] GET /healthz")
	hb, _ := httpJSON("GET", node+"/healthz", nil)
	fmt.Println(string(hb))

	fmt.Println("[*] GET /head (before)")
	headBefore, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headBefore))

	fmt.Println("[*] POST /submit_tx")
	resp, code := httpJSON("POST", node+"/submit_tx", req)
	fmt.Println("status:", code, "body:", string(resp))

	// Подождём продюсер блока
	time.Sleep(2 * time.Second)

	fmt.Println("[*] GET /head (after)")
	headAfter, _ := httpJSON("GET", node+"/head", nil)
	fmt.Println(string(headAfter))

	fmt.Println("[*] GET /balance/:rid")
	bal, _ := httpJSON("GET", node+"/balance/"+rid, nil)
	fmt.Println(string(bal))

	fmt.Println("[*] Done")
}

```


## FILE: tools/go_test/two_rids.go  (size=3944b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	base58 "github.com/mr-tron/base58/base58"
)

const defaultNode = "http://127.0.0.1:8080"

// порядок канонического сообщения на сервере:
// amount, from, nonce, public_key, to
type canonMsg struct {
	Amount    uint64 `json:"amount"`
	From      string `json:"from"`
	Nonce     uint64 `json:"nonce"`
	PublicKey string `json:"public_key"`
	To        string `json:"to"`
}

type submitTx struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
	SignatureB64 string `json:"signature_b64"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func httpJSON(method, url string, body any) ([]byte, int) {
	var rd io.Reader
	if body != nil {
		b := must(json.Marshal(body))
		rd = bytes.NewReader(b)
	}
	req := must(http.NewRequest(method, url, rd))
	if body != nil {
		req.Header.Set("content-type", "application/json")
	}
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func httpSimple(method, url string) ([]byte, int) {
	req := must(http.NewRequest(method, url, nil))
	client := &http.Client{Timeout: 10 * time.Second}
	resp := must(client.Do(req))
	defer resp.Body.Close()
	data, _ := io.ReadAll(resp.Body)
	return data, resp.StatusCode
}

func main() {
	node := os.Getenv("LRB_NODE")
	if node == "" { node = defaultNode }
	fmt.Println("[*] Node:", node)

	// Генерим A и B (ключи, RID)
	pubA, privA, _ := ed25519.GenerateKey(rand.Reader)
	ridA := base58.Encode(pubA)
	pubB, _, _ := ed25519.GenerateKey(rand.Reader)
	ridB := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", ridA)
	fmt.Println("[*] RID_B:", ridB)

	// 0) Краник для A (DEV режим должен быть включён: LRB_DEV=1 в сервисе)
	faucetURL := fmt.Sprintf("%s/faucet/%s/%d", node, ridA, 1_000_000)
	if b, code := httpSimple("POST", faucetURL); code == 200 {
		fmt.Println("[*] faucet ok:", string(b))
	} else {
		fmt.Println("[!] faucet failed code:", code, "body:", string(b))
	}

	// 1) Head/balances до
	fmt.Println("[*] GET /head (before)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (before)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	// 2) Канон по серверу
	amount := uint64(777)
	nonce  := uint64(1)
	canon := canonMsg{
		Amount:    amount,
		From:      ridA,
		Nonce:     nonce,
		PublicKey: base64.StdEncoding.EncodeToString(pubA),
		To:        ridB,
	}
	canonBytes := must(json.Marshal(canon))
	sig := ed25519.Sign(privA, canonBytes)

	req := submitTx{
		From:         ridA,
		To:           ridB,
		Amount:       amount,
		Nonce:        nonce,
		PublicKeyB58: base58.Encode(pubA),
		SignatureB64: base64.StdEncoding.EncodeToString(sig),
	}

	fmt.Println("[*] POST /submit_tx  A->B 777")
	if resp, code := httpJSON("POST", node+"/submit_tx", req); true {
		fmt.Println("status:", code, "body:", string(resp))
	}

	// 3) Ждём слот продюсера
	time.Sleep(1500 * time.Millisecond)

	// 4) Head/balances после
	fmt.Println("[*] GET /head (after)")
	if b, _ := httpSimple("GET", node+"/head"); len(b) > 0 { fmt.Println(string(b)) }

	fmt.Println("[*] GET balances (after)")
	if b, _ := httpSimple("GET", node+"/balance/"+ridA); len(b) > 0 { fmt.Println("A:", string(b)) }
	if b, _ := httpSimple("GET", node+"/balance/"+ridB); len(b) > 0 { fmt.Println("B:", string(b)) }

	fmt.Println("[*] Done")
}

```


## FILE: tools/load/load_submit_tx.go  (size=7096b)
```text
package main

import (
	"bytes"
	"crypto/ed25519"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"math/big"
	"net/http"
	"os"
	"sync"
	"sync/atomic"
	"time"

	"github.com/mr-tron/base58/base58"
)

/*
Нагрузчик батчей с корректной подписью:
— на каждую tx запрашивает у ноды /debug_canon (canon_hex) и подписывает её,
— отправляет на /submit_tx_batch,
— учитывает частичные приёмы (accepted < batch).
*/

type SubmitTx struct {
	From          string `json:"from"`
	To            string `json:"to"`
	Amount        uint64 `json:"amount"`
	Nonce         uint64 `json:"nonce"`
	PubKeyB58     string `json:"public_key_b58"`
	SignatureB64  string `json:"signature_b64"`
}
type DebugCanonReq struct {
	From         string `json:"from"`
	To           string `json:"to"`
	Amount       uint64 `json:"amount"`
	Nonce        uint64 `json:"nonce"`
	PublicKeyB58 string `json:"public_key_b58"`
}
type DebugCanonResp struct {
	CanonHex   string `json:"canon_hex"`
	ServerTxID string `json:"server_tx_id"`
}
type BatchResp struct {
	Accepted          int `json:"accepted"`
	Rejected          int `json:"rejected"`
	LGNCostMicrounits int `json:"lgn_cost_microunits"`
}

func must[T any](v T, err error) T { if err != nil { panic(err) }; return v }

func postJSON(cli *http.Client, url string, payload any) (*http.Response, []byte, error) {
	j, _ := json.Marshal(payload)
	req, _ := http.NewRequest("POST", url, bytes.NewReader(j))
	req.Header.Set("Content-Type", "application/json")
	resp, err := cli.Do(req)
	if err != nil { return nil, nil, err }
	body, _ := io.ReadAll(resp.Body)
	resp.Body.Close()
	return resp, body, nil
}

func fetchCanon(cli *http.Client, node string, r DebugCanonReq) ([]byte, string, error) {
	resp, body, err := postJSON(cli, node+"/debug_canon", r)
	if err != nil { return nil, "", err }
	if resp.StatusCode/100 != 2 {
		return nil, "", fmt.Errorf("debug_canon status=%d body=%s", resp.StatusCode, string(body))
	}
	var dc DebugCanonResp
	if err := json.Unmarshal(body, &dc); err != nil {
		return nil, "", err
	}
	raw, err := hex.DecodeString(dc.CanonHex)
	if err != nil { return nil, "", fmt.Errorf("bad canon_hex: %v", err) }
	return raw, dc.ServerTxID, nil
}

func sleepToRate(start time.Time, sent uint64, rate int) {
	if rate <= 0 { return }
	elapsed := time.Since(start)
	should := time.Duration(float64(sent)/float64(rate) * float64(time.Second))
	if should > elapsed { time.Sleep(should - elapsed) }
}

func main() {
	node := flag.String("node", "http://127.0.0.1:8080", "LOGOS node base URL")
	concurrency := flag.Int("c", 200, "concurrency (workers)")
	dur := flag.Duration("d", time.Minute, "test duration")
	rate := flag.Int("rate", 5000, "target submit rate (tx/s)")
	amount := flag.Uint64("amount", 1, "tx amount (μLGN)")
	nonce0 := flag.Uint64("nonce0", 1, "starting nonce")
	faucet := flag.Uint64("faucet", 5_000_000, "faucet top-up for RID_A (DEV)")
	batch := flag.Int("batch", 100, "batch size for /submit_tx_batch")
	flag.Parse()

	fmt.Println("NODE   :", *node)
	fmt.Println("CONC   :", *concurrency)
	fmt.Println("DUR    :", *dur)
	fmt.Println("RATE   :", *rate, "tx/s")
	fmt.Println("AMOUNT :", *amount)
	fmt.Println("NONCE0 :", *nonce0)
	fmt.Println("FAUCET :", *faucet)
	fmt.Println("BATCH  :", *batch)

	// ключи A (отправитель) и B (получатель)
	_, privA, _ := ed25519.GenerateKey(rand.Reader)
	pubA := privA.Public().(ed25519.PublicKey)
	RID_A := base58.Encode(pubA)

	_, privB, _ := ed25519.GenerateKey(rand.Reader)
	_ = privB
	pubB := privB.Public().(ed25519.PublicKey)
	RID_B := base58.Encode(pubB)

	fmt.Println("[*] RID_A:", RID_A)
	fmt.Println("[*] RID_B:", RID_B)

	cli := &http.Client{ Timeout: 10 * time.Second }

	// faucet
	if *faucet > 0 {
		furl := fmt.Sprintf("%s/faucet/%s/%d", *node, RID_A, *faucet)
		resp, err := cli.Post(furl, "application/json", nil)
		if err != nil { fmt.Println("[!] faucet error:", err); os.Exit(1) }
		io.Copy(io.Discard, resp.Body); resp.Body.Close()
	}

	// дросселирование
	per := time.Second / time.Duration(*rate)
	if per == 0 { per = time.Millisecond }

	start := time.Now()
	stopAt := start.Add(*dur)

	// разнести nonce по потокам
	nonceStride := uint64(1 << 32)
	rOff, _ := rand.Int(rand.Reader, big.NewInt(int64(nonceStride)))
	baseOffset := uint64(rOff.Int64())

	var sent, ok uint64
	var wg sync.WaitGroup
	wg.Add(*concurrency)

	var barrier sync.WaitGroup
	barrier.Add(*concurrency)

	var firstErrOnce sync.Once

	for w := 0; w < *concurrency; w++ {
		w := w
		go func() {
			defer wg.Done()
			barrier.Done()
			barrier.Wait()

			localNonce := *nonce0 + baseOffset + uint64(w)*nonceStride
			timer := time.NewTimer(per)

			for time.Now().Before(stopAt) {
				k := *batch
				if k < 1 { k = 1 }

				reqs := make([]SubmitTx, 0, k)
				for i := 0; i < k; i++ {
					n := localNonce + uint64(i)
					// 1) canon от сервера
					dcReq := DebugCanonReq{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PublicKeyB58: base58.Encode(pubA),
					}
					canon, _, err := fetchCanon(cli, *node, dcReq)
					if err != nil {
						firstErrOnce.Do(func() { fmt.Println("[!] debug_canon error:", err) })
						continue
					}
					// 2) подпись
					sig := ed25519.Sign(privA, canon)
					reqs = append(reqs, SubmitTx{
						From: RID_A, To: RID_B, Amount: *amount, Nonce: n,
						PubKeyB58: base58.Encode(pubA),
						SignatureB64: base64.StdEncoding.EncodeToString(sig),
					})
				}

				if len(reqs) == 0 {
					// троттлинг
					select {
					case <-timer.C:
						timer.Reset(per)
					default:
						sleepToRate(start, atomic.LoadUint64(&sent), *rate)
					}
					continue
				}

				// отправка батча
				resp, body, err := postJSON(cli, *node+"/submit_tx_batch", reqs)
				atomic.AddUint64(&sent, uint64(len(reqs)))

				if err != nil {
					firstErrOnce.Do(func() { fmt.Println("[!] batch post error:", err) })
				} else if resp.StatusCode/100 == 2 {
					var br BatchResp
					if json.Unmarshal(body, &br) == nil {
						atomic.AddUint64(&ok, uint64(br.Accepted)) // NEW: учитываем частичный приём
					} else {
						// если не распарсили, считаем всё принято (редко)
						atomic.AddUint64(&ok, uint64(len(reqs)))
					}
				} else {
					firstErrOnce.Do(func() {
						fmt.Printf("[!] submit_tx_batch status=%d body=%s\n", resp.StatusCode, string(body))
					})
				}

				localNonce += uint64(len(reqs))

				// троттлинг
				select {
				case <-timer.C:
					timer.Reset(per)
				default:
					sleepToRate(start, atomic.LoadUint64(&sent), *rate)
				}
			}
		}()
	}

	wg.Wait()
	el := time.Since(start).Seconds()
	total := atomic.LoadUint64(&sent)
	okCnt := atomic.LoadUint64(&ok)
	rps := float64(total) / math.Max(el, 0.001)
	fmt.Printf("\n=== RESULT ===\n sent=%d ok=%d err=%d  (elapsed=%.1fs, ~%.0f tx/s)\n", total, okCnt, total-okCnt, el, rps)
}

```


## FILE: tools/lrb_audit.sh  (size=3026b)
```text
#!/usr/bin/env bash
set -euo pipefail
cd /root/logos_lrb

REPORT="AUDIT_REPORT.md"
echo "# LOGOS LRB — Аудит модулей" > "$REPORT"
echo "_$(date -u)_ UTC" >> "$REPORT"
echo >> "$REPORT"

sha() { sha256sum "$1" | awk '{print $1}'; }

audit_rust() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_unsafe s_unwrap s_expect s_panic s_todo s_dbg
  s_unsafe=$(grep -c '\<unsafe\>' "$f" || true)
  s_unwrap=$(grep -c 'unwrap(' "$f" || true)
  s_expect=$(grep -c 'expect(' "$f" || true)
  s_panic=$(grep -c 'panic!(' "$f" || true)
  s_dbg=$(grep -Ec 'dbg!|println!' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME\|todo!\|unimplemented!' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Rust)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: unsafe=$s_unsafe, unwrap=$s_unwrap, expect=$s_expect, panic=$s_panic, dbg/println=$s_dbg"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_py() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  local s_eval s_exec s_pickle s_subp s_todo
  s_eval=$(grep -c '\<eval\>' "$f" || true)
  s_exec=$(grep -c '\<exec\>' "$f" || true)
  s_pickle=$(grep -c 'pickle' "$f" || true)
  s_subp=$(grep -c 'subprocess' "$f" || true)
  s_todo=$(grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    /' || true)
  {
    echo "### \`$f\` (Python)"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    echo "- red-flags: eval=$s_eval, exec=$s_exec, pickle=$s_pickle, subprocess=$s_subp"
    [ -n "$s_todo" ] && echo "- TODO/FIXME:"$'\n'"$s_todo"
    echo
  } >> "$REPORT"
}

audit_other() {
  local f="$1"
  local lines; lines=$(wc -l <"$f")
  {
    echo "### \`$f\`"
    echo "- lines: $lines | sha256: \`$(sha "$f")\`"
    grep -ni 'TODO\|FIXME' "$f" | sed 's/^/    - /' || true
    echo
  } >> "$REPORT"
}

echo "## Files in modules/" >> "$REPORT"
find modules -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.tsx|*.ts|*.yaml|*.yml|*.md) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Files in core/" >> "$REPORT"
find core -maxdepth 1 -type f | sort | while read -r f; do
  case "$f" in
    *.rs) audit_rust "$f" ;;
    *.py) audit_py "$f" ;;
    *.yaml|*.yml|*.md|*.toml) audit_other "$f" ;;
    *) audit_other "$f" ;;
  esac
done
echo >> "$REPORT"

echo "## Quick checks" >> "$REPORT"
{
  echo '```'
  cargo --version 2>/dev/null || true
  python3 --version 2>/dev/null || true
  echo '```'
  echo
} >> "$REPORT"

if [ -f Cargo.toml ]; then
  echo "### cargo check" >> "$REPORT"
  ( cargo check 2>&1 || true ) | sed 's/^/    /' >> "$REPORT"
  echo >> "$REPORT"
fi

# Python syntax check
: > py_err.log || true
find core modules -name '*.py' -print0 | xargs -0 -I{} sh -c 'python3 -m py_compile "{}" 2>>py_err.log' || true
if [ -s py_err.log ]; then
  echo "### python syntax errors" >> "$REPORT"
  sed 's/^/    /' py_err.log >> "$REPORT"
  echo >> "$REPORT"
fi

echo "Done -> $REPORT"

```


## FILE: tools/test_tx.sh  (size=1841b)
```text
#!/usr/bin/env bash
set -euo pipefail

NODE="${NODE:-http://127.0.0.1:8080}"

echo "[*] Installing deps (jq, pip, pynacl, base58)..."
apt-get update -y >/dev/null 2>&1 || true
apt-get install -y jq python3-pip >/dev/null 2>&1 || true
python3 -m pip install --quiet --no-input pynacl base58

echo "[*] Generating key, RID and signed tx..."
PYOUT="$(python3 - <<'PY'
import json, base64, base58
from nacl.signing import SigningKey

sk = SigningKey.generate()
vk = sk.verify_key
pk = bytes(vk)
rid = base58.b58encode(pk).decode()

amount = 12345
nonce  = 1

msg_obj = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key": base64.b64encode(pk).decode()
}
msg = json.dumps(msg_obj, separators=(',',':')).encode()
sig = sk.sign(msg).signature

tx = {
    "from": rid,
    "to": rid,
    "amount": amount,
    "nonce": nonce,
    "public_key_b58": base58.b58encode(pk).decode(),
    "signature_b64": base64.b64encode(sig).decode()
}

print(json.dumps({"rid": rid, "tx": tx}))
PY
)"

RID="$(echo "$PYOUT" | jq -r .rid)"
TX="$(echo "$PYOUT" | jq -c .tx)"

echo "[*] Healthz:"
curl -s "$NODE/healthz" | jq .

echo "[*] Head before:"
curl -s "$NODE/head" | jq .

echo "[*] Submitting tx..."
RESP="$(curl -s -X POST "$NODE/submit_tx" -H 'content-type: application/json' -d "$TX")" || true
echo "$RESP" | jq . || true

# Если узел отклонил (например, nonce/balance), покажем причину и выйдем
if ! echo "$RESP" | jq -e '.accepted == true' >/dev/null 2>&1 ; then
  echo "[!] TX not accepted. Response above."
  exit 1
fi

TXID="$(echo "$RESP" | jq -r .tx_id)"
echo "[*] tx_id=$TXID"

echo "[*] Waiting 2s for block producer..."
sleep 2

echo "[*] Head after:"
curl -s "$NODE/head" | jq .

echo "[*] Balance for RID:"
curl -s "$NODE/balance/$RID" | jq .

echo "[*] Done."

```


## FILE: wallet-proxy/app.py  (size=7115b)
```text
import os, json, time, asyncio
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True)
    rid = Column(String, index=True, nullable=False)
    token = Column(String, nullable=False)
    network = Column(String, nullable=False)
    index = Column(Integer, nullable=False, default=0)
    address = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda:int(time.time()))
Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True)
    txid = Column(String, unique=True, nullable=False)
    rid = Column(String, index=True)
    token = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
        if w3.is_connected():
            USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable"); w3=None
    except Exception as e:
        print("WARN web3 init error:", e); w3=None; USDT=None

# ====== HTTP helper ======
async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(CORSMiddleware, allow_origins=CORS if CORS else ["*"],
                   allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
class TopupResponse(BaseModel):
    rid: str; token: str; network: str; address: str
class WithdrawRequest(BaseModel):
    rid: str; token: Literal["USDT"]="USDT"; network: Literal["ETH"]="ETH"
    amount: int; to_address: str; request_id: str
class QuoteRequest(BaseModel):
    from_token: str; to_token: str; amount: int
class QuoteResponse(BaseModel):
    price: float; expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ   = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR= Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return app.responses.Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# ====== Endpoints ======
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3: raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")
    deposit_address = w3.eth.account.from_key(HOT_PK).address
    with Session(engine) as s:
        dm = s.execute(select(DepositMap).where(
            DepositMap.rid==req.rid, DepositMap.token==req.token, DepositMap.network==req.network
        )).scalar_one_or_none()
        if dm is None:
            s.add(DepositMap(rid=req.rid, token=req.token, network=req.network, address=deposit_address))
            s.commit()
    return TopupResponse(rid=req.rid, token=req.token, network=req.network, address=deposit_address)

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount<=0: raise HTTPException(400,"amount<=0")
        if not w3 or not USDT: raise HTTPException(503, "ETH RPC not connected")
        acct = w3.eth.account.from_key(HOT_PK)
        # redeem
        hdr = {"X-Bridge-Key": BRIDGE_KEY} if not BRIDGE_KEY.startswith("ey") else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem", {
            "rid": req.rid, "amount": req.amount, "request_id": req.request_id
        }, hdr)
        if st//100 != 2: raise HTTPException(st, f"bridge redeem failed: {data}")
        # ERC-20
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(Web3.to_checksum_address(req.to_address), int(req.amount)).build_transaction({
            "chainId": w3.eth.chain_id, "from": acct.address, "nonce": nonce,
            "gas": 90000, "maxFeePerGas": w3.to_wei("30","gwei"), "maxPriorityFeePerGas": w3.to_wei("1","gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()
        with Session(engine) as s: s.add(SeenTx(txid=tx_hash, rid=req.rid, token=req.token, network=req.network)); s.commit()
        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc(); raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc(); raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```


## FILE: wallet-proxy/requirements.txt  (size=1147b)
```text
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```


## FILE: wallet-proxy/scanner.py  (size=5538b)
```text
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```


## FILE: www/wallet/index.html  (size=7993b)
```text
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS LRB — Web Wallet</title>
  <style>
    :root{--bg:#0b0e12;--fg:#e8eef4;--muted:#9aa8b3;--card:#121821;--acc:#78e08f;--warn:#e77;--ok:#8f8;--link:#79a6ff}
    *{box-sizing:border-box} body{background:var(--bg);color:var(--fg);font:15px/1.5 system-ui,Arial,sans-serif;margin:0}
    header{padding:18px 20px;background:#0e131a;position:sticky;top:0;border-bottom:1px solid #1f2834}
    h1{margin:0;font-size:18px} a{color:var(--link)} main{max-width:1080px;margin:18px auto;padding:0 16px}
    .grid{display:grid;gap:16px;grid-template-columns:repeat(auto-fit,minmax(320px,1fr))}
    .card{background:var(--card);border:1px solid #1f2834;border-radius:14px;padding:16px}
    .row{display:flex;gap:8px;flex-wrap:wrap} .mono{font-family:ui-monospace,Consolas,monospace}
    label{display:block;margin:6px 0 2px;color:var(--muted)} input,button,select,textarea{background:#0c1219;color:var(--fg);
      border:1px solid #243141;border-radius:10px;padding:9px 10px} input,select,textarea{width:100%}
    button{cursor:pointer} button.primary{background:#112236;border-color:#213f66} button.ok{background:#103418;border-color:#1c5c2b}
    .muted{color:var(--muted)} .ok{color:var(--ok)} .warn{color:var(--warn)} .kvs div{display:flex;justify-content:space-between}
    .kvs div span:first-child{color:var(--muted)} .pill{display:inline-block;border:1px solid #2a394d;padding:2px 8px;border-radius:999px}
    table{width:100%;border-collapse:collapse} th,td{border-bottom:1px solid #1f2834;padding:8px 6px;text-align:left}
    .small{font-size:12px} .right{text-align:right}
    .tabs{display:flex;gap:6px;margin-bottom:8px} .tabs button{padding:6px 10px;border-radius:8px;border:1px solid #2a394d;background:#0d141c}
    .tabs button.active{background:#1a2635}
  </style>
</head>
<body>
  <header><h1>LOGOS LRB — Web Wallet</h1></header>
  <main class="grid">

    <!-- Сеть / нода -->
    <section class="card">
      <h3>Сеть / Нода</h3>
      <label>Node URL</label>
      <input id="nodeUrl" placeholder="http://45.159.248.232:8080"/>
      <div class="row">
        <button id="saveNode" class="primary">Сохранить</button>
        <button id="ping">Проверить /healthz</button>
        <span id="pingRes" class="mono"></span>
      </div>
      <div class="kvs small" style="margin-top:8px">
        <div><span>height</span><span id="headHeight" class="mono">-</span></div>
        <div><span>finalized</span><span id="headFinal" class="mono">-</span></div>
        <div><span>hash</span><span id="headHash" class="mono">-</span></div>
      </div>
    </section>

    <!-- Ключи -->
    <section class="card">
      <h3>Ключи (Ed25519, локально)</h3>
      <div class="row">
        <button id="gen" class="primary">Сгенерировать</button>
        <button id="wipe">Удалить из браузера</button>
      </div>
      <label>RID (base58)</label>
      <div id="rid" class="mono small"></div>
      <label>Публичный ключ (base58)</label>
      <div id="pk58" class="mono small"></div>
      <details style="margin-top:8px"><summary class="muted">Экспорт/импорт</summary>
        <label>Приватный ключ (hex)</label>
        <textarea id="skHex" rows="3" class="mono" placeholder="hex..."></textarea>
        <div class="row"><button id="importSk">Импорт</button><button id="exportSk">Экспорт</button><span id="impRes" class="mono"></span></div>
      </details>
    </section>

    <!-- Состояние -->
    <section class="card">
      <h3>Состояние аккаунта</h3>
      <div class="row"><button id="refreshState">Обновить</button><span id="stateRes" class="mono"></span></div>
      <div class="kvs">
        <div><span>Баланс (μLGN)</span><span id="balance" class="mono">0</span></div>
        <div><span>Nonce</span><span id="nonce" class="mono">0</span></div>
      </div>
    </section>

    <!-- Перевод -->
    <section class="card">
      <div class="tabs"><button id="tabSend" class="active">Перевод</button><button id="tabBatch">Батч</button></div>

      <div id="panelSend">
        <label>Получатель (RID)</label><input id="toRid" placeholder="RID получателя"/>
        <label>Сумма (μLGN)</label><input id="amount" type="number" value="1"/>
        <div class="row"><button id="send" class="ok">Отправить</button><span id="sendRes" class="mono small"></span></div>
      </div>

      <div id="panelBatch" style="display:none">
        <label>Список получателей (по одному RID в строке)</label>
        <textarea id="batchList" rows="6" placeholder="RID1&#10;RID2&#10;..."></textarea>
        <label>Сумма на каждого (μLGN)</label><input id="batchAmount" type="number" value="1"/>
        <label>Размер батча (tx за один запрос)</label><input id="batchSize" type="number" value="50"/>
        <div class="row"><button id="sendBatch" class="ok">Отправить батч</button><span id="batchRes" class="mono small"></span></div>
      </div>
    </section>

    <!-- История / Недавние -->
    <section class="card">
      <h3>История</h3>
      <div class="row"><button id="loadTxs">Загрузить</button><button id="nextTxs">Дальше</button><span id="histRes" class="mono small"></span></div>
      <table id="hist"><thead><tr><th>H</th><th>Tx</th><th>Dir</th><th class="right">Amount</th><th>Counterparty</th></tr></thead><tbody></tbody></table>
    </section>

    <section class="card">
      <h3>Недавние</h3>
      <div class="row"><button id="recentBlocks">Блоки</button><button id="recentTxs">Tx</button><span id="recentRes" class="mono small"></span></div>
      <table id="recent"><thead><tr><th>Тип</th><th>Данные</th></tr></thead><tbody></tbody></table>
    </section>

    <!-- Мост (для операторов/интегратора) -->
    <section class="card">
      <h3>rToken мост (оператор)</h3>
      <label>X-Bridge-Key (или Bearer JWT)</label><input id="bridgeKey" placeholder="введите ключ или JWT (опц.)"/>
      <label>RID</label><input id="bridgeRid" placeholder="RID для зачисления/списания"/>
      <div class="row">
        <div style="flex:1">
          <label>Deposit (μrLGN)</label><input id="depAmount" type="number" value="1000"/>
          <label>ext_txid</label><input id="depExt" placeholder="например, txid внешней сети"/>
          <button id="deposit" class="primary">Deposit</button>
        </div>
        <div style="flex:1">
          <label>Redeem (μrLGN)</label><input id="redAmount" type="number" value="500"/>
          <label>request_id</label><input id="redReq" placeholder="уникальный ID запроса"/>
          <button id="redeem" class="primary">Redeem</button>
        </div>
      </div>
      <div class="small mono" id="bridgeRes"></div>
    </section>

    <!-- Админ-токен -->
    <section class="card">
      <h3>Админ (JWT)</h3>
      <label>X-Admin-Key</label><input id="adminKey" placeholder="только для операторов"/>
      <div class="row"><label class="muted">TTL (сек)</label><input id="adminTtl" type="number" value="600" style="width:120px"/>
        <button id="mintAdminToken">Получить токен</button><span id="adminRes" class="mono small"></span></div>
    </section>

  </main>

  <!-- noble-ed25519 + bs58 CDN -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/@noble/ed25519@1.7.3/+esm"></script>
  <script type="module" src="https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm"></script>
  <script type="module" src="./wallet.js"></script>
</body>
</html>

```


## FILE: www/wallet/wallet.js  (size=10848b)
```text
import * as ed from "https://cdn.jsdelivr.net/npm/@noble/ed25519@1.7.3/+esm";
import bs58 from "https://cdn.jsdelivr.net/npm/bs58@5.0.0/+esm";

/* =============== helpers =============== */
const $ = (id)=>document.getElementById(id);
const enc = new TextEncoder();

const st = {
  node: localStorage.getItem("lrb_node") || "http://45.159.248.232:8080",
  skHex: localStorage.getItem("lrb_sk") || "",
  pkHex: localStorage.getItem("lrb_pk") || "",
  cursor_h: null, cursor_seq: null
};

function ridFromPkHex(pkHex){ return bs58.encode(Buffer.from(pkHex,"hex")); }
function toB64(u8){ return btoa(String.fromCharCode(...u8)); }

function canonicalBytes(from, to, amount, nonce, pkHex) {
  const pk = Buffer.from(pkHex, "hex");
  const a = enc.encode(from), b = enc.encode(to),
        c = enc.encode(String(amount)), d = enc.encode(String(nonce));
  const out = new Uint8Array(a.length+b.length+c.length+d.length+pk.length);
  out.set(a,0); out.set(b,a.length); out.set(c,a.length+b.length);
  out.set(d,a.length+b.length+c.length); out.set(pk,a.length+b.length+c.length+d.length);
  return out;
}

async function getJSON(url, opts={}) {
  const r = await fetch(url, opts);
  if (!r.ok) throw new Error(`HTTP ${r.status}`);
  return await r.json();
}
async function postJSON(url, body, headers={}) {
  const r = await fetch(url, {method:"POST",headers:{'content-type':'application/json',...headers},body:JSON.stringify(body)});
  const t = await r.text();
  try { return { ok:r.ok, status:r.status, body: JSON.parse(t||"{}") }; }
  catch { return { ok:r.ok, status:r.status, body: t }; }
}

/* =============== network / head =============== */
$("nodeUrl").value = st.node;
$("saveNode").onclick = () => { st.node = $("nodeUrl").value.trim(); localStorage.setItem("lrb_node", st.node); alert("Node URL сохранён"); };
$("ping").onclick = async ()=>{
  try {
    const h = await getJSON(`${st.node}/healthz`); $("pingRes").textContent = h.ok?"OK":"ERR";
    const head = await getJSON(`${st.node}/head`);
    $("headHeight").textContent = head.height ?? "-";
    $("headFinal").textContent  = head.finalized ?? "-";
    $("headHash").textContent   = (head.hash||"").slice(0,16)+"…";
  } catch(e){ $("pingRes").textContent = `ERR: ${e.message}`; }
};

/* =============== keys =============== */
function renderKeys(){
  const pkHex = st.pkHex;
  $("pk58").textContent = pkHex? bs58.encode(Buffer.from(pkHex,"hex")) : "";
  $("rid").textContent  = pkHex? ridFromPkHex(pkHex) : "";
  $("skHex").value = st.skHex || "";
}
$("gen").onclick = async ()=>{
  const sk = ed.utils.randomPrivateKey(); const pk = await ed.getPublicKey(sk);
  st.skHex = Buffer.from(sk).toString("hex"); st.pkHex = Buffer.from(pk).toString("hex");
  localStorage.setItem("lrb_sk", st.skHex); localStorage.setItem("lrb_pk", st.pkHex); renderKeys();
};
$("wipe").onclick = ()=>{ localStorage.removeItem("lrb_sk"); localStorage.removeItem("lrb_pk"); st.skHex=""; st.pkHex=""; renderKeys(); };
$("importSk").onclick = async ()=>{
  try{
    const val = $("skHex").value.trim(); if(!val) throw new Error("пусто");
    const sk = Buffer.from(val,"hex"); const pk = await ed.getPublicKey(sk);
    st.skHex = val; st.pkHex = Buffer.from(pk).toString("hex");
    localStorage.setItem("lrb_sk", st.skHex); localStorage.setItem("lrb_pk", st.pkHex); renderKeys();
    $("impRes").textContent = "OK";
  }catch(e){ $("impRes").textContent = "ERR"; }
};
$("exportSk").onclick = ()=>{ $("skHex").value = st.skHex || ""; };

renderKeys();

/* =============== account state =============== */
$("refreshState").onclick = async ()=>{
  $("stateRes").textContent = "";
  if(!st.pkHex) return $("stateRes").textContent = "Нет ключа";
  try{
    const rid = $("rid").textContent;
    const s = await getJSON(`${st.node}/account/${rid}/state`);
    $("balance").textContent = s.balance ?? 0;
    $("nonce").textContent   = s.nonce ?? 0;
    $("stateRes").textContent = "OK";
  }catch(e){ $("stateRes").textContent = `ERR: ${e.message}`; }
};

/* =============== send / batch =============== */
function nextNonce(){ return (parseInt($("nonce").textContent||"0",10) || 0) + 1; }

$("tabSend").onclick = ()=>{ $("panelSend").style.display="block"; $("panelBatch").style.display="none"; $("tabSend").classList.add("active"); $("tabBatch").classList.remove("active"); };
$("tabBatch").onclick= ()=>{ $("panelSend").style.display="none"; $("panelBatch").style.display="block"; $("tabBatch").classList.add("active"); $("tabSend").classList.remove("active"); };

$("send").onclick = async ()=>{
  try{
    if(!st.skHex||!st.pkHex) throw new Error("нет ключей");
    const from = $("rid").textContent.trim(), to=$("toRid").value.trim();
    const amount = parseInt($("amount").value||"0",10); if(!to||!amount) throw new Error("проверь поля");
    const nonce = nextNonce();
    const canon = canonicalBytes(from,to,amount,nonce,st.pkHex);
    const sig = await ed.sign(canon, st.skHex);
    const item = { from,to,amount,nonce, public_key_b58: bs58.encode(Buffer.from(st.pkHex,"hex")), signature_b64: toB64(sig) };
    const r = await postJSON(`${st.node}/submit_tx_batch`, [item]);
    $("sendRes").textContent = r.ok? `OK accepted=${r.body.accepted||0}` : `ERR ${r.status}`;
    // обновим nonce
    await $("refreshState").onclick();
  }catch(e){ $("sendRes").textContent = `ERR: ${e.message}`; }
};

$("sendBatch").onclick = async ()=>{
  try{
    if(!st.skHex||!st.pkHex) throw new Error("нет ключей");
    const from = $("rid").textContent.trim();
    const list = $("batchList").value.split("\n").map(s=>s.trim()).filter(Boolean);
    const amount = parseInt($("batchAmount").value||"0",10);
    const batchSize = parseInt($("batchSize").value||"50",10);
    if(list.length===0 || !amount) throw new Error("укажи получателей и сумму");
    let nonce = nextNonce(), accepted=0, sent=0;
    for(let i=0;i<list.length;i+=batchSize){
      const chunk = list.slice(i,i+batchSize);
      const req = [];
      for(const to of chunk){
        const canon = canonicalBytes(from,to,amount,nonce,st.pkHex);
        const sig   = await ed.sign(canon, st.skHex);
        req.push({ from,to,amount,nonce, public_key_b58: bs58.encode(Buffer.from(st.pkHex,"hex")), signature_b64: toB64(sig) });
        nonce++;
      }
      const r = await postJSON(`${st.node}/submit_tx_batch`, req);
      sent += req.length; if(r.ok) accepted += (r.body.accepted||0);
      $("batchRes").textContent = `sent=${sent} accepted=${accepted}`;
    }
    await $("refreshState").onclick();
  }catch(e){ $("batchRes").textContent = `ERR: ${e.message}`; }
};

/* =============== history / recent =============== */
async function loadAccountTxs(next=false){
  try{
    const rid = $("rid").textContent.trim(), params=[];
    params.push(`limit=20`);
    if(next && st.cursor_h!=null && st.cursor_seq!=null){
      params.push(`cursor_h=${st.cursor_h}`); params.push(`cursor_seq=${st.cursor_seq}`);
    }
    const url = `${st.node}/account/${rid}/txs?`+params.join("&");
    const r = await getJSON(url);
    const tbody = $("hist").querySelector("tbody");
    if(!next) tbody.innerHTML="";
    for(const it of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="mono small">${it.height??""}</td>
                      <td class="mono small">${(it.tx_id||"").slice(0,12)}…</td>
                      <td>${it.dir==-1?"→":"←"}</td>
                      <td class="right mono">${it.amount??0}</td>
                      <td class="mono small">${(it.counterparty||"").slice(0,10)}…</td>`;
      tbody.appendChild(tr);
    }
    st.cursor_h = r.next_cursor_h ?? null;
    st.cursor_seq = r.next_cursor_seq ?? null;
    $("histRes").textContent = r.items?.length ? "OK" : "—";
  }catch(e){ $("histRes").textContent = `ERR: ${e.message}`; }
}
$("loadTxs").onclick = ()=>loadAccountTxs(false);
$("nextTxs").onclick = ()=>loadAccountTxs(true);

$("recentBlocks").onclick = async ()=>{
  try{
    const r = await getJSON(`${st.node}/recent/blocks?limit=10`);
    const tbody = $("recent").querySelector("tbody"); tbody.innerHTML="";
    for(const b of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="pill">Block</td><td class="mono small">h=${b.height} tx=${(b.txs||[]).length} hash=${(b.block_hash||"").slice(0,14)}…</td>`;
      tbody.appendChild(tr);
    }
    $("recentRes").textContent="OK";
  }catch(e){ $("recentRes").textContent = `ERR: ${e.message}`; }
};
$("recentTxs").onclick = async ()=>{
  try{
    const r = await getJSON(`${st.node}/recent/txs?limit=20`);
    const tbody = $("recent").querySelector("tbody"); tbody.innerHTML="";
    for(const t of r.items||[]){
      const tr = document.createElement("tr");
      tr.innerHTML = `<td class="pill">Tx</td><td class="mono small">h=${t.height} tx=${(t.tx_id||"").slice(0,12)}… ${t.from?.slice(0,8)}→${t.to?.slice(0,8)} a=${t.amount}</td>`;
      tbody.appendChild(tr);
    }
    $("recentRes").textContent="OK";
  }catch(e){ $("recentRes").textContent = `ERR: ${e.message}`; }
};

/* =============== bridge (operator) =============== */
function authHeader(val){
  const s = (val||"").trim(); if(!s) return {};
  // Если строка похожа на JWT — отправим как Bearer, иначе X-Bridge-Key
  return s.split(".").length===3 ? {Authorization:`Bearer ${s}`} : {"X-Bridge-Key": s};
}
$("deposit").onclick = async ()=>{
  const key = $("bridgeKey").value, rid = $("bridgeRid").value.trim();
  const amount = parseInt($("depAmount").value||"0",10), ext = $("depExt").value.trim();
  const r = await postJSON(`${st.node}/bridge/deposit`, {rid,amount,ext_txid:ext}, authHeader(key));
  $("bridgeRes").textContent = r.ok ? `deposit OK: r_balance=${r.body.r_balance}` : `ERR ${r.status}`;
};
$("redeem").onclick = async ()=>{
  const key = $("bridgeKey").value, rid = $("bridgeRid").value.trim();
  const amount = parseInt($("redAmount").value||"0",10), req = $("redReq").value.trim();
  const r = await postJSON(`${st.node}/bridge/redeem`, {rid,amount,request_id:req}, authHeader(key));
  $("bridgeRes").textContent = r.ok ? `redeem OK: ticket=${r.body.redeem_ticket.slice(0,18)}…` : `ERR ${r.status}`;
};

/* =============== admin JWT =============== */
$("mintAdminToken").onclick = async ()=>{
  const key = $("adminKey").value.trim(), ttl = parseInt($("adminTtl").value||"600",10);
  const r = await fetch(`${st.node}/admin/token?ttl=${ttl}`, {headers: {"X-Admin-Key": key}});
  const body = await r.json().catch(()=>({}));
  $("adminRes").textContent = r.ok ? `OK token=${(body.token||"").slice(0,16)}…` : `ERR ${r.status}`;
};

/* =============== init =============== */
(async()=>{ await $("ping").onclick(); if(st.pkHex) await $("refreshState").onclick(); })();

```
```


### FILE: /root/logos_lrb/infra/nginx/lrb_wallet.conf

```conf
# Глобальные зоны rate-limit (по IP)
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;
limit_req_zone $binary_remote_addr zone=proxy_zone:10m rate=10r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

server {
    listen 80;
    server_name _;

    # --- Безопасные заголовки ---
    add_header X-Frame-Options        SAMEORIGIN       always;
    add_header X-Content-Type-Options nosniff          always;
    add_header Referrer-Policy        strict-origin-when-cross-origin always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # CSP: только self, без inline/CDN. Разрешаем data: для иконок/картинок в UI.
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;

    # --- Gzip для JSON/JS/CSS/HTML ---
    gzip on;
    gzip_types text/plain text/css application/json application/javascript application/xml;
    gzip_min_length 1024;

    # --- Редирект корня на кошелёк ---
    location = / {
        return 302 /wallet/;
    }

    # --- Кошелёк (статические файлы) ---
    location /wallet/ {
        root /opt/logos/www;
        index index.html;
        try_files $uri $uri/ /wallet/index.html;
        # кэш статики
        location ~* \.(?:js|css|png|jpg|jpeg|gif|svg|ico)$ {
            expires 30d;
            access_log off;
        }
    }

    # --- LRB node API (Axum на 8080) ---
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_pass http://127.0.0.1:8080/;
    }

    # --- Wallet Proxy (FastAPI на 9090) ---
    location /proxy/ {
        limit_req zone=proxy_zone burst=20 nodelay;

        proxy_read_timeout      30s;
        proxy_connect_timeout   5s;
        proxy_send_timeout      15s;

        proxy_set_header Host                $host;
        proxy_set_header X-Real-IP           $remote_addr;
        proxy_set_header X-Forwarded-For     $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto   $scheme;

        proxy_http_version 1.1;
        proxy_set_header Upgrade             $http_upgrade;
        proxy_set_header Connection          $connection_upgrade;

        proxy_pass http://127.0.0.1:9090/;
    }

    # --- Закрыть доступ к скрытому/служебному ---
    location ~ /\.(?!well-known) {
        deny all;
    }
}
```


### FILE: /root/logos_lrb/infra/systemd/lrb-proxy.service

```service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
```


### FILE: /root/logos_lrb/modules/x_guard/Cargo.toml

```toml
[package]
name = "logos_x_guard"
version = "0.1.0"
edition = "2021"

[dependencies]
tokio = { workspace = true }
axum = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }
reqwest = { workspace = true }
tracing = { workspace = true }
tracing-subscriber = { workspace = true }
anyhow = { workspace = true }
```


### FILE: /root/logos_lrb/node/Cargo.toml

```toml
[package]
name        = "logos_node"
version     = "0.1.0"
edition     = "2021"
license     = "Apache-2.0"
description = "LOGOS LRB node: Axum REST + archive + producer + wallet/stake"
build       = "build.rs"

# Основной бинарь узла
[[bin]]
name = "logos_node"
path = "src/main.rs"

[lib]
name = "logos_node"
path = "src/lib.rs"

[dependencies]
# базовый стек (всё из workspace)
axum.workspace                = true
tower.workspace               = true
tower-http.workspace          = true
tokio.workspace               = true

serde.workspace               = true
serde_json.workspace          = true
anyhow.workspace              = true
thiserror.workspace           = true
once_cell.workspace           = true
dashmap.workspace             = true
tracing.workspace             = true
tracing-subscriber.workspace  = true
sha2.workspace                = true   # canonical_msg в API

# хранилища/индексация
sled.workspace                = true
deadpool-postgres.workspace   = true
tokio-postgres.workspace      = true
rusqlite.workspace            = true
r2d2_sqlite.workspace         = true

# утилиты/крипта/метрики
hex.workspace                 = true
base64.workspace              = true
bs58.workspace                = true
ed25519-dalek.workspace       = true
blake3.workspace              = true
ipnet.workspace               = true
prometheus.workspace          = true
uuid.workspace                = true

# security & utils
hmac = { version = "0.12", default-features = false }
rand = { version = "0.8", features = ["std","std_rng"] }
parking_lot = "0.12"

# HTTP‑клиент (bridge payout + утилиты)
reqwest   = { workspace = true, features = ["rustls-tls","http2","json","blocking"] }
rand_core = "0.6"

# ядро
lrb_core = { path = "../lrb_core" }

[build-dependencies]
chrono = { version = "0.4", default-features = false, features = ["clock"] }
```


### FILE: /root/logos_lrb/node/openapi/openapi.json

```json
{
  "openapi": "3.0.3",
  "info": {
    "title": "LOGOS LRB — Core API",
    "version": "0.1.0",
    "description": "Public & Admin API for LOGOS LRB (strict CSP, JWT admin, rToken bridge, archive)"
  },
  "servers": [{ "url": "https://45-159-248-232.sslip.io" }],
  "paths": {
    "/healthz": {
      "get": { "summary": "Healthcheck", "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/OkMsg" } } } } } }
    },
    "/head": {
      "get": { "summary": "Chain head", "responses": { "200": { "description": "Head", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Head" } } } } } }
    },
    "/balance/{rid}": {
      "get": {
        "summary": "Account balance & nonce",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": { "200": { "description": "Balance", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Balance" } } } } }
      }
    },
    "/submit_tx": {
      "post": {
        "summary": "Submit transaction",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TxIn" } } } },
        "responses": { "200": { "description": "Result", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitResult" } } } } }
      }
    },
    "/economy": {
      "get": { "summary": "Economy snapshot", "responses": { "200": { "description": "Economy", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Economy" } } } } } }
    },
    "/history/{rid}": {
      "get": {
        "summary": "History by RID (from sled index)",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "History", "content": { "application/json": { "schema": { "type": "array", "items": { "$ref": "#/components/schemas/HistoryItem" } } } } }
        }
      }
    },
    "/archive/history/{rid}": {
      "get": {
        "summary": "History by RID (archive backend: SQLite/PG)",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "History", "content": { "application/json": { "schema": { "type": "array", "items": { "type": "object" } } } } }
        }
      }
    },
    "/archive/tx/{txid}": {
      "get": {
        "summary": "Get TX by txid (archive backend)",
        "parameters": [{ "name": "txid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "TX (if any)", "content": { "application/json": { "schema": { "type": "object" } } } }
        }
      }
    },
    "/bridge/deposit": {
      "post": {
        "summary": "Register external deposit to rToken",
        "security": [{ "BridgeKey": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DepositReq" } } } },
        "responses": { "200": { "description": "BridgeResp", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeResp" } } } } }
      }
    },
    "/bridge/redeem": {
      "post": {
        "summary": "Request redeem from rToken to external chain",
        "security": [{ "BridgeKey": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/RedeemReq" } } } },
        "responses": { "200": { "description": "BridgeResp", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeResp" } } } } }
      }
    },
    "/bridge/verify": {
      "post": {
        "summary": "Verify bridge operation",
        "security": [{ "BridgeKey": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/VerifyReq" } } } },
        "responses": { "200": { "description": "BridgeResp", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeResp" } } } } }
      }
    },
    "/admin/set_balance": {
      "post": {
        "summary": "Set balance (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SetBalanceReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    },
    "/admin/set_nonce": {
      "post": {
        "summary": "Set nonce (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SetNonceReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    },
    "/admin/bump_nonce": {
      "post": {
        "summary": "Bump nonce (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BumpNonceReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    },
    "/admin/mint": {
      "post": {
        "summary": "Add minted amount (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/MintReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    },
    "/admin/burn": {
      "post": {
        "summary": "Add burned amount (admin)",
        "security": [{ "AdminJWT": [] }],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BurnReq" } } } },
        "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "type": "object" } } } } }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "AdminJWT": { "type": "apiKey", "in": "header", "name": "X-Admin-JWT" },
      "BridgeKey": { "type": "apiKey", "in": "header", "name": "X-Bridge-Key" }
    },
    "schemas": {
      "OkMsg": { "type": "object", "properties": { "status": { "type": "string" } }, "required": ["status"] },
      "Head":  { "type": "object", "properties": { "height": { "type": "integer", "format": "uint64" } }, "required": ["height"] },
      "Balance": {
        "type": "object",
        "properties": { "rid": { "type": "string" }, "balance": { "type": "string" }, "nonce": { "type": "integer", "format": "uint64" } },
        "required": ["rid","balance","nonce"]
      },
      "TxIn": {
        "type": "object",
        "properties": {
          "from": { "type": "string" }, "to": { "type": "string" },
          "amount": { "type": "integer", "format": "uint64" },
          "nonce": { "type": "integer", "format": "uint64" },
          "memo": { "type": "string", "nullable": true },
          "sig_hex": { "type": "string" }
        },
        "required": ["from","to","amount","nonce","sig_hex"]
      },
      "SubmitResult": {
        "type": "object",
        "properties": {
          "ok": { "type": "boolean" },
          "txid": { "type": "string", "nullable": true },
          "info": { "type": "string" }
        }, "required": ["ok","info"]
      },
      "Economy": {
        "type": "object",
        "properties": { "supply": { "type": "integer" }, "burned": { "type": "integer" }, "cap": { "type": "integer" } },
        "required": ["supply","burned","cap"]
      },
      "HistoryItem": {
        "type": "object",
        "properties": {
          "txid": { "type": "string" }, "height": { "type": "integer" }, "from": { "type": "string" },
          "to": { "type": "string" }, "amount": { "type": "integer" }, "nonce": { "type": "integer" }, "ts": { "type": "integer", "nullable": true }
        },
        "required": ["txid","height","from","to","amount","nonce"]
      },
      "DepositReq": {
        "type": "object",
        "properties": { "txid":{ "type": "string" }, "amount":{ "type": "integer" }, "from_chain":{ "type": "string" }, "to_rid":{ "type": "string" } },
        "required": ["txid","amount","from_chain","to_rid"]
      },
      "RedeemReq": {
        "type": "object",
        "properties": { "rtoken_tx":{ "type": "string" }, "to_chain":{ "type": "string" }, "to_addr":{ "type": "string" }, "amount":{ "type": "integer" } },
        "required": ["rtoken_tx","to_chain","to_addr","amount"]
      },
      "VerifyReq": {
        "type": "object",
        "properties": { "op_id":{ "type": "string" } }, "required": ["op_id"]
      },
      "BridgeResp": {
        "type": "object",
        "properties": { "ok":{ "type": "boolean" }, "op_id":{ "type": "string" }, "info":{ "type": "string" } },
        "required": ["ok","op_id","info"]
      },
      "SetBalanceReq": { "type": "object", "properties": { "rid":{"type":"string"}, "amount":{"type":"string"} }, "required": ["rid","amount"] },
      "SetNonceReq":   { "type": "object", "properties": { "rid":{"type":"string"}, "value":{"type":"integer"} }, "required": ["rid","value"] },
      "BumpNonceReq":  { "type": "object", "properties": { "rid":{"type":"string"} }, "required": ["rid"] },
      "MintReq":       { "type": "object", "properties": { "amount":{"type":"integer"} }, "required": ["amount"] },
      "BurnReq":       { "type": "object", "properties": { "amount":{"type":"integer"} }, "required": ["amount"] }
    }
  }
}
```


### FILE: /root/logos_lrb/node/src/openapi.json

```json
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB Node API", "version": "0.1.0" },
  "servers": [{ "url": "http://{host}", "variables": { "host": { "default": "localhost:8080" } } }],
  "paths": {
    "/healthz": { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/livez":   { "get": { "summary": "Liveness", "responses": { "200": { "description": "OK" } } } },
    "/readyz":  { "get": { "summary": "Readiness", "responses": { "200": { "description": "Ready" } } } },
    "/version": { "get": { "summary": "Build info", "responses": { "200": { "description": "JSON" } } } },
    "/metrics": { "get": { "summary": "Prometheus metrics", "responses": { "200": { "description": "text/plain" } } } },

    "/head": {
      "get": {
        "summary": "Chain head",
        "responses": {
          "200": { "description": "Height/finalized",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/HeadResp" },
            "examples": { "ok": { "value": { "height": 123, "finalized": false } } } } }
          }
        }
      }
    },

    "/balance/{rid}": {
      "get": {
        "summary": "Account state",
        "parameters": [{ "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } }],
        "responses": {
          "200": { "description": "Balance/nonce",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BalanceResp" },
            "examples": { "ok": { "value": { "rid": "A...Z", "balance": 1000000, "nonce": 5 } } } } }
          },
          "404": { "description": "Unknown RID" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "Submit batch of signed transactions",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/SubmitTxBatchReq" },
          "examples": { "one": { "value": { "txs": [
            { "from":"A...Z","to":"B...Y","amount":1234,"nonce":6,"sig_hex":"<ed25519 hex>" }
          ] } } } } } },
        "responses": {
          "200": { "description": "Accepted/rejected with details",
            "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitTxBatchResp" },
            "examples": { "ok": { "value": {
              "accepted": 1, "rejected": 0, "new_height": 124,
              "results": [{ "idx": 0, "status": "accepted", "code": 0, "reason": "ok" }]
            } } } } } }
        }
      }
    },

    "/debug_canon": {
      "post": {
        "summary": "Canonical JSON for signing (server-side canonicalization)",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/DebugCanonReq" },
          "examples": { "tx": { "value": { "tx": { "from":"A...Z","to":"B...Y","amount":1,"nonce":1 } } } }
        } } },
        "responses": { "200": {
          "description": "Canon hex",
          "content": { "application/json": { "schema": { "$ref": "#/components/schemas/DebugCanonResp" } } }
        } }
      }
    },

    "/faucet": {
      "post": {
        "summary": "DEV only. Mint LGN to RID",
        "requestBody": { "required": true, "content": { "application/json": {
          "schema": { "$ref": "#/components/schemas/FaucetReq" }
        } } },
        "responses": {
          "200": { "description": "Granted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/FaucetResp" } } } },
          "400": { "description": "Bad request" }
        }
      }
    }
  },

  "components": {
    "schemas": {
      "TxIn": {
        "type": "object",
        "required": ["from", "to", "amount", "nonce", "sig_hex"],
        "properties": {
          "from":   { "type": "string", "description": "RID (base58 pubkey)" },
          "to":     { "type": "string", "description": "RID (base58 pubkey)" },
          "amount": { "type": "integer", "format": "uint64", "minimum": 1 },
          "nonce":  { "type": "integer", "format": "uint64" },
          "sig_hex":{ "type": "string", "description": "Ed25519 signature hex over canonical bytes from /debug_canon" }
        }
      },

      "SubmitTxBatchReq": { "type": "object", "required": ["txs"], "properties": { "txs": { "type": "array", "minItems": 1, "items": { "$ref": "#/components/schemas/TxIn" } } } },

      "TxResult": {
        "type": "object",
        "required": ["idx", "status", "code", "reason"],
        "properties": {
          "idx":    { "type": "integer" },
          "status": { "type": "string", "enum": ["accepted", "rejected"] },
          "code":   { "type": "integer", "enum": [0, 400, 401, 402, 409] },
          "reason": { "type": "string", "enum": ["ok", "bad_rid", "bad_sig", "bad_canon", "bad_nonce", "insufficient_funds"] }
        }
      },

      "SubmitTxBatchResp": {
        "type": "object",
        "required": ["accepted", "rejected", "new_height", "results"],
        "properties": {
          "accepted":  { "type": "integer" },
          "rejected":  { "type": "integer" },
          "new_height":{ "type": "integer", "format": "uint64" },
          "results":   { "type": "array", "items": { "$ref": "#/components/schemas/TxResult" } }
        }
      },

      "HeadResp":   { "type": "object", "properties": { "height": { "type": "integer" }, "finalized": { "type": "boolean" } } },
      "BalanceResp":{ "type": "object", "properties": { "rid": { "type": "string" }, "balance": { "type": "integer" }, "nonce": { "type": "integer" } } },

      "DebugCanonReq":  { "type": "object", "properties": { "tx": { "type": "object" } } },
      "DebugCanonResp": { "type": "object", "required": ["canon_hex"], "properties": { "canon_hex": { "type": "string" } } },

      "FaucetReq":  { "type": "object", "required": ["rid", "amount"], "properties": { "rid": { "type": "string" }, "amount": { "type": "integer" } } },
      "FaucetResp": { "type": "object", "properties": { "granted": { "type": "integer" }, "rid": { "type": "string" } } }
    }
  }
}
```


### FILE: /root/logos_lrb/node/src/openapi/openapi.json

```json
{
  "openapi": "3.0.3",
  "info": { "title": "LOGOS LRB API", "version": "0.1.0" },
  "paths": {
    "/healthz": {
      "get": { "summary": "health", "responses": { "200": { "description": "OK" } } }
    },
    "/livez": {
      "get": { "summary": "liveness", "responses": { "200": { "description": "alive" } } }
    },
    "/readyz": {
      "get": {
        "summary": "readiness",
        "responses": {
          "200": { "description": "ready" },
          "503": { "description": "not ready" }
        }
      }
    },
    "/version": { "get": { "summary": "build info", "responses": { "200": { "description": "OK" } } } },
    "/metrics": { "get": { "summary": "prometheus metrics", "responses": { "200": { "description": "OK" } } } },

    "/head": {
      "get": {
        "summary": "current head heights",
        "responses": {
          "200": { "description": "OK", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Head" } } } }
        }
      }
    },

    "/submit_tx": {
      "post": {
        "summary": "submit transaction (Ed25519 verified)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/TxIn" } } } },
        "responses": {
          "200": { "description": "accepted", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitResult" } } } },
          "401": { "description": "bad signature" },
          "409": { "description": "nonce reuse" }
        }
      }
    },

    "/submit_tx_batch": {
      "post": {
        "summary": "submit batch of transactions (Ed25519 verified)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/SubmitBatchReq" } } } },
        "responses": {
          "200": { "description": "per-item results", "content": { "application/json": { "schema": { "type": "array", "items": { "$ref": "#/components/schemas/SubmitBatchItem" } } } } }
        }
      }
    },

    "/archive/blocks": {
      "get": {
        "summary": "recent blocks",
        "parameters": [
          { "name": "limit", "in": "query", "schema": { "type": "integer" } },
          { "name": "before_height", "in": "query", "schema": { "type": "integer" } }
        ],
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/archive/txs": {
      "get": {
        "summary": "recent txs",
        "parameters": [
          { "name": "limit", "in": "query", "schema": { "type": "integer" } },
          { "name": "rid", "in": "query", "schema": { "type": "string" } },
          { "name": "before_ts", "in": "query", "schema": { "type": "integer" } }
        ],
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/archive/history/{rid}": {
      "get": {
        "summary": "history by rid",
        "parameters": [ { "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } } ],
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/archive/tx/{txid}": {
      "get": {
        "summary": "tx by id",
        "parameters": [ { "name": "txid", "in": "path", "required": true, "schema": { "type": "string" } } ],
        "responses": { "200": { "description": "OK" }, "404": { "description": "not found" } }
      }
    },

    "/stake/delegate": {
      "post": {
        "summary": "delegate (compat wrapper)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/StakeAction" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/undelegate": {
      "post": {
        "summary": "undelegate (compat wrapper)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/StakeAction" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/claim": {
      "post": {
        "summary": "claim rewards (compat wrapper)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/StakeAction" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/my/{rid}": {
      "get": {
        "summary": "my delegations + rewards (compat wrapper)",
        "parameters": [ { "name": "rid", "in": "path", "required": true, "schema": { "type": "string" } } ],
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/stake/claim_settle": {
      "post": {
        "summary": "settle reward into ledger",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/ClaimSettle" } } } },
        "responses": { "200": { "description": "OK" } }
      }
    },

    "/bridge/deposit_json": {
      "post": {
        "summary": "bridge deposit (mTLS + HMAC)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeDeposit" } } } },
        "responses": { "200": { "description": "idempotent OK" }, "202": { "description": "queued/retry" }, "401": { "description": "unauthorized (key/HMAC/nonce)" } }
      }
    },
    "/bridge/redeem_json": {
      "post": {
        "summary": "bridge redeem (mTLS + HMAC)",
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "$ref": "#/components/schemas/BridgeRedeem" } } } },
        "responses": { "200": { "description": "ok" }, "202": { "description": "queued/retry" }, "401": { "description": "unauthorized (key/HMAC/nonce)" } }
      }
    }
  },

  "components": {
    "schemas": {
      "Head": {
        "type": "object",
        "required": ["height","finalized"],
        "properties": {
          "height":   { "type": "integer", "format": "uint64" },
          "finalized":{ "type": "integer", "format": "uint64" }
        }
      },
      "Balance": {
        "type": "object",
        "required": ["rid","balance","nonce"],
        "properties": {
          "rid":     { "type": "string" },
          "balance": { "type": "integer", "format": "uint128" },
          "nonce":   { "type": "integer", "format": "uint64" }
        }
      },
      "TxIn": {
        "type": "object",
        "required": ["from","to","amount","nonce","sig_hex"],
        "properties": {
          "from":    { "type": "string", "description": "base58(pubkey)" },
          "to":      { "type": "string" },
          "amount":  { "type": "integer", "format": "uint64" },
          "nonce":   { "type": "integer", "format": "uint64" },
          "sig_hex": { "type": "string" },
          "memo":    { "type": "string", "nullable": true }
        }
      },
      "SubmitResult": {
        "type": "object",
        "required": ["ok","info"],
        "properties": {
          "ok":   { "type": "boolean" },
          "txid": { "type": "string", "nullable": true },
          "info": { "type": "string" }
        }
      },
      "SubmitBatchReq": {
        "type": "object",
        "required": ["txs"],
        "properties": {
          "txs": { "type": "array", "items": { "$ref": "#/components/schemas/TxIn" } }
        }
      },
      "SubmitBatchItem": {
        "type": "object",
        "required": ["ok","info","index"],
        "properties": {
          "ok":    { "type": "boolean" },
          "txid":  { "type": "string", "nullable": true },
          "info":  { "type": "string" },
          "index": { "type": "integer" }
        }
      },
      "StakeAction": {
        "type": "object",
        "required": ["rid"],
        "properties": {
          "rid":       { "type": "string" },
          "validator": { "type": "string" },
          "amount":    { "type": "integer", "format": "uint64", "nullable": true }
        }
      },
      "ClaimSettle": {
        "type": "object",
        "required": ["rid","amount"],
        "properties": {
          "rid":    { "type": "string" },
          "amount": { "type": "integer", "format": "uint64" }
        }
      },
      "BridgeDeposit": {
        "type": "object",
        "required": ["rid","amount","ext_txid"],
        "properties": {
          "rid":      { "type": "string" },
          "amount":   { "type": "integer", "format": "uint64" },
          "ext_txid": { "type": "string" }
        }
      },
      "BridgeRedeem": {
        "type": "object",
        "required": ["rid","amount","ext_txid"],
        "properties": {
          "rid":      { "type": "string" },
          "amount":   { "type": "integer", "format": "uint64" },
          "ext_txid": { "type": "string" }
        }
      }
    }
  }
}
```


### FILE: /root/logos_lrb/www/wallet/api_base.js

```js
(() => {
  const origin = window.location.origin.replace(/\/+$/, "");
  // nginx proxies:
  // /wallet-api -> wallet-proxy (9090)
  // /node-api   -> logos_node   (8080/8081)
  window.LOGOS_WALLET_API = origin + "/wallet-api";
  window.LOGOS_NODE_API   = origin + "/node-api";
})();
```


### FILE: /root/logos_lrb/www/wallet/app.html

```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="./ui.css"/>
  <script src="./api_base.js"></script>
  <script src="./common.js"></script>
</head>
<body>
  <div class="container">
    <div class="topbar">
      <div class="brand">
        <div class="logo"></div>
        <div>
          <div class="h1">LOGOS Wallet</div>
          <div class="muted">Web MVP · Assets / Send / History / Staking / Settings</div>
        </div>
      </div>
      <div class="row" style="justify-content:flex-end">
        <div class="pill mono copy" id="ridPill" title="Клик — копировать RID">RID: …</div>
        <div class="pill copy" id="themeBtn">Theme</div>
        <div class="pill copy" id="logoutBtn">Logout</div>
      </div>
    </div>

    <div class="card">
      <div class="kv">
        <div>NODE API</div><div class="mono" id="nodeApi">—</div>
        <div>WALLET API</div><div class="mono" id="walletApi">—</div>
        <div>HEAD</div><div class="mono" id="head">—</div>
        <div>LGN Balance</div><div class="mono" id="bal">—</div>
        <div>Nonce</div><div class="mono" id="nonce">—</div>
      </div>
      <div class="toast" id="toast"></div>

      <div class="footerNav">
        <div class="navbar">
          <div class="navbtn active" data-tab="assets">Главная</div>
          <div class="navbtn" data-tab="send">Отправить</div>
          <div class="navbtn" data-tab="history">История</div>
          <div class="navbtn" data-tab="staking">Стейкинг</div>
          <div class="navbtn" data-tab="settings">Настройки</div>
        </div>
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="card" id="tab-assets">
        <h2>Активы</h2>
        <div class="muted">LGN всегда первый. В этом MVP показываем LGN (и основу под мультиактив).</div>
        <hr/>
        <div class="row">
          <button class="btn2" id="btnRefresh">Обновить</button>
          <button class="btn2" id="btnCopyRID">Копировать RID</button>
        </div>
      </div>

      <div class="card hidden" id="tab-send">
        <h2>Отправить LGN</h2>
        <div class="muted">Транзакция подписывается локально (Ed25519). Сервер не знает ваш приватный ключ.</div>
        <hr/>
        <label class="muted">Кому (RID)</label>
        <input class="input mono" id="toRid" placeholder="RID получателя"/>
        <label class="muted" style="margin-top:10px;display:block">Сумма</label>
        <input class="input" id="amount" placeholder="например 1.23"/>
        <label class="muted" style="margin-top:10px;display:block">Nonce (авто)</label>
        <input class="input mono" id="nonceIn" placeholder="авто" />
        <div class="row" style="margin-top:10px">
          <button class="btn" id="btnSend">Подписать и отправить</button>
        </div>
        <div class="toast" id="toastSend"></div>
      </div>

      <div class="card hidden" id="tab-history">
        <h2>История</h2>
        <div class="muted">Берём из node-api (archive/history если включено).</div>
        <hr/>
        <button class="btn2" id="btnHist">Загрузить</button>
        <pre class="mono small" id="histBox" style="white-space:pre-wrap"></pre>
      </div>

      <div class="card hidden" id="tab-staking">
        <h2>Стейкинг</h2>
        <div class="muted">MVP: my / delegate / undelegate / claim.</div>
        <hr/>
        <button class="btn2" id="btnStakeMy">Мой стейк</button>
        <pre class="mono small" id="stakeBox" style="white-space:pre-wrap"></pre>
      </div>

      <div class="card hidden" id="tab-settings">
        <h2>Настройки</h2>
        <div class="muted">Тема, безопасность, экспорт/импорт, диагностика.</div>
        <hr/>
        <div class="row">
          <button class="btn2" id="btnExport">Backup Code</button>
          <button class="btn2" id="btnLock">Заблокировать</button>
        </div>
        <div class="toast" id="toastSet"></div>
      </div>
    </div>
  </div>

<script src="./app.js"></script>
</body>
</html>
```


### FILE: /root/logos_lrb/www/wallet/app.js

```js
"use strict";

loadTheme();

const NODE_API   = (window.LOGOS_NODE_API || (location.origin + "/node-api")).replace(/\/+$/,"");
const WALLET_API = (window.LOGOS_WALLET_API || (location.origin + "/wallet-api")).replace(/\/+$/,"");

$("#nodeApi").textContent = NODE_API;
$("#walletApi").textContent = WALLET_API;

function toast(el, msg, cls=""){ el.className = "toast " + cls; el.textContent = msg; }

$("#themeBtn").onclick = () => {
  const cur = document.documentElement.dataset.theme || "dark";
  setTheme(cur === "dark" ? "light" : "dark");
  $("#themeBtn").textContent = "Theme: " + (document.documentElement.dataset.theme);
};
$("#themeBtn").textContent = "Theme: " + (document.documentElement.dataset.theme || "dark");

$("#logoutBtn").onclick = () => {
  localStorage.removeItem("logos_unlocked");
  window.location.href="./auth.html";
};

async function walletMeta(){
  const meta = await kvGet("meta");
  if (!meta || !meta.rid) throw new Error("Кошелёк не найден. Вернись и создай/восстанови.");
  return meta;
}

async function requireUnlocked(){
  if (localStorage.getItem("logos_unlocked") !== "1"){
    throw new Error("Кошелёк заблокирован. Вернись на вход.");
  }
}

async function getBalance(rid){
  // ожидаем: {rid,balance,nonce} (если nonce нет — покажем 0)
  const j = await fetchJSON(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
  return {balance: j.balance ?? null, nonce: j.nonce ?? 0};
}

async function getHead(){
  const j = await fetchJSON(`${NODE_API}/head`);
  return j;
}

async function signTx(privKey, from, to, amountStr, nonce){
  // canonical: from|to|amount|nonce -> sha256 -> ed25519 sign
  const msg = await sha256Bytes(utf8(`${from}|${to}|${amountStr}|${nonce}`));
  const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msg);
  return bufToHex(sig);
}

async function unlockWithPassword(){
  const pw = prompt("Пароль для подписи:");
  if (!pw) throw new Error("Отменено.");
  const enc  = await kvGet("enc");
  const meta = await kvGet("meta");
  const pkcs8 = await decryptBlob(pw, enc);
  const priv = await crypto.subtle.importKey("pkcs8", pkcs8, {name:"Ed25519"}, true, ["sign"]);
  return {rid: meta.rid, priv};
}

async function refreshAll(){
  const el = $("#toast");
  try{
    await requireUnlocked();
    const meta = await walletMeta();

    $("#ridPill").textContent = "RID: " + meta.rid;
    $("#ridPill").onclick = async()=>{ await navigator.clipboard.writeText(meta.rid); toast(el, "RID скопирован.", "ok"); };

    const head = await getHead();
    $("#head").textContent = JSON.stringify(head);

    const b = await getBalance(meta.rid);
    $("#bal").textContent = String(b.balance);
    $("#nonce").textContent = String(b.nonce);
    $("#nonceIn").value = String((b.nonce|0) + 1);

    toast(el, "Обновлено.", "ok");
  }catch(e){
    toast(el, String(e.message||e), "bad");
  }
}

function setTab(name){
  for (const b of document.querySelectorAll(".navbtn")){
    b.classList.toggle("active", b.dataset.tab === name);
  }
  for (const id of ["assets","send","history","staking","settings"]){
    const el = $(`#tab-${id}`);
    el.classList.toggle("hidden", id !== name);
  }
}

for (const b of document.querySelectorAll(".navbtn")){
  b.onclick = ()=> setTab(b.dataset.tab);
}

$("#btnRefresh").onclick = refreshAll;
$("#btnCopyRID").onclick = async()=>{
  const meta = await walletMeta();
  await navigator.clipboard.writeText(meta.rid);
  toast($("#toast"), "RID скопирован.", "ok");
};

$("#btnSend").onclick = async()=>{
  const el = $("#toastSend");
  try{
    await requireUnlocked();
    const meta = await walletMeta();
    const to = ($("#toRid").value||"").trim();
    const amountStr = ($("#amount").value||"").trim();
    const nonce = parseInt(($("#nonceIn").value||"").trim(),10);

    if (!to) throw new Error("Укажи RID получателя.");
    if (!amountStr) throw new Error("Укажи сумму.");
    if (!Number.isFinite(nonce) || nonce <= 0) throw new Error("Некорректный nonce.");

    toast(el, "Подписываю…");
    const {priv} = await unlockWithPassword();
    const sig_hex = await signTx(priv, meta.rid, to, amountStr, nonce);

    const payload = {from: meta.rid, to, amount: amountStr, nonce, memo:"", sig_hex};
    const j = await fetchJSON(`${NODE_API}/submit_tx`, {
      method:"POST",
      headers: {"content-type":"application/json"},
      body: JSON.stringify(payload)
    });
    toast(el, "OK: " + JSON.stringify(j), "ok");
    await refreshAll();
  }catch(e){
    toast(el, String(e.message||e), "bad");
  }
};

$("#btnHist").onclick = async()=>{
  const box = $("#histBox");
  const el = $("#toast");
  try{
    await requireUnlocked();
    const meta = await walletMeta();
    // если у тебя другой путь истории — скажешь, подгоним
    const j = await fetchJSON(`${NODE_API}/history/${encodeURIComponent(meta.rid)}`);
    box.textContent = JSON.stringify(j, null, 2);
  }catch(e){
    toast(el, String(e.message||e), "bad");
  }
};

$("#btnStakeMy").onclick = async()=>{
  const box = $("#stakeBox");
  const el = $("#toast");
  try{
    await requireUnlocked();
    const meta = await walletMeta();
    const j = await fetchJSON(`${NODE_API}/stake/my/${encodeURIComponent(meta.rid)}`);
    box.textContent = JSON.stringify(j, null, 2);
  }catch(e){
    toast(el, String(e.message||e), "bad");
  }
};

$("#btnExport").onclick = async()=>{
  const el = $("#toastSet");
  try{
    const meta = await walletMeta();
    const enc  = await kvGet("enc");
    const pack = {meta, enc};
    const b64 = bufToB64(utf8(JSON.stringify(pack)).buffer);
    toast(el, "Backup Code:\n" + b64, "warn");
  }catch(e){
    toast(el, String(e.message||e), "bad");
  }
};

$("#btnLock").onclick = async()=>{
  localStorage.removeItem("logos_unlocked");
  toast($("#toastSet"), "Заблокировано. Вернись на вход.", "ok");
};

(async ()=>{
  try{
    const meta = await walletMeta();
    $("#ridPill").textContent = "RID: " + meta.rid;
    await refreshAll();
  }catch(e){
    toast($("#toast"), String(e.message||e), "bad");
    setTimeout(()=>window.location.href="./auth.html", 600);
  }
})();
```


### FILE: /root/logos_lrb/www/wallet/compat.js

```js
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/wallet-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();
```


### FILE: /root/logos_lrb/www/wallet/ui.js

```js
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/wallet-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();
```

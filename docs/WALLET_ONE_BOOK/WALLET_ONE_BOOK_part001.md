# LOGOS WALLET — ONE FULL BOOK (NO TRUNCATION)

- Generated: `20260112T135218Z`
- Policy: **NO CODE TRUNCATION** (large files are chunked, not cut)

---

## CONTENT

- `/etc/nginx/conf.d/off/10_lrb_https.conf`
- `/etc/nginx/conf.d/off/logos-api-lb.conf`
- `/etc/nginx/sites-available/logos-node-8000.conf`
- `/etc/nginx/sites-available/logos.conf`
- `/etc/nginx/sites-enabled/logos-node-8000.conf`
- `/etc/nginx/sites-enabled/logos.conf`
- `/etc/systemd/system/logos-airdrop-tg-bot.service`
- `/etc/systemd/system/logos-node.service.d/00-prod.conf`
- `/etc/systemd/system/logos-node.service.d/disabled/override.conf`
- `/etc/systemd/system/logos-wallet-proxy.service`
- `/etc/systemd/system/logos-wallet-proxy.service.d/override.conf`
- `/etc/systemd/system/logos-wallet-scanner.service`
- `/etc/systemd/system/lrb-proxy.service`
- `/etc/systemd/system/lrb-scanner.service`
- `/etc/systemd/system/multi-user.target.wants/logos-wallet-proxy.service`
- `/etc/systemd/system/multi-user.target.wants/lrb-proxy.service`
- `/etc/systemd/system/multi-user.target.wants/lrb-scanner.service`
- `/lib/systemd/system/sysinit.target.wants/systemd-binfmt.service`
- `/lib/systemd/system/systemd-binfmt.service`
- `/lib/systemd/system/systemd-remount-fs.service`
- `/opt/logos/wallet-proxy/app.py`
- `/opt/logos/wallet-proxy/init_db.py`
- `/opt/logos/wallet-proxy/requirements.txt`
- `/opt/logos/wallet-proxy/scanner.py`
- `/opt/logos/www/wallet/_bak_bridge_20260107T102635Z/app.css`
- `/opt/logos/www/wallet/_bak_bridge_20260107T102635Z/app.html`
- `/opt/logos/www/wallet/_bak_bridge_20260107T102635Z/app.js`
- `/opt/logos/www/wallet/_bak_bridge_20260107T102822Z/app.css`
- `/opt/logos/www/wallet/_bak_bridge_20260107T102822Z/app.html`
- `/opt/logos/www/wallet/_bak_bridge_20260107T102822Z/app.js`
- `/opt/logos/www/wallet/_bak_entry_20260107T105554Z/index.html`
- `/opt/logos/www/wallet/_bak_entry_20260108T142703Z/index.html`
- `/opt/logos/www/wallet/_bak_ui_20260107T101342Z/app.css`
- `/opt/logos/www/wallet/_bak_ui_20260107T101342Z/app.html`
- `/opt/logos/www/wallet/_bak_ui_20260107T101342Z/app.js`
- `/opt/logos/www/wallet/api_base.js`
- `/opt/logos/www/wallet/app.css`
- `/opt/logos/www/wallet/app.html`
- `/opt/logos/www/wallet/app.js`
- `/opt/logos/www/wallet/auth.css`
- `/opt/logos/www/wallet/auth.html`
- `/opt/logos/www/wallet/auth.js`
- `/opt/logos/www/wallet/compat.js`
- `/opt/logos/www/wallet/connect.js`
- `/opt/logos/www/wallet/index.html`
- `/opt/logos/www/wallet/login.html`
- `/opt/logos/www/wallet/ui.js`
- `/opt/logos/www/wallet/wallet.css`
- `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.css`
- `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.html`
- `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.js`
- `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.css`
- `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.html`
- `/opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.js`
- `/opt/logos/www/wallet_dev/_bak_entry_20260107T105554Z/index.html`
- `/opt/logos/www/wallet_dev/_bak_entry_20260108T142703Z/index.html`
- `/opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/app.html`
- `/opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/app.js`
- `/opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/ui.css`
- `/opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.css`
- `/opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.html`
- `/opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.js`
- `/opt/logos/www/wallet_dev/api_base.js`
- `/opt/logos/www/wallet_dev/app.css`
- `/opt/logos/www/wallet_dev/app.html`
- `/opt/logos/www/wallet_dev/app.js`
- `/opt/logos/www/wallet_dev/assets.js`
- `/opt/logos/www/wallet_dev/auth.css`
- `/opt/logos/www/wallet_dev/auth.html`
- `/opt/logos/www/wallet_dev/auth.js`
- `/opt/logos/www/wallet_dev/compat.js`
- `/opt/logos/www/wallet_dev/connect.js`
- `/opt/logos/www/wallet_dev/index.html`
- `/opt/logos/www/wallet_dev/login.html`
- `/opt/logos/www/wallet_dev/modules/send.js`
- `/opt/logos/www/wallet_dev/modules/settings.js`
- `/opt/logos/www/wallet_dev/modules/tx_redirect.js`
- `/opt/logos/www/wallet_dev/tabs.js`
- `/opt/logos/www/wallet_dev/ui.css`
- `/opt/logos/www/wallet_dev/ui.js`
- `/opt/logos/www/wallet_dev/wallet.css`
- `/root/logos_lrb/wallet-proxy/app.py`
- `/root/logos_lrb/wallet-proxy/requirements.txt`
- `/root/logos_lrb/wallet-proxy/scanner.py`
- `/var/www/logos/wallet/app.html`
- `/var/www/logos/wallet/app.js`
- `/var/www/logos/wallet/app.v2.js`
- `/var/www/logos/wallet/app.v3.js`
- `/var/www/logos/wallet/auth.js`
- `/var/www/logos/wallet/css/styles.css`
- `/var/www/logos/wallet/index.html`
- `/var/www/logos/wallet/js/api.js`
- `/var/www/logos/wallet/js/app.js`
- `/var/www/logos/wallet/js/app_wallet.js`
- `/var/www/logos/wallet/js/core.js`
- `/var/www/logos/wallet/js/unlock.js`
- `/var/www/logos/wallet/js/vault.js`
- `/var/www/logos/wallet/js/vault_bridge.js`
- `/var/www/logos/wallet/login.html`
- `/var/www/logos/wallet/ping.html`
- `/var/www/logos/wallet/staking.js`
- `/var/www/logos/wallet/wallet.css`
- `/var/www/logos/wallet/wallet.js`
- `/var/www/logos/wallet3/app.v3.js`
- `/var/www/logos/wallet3/index.html`

---

## FULL SOURCE

### FILE: /etc/nginx/conf.d/off/10_lrb_https.conf
```conf
# LOGOS LRB — HTTPS reverse-proxy (STRICT CSP), prod

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    # TLS
    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header X-Frame-Options "DENY" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer" always;
    add_header Permissions-Policy "geolocation=(), microphone=(), camera=()" always;

    # STRICT CSP одной строкой (без \ и переносов)
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; style-src 'self'; img-src 'self' data:; font-src 'self' data:; connect-src 'self' https:; base-uri 'none'; frame-ancestors 'none'; object-src 'none'; upgrade-insecure-requests" always;

    # CORS (при необходимости)
    add_header Access-Control-Allow-Origin  https://45-159-248-232.sslip.io always;
    add_header Access-Control-Allow-Headers "Content-Type, Authorization, X-Bridge-Key, X-Admin-Key" always;
    add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
    if ($request_method = OPTIONS) { return 204; }

    # API → Axum node (:8080)
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_read_timeout 60s;
        proxy_connect_timeout 5s;
    }

    # OpenAPI контракт
    location = /openapi.json {
        proxy_pass http://127.0.0.1:8080/openapi.json;
        add_header Cache-Control "no-store" always;
    }

    # Статика (строгая CSP уже применена выше)
    location /wallet/ {
        root /opt/logos/www;
        add_header Cache-Control "no-store" always;
        try_files $uri $uri/ =404;
    }
    location /explorer/ {
        root /opt/logos/www;
        add_header Cache-Control "no-store" always;
        try_files $uri $uri/ =404;
    }

    # Корень ничего не отдаёт (не ломаем другие пути)
    location = / { return 404; }
}

```

### FILE: /etc/nginx/conf.d/off/logos-api-lb.conf
```conf
server {
    listen 80;
    server_name 45-159-248-232.sslip.io;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name 45-159-248-232.sslip.io;

    ssl_certificate     /etc/letsencrypt/live/45-159-248-232.sslip.io/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/45-159-248-232.sslip.io/privkey.pem;

    root /opt/logos/www;
    index index.html;

    # Статика: долгий кэш
    location /wallet/ {
        alias /opt/logos/www/wallet/;
        index index.html;
        expires 30d;
        add_header Cache-Control "public, max-age=2592000, immutable";
    }

    # API → узел
    location /api/ {
        proxy_pass http://127.0.0.1:8080/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Безопасность
    add_header Content-Security-Policy "default-src 'self'; script-src 'self'; connect-src 'self' http: https:; img-src 'self' data:; style-src 'self'; object-src 'none'; frame-ancestors 'none'; base-uri 'none';" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header Permissions-Policy "accelerometer=(),camera=(),geolocation=(),microphone=()" always;
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

    # Gzip/браузерные оптимизации
    gzip on; gzip_types text/plain text/css application/json application/javascript application/octet-stream image/svg+xml;
    gzip_min_length 1024;

    access_log /var/log/nginx/logos_access.log;
    error_log  /var/log/nginx/logos_error.log;
}

```

### FILE: /etc/nginx/sites-available/logos-node-8000.conf
```conf
server {
    listen 8000;
    server_name _;
    # если будете раздавать фронт-кошелёк со статикой — пропишите root
    # root /var/www/wallet;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

```

### FILE: /etc/nginx/sites-available/logos.conf
```conf
# Лимиты запросов к API
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;

# WebSocket/upgrade helper
map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

# Узел LOGOS (REST API)
upstream logos_node_backend {
    server 127.0.0.1:8080;
    keepalive 32;
}

# Wallet-proxy (депозиты USDT -> rLGN)
upstream logos_wallet_api {
    server 127.0.0.1:9090;
    keepalive 16;
}

# Airdrop API — upstream объявлен в /etc/nginx/conf.d/logos_airdrop_upstream.conf
# upstream logos_airdrop_api { ... }

server {
    listen 80;
    server_name mw-expedition.com www.mw-expedition.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name mw-expedition.com www.mw-expedition.com;

    ssl_certificate     /etc/letsencrypt/live/mw-expedition.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/mw-expedition.com/privkey.pem;

    # По умолчанию — статика кошелька/эксплорера
    root /opt/logos/www;
    index index.html;

    # === Лендинг ===
    location = / {
        root /var/www/logos/landing;
        try_files /index.html =404;
        add_header Cache-Control "no-store" always;
    }

    # Страница аирдропа /airdrop.html
    # === Wallet SPA ===
    location /wallet/ {
        try_files $uri /wallet/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/api https://mw-expedition.com/proxy https://vnet.web3games.org https://mainnet.infura.io;" always;
    }

    # === Explorer SPA ===
    location /explorer/ {
        try_files $uri /explorer/index.html;
        add_header Cache-Control "no-store" always;
        # Разрешаем inline-стили и скрипты для explorer, API остаётся только self
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/api;" always;
    }

    # === REST API ноды ===
    location /api/ {
        limit_req zone=api_zone burst=60 nodelay;

        proxy_pass http://logos_node_backend/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # === Wallet-proxy API ===
    location /proxy/ {
        proxy_pass http://logos_wallet_api/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";

        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # === Airdrop API ===
    # Общая статика (JS/CSS/иконки)
    location ~* \.(?:css|js|ico|png|jpg|jpeg|svg|woff2?)$ {
        try_files $uri =404;
        add_header Cache-Control "no-store" always;
    }
}

```

### FILE: /etc/nginx/sites-enabled/logos-node-8000.conf
```conf
server {
    listen 8000;
    server_name _;
    # если будете раздавать фронт-кошелёк со статикой — пропишите root
    # root /var/www/wallet;

    location / {
        proxy_pass http://127.0.0.1:8080;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}

```

### FILE: /etc/nginx/sites-enabled/logos.conf
```conf
# Лимиты запросов к API
limit_req_zone $binary_remote_addr zone=api_zone:10m rate=30r/s;

map $http_upgrade $connection_upgrade {
    default upgrade;
    ''      close;
}

upstream logos_node_backend {
    server 127.0.0.1:8080;
    keepalive 32;
}

upstream logos_wallet_api {
    server 127.0.0.1:9090;
    keepalive 16;
}

server {
    listen 80;
    server_name mw-expedition.com www.mw-expedition.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl http2;
    server_name mw-expedition.com www.mw-expedition.com;

    ssl_certificate     /etc/letsencrypt/live/mw-expedition.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/mw-expedition.com/privkey.pem;

    root /opt/logos/www;
    index index.html;

    location = / {
        root /var/www/logos/landing;
        try_files /index.html =404;
        add_header Cache-Control "no-store" always;
    }

    location ^~ /wallet_v2/ {
        try_files $uri $uri/ /wallet_v2/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/node-api https://mw-expedition.com/wallet-api; img-src 'self' data:; font-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline';" always;
    }

    location ^~ /wallet_dev/ {
        alias /opt/logos/www/wallet_dev/;
        try_files $uri $uri/ /wallet_dev/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/node-api https://mw-expedition.com/wallet-api; img-src 'self' data:; font-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline';" always;
    }

    location ^~ /wallet/ {
        try_files $uri /wallet/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/node-api https://mw-expedition.com/wallet-api; img-src 'self' data:; font-src 'self' data:; style-src 'self' 'unsafe-inline'; script-src 'self' 'unsafe-inline';" always;
    }

    location ^~ /explorer/ {
        try_files $uri /explorer/index.html;
        add_header Cache-Control "no-store" always;
        add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; connect-src 'self' https://mw-expedition.com https://mw-expedition.com/node-api;" always;
    }

    location = /node-api { return 301 /node-api/; }
    location ^~ /node-api/ {
        limit_req zone=api_zone burst=60 nodelay;
        proxy_pass http://logos_node_backend/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location = /wallet-api { return 301 /wallet-api/; }
    location ^~ /wallet-api/ {
        limit_req zone=api_zone burst=60 nodelay;
        proxy_pass http://logos_wallet_api/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # Совместимость (старые пути)
    location ^~ /api/ {
        limit_req zone=api_zone burst=60 nodelay;
        proxy_pass http://logos_node_backend/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ^~ /proxy/ {
        limit_req zone=api_zone burst=60 nodelay;
        proxy_pass http://logos_wallet_api/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host              $host;
        proxy_set_header X-Real-IP         $remote_addr;
        proxy_set_header X-Forwarded-For   $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    location ~* \.(?:css|js|ico|png|jpg|jpeg|svg|woff2?)$ {
        try_files $uri =404;
        add_header Cache-Control "no-store" always;
    }
}

```

### FILE: /etc/systemd/system/logos-airdrop-tg-bot.service
```service
[Unit]
Description=LOGOS Airdrop Telegram Bot (subscription verifier)
After=network-online.target logos-airdrop-api.service
Wants=network-online.target

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos/airdrop-tg-bot

# Никакие ключи не меняем — только подключаем где они лежат
EnvironmentFile=/etc/logos/logos_tg_bot.env
EnvironmentFile=/etc/logos/airdrop-api.env
EnvironmentFile=/etc/logos/node-main.env

Environment=TG_CHANNEL=@logosblockchain
Environment=AIRDROP_UPDATE_URL=http://127.0.0.1:8092/api/airdrop/update
Environment=AIRDROP_API_KEY_HEADER=X-API-Key
Environment=LOG_LEVEL=INFO

ExecStart=/opt/logos/airdrop-tg-bot/.venv/bin/python /opt/logos/airdrop-tg-bot/bot.py

Restart=always
RestartSec=3
TimeoutStopSec=20
LimitNOFILE=65535

StandardOutput=journal
StandardError=journal

NoNewPrivileges=true
PrivateTmp=true

[Install]
WantedBy=multi-user.target

```

### FILE: /etc/systemd/system/logos-node.service.d/00-prod.conf
```conf
[Service]
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_NODE_LISTEN=127.0.0.1:8080
Environment=LRB_ARCHIVE_URL=postgres://logos:StrongPass123@127.0.0.1:5432/logos
Environment=LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io
Environment=LRB_SLOT_MS=200
# сгенерируй рандомные секреты:
#  openssl rand -hex 32
Environment=LRB_JWT_SECRET=8e7b2b39d44c4acfa20c7a51a21a4fe1e77b21b2dd4fd8f1c1c6e7bf0a0fbe9c
Environment=LRB_BRIDGE_KEY=6f0d1b3c4e5f6a7b8c9d0e1f2a3b4c5d6e7f8091a2b3c4d5e6f708192a3b4c5d

```

### FILE: /etc/systemd/system/logos-node.service.d/disabled/override.conf
```conf
[Service]
# === Основные ENV ===
WorkingDirectory=/root/logos_lrb
Environment=LRB_BIND=0.0.0.0:8080
Environment=LRB_DATA_PATH=/var/lib/logos/data.sled
Environment=LRB_WALLET_ORIGIN=https://45-159-248-232.sslip.io

# === Rate-limit (боевые; под стресс увеличивай временно) ===
Environment=LRB_QPS=500
Environment=LRB_BURST=1000
Environment=LRB_RATE_BYPASS_CIDRS=127.0.0.1/32,::1/128
Environment=LRB_ADMIN_ALLOW_CIDRS=127.0.0.1/32,::1/128

# === Архив: Postgres (вместо SQLite) ===
# Environment=LRB_ARCHIVE_PATH=/var/lib/logos/archive.sqlite
Environment=LRB_ARCHIVE_URL=postgres://logos:StrongPass123@127.0.0.1:5432/logos

# Логи
Environment=RUST_LOG=info

# Секреты (seed ноды, JWT, bridge)
EnvironmentFile=/etc/logos/keys.env

```

### FILE: /etc/systemd/system/logos-wallet-proxy.service
```service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI + Uvicorn)
After=network-online.target
Wants=network-online.target

[Service]
EnvironmentFile=/etc/logos/wallet-proxy.env
User=logos
Group=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/wallet-proxy.env

ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app \
  --host 0.0.0.0 \
  --port 9090 \
  --workers 2

Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```

### FILE: /etc/systemd/system/logos-wallet-proxy.service.d/override.conf
```conf
[Service]
EnvironmentFile=
EnvironmentFile=/etc/logos/wallet-proxy.env

# гарантируем, что таблица есть до старта uvicorn
ExecStartPre=/opt/logos/wallet-proxy/venv/bin/python3 /opt/logos/wallet-proxy/init_db.py

```

### FILE: /etc/systemd/system/logos-wallet-scanner.service
```service
[Unit]
Description=LOGOS Wallet ETH->LRB USDT Scanner
After=network-online.target
Wants=network-online.target
PartOf=logos-wallet-proxy.service

[Service]
User=logos
Group=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/wallet-proxy.env

ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py

Restart=always
RestartSec=5

LimitNOFILE=65535
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target

```

### FILE: /etc/systemd/system/lrb-proxy.service
```service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

### FILE: /etc/systemd/system/lrb-scanner.service
```service
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

### FILE: /etc/systemd/system/multi-user.target.wants/logos-wallet-proxy.service
```service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI + Uvicorn)
After=network-online.target
Wants=network-online.target

[Service]
EnvironmentFile=/etc/logos/wallet-proxy.env
User=logos
Group=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/wallet-proxy.env

ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app \
  --host 0.0.0.0 \
  --port 9090 \
  --workers 2

Restart=on-failure
RestartSec=3

[Install]
WantedBy=multi-user.target

```

### FILE: /etc/systemd/system/multi-user.target.wants/lrb-proxy.service
```service
[Unit]
Description=LOGOS Wallet Proxy (FastAPI on :9090)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/uvicorn app:app --host 0.0.0.0 --port 9090 --workers 2
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

### FILE: /etc/systemd/system/multi-user.target.wants/lrb-scanner.service
```service
[Unit]
Description=LOGOS Wallet Scanner (USDT->rLGN)
After=network-online.target
Wants=network-online.target

[Service]
User=logos
WorkingDirectory=/opt/logos/wallet-proxy
EnvironmentFile=/etc/logos/proxy.env
ExecStart=/opt/logos/wallet-proxy/venv/bin/python /opt/logos/wallet-proxy/scanner.py
Restart=always
RestartSec=2
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target

```

### FILE: /lib/systemd/system/sysinit.target.wants/systemd-binfmt.service
```service
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Set Up Additional Binary Formats
Documentation=man:systemd-binfmt.service(8) man:binfmt.d(5)
Documentation=https://docs.kernel.org/admin-guide/binfmt-misc.html
Documentation=https://www.freedesktop.org/wiki/Software/systemd/APIFileSystems
DefaultDependencies=no
Conflicts=shutdown.target
After=proc-sys-fs-binfmt_misc.automount
After=proc-sys-fs-binfmt_misc.mount
After=local-fs.target
Before=sysinit.target shutdown.target
ConditionPathIsMountPoint=/proc/sys/fs/binfmt_misc
ConditionDirectoryNotEmpty=|/lib/binfmt.d
ConditionDirectoryNotEmpty=|/usr/lib/binfmt.d
ConditionDirectoryNotEmpty=|/usr/local/lib/binfmt.d
ConditionDirectoryNotEmpty=|/etc/binfmt.d
ConditionDirectoryNotEmpty=|/run/binfmt.d

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/lib/systemd/systemd-binfmt
ExecStop=/usr/lib/systemd/systemd-binfmt --unregister
TimeoutSec=90s

```

### FILE: /lib/systemd/system/systemd-binfmt.service
```service
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Set Up Additional Binary Formats
Documentation=man:systemd-binfmt.service(8) man:binfmt.d(5)
Documentation=https://docs.kernel.org/admin-guide/binfmt-misc.html
Documentation=https://www.freedesktop.org/wiki/Software/systemd/APIFileSystems
DefaultDependencies=no
Conflicts=shutdown.target
After=proc-sys-fs-binfmt_misc.automount
After=proc-sys-fs-binfmt_misc.mount
After=local-fs.target
Before=sysinit.target shutdown.target
ConditionPathIsMountPoint=/proc/sys/fs/binfmt_misc
ConditionDirectoryNotEmpty=|/lib/binfmt.d
ConditionDirectoryNotEmpty=|/usr/lib/binfmt.d
ConditionDirectoryNotEmpty=|/usr/local/lib/binfmt.d
ConditionDirectoryNotEmpty=|/etc/binfmt.d
ConditionDirectoryNotEmpty=|/run/binfmt.d

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/lib/systemd/systemd-binfmt
ExecStop=/usr/lib/systemd/systemd-binfmt --unregister
TimeoutSec=90s

```

### FILE: /lib/systemd/system/systemd-remount-fs.service
```service
#  SPDX-License-Identifier: LGPL-2.1-or-later
#
#  This file is part of systemd.
#
#  systemd is free software; you can redistribute it and/or modify it
#  under the terms of the GNU Lesser General Public License as published by
#  the Free Software Foundation; either version 2.1 of the License, or
#  (at your option) any later version.

[Unit]
Description=Remount Root and Kernel File Systems
Documentation=man:systemd-remount-fs.service(8)
Documentation=https://www.freedesktop.org/wiki/Software/systemd/APIFileSystems

DefaultDependencies=no
After=systemd-fsck-root.service
Before=local-fs-pre.target local-fs.target
Wants=local-fs-pre.target
Conflicts=shutdown.target
Before=shutdown.target

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/lib/systemd/systemd-remount-fs

```

### FILE: /opt/logos/wallet-proxy/app.py
```py
import os, json, time, asyncio

# ====== DB session fallback (SessionLocal) ======
# Ensures SessionLocal exists even if earlier patches removed DB setup.
try:
    SessionLocal  # noqa
except NameError:
    try:
        from sqlalchemy import create_engine
        from sqlalchemy.orm import sessionmaker
    except Exception as e:
        raise RuntimeError(f"SQLAlchemy missing or broken: {e}")

    _engine = globals().get("engine") or globals().get("ENGINE")
    if _engine is None:
        DB_URL = (
            os.environ.get("WALLET_PROXY_DB_URL")
            or os.environ.get("DATABASE_URL")
            or "sqlite:////opt/logos/wallet-proxy/wallet_proxy.db"
        )
        if DB_URL.startswith("sqlite"):
            _engine = create_engine(DB_URL, connect_args={"check_same_thread": False})
        else:
            _engine = create_engine(DB_URL)
        globals()["engine"] = _engine

    SessionLocal = sessionmaker(bind=_engine, autocommit=False, autoflush=False)
    globals()["SessionLocal"] = SessionLocal
# ====== /DB session fallback ======
from typing import Optional, Literal

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import Response
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from bip_utils import Bip84, Bip84Coins, Bip44, Bip44Coins, Bip44Changes
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST


# ====== env fallback loader (so systemd/envfile issues won't break XPUB) ======
def _load_env_file(path="/etc/logos/wallet-proxy.env"):
    try:
        with open(path, "r", encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" not in line:
                    continue
                k, v = line.split("=", 1)
                k = k.strip()
                v = v.strip().strip('"').strip("'")
                # do not override existing env
                if k and k not in os.environ:
                    os.environ[k] = v
    except FileNotFoundError:
        pass
    except Exception as e:
        print("WARN: failed to load env file:", e)

_load_env_file()

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
BTC_XPUB     = os.environ.get("BTC_XPUB", "")
ETH_XPUB     = os.environ.get("ETH_XPUB", "")
TRON_XPUB    = os.environ.get("TRON_XPUB", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()

class DepositMap(Base):
    __tablename__ = "deposit_map"
    id         = Column(Integer, primary_key=True)
    rid        = Column(String, index=True, nullable=False)
    token      = Column(String, nullable=False)
    network    = Column(String, nullable=False)
    index      = Column(Integer, nullable=False, default=0)
    address    = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda: int(time.time()))

Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id      = Column(Integer, primary_key=True)
    txid    = Column(String, unique=True, nullable=False)
    rid     = Column(String, index=True)
    token   = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout": 10}))
        if w3.is_connected():
            USDT = w3.eth.contract(
                address=Web3.to_checksum_address(USDT_ADDRESS),
                abi=ERC20_ABI,
            )
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable")
            w3 = None
    except Exception as e:
        print("WARN web3 init error:", e)
        w3 = None
        USDT = None

# ====== HTTP helper ======
async def http_json(method: str, url: str, body: dict = None, headers: dict = None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try:
                data = json.loads(t) if t else {}
            except Exception:
                data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(
    CORSMiddleware,
    allow_origins=CORS if CORS else ["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"

class TopupResponse(BaseModel):
    rid: str
    token: str
    network: str
    address: str

class WithdrawRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
    amount: int
    to_address: str
    request_id: str

class QuoteRequest(BaseModel):
    from_token: str
    to_token: str
    amount: int

class QuoteResponse(BaseModel):
    price: float
    expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ    = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK  = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR = Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)



# ====== Address derivation (watch-only) ======

# ====== Address derivation (watch-only) ======
# NOTE: address must be globally unique in deposit_map.address
# so we allocate a unique index per chain and retry on collisions.

from sqlalchemy.exc import IntegrityError
from bip_utils import Bip84, Bip84Coins, Bip44, Bip44Coins, Bip44Changes

def _require_env(name: str) -> str:
    v = (os.environ.get(name, "") or "").strip()
    if not v:
        raise HTTPException(status_code=500, detail=f"{name} not configured")
    return v

def _derive_address(chain: str, index: int) -> str:
    chain = chain.upper()
    if chain == "BTC":
        key = _require_env("BTC_XPUB")  # actually zpub ok
        acc = Bip84.FromExtendedKey(key, Bip84Coins.BITCOIN)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    if chain == "ETH":
        key = _require_env("ETH_XPUB")
        acc = Bip44.FromExtendedKey(key, Bip44Coins.ETHEREUM)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    if chain == "TRON":
        key = _require_env("TRON_XPUB")
        acc = Bip44.FromExtendedKey(key, Bip44Coins.TRON)
        return acc.Change(Bip44Changes.CHAIN_EXT).AddressIndex(index).PublicKey().ToAddress()
    raise HTTPException(status_code=400, detail=f"unsupported chain: {chain}")

def _chain_from(token: str, network: str) -> str:
    # нормализуем в "цепь", чтобы USDT на ETH использовал тот же пул адресов ETH
    n = (network or "").upper()
    if n in ("ETH", "ETHEREUM", "ERC20"):
        return "ETH"
    if n in ("TRON", "TRC20"):
        return "TRON"
    if n in ("BTC", "BITCOIN"):
        return "BTC"
    return n

def _next_index(sess, chain: str) -> int:
    # глобальный next index по цепи (не по RID!)
    q = sess.query(DepositMap).filter(DepositMap.network == chain).order_by(DepositMap.index.desc()).first()
    if not q:
        return 0
    try:
        return int(q.index) + 1
    except Exception:
        return 0

def _get_or_create_addr(rid: str, token: str, network: str) -> str:
    chain = _chain_from(token, network)

    # 1) если уже есть адрес для rid+chain — вернём
    with SessionLocal() as sess:
        row = sess.query(DepositMap).filter(
            DepositMap.rid == rid,
            DepositMap.network == chain
        ).first()
        if row:
            return row.address

        # 2) выделяем уникальный индекс по chain
        for _ in range(0, 2048):
            idx = _next_index(sess, chain) + _
            addr = _derive_address(chain, idx)

            obj = DepositMap(
                rid=rid,
                token=token,
                network=chain,
                index=idx,
                address=addr,
                created_at=int(time.time()),
            )

            sess.add(obj)

            # --- race-safe commit ---
            try:
                sess.commit()
                return addr
            except IntegrityError:
                sess.rollback()

                # 1) если параллельный запрос уже создал маппинг для этого кошелька — просто вернём его
                row2 = sess.query(DepositMap).filter(
                    DepositMap.rid == rid,
                    DepositMap.token == token,
                    DepositMap.network == chain
                ).first()
                if row2:
                    return row2.address

                # 2) иначе это коллизия по address/index (или другой UNIQUE) — пробуем следующий idx
                continue

        raise HTTPException(status_code=500, detail="unable to allocate unique address")
# ====== Endpoints ======

# --- receive addresses (watch-only) ---
@app.get("/v1/receive/{rid}")
def receive_addresses(rid: str):
    rid = (rid or "").strip()
    if not rid:
        raise HTTPException(status_code=400, detail="rid is required")

    # BTC / ETH / TRON: один адрес на цепь.
    # USDT на ETH/TRON использует тот же адрес соответствующей цепи.
    addrs = {
        "BTC": _get_or_create_addr(rid, "BTC", "BTC"),
        "ETH": _get_or_create_addr(rid, "ETH", "ETH"),
        "TRON": _get_or_create_addr(rid, "TRON", "TRON"),
        "USDT_ERC20": _get_or_create_addr(rid, "USDT", "ETH"),
        "USDT_TRC20": _get_or_create_addr(rid, "USDT", "TRON"),
    }
    return {"rid": rid, "lgn_rid": rid, "addresses": addrs}



# --- balances (live) ---
from decimal import Decimal
import time

_USDT_ETH = "0xdAC17F958D2ee523a2206206994597C13D831ec7"  # USDT ERC20 mainnet
_USDT_TRON = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"         # USDT TRC20 (Tether)

_ERC20_ABI_MIN = [
    {"name":"balanceOf","type":"function","stateMutability":"view",
     "inputs":[{"name":"account","type":"address"}],
     "outputs":[{"name":"","type":"uint256"}]},
    {"name":"decimals","type":"function","stateMutability":"view",
     "inputs":[], "outputs":[{"name":"","type":"uint8"}]},
]

def _d(x, q=18):
    try:
        return str((Decimal(x) / (Decimal(10) ** Decimal(q))).normalize())
    except Exception:
        return None

def _http_get_json(url: str, params=None, timeout=12):
    # requests может не быть -> fallback на urllib
    try:
        import requests
        r = requests.get(url, params=params, timeout=timeout, headers={"User-Agent":"logos-wallet-proxy/1.0"})
        r.raise_for_status()
        return r.json()
    except Exception:
        import json, urllib.request, urllib.parse
        if params:
            url = url + ("&" if "?" in url else "?") + urllib.parse.urlencode(params)
        req = urllib.request.Request(url, headers={"User-Agent":"logos-wallet-proxy/1.0"})
        with urllib.request.urlopen(req, timeout=timeout) as resp:
            return json.loads(resp.read().decode("utf-8", "ignore"))

def _btc_balance_blockstream(addr: str):
    # confirmed + mempool balances in sats
    j = _http_get_json(f"https://blockstream.info/api/address/{addr}")
    cs = j.get("chain_stats") or {}
    ms = j.get("mempool_stats") or {}
    confirmed = int(cs.get("funded_txo_sum", 0)) - int(cs.get("spent_txo_sum", 0))
    mempool = int(ms.get("funded_txo_sum", 0)) - int(ms.get("spent_txo_sum", 0))
    total = confirmed + mempool
    return {
        "confirmed_sat": confirmed,
        "mempool_sat": mempool,
        "total_sat": total,
        "total_btc": _d(total, 8),
        "source": "blockstream.info"
    }

def _eth_balances_web3(addr: str):
    # web3 instance
    try:
        w3 = globals().get("w3") or globals().get("W3")
        if w3 is None:
            from web3 import Web3
            w3 = Web3(Web3.HTTPProvider(_require_env("ETH_PROVIDER_URL"), request_kwargs={"timeout": 12}))
            globals()["w3"] = w3
        if not w3.is_connected():
            return {"error": "ETH provider not connected"}

        wei = int(w3.eth.get_balance(addr))
        out = {"wei": wei, "eth": _d(wei, 18), "source": "web3"}

        # USDT ERC20
        c = w3.eth.contract(address=w3.to_checksum_address(_USDT_ETH), abi=_ERC20_ABI_MIN)
        try:
            dec = int(c.functions.decimals().call())
        except Exception:
            dec = 6
        raw = int(c.functions.balanceOf(w3.to_checksum_address(addr)).call())
        out["usdt_erc20"] = {"raw": raw, "usdt": _d(raw, dec), "decimals": dec, "contract": _USDT_ETH}
        return out
    except Exception as e:
        return {"error": f"eth_web3_failed: {e}"}

def _tron_balances(addr: str):
    # 1) try tronpy (if installed)
    try:
        from tronpy import Tron
        client = Tron()
        trx = client.get_account_balance(addr)  # float TRX
        # TRC20 USDT
        usdt = client.get_contract(_USDT_TRON).functions.balanceOf(addr)
        usdt_raw = int(usdt)
        return {
            "trx": str(trx),
            "sun": int(Decimal(trx) * Decimal(1_000_000)),
            "usdt_trc20": {"raw": usdt_raw, "usdt": _d(usdt_raw, 6), "decimals": 6, "contract": _USDT_TRON},
            "source": "tronpy"
        }
    except Exception:
        pass

    # 2) fallback: tronscan public api
    try:
        j = _http_get_json("https://apilist.tronscanapi.com/api/account", params={"address": addr})
        # TRX
        bal_sun = int(j.get("balance", 0))
        out = {
            "sun": bal_sun,
            "trx": _d(bal_sun, 6),
            "source": "tronscan"
        }
        # USDT TRC20 from token balances
        tb = j.get("trc20token_balances") or j.get("trc20TokenBalances") or []
        usdt_raw = None
        for it in tb:
            ca = (it.get("contract_address") or it.get("contractAddress") or "").strip()
            if ca == _USDT_TRON:
                usdt_raw = it.get("balance") or it.get("tokenBalance") or it.get("quantity")
                break
        if usdt_raw is not None:
            try:
                usdt_raw = int(str(usdt_raw))
            except Exception:
                usdt_raw = None
        out["usdt_trc20"] = {"raw": usdt_raw, "usdt": _d(usdt_raw or 0, 6), "decimals": 6, "contract": _USDT_TRON}
        return out
    except Exception as e:
        return {"error": f"tron_failed: {e}"}

@app.get("/v1/balances/{rid}")
def balances(rid: str):
    rid = (rid or "").strip()
    if not rid:
        raise HTTPException(status_code=400, detail="rid is required")

    # addresses (ensure mapping exists)
    addrs = {
        "BTC": _get_or_create_addr(rid, "BTC", "BTC"),
        "ETH": _get_or_create_addr(rid, "ETH", "ETH"),
        "TRON": _get_or_create_addr(rid, "TRON", "TRON"),
        "USDT_ERC20": _get_or_create_addr(rid, "USDT", "ETH"),
        "USDT_TRC20": _get_or_create_addr(rid, "USDT", "TRON"),
    }

    t0 = time.time()
    out = {
        "rid": rid,
        "addresses": addrs,
        "balances": {},
        "ts": int(time.time())
    }

    # BTC
    try:
        out["balances"]["BTC"] = _btc_balance_blockstream(addrs["BTC"])
    except Exception as e:
        out["balances"]["BTC"] = {"error": f"btc_failed: {e}"}

    # ETH + USDT_ERC20
    out["balances"]["ETH"] = _eth_balances_web3(addrs["ETH"])

    # TRON + USDT_TRC20
    out["balances"]["TRON"] = _tron_balances(addrs["TRON"])

    out["latency_ms"] = int((time.time() - t0) * 1000)
    return out
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3:
        raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK:
        raise HTTPException(500, "HOT wallet not configured")

    deposit_address = w3.eth.account.from_key(HOT_PK).address

    with Session(engine) as s:
        dm = s.execute(
            select(DepositMap).where(
                DepositMap.rid == req.rid,
                DepositMap.token == req.token,
                DepositMap.network == req.network,
            )
        ).scalar_one_or_none()
        if dm is None:
            s.add(
                DepositMap(
                    rid=req.rid,
                    token=req.token,
                    network=req.network,
                    address=deposit_address,
                )
            )
            s.commit()

    return TopupResponse(
        rid=req.rid,
        token=req.token,
        network=req.network,
        address=deposit_address,
    )

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount <= 0:
            raise HTTPException(400, "amount<=0")
        if not w3 or not USDT:
            raise HTTPException(503, "ETH RPC not connected")

        acct = w3.eth.account.from_key(HOT_PK)

        # redeem из LRB-ноды
        hdr = (
            {"X-Bridge-Key": BRIDGE_KEY}
            if not BRIDGE_KEY.startswith("ey")
            else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        )
        st, data = await http_json(
            "POST",
            f"{NODE_URL}/bridge/redeem",
            {
                "rid": req.rid,
                "amount": req.amount,
                "request_id": req.request_id,
            },
            hdr,
        )
        if st // 100 != 2:
            raise HTTPException(st, f"bridge redeem failed: {data}")

        # ERC-20 перевод USDT
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(
            Web3.to_checksum_address(req.to_address),
            int(req.amount),
        ).build_transaction(
            {
                "chainId": w3.eth.chain_id,
                "from": acct.address,
                "nonce": nonce,
                "gas": 90000,
                "maxFeePerGas": w3.to_wei("30", "gwei"),
                "maxPriorityFeePerGas": w3.to_wei("1", "gwei"),
            }
        )
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()

        with Session(engine) as s:
            s.add(
                SeenTx(
                    txid=tx_hash,
                    rid=req.rid,
                    token=req.token,
                    network=req.network,
                )
            )
            s.commit()

        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc()
        raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc()
        raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```

### FILE: /opt/logos/wallet-proxy/init_db.py
```py
import os, sqlite3, sys

def db_path_from_url(url: str) -> str:
    url = (url or "").strip()
    if not url:
        return "/opt/logos/wallet-proxy/wallet_proxy.db"
    if url.startswith("sqlite:////"):
        return url[len("sqlite:////")-1:]  # keep leading /
    if url.startswith("sqlite:///"):
        return url[len("sqlite:///"):]
    if url.startswith("sqlite://"):
        # rare, but handle
        return url.replace("sqlite://", "", 1)
    # not sqlite -> do nothing here
    return ""

DB_URL = os.environ.get("WALLET_PROXY_DB_URL") or os.environ.get("DATABASE_URL") or "sqlite:////opt/logos/wallet-proxy/wallet_proxy.db"
path = db_path_from_url(DB_URL)

if not path:
    print("INFO: non-sqlite DB configured, skip init_db")
    sys.exit(0)

os.makedirs(os.path.dirname(path), exist_ok=True)

con = sqlite3.connect(path)
cur = con.cursor()

cur.execute("""
CREATE TABLE IF NOT EXISTS deposit_map (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  rid TEXT NOT NULL,
  token TEXT NOT NULL,
  network TEXT NOT NULL,
  "index" INTEGER NOT NULL DEFAULT 0,
  address TEXT NOT NULL,
  created_at INTEGER NOT NULL
);
""")

# глобальная уникальность адреса (у тебя это уже требуется по логике)
cur.execute("""CREATE UNIQUE INDEX IF NOT EXISTS ux_deposit_map_address ON deposit_map(address);""")

# чтобы быстро находить по (rid, network) — под ваш SELECT
cur.execute("""CREATE INDEX IF NOT EXISTS ix_deposit_map_rid_network ON deposit_map(rid, network);""")

con.commit()
con.close()

print("OK: init_db done ->", path)

```

### FILE: /opt/logos/wallet-proxy/requirements.txt
```txt
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```

### FILE: /opt/logos/wallet-proxy/scanner.py
```py
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```

### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102635Z/app.css
```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */

```

### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102635Z/app.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->

</body>
</html>

```

### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102635Z/app.js
```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */

```

### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102822Z/app.css
```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */


/* ====== Bridge result box ====== */
.bridgeResult{
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  font-size:12px;
  line-height:1.35;
  white-space:pre-wrap;
}
.bridgeResult.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.bridgeResult.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
/* ====== /Bridge result box ====== */

```

### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102822Z/app.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>

```

### FILE: /opt/logos/www/wallet/_bak_bridge_20260107T102822Z/app.js
```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */

```

### FILE: /opt/logos/www/wallet/_bak_entry_20260107T105554Z/index.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="color-scheme" content="dark"/>
  <link rel="stylesheet" href="./wallet.css?v=30"/>
</head>
<body>
  <!-- Верхняя панель -->
  <header class="topbar">
    <div class="topbar-left">
      <div class="logo-dot"></div>
      <div class="topbar-title">
        <span class="brand">LOGOS</span>
        <span class="product">Wallet</span>
      </div>
    </div>
    <div class="topbar-right">
      <span class="endpoint-label">Endpoint</span>
      <span class="endpoint-value" id="endpoint"></span>
      <button id="btn-lock" class="chip chip-ghost">Выйти</button>
    </div>
  </header>

  <main class="page-shell">
    <header class="page-header">
      <div>
        <h1>LOGOS Wallet — Кошелёк</h1>
        <p class="subtitle">
          Non‑custodial кошелёк: ключи и подписи живут только в этом браузере.
          Никакого серверного хранилища.
        </p>
      </div>
    </header>

    <!-- RID / PUB -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Твой RID / Публичный ключ</h2>
          <p class="card-caption">
            RID — адрес аккаунта в сети LOGOS. Публичный ключ (hex) используется для проверки подписи.
          </p>
        </div>
      </header>
      <div class="card-body">
        <textarea id="pub" class="mono-field" readonly></textarea>
        <p class="hint">
          Ключи живут только в памяти этой вкладки. После выхода или закрытия
          вкладки для доступа к кошельку снова нужен пароль.
        </p>
      </div>
    </section>

    <!-- Баланс -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Баланс</h2>
          <p class="card-caption">
            Проверка баланса и nonce для выбранного RID.
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">RID</span>
          <input id="rid-balance" type="text" class="field-input" placeholder="RID"/>
        </label>

        <div class="actions-row">
          <button id="btn-balance" class="btn primary">Показать баланс</button>
        </div>

        <pre id="out-balance" class="mono-output"></pre>
      </div>
    </section>

    <!-- Подпись и отправка -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Подпись и отправка (batch)</h2>
          <p class="card-caption">
            Подписанная Ed25519 транзакция отправляется в ноду как батч (одна транзакция).
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">Получатель (RID)</span>
          <input id="to" type="text" class="field-input" placeholder="RID получателя"/>
        </label>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Сумма (LGN)</span>
            <input id="amount" type="number" min="0" step="1" class="field-input"/>
          </label>

          <label class="field field-nonce">
            <span class="field-label">Nonce (debug)</span>
            <input id="nonce" type="number" class="field-input"/>
          </label>
        </div>

        <div class="actions-row">
          <button id="btn-send" class="btn primary">Подписать и отправить</button>
          <button id="btn-nonce" class="btn ghost">Получить nonce</button>
        </div>

        <pre id="out-send" class="mono-output"></pre>
      </div>
    </section>

    <!-- Стейкинг -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Стейкинг (delegate / undelegate / claim)</h2>
          <p class="card-caption">
            Управление стейкингом текущего RID: делегирование, раз‑делегирование и заявка наград.
          </p>
        </div>
        <button id="btn-stake-refresh" class="chip chip-ghost">Обновить статус</button>
      </header>
      <div class="card-body">
        <pre id="out-stake" class="mono-output"></pre>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Застейкать (delegate, LGN)</span>
            <input id="stake-amount" type="number" min="0" step="1" class="field-input"/>
          </label>
          <button id="btn-stake-delegate" class="btn primary">Делегировать</button>
        </div>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Разстейкать (undelegate, LGN)</span>
            <input id="unstake-amount" type="number" min="0" step="1" class="field-input"/>
          </label>
          <button id="btn-stake-undelegate" class="btn ghost">Разстейкать</button>
        </div>

        <div class="actions-row">
          <button id="btn-stake-claim" class="btn secondary">Заявить награду (claim)</button>
        </div>
      </div>
    </section>

    <!-- Мост rToken -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Мост rToken (депозит, demo)</h2>
          <p class="card-caption">
            Демонстрационный депозит rLGN через внешний txid.
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">RID</span>
          <input id="rid-bridge" type="text" class="field-input" placeholder="RID для депозита rLGN"/>
        </label>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Сумма (rLGN)</span>
            <input id="amount-bridge" type="number" min="0" step="1" class="field-input"/>
          </label>

          <label class="field grow">
            <span class="field-label">ext_txid (например eth_txid_0xabc)</span>
            <input id="ext" type="text" class="field-input"/>
          </label>
        </div>

        <div class="actions-row">
          <button id="btn-deposit" class="btn primary">Deposit rLGN (demo)</button>
        </div>

        <pre id="out-bridge" class="mono-output"></pre>
      </div>
    </section>
  </main>

  <script src="./app.js?v=1" defer></script>
</body>
</html>

```

### FILE: /opt/logos/www/wallet/_bak_entry_20260108T142703Z/index.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>

```

### FILE: /opt/logos/www/wallet/_bak_ui_20260107T101342Z/app.css
```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}

```

### FILE: /opt/logos/www/wallet/_bak_ui_20260107T101342Z/app.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>
</body>
</html>

```

### FILE: /opt/logos/www/wallet/_bak_ui_20260107T101342Z/app.js
```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);

```

### FILE: /opt/logos/www/wallet/api_base.js
```js
(() => {
  const origin = window.location.origin.replace(/\/+$/, "");
  window.LOGOS_WALLET_API = origin + "/wallet-api";
  window.LOGOS_NODE_API   = origin + "/node-api";
})();

```

### FILE: /opt/logos/www/wallet/app.css
```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */


/* ====== Bridge result box ====== */
.bridgeResult{
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  font-size:12px;
  line-height:1.35;
  white-space:pre-wrap;
}
.bridgeResult.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.bridgeResult.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
/* ====== /Bridge result box ====== */

```

### FILE: /opt/logos/www/wallet/app.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>

```

### FILE: /opt/logos/www/wallet/app.js
```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */

```

### FILE: /opt/logos/www/wallet/auth.css
```css
/* Wallet Auth page tweaks (theme in /shared/wallet-theme.css) */

/* ВАЖНО: hidden управляет видимостью, CSS его не должен ломать */
[hidden]{ display:none !important; }

/* НЕ ставим display:none на эти блоки! */
#listWrap{ margin-top:12px; }
#mnemonicSection{ margin-top:14px; }

#mnemonicShow,#mnemonicConfirm,#restoreMnemonic{ min-height:120px; }

#ridList{
  list-style:none;
  padding:0;
  margin:10px 0 0;
  display:grid;
  gap:8px;
}

#ridList li{
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.22);
  cursor:pointer;
  font-family:var(--mono);
  font-size:12.5px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

#ridList li:hover{
  border-color:rgba(77,163,255,.35);
  background:rgba(0,0,0,.28);
}

#out{ min-height:84px; }

```

### FILE: /opt/logos/www/wallet/auth.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Secure</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./authP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · AES‑GCM + PBKDF2 · Ed25519 via tweetnacl</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">HTTPS only</div>
      </div>
    </div>
  </header>

  <main class="container">
    <section class="card hero">
      <h1>Доступ к кошельку</h1>
      <p class="muted">Ключи живут локально в браузере. Сервер получает только подписанные операции.</p>
    </section>

    <div class="grid-2">
      <section class="card">
        <header class="card__head">
          <h2>Вход</h2>
          <p class="muted">Если RID уже есть на этом устройстве — вход по паролю.</p>
        </header>

        <label for="loginRid">RID</label>
        <input id="loginRid" class="mono" placeholder="RID (base58) или выбери ниже" autocomplete="off"/>

        <label for="loginPass">Пароль</label>
        <input id="loginPass" type="password" placeholder="Пароль, которым шифровали ключ" autocomplete="current-password"/>

        <div class="row">
          <button id="btn-login" class="primary" type="button">Войти по RID + пароль</button>
          <button id="btn-list" type="button">Показать сохранённые RID</button>
        </div>

        <div id="listWrap" hidden>
          <div class="muted">Локально сохранённые RID (кликни, чтобы подставить):</div>
          <ul id="ridList"></ul>
        </div>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Создать новый</h2>
          <p class="muted">Ключ генерируется в браузере. Запиши 16 слов — это единственный способ восстановления.</p>
        </header>

        <label for="createPass">Новый пароль</label>
        <input id="createPass" type="password" placeholder="Минимум 10 символов, буквы + цифры" autocomplete="new-password"/>

        <div class="row">
          <button id="btn-create" class="primary" type="button">Создать новый RID + фразу</button>
        </div>

        <div id="mnemonicSection" hidden>
          <h3>Резервная фраза (16 слов)</h3>

          <label for="mnemonicShow">Фраза (только чтение)</label>
          <textarea id="mnemonicShow" class="mono" readonly spellcheck="false"></textarea>

          <label for="mnemonicConfirm">Повтори фразу для проверки ещё раз</label>
          <textarea id="mnemonicConfirm" class="mono" placeholder="введите те же 16 слов через пробел" spellcheck="false"></textarea>

          <div class="row">
            <button id="btn-mnemonic-ok" class="primary" type="button">Я записал фразу, перейти в кошелёк</button>
          </div>
        </div>
      </section>
    </div>

    <section class="card">
      <header class="card__head">
        <h2>Восстановить по фразе</h2>
        <p class="muted">Вводишь 16 слов и задаёшь новый пароль. RID восстановится автоматически.</p>
      </header>

      <label for="restoreMnemonic">Резервная фраза (16 слов)</label>
      <textarea id="restoreMnemonic" class="mono" placeholder="16 слов через пробел" spellcheck="false"></textarea>

      <label for="restorePass">Новый пароль</label>
      <input id="restorePass" type="password" placeholder="Минимум 10 символов, буквы + цифры" autocomplete="new-password"/>

      <div class="row">
        <button id="btn-restore" class="primary" type="button">Восстановить кошелёк</button>
      </div>
    </section>

    <section class="card">
      <header class="card__head">
        <h2>Сервис</h2>
        <p class="muted">Сброс локальных аккаунтов доступен только на localhost (dev).</p>
      </header>
      <div class="row">
        <button id="btn-reset" class="danger" type="button" hidden>Сбросить локальные аккаунты (DEV)</button>
      </div>
      <pre id="out" class="mono">Статус: жду действий…</pre>
    </section>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./auth.js?v=20251212_04" defer></script>
</body>
</html>

```

### FILE: /opt/logos/www/wallet/auth.js
```js
/* connect hook: remember challenge if opened from airdrop */
(() => {
  try {
    const q = new URLSearchParams(location.search);
    if (q.get("connect") === "1") {
      const ch = (q.get("challenge") || "").trim();
      if (ch) sessionStorage.setItem("logos_connect_challenge", ch);
      sessionStorage.setItem("logos_connect_mode", "1");
    }
  } catch (e) {}
})();
'use strict';

// AUTH (mainnet-grade):
// - AES-GCM + PBKDF2 (WebCrypto)
// - Ed25519 via tweetnacl (НЕ зависит от WebCrypto Ed25519)
// - хранение: IndexedDB, зашифрованный PKCS8 (RFC8410 prefix + seed32)
// - CSP-safe: без inline handlers и без element.style

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc     = new TextEncoder();
const ALPH    = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

const MN_WORDS = 16;
const MN_ALPH  = 'abcdefghjkmnpqrstuvwxyz';

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);
const out = (msg) => { const el = $('#out'); if (el) el.textContent = String(msg); };

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function normRid(s) { return (s || '').replace(/\s+/g, '').trim(); }
function normalizeMnemonic(s) { return (s || '').trim().toLowerCase().replace(/\s+/g, ' '); }

function b58encode(bytes) {
  const src = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes || []);
  if (src.length === 0) return '';
  const digits = [0];
  for (let i = 0; i < src.length; i++) {
    let carry = src[i];
    for (let j = 0; j < digits.length; j++) {
      carry += digits[j] << 8;
      digits[j] = carry % 58;
      carry = (carry / 58) | 0;
    }
    while (carry) {
      digits.push(carry % 58);
      carry = (carry / 58) | 0;
    }
  }
  let out = '';
  for (let k = 0; k < src.length && src[k] === 0; k++) out += ALPH[0];
  for (let q = digits.length - 1; q >= 0; q--) out += ALPH[digits[q]];
  return out;
}

function validateNewPassword(pass) {
  if (!pass || pass.length < 10) throw new Error('Пароль ≥10 символов');
  if (!/[A-Za-z]/.test(pass) || !/[0-9]/.test(pass)) throw new Error('Пароль должен содержать буквы и цифры');
  return pass;
}
function ensureLoginPassword(pass) {
  if (!pass || pass.length < 6) throw new Error('Пароль ≥6 символов');
  return pass;
}

async function sha256Bytes(str) {
  const digest = await crypto.subtle.digest('SHA-256', enc.encode(str));
  return new Uint8Array(digest);
}

function randomWord(len = 5) {
  const buf = new Uint8Array(len);
  crypto.getRandomValues(buf);
  let w = '';
  for (let i = 0; i < len; i++) w += MN_ALPH[buf[i] % MN_ALPH.length];
  return w;
}
function generateMnemonic() {
  const words = [];
  for (let i = 0; i < MN_WORDS; i++) words.push(randomWord());
  return words.join(' ');
}

async function mnemonicToSeed(mnemonic) {
  const norm = normalizeMnemonic(mnemonic);
  if (!norm) throw new Error('Резервная фраза пуста');
  return sha256Bytes('logos-lrb-ed25519:' + norm); // 32 bytes
}

function buildPkcs8FromSeed(seed32) {
  if (!(seed32 instanceof Uint8Array) || seed32.length !== 32) throw new Error('seed должен быть 32 байта');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed32, ED25519_PKCS8_PREFIX.length);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

async function deriveKey(pass, saltU8) {
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt: saltU8, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['encrypt', 'decrypt']
  );
}

async function aesEncrypt(aesKey, plainU8) {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = new Uint8Array(await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, aesKey, plainU8));
  return { iv, ct };
}

async function aesDecrypt(aesKey, ivU8, ctU8) {
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

// ---------- IndexedDB ----------
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}
async function idbSet(key, val) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = () => resolve();
    r.onerror = () => reject(r.error);
  });
}
async function idbDel(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.delete(key);
    r.onsuccess = () => resolve();
    r.onerror = () => reject(r.error);
  });
}

async function listAccounts() { return (await idbGet('accounts')) || []; }
async function addAccount(rid) {
  const list = (await idbGet('accounts')) || [];
  if (!list.includes(rid)) {
    list.push(rid);
    await idbSet('accounts', list);
  }
}

// Pending state
let pendingRid = null;
let pendingMnemonic = null;

async function createAccount(passRaw) {
  ensureEnv();
  const pass = validateNewPassword(passRaw);

  out('Создаём ключ и фразу…');

  const mnemonic = generateMnemonic();
  const seed = await mnemonicToSeed(mnemonic);
  const pkcs8 = buildPkcs8FromSeed(seed);

  const kp = nacl.sign.keyPair.fromSeed(seed);
  const pub = new Uint8Array(kp.publicKey);
  const rid = b58encode(pub);

  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt);
  const { iv, ct } = await aesEncrypt(aes, pkcs8);

  const meta = {
    rid,
    pub: Array.from(pub),
    salt: Array.from(salt),
    iv: Array.from(iv),
    priv: Array.from(ct),
  };

  await idbSet('acct:' + rid, meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass', pass);
  sessionStorage.setItem('logos_rid', rid);

  pendingRid = rid;
  pendingMnemonic = mnemonic;

  const sec = $('#mnemonicSection');
  const disp = $('#mnemonicShow');
  const confirm = $('#mnemonicConfirm');
  if (sec && disp && confirm) {
    disp.value = mnemonic;
    confirm.value = '';
    sec.hidden = false;
    sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  out('RID создан: ' + rid + '. Запиши фразу и подтверди её.');
}

async function loginAccount(ridRaw, passRaw) {
  ensureEnv();
  const rid = normRid(ridRaw);
  const pass = ensureLoginPassword(passRaw);
  if (!rid) throw new Error('Укажи RID');

  const meta = await idbGet('acct:' + rid);
  if (!meta) {
    const list = await listAccounts();
    throw new Error('RID не найден на этом устройстве.\n' + (list.length ? list.join('\n') : '— пусто —'));
  }

  const aes = await deriveKey(pass, new Uint8Array(meta.salt || []));
  try {
    const pkcs8 = await aesDecrypt(aes, new Uint8Array(meta.iv || []), new Uint8Array(meta.priv || []));
    // проверим, что это действительно наш PKCS8 (совместимость/коррупция)
    extractSeedFromPkcs8(pkcs8);
  } catch (_) {
    throw new Error('Неверный пароль или повреждённый ключ');
  }

  sessionStorage.setItem('logos_pass', pass);
  sessionStorage.setItem('logos_rid', rid);
  await idbSet('last_rid', rid);

  out('Вход…');
  location.href = './app.html';
}

async function restoreAccount(mnemonicRaw, passRaw) {
  ensureEnv();
  const pass = validateNewPassword(passRaw);
  const mnemonic = normalizeMnemonic(mnemonicRaw);
  if (!mnemonic) throw new Error('Введи резервную фразу');

  out('Восстанавливаем кошелёк…');

  const seed = await mnemonicToSeed(mnemonic);
  const pkcs8 = buildPkcs8FromSeed(seed);

  const kp = nacl.sign.keyPair.fromSeed(seed);
  const pub = new Uint8Array(kp.publicKey);
  const rid = b58encode(pub);

  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt);
  const { iv, ct } = await aesEncrypt(aes, pkcs8);

  const meta = {
    rid,
    pub: Array.from(pub),
    salt: Array.from(salt),
    iv: Array.from(iv),
    priv: Array.from(ct),
  };

  await idbSet('acct:' + rid, meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass', pass);
  sessionStorage.setItem('logos_rid', rid);

  out('Кошелёк восстановлен: ' + rid + ' → вход…');
  location.href = './app.html';
}

async function resetAll() {
  const ok = confirm('Точно стереть все локальные аккаунты? Это нельзя отменить.');
  if (!ok) return;
  const list = await listAccounts();
  for (const rid of list) await idbDel('acct:' + rid);
  await idbDel('accounts');
  await idbDel('last_rid');
  sessionStorage.clear();
  pendingRid = null;
  pendingMnemonic = null;
  out('Все аккаунты удалены.');
}

function renderRidList(list) {
  const wrap = $('#listWrap');
  const ul = $('#ridList');
  if (!wrap || !ul) return;
  ul.innerHTML = '';
  wrap.hidden = false;

  if (!list.length) {
    const li = document.createElement('li');
    li.textContent = '— пусто —';
    ul.appendChild(li);
    return;
  }

  for (const rid of list) {
    const li = document.createElement('li');
    li.textContent = rid;
    li.addEventListener('click', () => {
      const inp = $('#loginRid');
      if (inp) inp.value = rid;
      out('RID подставлен');
    });
    ul.appendChild(li);
  }
}

// boot helpers
(async () => {
  try {
    // last_rid
    const last = await idbGet('last_rid');
    const loginRid = $('#loginRid');
    if (last && loginRid) loginRid.value = last;

    // DEV reset only on localhost
    const resetBtn = $('#btn-reset');
    if (resetBtn) {
      const isDevHost = (location.hostname === 'localhost' || location.hostname === '127.0.0.1');
      resetBtn.hidden = !isDevHost;
    }
  } catch (e) {
    console.error(e);
  }
})();

// UI wiring
$('#btn-login')?.addEventListener('click', async () => {
  try {
    await loginAccount($('#loginRid')?.value || '', $('#loginPass')?.value || '');
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});

$('#btn-create')?.addEventListener('click', async () => {
  try {
    await createAccount($('#createPass')?.value || '');
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});

$('#btn-list')?.addEventListener('click', async () => {
  try {
    renderRidList(await listAccounts());
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});

$('#btn-reset')?.addEventListener('click', async () => {
  const isDevHost = (location.hostname === 'localhost' || location.hostname === '127.0.0.1');
  if (!isDevHost) {
    out('ERR: reset доступен только на localhost (dev)');
    return;
  }
  try {
    await resetAll();
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});

$('#btn-mnemonic-ok')?.addEventListener('click', () => {
  if (!pendingRid || !pendingMnemonic) {
    out('Нет созданного кошелька для подтверждения');
    return;
  }
  const typed = normalizeMnemonic($('#mnemonicConfirm')?.value || '');
  if (!typed) { out('Повтори фразу для подтверждения'); return; }
  if (typed !== normalizeMnemonic(pendingMnemonic)) { out('Фразы не совпадают'); return; }
  out('Фраза подтверждена, вход…');
  location.href = './app.html';
});

$('#btn-restore')?.addEventListener('click', async () => {
  try {
    await restoreAccount($('#restoreMnemonic')?.value || '', $('#restorePass')?.value || '');
  } catch (e) {
    out('ERR: ' + (e && e.message ? e.message : e));
  }
});

```

### FILE: /opt/logos/www/wallet/compat.js
```js
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();

```

### FILE: /opt/logos/www/wallet/connect.js
```js
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };

```

### FILE: /opt/logos/www/wallet/index.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>

```

### FILE: /opt/logos/www/wallet/login.html
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="refresh" content="0; url=./auth.html"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
</head>
<body>
  <p>Redirect to <a href="./auth.html">auth.html</a>…</p>
</body>
</html>

```

### FILE: /opt/logos/www/wallet/ui.js
```js
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();

```

### FILE: /opt/logos/www/wallet/wallet.css
```css
:root {
  --bg: #050910;
  --bg-grad-1: rgba(56,189,248,0.18);
  --bg-grad-2: rgba(129,140,248,0.20);

  --card: #020617;
  --card-alt: #020617;

  --border-subtle: rgba(148,163,184,0.30);
  --border-strong: rgba(148,163,184,0.65);

  --accent: #3b82f6;
  --accent-soft: rgba(59,130,246,0.16);
  --accent-strong: #60a5fa;

  --danger: #f97373;

  --text-main: #e5e7eb;
  --text-muted: #9ca3af;

  --radius-card: 20px;
  --radius-sm: 10px;

  --shadow-soft: 0 24px 60px rgba(0,0,0,0.75);

  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
           "Liberation Mono", "Courier New", monospace;
}

/* базовые */

*,
*::before,
*::after {
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
               Roboto, sans-serif;
  background:
    radial-gradient(circle at top left, var(--bg-grad-1), transparent 58%),
    radial-gradient(circle at bottom right, var(--bg-grad-2), transparent 55%),
    var(--bg);
  color: var(--text-main);
  min-height: 100vh;
}

/* верхняя панель */

.topbar {
  position: sticky;
  top: 0;
  z-index: 40;
  background: linear-gradient(95deg, rgba(15,23,42,0.98), rgba(15,23,42,0.96));
  backdrop-filter: blur(16px);
  border-bottom: 1px solid rgba(148,163,184,0.18);
  box-shadow: 0 18px 40px rgba(0,0,0,0.65);
  padding: 10px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.topbar-left {
  display: flex;
  align-items: center;
  gap: 10px;
}

.logo-dot {
  width: 26px;
  height: 26px;
  border-radius: 999px;
  background: radial-gradient(circle at 30% 30%, #22d3ee, #6366f1);
  box-shadow: 0 0 20px rgba(56,189,248,0.55);
}

.topbar-title {
  display: flex;
  flex-direction: column;
  line-height: 1.1;
}

.topbar-title .brand {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  color: #e5e7eb;
}

.topbar-title .product {
  font-size: 13px;
  color: var(--text-muted);
}

.topbar-right {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
}

.endpoint-label {
  color: var(--text-muted);
}

.endpoint-value {
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.9);
}

/* общая раскладка */

.page-shell {
  max-width: 1040px;
  margin: 0 auto;
  padding: 18px 16px 40px;
}

.page-header {
  margin-bottom: 18px;
}

.page-header h1 {
  font-size: 22px;
  margin: 0 0 6px;
}

.subtitle {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

/* карточки */

.card {
  background: radial-gradient(circle at top left, rgba(56,189,248,0.10), transparent 55%),
              var(--card);
  border-radius: var(--radius-card);
  border: 1px solid var(--border-subtle);
  box-shadow: var(--shadow-soft);
  margin-bottom: 18px;
  overflow: hidden;
}

.card-header {
  padding: 14px 18px 10px;
  border-bottom: 1px solid rgba(15,23,42,0.9);
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.card-title {
  font-size: 16px;
  margin: 0 0 4px;
}

.card-caption {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

.card-body {
  padding: 14px 18px 16px;
}

/* поля */

.field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 12px;
}

.field-row {
  display: flex;
  gap: 10px;
  align-items: flex-end;
  margin-bottom: 12px;
}

.field-row .grow {
  flex: 1 1 auto;
}

.field-label {
  font-size: 12px;
  color: var(--text-muted);
}

.field-input {
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.95);
  color: var(--text-main);
  padding: 8px 10px;
  font-size: 14px;
  outline: none;
}

.field-input:focus {
  border-color: var(--accent-strong);
  box-shadow: 0 0 0 1px rgba(59,130,246,0.55);
}

/* текстовые выводы */

.mono-field,
.mono-output {
  width: 100%;
  font-family: var(--mono);
  font-size: 13px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(2,6,23,0.96);
  color: var(--text-main);
  padding: 10px 12px;
  resize: vertical;
  min-height: 80px;
  white-space: pre-wrap;
}

.mono-output {
  margin-top: 8px;
}

/* кнопки */

.actions-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 6px;
  margin-bottom: 6px;
}

.btn {
  border-radius: 999px;
  border: 1px solid transparent;
  padding: 7px 14px;
  font-size: 13px;
  cursor: pointer;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.btn.primary {
  background: linear-gradient(135deg, #2563eb, #3b82f6);
  border-color: rgba(59,130,246,0.8);
  color: #fff;
}

.btn.primary:hover {
  background: linear-gradient(135deg, #1d4ed8, #2563eb);
}

.btn.secondary {
  background: rgba(15,23,42,0.95);
  border-color: var(--border-strong);
  color: var(--text-main);
}

.btn.secondary:hover {
  border-color: var(--accent-strong);
}

.btn.ghost {
  background: transparent;
  border-color: var(--border-subtle);
  color: var(--text-muted);
}

.btn.ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* чипы */

.chip {
  padding: 5px 10px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.92);
  font-size: 12px;
  color: var(--text-muted);
  cursor: pointer;
}

.chip-ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* подсказки */

.hint {
  margin-top: 8px;
  font-size: 12px;
  color: var(--text-muted);
}

/* адаптив */

@media (max-width: 720px) {
  .topbar {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }

  .field-row {
    flex-direction: column;
    align-items: stretch;
  }

  .page-shell {
    padding: 14px 10px 32px;
  }
}

```

### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.css
```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */

```

### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->

</body>
</html>

```

### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102635Z/app.js
```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */

```

### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.css
```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}


/* ====== External wallets card ====== */
.extWalletCard{ margin-top:16px; }
.extHead{ display:flex; align-items:flex-start; justify-content:space-between; gap:12px; }
.extTitle{ font-weight:700; font-size:16px; letter-spacing:0.2px; }
.extSub{ opacity:.75; font-size:12px; margin-top:2px; }
.extMeta{ display:flex; gap:8px; align-items:center; }
.pill{ padding:6px 10px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.10); background:rgba(255,255,255,.04); }
.pill.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.pill.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
.pill.ghost{ opacity:.8; }

.extGrid{ margin-top:12px; display:flex; flex-direction:column; gap:10px; }
.extRow{
  display:grid;
  grid-template-columns: 140px 120px 1fr 78px;
  gap:10px;
  align-items:center;
  padding:10px 10px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.08);
  background: rgba(0,0,0,.18);
}
.extCoin{ font-weight:650; }
.extAmt{ font-variant-numeric: tabular-nums; opacity:.95; }
.extAddr{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size:12px; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
.btnMini{
  padding:8px 10px;
  border-radius:10px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.06);
  cursor:pointer;
}
.btnMini:hover{ background: rgba(255,255,255,.10); }
.extFoot{ display:flex; justify-content:space-between; align-items:center; gap:12px; margin-top:10px; }
.extHint{ opacity:.75; font-size:12px; }
.extSrc{ opacity:.6; font-size:12px; text-align:right; }
/* ====== /External wallets card ====== */


/* ====== Bridge result box ====== */
.bridgeResult{
  margin-top:10px;
  padding:10px 12px;
  border-radius:12px;
  border:1px solid rgba(255,255,255,.10);
  background: rgba(0,0,0,.18);
  font-size:12px;
  line-height:1.35;
  white-space:pre-wrap;
}
.bridgeResult.ok{ border-color: rgba(80,255,170,.25); background: rgba(80,255,170,.06); }
.bridgeResult.bad{ border-color: rgba(255,100,120,.25); background: rgba(255,100,120,.06); }
/* ====== /Bridge result box ====== */

```

### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>

```

### FILE: /opt/logos/www/wallet_dev/_bak_bridge_20260107T102822Z/app.js
```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */

```

### FILE: /opt/logos/www/wallet_dev/_bak_entry_20260107T105554Z/index.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="color-scheme" content="dark"/>
  <link rel="stylesheet" href="./wallet.css?v=30"/>
</head>
<body>
  <!-- Верхняя панель -->
  <header class="topbar">
    <div class="topbar-left">
      <div class="logo-dot"></div>
      <div class="topbar-title">
        <span class="brand">LOGOS</span>
        <span class="product">Wallet</span>
      </div>
    </div>
    <div class="topbar-right">
      <span class="endpoint-label">Endpoint</span>
      <span class="endpoint-value" id="endpoint"></span>
      <button id="btn-lock" class="chip chip-ghost">Выйти</button>
    </div>
  </header>

  <main class="page-shell">
    <header class="page-header">
      <div>
        <h1>LOGOS Wallet — Кошелёк</h1>
        <p class="subtitle">
          Non‑custodial кошелёк: ключи и подписи живут только в этом браузере.
          Никакого серверного хранилища.
        </p>
      </div>
    </header>

    <!-- RID / PUB -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Твой RID / Публичный ключ</h2>
          <p class="card-caption">
            RID — адрес аккаунта в сети LOGOS. Публичный ключ (hex) используется для проверки подписи.
          </p>
        </div>
      </header>
      <div class="card-body">
        <textarea id="pub" class="mono-field" readonly></textarea>
        <p class="hint">
          Ключи живут только в памяти этой вкладки. После выхода или закрытия
          вкладки для доступа к кошельку снова нужен пароль.
        </p>
      </div>
    </section>

    <!-- Баланс -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Баланс</h2>
          <p class="card-caption">
            Проверка баланса и nonce для выбранного RID.
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">RID</span>
          <input id="rid-balance" type="text" class="field-input" placeholder="RID"/>
        </label>

        <div class="actions-row">
          <button id="btn-balance" class="btn primary">Показать баланс</button>
        </div>

        <pre id="out-balance" class="mono-output"></pre>
      </div>
    </section>

    <!-- Подпись и отправка -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Подпись и отправка (batch)</h2>
          <p class="card-caption">
            Подписанная Ed25519 транзакция отправляется в ноду как батч (одна транзакция).
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">Получатель (RID)</span>
          <input id="to" type="text" class="field-input" placeholder="RID получателя"/>
        </label>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Сумма (LGN)</span>
            <input id="amount" type="number" min="0" step="1" class="field-input"/>
          </label>

          <label class="field field-nonce">
            <span class="field-label">Nonce (debug)</span>
            <input id="nonce" type="number" class="field-input"/>
          </label>
        </div>

        <div class="actions-row">
          <button id="btn-send" class="btn primary">Подписать и отправить</button>
          <button id="btn-nonce" class="btn ghost">Получить nonce</button>
        </div>

        <pre id="out-send" class="mono-output"></pre>
      </div>
    </section>

    <!-- Стейкинг -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Стейкинг (delegate / undelegate / claim)</h2>
          <p class="card-caption">
            Управление стейкингом текущего RID: делегирование, раз‑делегирование и заявка наград.
          </p>
        </div>
        <button id="btn-stake-refresh" class="chip chip-ghost">Обновить статус</button>
      </header>
      <div class="card-body">
        <pre id="out-stake" class="mono-output"></pre>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Застейкать (delegate, LGN)</span>
            <input id="stake-amount" type="number" min="0" step="1" class="field-input"/>
          </label>
          <button id="btn-stake-delegate" class="btn primary">Делегировать</button>
        </div>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Разстейкать (undelegate, LGN)</span>
            <input id="unstake-amount" type="number" min="0" step="1" class="field-input"/>
          </label>
          <button id="btn-stake-undelegate" class="btn ghost">Разстейкать</button>
        </div>

        <div class="actions-row">
          <button id="btn-stake-claim" class="btn secondary">Заявить награду (claim)</button>
        </div>
      </div>
    </section>

    <!-- Мост rToken -->
    <section class="card">
      <header class="card-header">
        <div>
          <h2 class="card-title">Мост rToken (депозит, demo)</h2>
          <p class="card-caption">
            Демонстрационный депозит rLGN через внешний txid.
          </p>
        </div>
      </header>
      <div class="card-body">
        <label class="field">
          <span class="field-label">RID</span>
          <input id="rid-bridge" type="text" class="field-input" placeholder="RID для депозита rLGN"/>
        </label>

        <div class="field-row">
          <label class="field grow">
            <span class="field-label">Сумма (rLGN)</span>
            <input id="amount-bridge" type="number" min="0" step="1" class="field-input"/>
          </label>

          <label class="field grow">
            <span class="field-label">ext_txid (например eth_txid_0xabc)</span>
            <input id="ext" type="text" class="field-input"/>
          </label>
        </div>

        <div class="actions-row">
          <button id="btn-deposit" class="btn primary">Deposit rLGN (demo)</button>
        </div>

        <pre id="out-bridge" class="mono-output"></pre>
      </div>
    </section>
  </main>

  <script src="./app.js?v=1" defer></script>
</body>
</html>

```

### FILE: /opt/logos/www/wallet_dev/_bak_entry_20260108T142703Z/index.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

</body>
</html>

```

### FILE: /opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/app.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>

<!-- ====== External wallets (wallet-api) ====== -->
<div class="card extWalletCard" id="extWalletCard" style="display:none;">
  <div class="extHead">
    <div>
      <div class="extTitle">External wallets</div>
      <div class="extSub">BTC / ETH / TRX / USDT — on-chain balances (watch-only)</div>
    </div>
    <div class="extMeta">
      <span class="pill" id="extWalletStatus">connecting…</span>
      <span class="pill ghost" id="extWalletLatency">—</span>
    </div>
  </div>

  <div class="extGrid">
    <div class="extRow">
      <div class="extCoin">BTC</div>
      <div class="extAmt" id="bal_btc">—</div>
      <div class="extAddr" id="addr_btc">—</div>
      <button class="btnMini" data-copy="addr_btc">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">ETH</div>
      <div class="extAmt" id="bal_eth">—</div>
      <div class="extAddr" id="addr_eth">—</div>
      <button class="btnMini" data-copy="addr_eth">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">TRX</div>
      <div class="extAmt" id="bal_trx">—</div>
      <div class="extAddr" id="addr_trx">—</div>
      <button class="btnMini" data-copy="addr_trx">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (ERC-20)</div>
      <div class="extAmt" id="bal_usdt_erc20">—</div>
      <div class="extAddr" id="addr_usdt_erc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_erc20">Copy</button>
    </div>

    <div class="extRow">
      <div class="extCoin">USDT (TRC-20)</div>
      <div class="extAmt" id="bal_usdt_trc20">—</div>
      <div class="extAddr" id="addr_usdt_trc20">—</div>
      <button class="btnMini" data-copy="addr_usdt_trc20">Copy</button>
    </div>
  </div>

  <div class="extFoot">
    <div class="extHint" id="extWalletHint">Tip: deposits show up automatically (refresh every ~15s).</div>
    <div class="extSrc" id="extWalletSources">—</div>
  </div>
</div>
<!-- ====== /External wallets ====== -->


<div class="bridgeResult" id="bridgeResult" style="display:none;"></div>

<script src="assets.js?v=1"></script>
</body>
</html>

```

### FILE: /opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/app.js
```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);


/* ====== LOGOS_EXT_WALLET_UI (wallet-api balances) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const show = (el, on=true) => { if (el) el.style.display = on ? "" : "none"; };

  const trunc = (s, a=8, b=6) => {
    if (!s || typeof s !== "string") return "—";
    if (s.length <= a+b+3) return s;
    return s.slice(0,a) + "…" + s.slice(-b);
  };

  const safeNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? n : 0;
  };

  const fmtFixed = (n, d=6) => {
    try {
      return safeNum(n).toFixed(d).replace(/\.?0+$/, "");
    } catch {
      return String(n ?? "0");
    }
  };

  const satToBtc = (sat) => safeNum(sat) / 1e8;
  const weiToEth = (wei) => safeNum(wei) / 1e18;

  const getRID = () => {
    // подстрахуемся под разные ключи
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("rid") ||
      localStorage.getItem("logos_rid") ||
      ""
    ).trim();
  };

  const apiGet = async (url, timeoutMs=8000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials: "omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally {
      clearTimeout(t);
    }
  };

  const bindCopyButtons = () => {
    document.querySelectorAll("[data-copy]").forEach((btn) => {
      if (btn.dataset.bound) return;
      btn.dataset.bound = "1";
      btn.addEventListener("click", async () => {
        const id = btn.getAttribute("data-copy");
        const el = $(id);
        const full = el ? (el.dataset.full || el.textContent || "") : "";
        if (!full || full === "—") return;
        try {
          await navigator.clipboard.writeText(full);
          const prev = btn.textContent;
          btn.textContent = "Copied";
          setTimeout(() => (btn.textContent = prev), 900);
        } catch {}
      });
    });
  };

  const setStatus = (ok, text) => {
    const s = $("extWalletStatus");
    if (!s) return;
    s.classList.remove("ok", "bad");
    s.classList.add(ok ? "ok" : "bad");
    s.textContent = text;
  };

  const setLatency = (ms) => {
    const el = $("extWalletLatency");
    if (!el) return;
    el.textContent = (ms != null) ? (ms + " ms") : "—";
  };

  const setAddr = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.dataset.full = val || "";
    el.textContent = trunc(val || "");
  };

  const setAmt = (id, val) => {
    const el = $(id);
    if (!el) return;
    el.textContent = val;
  };

  const render = (payload) => {
    const a = payload.addresses || {};
    const b = payload.balances || {};
    setAddr("addr_btc", a.BTC);
    setAddr("addr_eth", a.ETH);
    setAddr("addr_trx", a.TRON);
    setAddr("addr_usdt_erc20", a.USDT_ERC20 || a.ETH);
    setAddr("addr_usdt_trc20", a.USDT_TRC20 || a.TRON);

    if (b.BTC) {
      setAmt("bal_btc", fmtFixed(satToBtc(b.BTC.total_sat || 0), 8) + " BTC");
    }
    if (b.ETH) {
      setAmt("bal_eth", fmtFixed(weiToEth(b.ETH.wei || 0), 6) + " ETH");
      const u = (b.ETH.usdt_erc20 || {});
      setAmt("bal_usdt_erc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }
    if (b.TRON) {
      setAmt("bal_trx", fmtFixed((safeNum(b.TRON.sun || 0) / 1e6), 6) + " TRX");
      const u = (b.TRON.usdt_trc20 || {});
      // raw может быть null если API не вернул токены — считаем 0
      setAmt("bal_usdt_trc20", fmtFixed((safeNum(u.raw || 0) / 1e6), 2) + " USDT");
    }

    const src = $("extWalletSources");
    if (src) {
      const sBTC = b.BTC?.source || "—";
      const sETH = b.ETH?.source || "—";
      const sTR  = b.TRON?.source || "—";
      src.textContent = `Sources: BTC=${sBTC} · ETH=${sETH} · TRON=${sTR}`;
    }

    setLatency(payload.latency_ms);
  };

  const tick = async () => {
    const rid = getRID();
    const card = $("extWalletCard");
    if (!rid) { show(card, false); return; }
    show(card, true);
    bindCopyButtons();

    try {
      setStatus(true, "updating…");
      // balances уже включает addresses, но на всякий страх — дернём receive один раз при первом показе
      const data = await apiGet(`${WALLET_API}/v1/balances/${encodeURIComponent(rid)}`, 12000);
      render(data);
      setStatus(true, "live");
    } catch (e) {
      setStatus(false, "offline");
    }
  };

  // старт
  setTimeout(() => tick(), 250);
  setInterval(() => tick(), 15000);

  window.LOGOS_EXT_WALLET_UI = { tick };
})();
 /* ====== /LOGOS_EXT_WALLET_UI ====== */


/* ====== LOGOS_BRIDGE_UI_BIND (auto-detect bridge endpoints from wallet-api openapi) ====== */
(() => {
  const ORIGIN = (location.origin || "").replace(/\/$/, "");
  const WALLET_API = (window.LOGOS_WALLET_API || (ORIGIN + "/wallet-api")).replace(/\/$/, "");

  const $ = (id) => document.getElementById(id);
  const rid = () =>
    (localStorage.getItem("RID") || localStorage.getItem("rid") || localStorage.getItem("logos_rid") || "").trim();

  const showResult = (ok, text) => {
    const box = $("bridgeResult");
    if (!box) return;
    box.style.display = "";
    box.classList.remove("ok","bad");
    box.classList.add(ok ? "ok" : "bad");
    box.textContent = text;
  };

  const apiGet = async (url, timeoutMs=12000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, { signal: ctrl.signal, credentials:"omit" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      return await r.json();
    } finally { clearTimeout(t); }
  };

  const apiPost = async (url, body, timeoutMs=20000) => {
    const ctrl = new AbortController();
    const t = setTimeout(() => ctrl.abort(), timeoutMs);
    try {
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify(body),
        signal: ctrl.signal,
        credentials:"omit",
      });
      const txt = await r.text();
      let data = null;
      try { data = JSON.parse(txt); } catch {}
      if (!r.ok) throw new Error("HTTP " + r.status + (txt ? (": " + txt.slice(0,300)) : ""));
      return data ?? { ok:true, raw: txt };
    } finally { clearTimeout(t); }
  };

  const normDir = (v) => (v || "").trim();
  const normChain = (v) => (v || "").trim();
  const normAmt = (v) => {
    const n = Number(String(v||"").replace(",", "."));
    return Number.isFinite(n) ? n : 0;
  };

  // --- autodetect endpoints
  let EP = { quote:null, create:null, status:null, openapi:null };

  const detectEndpoints = async () => {
    if (EP.openapi) return EP;
    try {
      const spec = await apiGet(`${WALLET_API}/openapi.json`, 12000);
      EP.openapi = spec;

      const paths = Object.keys(spec.paths || {});
      const cand = (re) => paths.filter(p => re.test(p)).sort();

      // ищем популярные варианты
      const quote = cand(/quote/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*quote/i)[0] || cand(/quote/i)[0];
      const create = cand(/create|request|order|swap/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || cand(/bridge.*(create|request|order)/i)[0];
      const status = cand(/status|order/i).find(p => /bridge|swap|rlgn|convert/i.test(p)) || null;

      EP.quote = quote || null;
      EP.create = create || null;
      EP.status = status || null;

      return EP;
    } catch (e) {
      // fallback (если openapi не отдался)
      EP.quote  = "/v1/bridge/quote";
      EP.create = "/v1/bridge/create";
      EP.status = "/v1/bridge/status";
      return EP;
    }
  };

  const readForm = () => {
    const r = rid();
    if (!r) throw new Error("RID not found. Create/restore RID first.");
    const direction = normDir($("bridge_direction")?.value);
    const chain = normChain($("bridge_chain")?.value);
    const amount = normAmt($("bridge_amount")?.value);
    const ext_txid = ($("bridge_ext_txid")?.value || "").trim();

    return { rid: r, direction, chain, amount, ext_txid };
  };

  const doQuote = async () => {
    const ep = await detectEndpoints();
    if (!ep.quote) throw new Error("Bridge quote endpoint not found in openapi.");
    const f = readForm();

    // минимальный payload (без мусора)
    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.quote}`, body, 20000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[QUOTE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const doCreate = async () => {
    const ep = await detectEndpoints();
    if (!ep.create) throw new Error("Bridge create endpoint not found in openapi.");
    const f = readForm();

    const body = {
      rid: f.rid,
      direction: f.direction,
      chain: f.chain,
      amount: f.amount,
      ext_txid: f.ext_txid || undefined,
    };

    const t0 = performance.now();
    const res = await apiPost(`${WALLET_API}${ep.create}`, body, 25000);
    const ms = Math.round(performance.now() - t0);

    showResult(true, `[CREATE ✅] ${ms} ms\n` + JSON.stringify(res, null, 2));
  };

  const bind = () => {
    const bq = $("b_bridge_quote");
    const bc = $("b_bridge_create");
    if (bq && !bq.dataset.bound) {
      bq.dataset.bound = "1";
      bq.addEventListener("click", async () => {
        try { showResult(true, "Calculating…"); await doQuote(); }
        catch (e) { showResult(false, "[QUOTE ❌]\n" + (e?.message || String(e))); }
      });
    }
    if (bc && !bc.dataset.bound) {
      bc.dataset.bound = "1";
      bc.addEventListener("click", async () => {
        try { showResult(true, "Creating…"); await doCreate(); }
        catch (e) { showResult(false, "[CREATE ❌]\n" + (e?.message || String(e))); }
      });
    }
  };

  setTimeout(bind, 300);
  window.LOGOS_BRIDGE_UI_BIND = { bind };
})();
 /* ====== /LOGOS_BRIDGE_UI_BIND ====== */

```

### FILE: /opt/logos/www/wallet_dev/_bak_premiumtabs_20260109T063827Z/ui.css
```css

/* assets ui */
.assetsWrap{display:block;margin-top:16px}
.assetsHead{display:flex;gap:12px;align-items:center;justify-content:space-between;margin:8px 0 14px}
.assetsTitle{font-weight:800;font-size:20px;letter-spacing:.2px}
.assetsSub{margin-top:4px;color:rgba(255,255,255,.62);font-size:12px}
.assetsGrid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:14px}
@media (max-width: 900px){.assetsGrid{grid-template-columns:1fr}}
.assetCard{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:18px;padding:14px;box-shadow:0 16px 50px rgba(0,0,0,.35);backdrop-filter: blur(16px)}
.assetTop{display:flex;gap:12px;align-items:center}
.assetSym{width:48px;height:48px;border-radius:14px;display:flex;align-items:center;justify-content:center;font-weight:800;
  background:radial-gradient(120% 120% at 30% 10%, rgba(78,124,255,.35), rgba(139,92,246,.25), rgba(0,0,0,0));
  border:1px solid rgba(255,255,255,.12)
}
.assetName{font-weight:700}
.assetBal{margin-top:2px;font-size:13px;color:rgba(255,255,255,.75)}
.assetAddrRow{margin-top:12px;display:flex;gap:10px;align-items:center;justify-content:space-between}
.assetAddr{max-width:70%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:rgba(255,255,255,.85)}
.assetNote{margin-top:10px;font-size:12px}

```

### FILE: /opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.css
```css
/* Wallet App page tweaks (Lux v3) */

/* ключи/выводы выглядят как терминал */
#pub{
  min-height:120px;
  resize:vertical;
}

#pub,
#out-balance,
#out-send,
#out-stake,
#out-bridge{
  font-family:var(--mono);
  font-size:12.5px;
  line-height:1.45;
}

/* ограничим высоту логов, чтобы не раздувало страницу */
#out-balance,#out-send,#out-stake,#out-bridge{
  max-height:280px;
}

/* часто эти id встречаются — делаем RID-поля моно (не ломает, даже если каких-то id нет) */
#rid,#to,#loginRid{
  font-family:var(--mono);
  letter-spacing:.1px;
}

```

### FILE: /opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="/shared/wallet-themeP260101_01"/>
  <link rel="stylesheet" href="./appP260101_01"/>
<script src="./api_base.js"></script>
<link rel="stylesheet" href="/shared/wallet-theme.css?v=20260101_02"/>
</head>
<body class="logos-ui">
  <header class="topbar">
    <div class="topbar__inner">
      <div class="brand">
        <div class="brand__mark"><span>LRB</span></div>
        <div>
          <div class="brand__title">LOGOS Wallet</div>
          <div class="brand__sub">Local keys · Signed in browser · API ready</div>
        </div>
      </div>
      <div class="topbar__right">
        <div class="pill">API: <span id="endpoint" class="mono">/api</span></div>
        <button id="btn-lock" class="secondary" type="button">Выйти (лок)</button>
      </div>
    </div>
  </header>

  <main class="container">
    <div class="stack">
      <section class="card">
        <header class="card__head">
          <h2>Ключи</h2>
          <p class="muted">RID = base58(pubkey). Приватный ключ зашифрован локально (AES‑GCM + PBKDF2).</p>
        </header>
        <textarea id="pub" class="mono" readonly spellcheck="false"></textarea>
        <pre id="out-status" class="mono">OK</pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Баланс</h2>
        </header>

        <label>RID</label>
        <input id="rid-balance" class="mono" placeholder="RID"/>

        <div class="row">
          <button id="btn-balance" class="primary" type="button">Показать баланс</button>
          <button id="btn-nonce" type="button">Обновить nonce</button>
        </div>

        <pre id="out-balance" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Отправить транзакцию</h2>
        </header>

        <label>Кому (RID)</label>
        <input id="to" class="mono" placeholder="RID получателя"/>

        <label>Сумма (micro‑LGN)</label>
        <input id="amount" type="number" min="1" step="1" value="1"/>

        <label>Nonce (авто)</label>
        <input id="nonce" type="number" readonly/>

        <div class="row">
          <button id="btn-send" class="primary" type="button">Подписать и отправить</button>
        </div>

        <pre id="out-send" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Стейкинг</h2>
        </header>

        <div class="row">
          <button id="btn-stake-refresh" type="button">Обновить статус</button>
          <button id="btn-stake-claim" class="secondary" type="button">Claim</button>
        </div>

        <label>Delegate (LGN)</label>
        <input id="stake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-delegate" class="primary" type="button">Делегировать</button>

        <label>Undelegate (LGN)</label>
        <input id="unstake-amount" type="number" min="1" step="1" value="0"/>
        <button id="btn-stake-undelegate" class="secondary" type="button">Снять делегацию</button>

        <pre id="out-stake" class="mono"></pre>
      </section>

      <section class="card">
        <header class="card__head">
          <h2>Bridge deposit (demo)</h2>
        </header>

        <label>RID</label>
        <input id="rid-bridge" class="mono" placeholder="RID"/>

        <label>Amount</label>
        <input id="amount-bridge" type="number" min="1" step="1" value="1"/>

        <label>ext_txid</label>
        <input id="ext" class="mono" placeholder="например eth_txid_0xabc"/>

        <div class="row">
          <button id="btn-deposit" type="button">Deposit</button>
        </div>

        <pre id="out-bridge" class="mono"></pre>
      </section>
    </div>
  </main>

  <script src="/shared/tweetnacl.min.js?v=20251212_04" defer></script>
  <script src="./app.js?v=20251212_04" defer></script>
</body>
</html>

```

### FILE: /opt/logos/www/wallet_dev/_bak_ui_20260107T101342Z/app.js
```js
'use strict';

const API = (window.API_ENDPOINT || (location.origin.replace(/\/$/, '') + '/node-api'));

const DB_NAME  = 'logos_wallet_v2';
const STORE    = 'keys';
const AUTOLOCK_MS = 15 * 60 * 1000;

const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30, 0x2e, 0x02, 0x01, 0x00,
  0x30, 0x05, 0x06, 0x03, 0x2b, 0x65, 0x70,
  0x04, 0x22, 0x04, 0x20
]);

const $ = (s) => document.querySelector(s);

let RID  = sessionStorage.getItem('logos_rid') || '';
let PASS = sessionStorage.getItem('logos_pass') || '';

let META = null;
let SEED = null;           // Uint8Array(32)
let KP   = null;           // nacl keypair
let lastActivity = Date.now();

function bump() { lastActivity = Date.now(); }

function lockNow() {
  try {
    PASS = '';
    RID = '';
    META = null;
    SEED = null;
    KP = null;
    sessionStorage.removeItem('logos_pass');
    sessionStorage.removeItem('logos_rid');
  } catch (_) {}
  location.href = './auth.html';
}

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto || !window.crypto.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl || !window.nacl.sign || !window.nacl.sign.keyPair || !window.nacl.sign.keyPair.fromSeed) {
    throw new Error('tweetnacl не загружен (нет window.nacl)');
  }
}

function toHex(u8) {
  const a = (u8 instanceof Uint8Array) ? u8 : new Uint8Array(u8 || []);
  let s = '';
  for (let i = 0; i < a.length; i++) s += a[i].toString(16).padStart(2, '0');
  return s;
}
function fromHex(hex) {
  const clean = (hex || '').trim();
  if (clean.length % 2 !== 0) throw new Error('нечётная длина hex');
  const out = new Uint8Array(clean.length / 2);
  for (let i = 0; i < out.length; i++) out[i] = parseInt(clean.slice(i*2, i*2+2), 16);
  return out;
}

function extractSeedFromPkcs8(pkcs8) {
  const u = (pkcs8 instanceof Uint8Array) ? pkcs8 : new Uint8Array(pkcs8 || []);
  if (u.length !== ED25519_PKCS8_PREFIX.length + 32) throw new Error('Неверная длина PKCS8');
  for (let i = 0; i < ED25519_PKCS8_PREFIX.length; i++) {
    if (u[i] !== ED25519_PKCS8_PREFIX[i]) throw new Error('PKCS8 prefix mismatch');
  }
  return u.slice(ED25519_PKCS8_PREFIX.length);
}

// IndexedDB
let DBP = null;
function openDb() {
  if (DBP) return DBP;
  DBP = new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}
async function idbGet(key) {
  const db = await openDb();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE, 'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = () => resolve(r.result || null);
    r.onerror = () => reject(r.error);
  });
}

async function deriveKey(pass, saltArr) {
  const salt = (saltArr instanceof Uint8Array) ? saltArr : new Uint8Array(saltArr || []);
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 120000, hash: 'SHA-256' },
    keyMat,
    { name: 'AES-GCM', length: 256 },
    false,
    ['decrypt']
  );
}
async function aesDecrypt(aesKey, ivArr, ctArr) {
  const iv = (ivArr instanceof Uint8Array) ? ivArr : new Uint8Array(ivArr || []);
  const ct = (ctArr instanceof Uint8Array) ? ctArr : new Uint8Array(ctArr || []);
  const plain = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, aesKey, ct);
  return new Uint8Array(plain);
}

// HTTP
async function getJSON(url) {
  const r = await fetch(url, { method:'GET', cache:'no-store', credentials:'same-origin' });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}
async function postJSON(url, body) {
  const r = await fetch(url, {
    method:'POST', cache:'no-store', credentials:'same-origin',
    headers:{'Content-Type':'application/json'},
    body: JSON.stringify(body ?? {})
  });
  if (!r.ok) throw new Error(`${url} ${r.status}`);
  return r.json();
}

async function getBalance(rid) {
  return getJSON(`${API}/balance/${encodeURIComponent(rid)}`);
}
async function getNonce(rid) {
  const j = await getBalance(rid);
  if (!j || typeof j.nonce !== 'number') throw new Error('не удалось получить nonce');
  return j.nonce;
}

// msg = from | '|' | to | '|' | amount(8 BE) | '|' | nonce(8 BE)
function canonBytes(from, to, amount, nonce) {
  const fromB = enc.encode(from);
  const toB   = enc.encode(to);

  const ab = new ArrayBuffer(8);
  const av = new DataView(ab);
  av.setBigUint64(0, BigInt(amount), false);

  const nb = new ArrayBuffer(8);
  const nv = new DataView(nb);
  nv.setBigUint64(0, BigInt(nonce), false);

  const sep = new Uint8Array([ '|'.charCodeAt(0) ]);

  const parts = [fromB, sep, toB, sep, new Uint8Array(ab), sep, new Uint8Array(nb)];
  const total = parts.reduce((s,a)=>s+a.length,0);
  const out = new Uint8Array(total);
  let off=0;
  for (const p of parts) { out.set(p, off); off += p.length; }
  return out;
}

async function sha256(u8) {
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

async function signHash32(hash32) {
  if (!KP) throw new Error('ключ не загружен');
  const sig = nacl.sign.detached(hash32, KP.secretKey);
  return toHex(new Uint8Array(sig));
}

async function refreshBalanceUI() {
  const out = $('#out-balance');
  try {
    const rid = ($('#rid-balance')?.value || RID || '').trim();
    const j = await getBalance(rid);
    if (out) out.textContent = JSON.stringify(j, null, 2);
    const nonce = (typeof j.nonce === 'number') ? (j.nonce + 1) : '';
    const nonceInp = $('#nonce');
    if (nonceInp) nonceInp.value = String(nonce);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function refreshStakeUI() {
  const out = $('#out-stake');
  try {
    const j = await getJSON(`${API}/stake/my/${encodeURIComponent(RID)}`);
    if (out) out.textContent = JSON.stringify(j, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
}

async function submitBatch(txs) {
  return postJSON(`${API}/submit_tx_batch`, { txs });
}

(async () => {
  try {
    ensureEnv();

    if (!RID || !PASS) { lockNow(); return; }

    const ep = $('#endpoint');
    if (ep) ep.textContent = API;

    META = await idbGet('acct:' + RID);
    if (!META) { lockNow(); return; }

    const aes = await deriveKey(PASS, META.salt || []);
    const pkcs8 = await aesDecrypt(aes, META.iv || [], META.priv || []);
    SEED = extractSeedFromPkcs8(pkcs8);

    KP = nacl.sign.keyPair.fromSeed(SEED);

    const pubHex = toHex(new Uint8Array(KP.publicKey));
    const pubArea = $('#pub');
    if (pubArea) pubArea.value = `RID (base58): ${RID}\nPUB (hex): ${pubHex}`;

    const rb = $('#rid-balance');
    if (rb) rb.value = RID;

    const rbridge = $('#rid-bridge');
    if (rbridge) rbridge.value = RID;

    bump();
    await refreshBalanceUI();
    await refreshStakeUI();

  } catch (e) {
    console.error('wallet boot error:', e);
    const st = $('#out-status');
    if (st) st.textContent = 'ERR: ' + (e && e.message ? e.message : e);
    lockNow();
  }
})();

// глобальная активность (чтобы автолок не срабатывал “во время работы”)
['click','keydown','mousemove','touchstart'].forEach(ev=>{
  window.addEventListener(ev, ()=>bump(), { passive:true });
});

$('#btn-lock')?.addEventListener('click', () => lockNow());

$('#btn-balance')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-nonce')?.addEventListener('click', async () => {
  bump();
  await refreshBalanceUI();
});

$('#btn-send')?.addEventListener('click', async () => {
  const out = $('#out-send');
  try {
    bump();
    const to = ($('#to')?.value || '').trim();
    const amount = Number(($('#amount')?.value || '').trim());
    if (!to) throw new Error('введи RID получателя');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');

    const currentNonce = await getNonce(RID);
    const nonce = currentNonce + 1;
    if ($('#nonce')) $('#nonce').value = String(nonce);

    const msg = canonBytes(RID, to, amount, nonce);
    const h32 = await sha256(msg);
    const sig_hex = await signHash32(h32);

    const res = await submitBatch([{
      from: RID,
      to,
      amount,
      nonce,
      sig_hex
    }]);

    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshBalanceUI();
  } catch (e) {
    console.error(e);
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// staking
$('#btn-stake-refresh')?.addEventListener('click', async () => { bump(); await refreshStakeUI(); });
$('#btn-stake-delegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#stake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/delegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-undelegate')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const val = Number(($('#unstake-amount')?.value || '0'));
    if (!Number.isFinite(val) || val <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/stake/undelegate`, { rid: RID, amount: val });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});
$('#btn-stake-claim')?.addEventListener('click', async () => {
  const out = $('#out-stake');
  try {
    bump();
    const res = await postJSON(`${API}/stake/claim`, { rid: RID });
    if (out) out.textContent = JSON.stringify(res, null, 2);
    await refreshStakeUI();
    await refreshBalanceUI();
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// bridge
$('#btn-deposit')?.addEventListener('click', async () => {
  const out = $('#out-bridge');
  try {
    bump();
    const rid = ( ($('#rid-bridge')?.value || RID || '').trim() );
    const amount = Number(($('#amount-bridge')?.value || '0'));
    const ext = String($('#ext')?.value || '');
    if (!rid) throw new Error('RID пустой');
    if (!Number.isFinite(amount) || amount <= 0) throw new Error('сумма должна быть > 0');
    const res = await postJSON(`${API}/bridge/deposit`, { rid, amount, ext_txid: ext });
    if (out) out.textContent = JSON.stringify(res, null, 2);
  } catch (e) {
    if (out) out.textContent = 'ERR: ' + (e && e.message ? e.message : e);
  }
});

// autolock
setInterval(() => {
  const now = Date.now();
  if (now - lastActivity > AUTOLOCK_MS) lockNow();
}, 30_000);

```

### FILE: /opt/logos/www/wallet_dev/api_base.js
```js
(() => {
  // same-origin only
  window.API_BASE   = "/api";        // node backend (nginx -> 127.0.0.1:8080)
  window.WALLET_API = "/wallet-api"; // wallet proxy (FastAPI)
})();

```

### FILE: /opt/logos/www/wallet_dev/app.css
```css
:root{
  --bg:#070a12; --txt:#e7ecff; --mut:#9aa7d9;
  --br:rgba(255,255,255,.10); --br2:rgba(255,255,255,.16);
  --acc:#6f7bff; --acc2:#9b5cff;
  --ok:#2dd4bf; --bad:#fb7185;
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
  background:
    radial-gradient(1200px 700px at 20% 0%, rgba(111,123,255,.18), transparent 60%),
    radial-gradient(900px 600px at 80% 10%, rgba(155,92,255,.14), transparent 55%),
    linear-gradient(180deg, #050812, var(--bg));
  color:var(--txt);
}
.mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace}
.wrap{max-width:1240px;margin:26px auto;padding:0 16px}
.card{
  background: linear-gradient(180deg, rgba(255,255,255,.045), rgba(255,255,255,.02));
  border:1px solid var(--br);
  border-radius:18px;
  padding:18px;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
  backdrop-filter: blur(10px);
}
.topbar{
  display:flex;align-items:center;justify-content:space-between;
  padding:14px 16px;border-bottom:1px solid var(--br);
  background: rgba(0,0,0,.25);
  position:sticky;top:0;z-index:10;
  backdrop-filter: blur(12px);
}
.brand{font-weight:800;letter-spacing:.4px}
.topbar-right{display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:flex-end}
.pill{
  border:1px solid var(--br2);
  padding:6px 10px;border-radius:999px;
  background: rgba(0,0,0,.25);
  font-size:12px;
}
.h1{font-size:20px;font-weight:800;margin:10px 0 6px}
.h2{font-size:16px;font-weight:800;margin:0 0 8px}
.muted{color:var(--mut);font-size:12px;line-height:1.35}
label{font-size:12px;color:var(--mut)}
input, select, textarea{
  width:100%;
  padding:12px 12px;
  border-radius:14px;
  border:1px solid var(--br);
  background: rgba(0,0,0,.28);
  color:var(--txt);
  outline:none;
}
textarea{min-height:92px;resize:vertical}
input:focus, select:focus, textarea:focus{border-color:rgba(111,123,255,.55)}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:10px}
.btn{
  border:1px solid var(--br2);
  background: rgba(0,0,0,.22);
  color:var(--txt);
  padding:10px 12px;
  border-radius:14px;
  cursor:pointer;
  user-select:none;
}
.btn.small{padding:8px 10px;border-radius:12px;font-size:12px}
.btn.primary{
  border-color: rgba(111,123,255,.55);
  background: linear-gradient(135deg, rgba(111,123,255,.35), rgba(155,92,255,.25));
}
.btn.danger{
  border-color: rgba(251,113,133,.55);
  background: rgba(251,113,133,.12);
}
.status{margin-top:10px;color:var(--mut);font-size:12px;min-height:16px}
.grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
@media (max-width: 980px){.grid{grid-template-columns:1fr}}
.big-num{font-size:30px;font-weight:900;letter-spacing:.4px}
.pre{white-space:pre-wrap;word-break:break-word;background:rgba(0,0,0,.24);border:1px solid var(--br);padding:12px;border-radius:14px;color:var(--txt)}
details{margin-top:10px}

.tabs{
  display:flex;gap:10px;flex-wrap:wrap;
  margin:14px 0 16px;
}
.tab{
  border:1px solid var(--br2);
  background: rgba(0,0,0,.18);
  padding:10px 14px;border-radius:999px;
  cursor:pointer;
  font-size:13px;
}
.tab.active{
  border-color: rgba(111,123,255,.55);
  background: linear-gradient(135deg, rgba(111,123,255,.22), rgba(155,92,255,.16));
}
.panel{display:none}
.panel.active{display:block}
.kv{
  display:grid;grid-template-columns: 1fr auto;gap:10px;align-items:center;
  padding:10px;border:1px solid var(--br);border-radius:14px;background:rgba(0,0,0,.18);
  margin-top:10px;
}
.kv .k{color:var(--mut);font-size:12px}
.kv .v{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size:12px; overflow-wrap:anywhere}
.badge-ok{color:var(--ok)}
.badge-bad{color:var(--bad)}

/* ===== Settings module helpers ===== */
.devOnly { display:none !important; }
.dev .devOnly { display:block !important; }

.kvRow{
  display:flex; align-items:center; justify-content:space-between;
  gap:12px;
  padding:10px 12px;
  border:1px solid rgba(255,255,255,.06);
  border-radius:12px;
  background: rgba(0,0,0,.10);
}
.btnRow{ display:flex; gap:10px; flex-wrap:wrap; }
.btn.danger{ border-color: rgba(255,107,107,.6); }
.btn.danger:hover{ filter:brightness(1.08); }

/* switch */
.switch{ position:relative; display:inline-block; width:44px; height:24px; }
.switch input{ opacity:0; width:0; height:0; }
.slider{
  position:absolute; cursor:pointer; inset:0;
  background: rgba(255,255,255,.10);
  border:1px solid rgba(255,255,255,.10);
  transition:.2s;
  border-radius:999px;
}
.slider:before{
  position:absolute; content:"";
  height:18px; width:18px; left:3px; top:50%;
  transform: translateY(-50%);
  background: rgba(255,255,255,.85);
  transition:.2s;
  border-radius:999px;
}
.switch input:checked + .slider{
  background: rgba(120,110,255,.35);
  border-color: rgba(120,110,255,.55);
}
.switch input:checked + .slider:before{
  transform: translateY(-50%) translateX(20px);
}

/* ===== Send module helpers ===== */
.grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
@media (max-width: 780px){ .grid2{ grid-template-columns:1fr; } }
.btnRow{ display:flex; gap:10px; flex-wrap:wrap; }

```

### FILE: /opt/logos/www/wallet_dev/app.html
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="./app.css?v=20260111_110230" />
  <script>
    // fixed routes (same-origin)
    window.API_BASE="/api";            // node backend
    window.WALLET_API="/wallet-api";   // wallet proxy
  </script>
</head>
<body>
  <div class="topbar">
    <div class="brand">LOGOS Wallet</div>
    <div class="topbar-right">
      <div class="pill">API: <span id="api" class="mono">/api</span></div>
      <div class="pill">RID: <span id="topRid" class="mono">—</span></div>
      <div class="pill">LGN: <span id="topBal" class="mono">—</span></div>
      <button id="btnLogout" class="btn small">Выйти</button>
    </div>
  </div>

  <div class="wrap">

    <div class="tabs">
      <div class="tab active" data-tab="assets">Активы</div>
      <div class="tab" data-tab="send">Отправка</div>
      <div class="tab" data-tab="staking">Стейкинг</div>
      <div class="tab" data-tab="bridge">Bridge</div>
      <div class="tab" data-tab="settings">Настройки</div>
    </div>

    <!-- ASSETS -->
    <div class="panel active" id="panel-assets">
      <div class="grid">
        <div class="card">
          <div class="h2">RID / Identity</div>
          <div class="muted">Это твой резонансный адрес. Сервер видит только подпись.</div>

          <label style="margin-top:10px">RID</label>
          <input id="rid" class="mono" readonly />

          <div class="row">
            <button id="btnCopyRid" class="btn">Copy</button>
            <button id="btnRefresh" class="btn primary">Refresh LOGOS</button>
            <span id="netBadge" class="muted"></span>
          </div>

          <div id="status" class="status"></div>
        </div>

        <div class="card">
          <div class="h2">Portfolio</div>
          <div class="muted">LOGOS (LGN) — баланс в сети.</div>

          <div style="margin-top:10px">
            <div class="big-num mono" id="balLgn">—</div>
            <div class="muted mono" id="balMicro">—</div>
          </div>

          <div class="row">
            <div class="pill">nonce: <span id="nonce" class="mono">—</span></div>
            <div class="pill">latency: <span id="lat" class="mono">—</span></div>
          </div>

          <details>
            <summary>Details (raw)</summary>
            <pre id="rawNode" class="pre"></pre>
          </details>
        </div>
      </div>

      <div class="grid" style="margin-top:16px">
        <div class="card">
          <div class="h2">Receive addresses</div>
          <div class="muted">BTC/ETH/TRON/USDT адреса закреплены за RID (wallet-api).</div>
          <div id="recvBox"></div>

          <details>
            <summary>Details (wallet-api raw)</summary>
            <pre id="rawRecv" class="pre"></pre>
          </details>
        </div>

        <div class="card">
          <div class="h2">External balances</div>
          <div class="muted">Баланс внешних сетей (wallet-api).</div>
          <div id="extBalBox"></div>

          <details>
            <summary>Details (wallet-api raw)</summary>
            <pre id="rawExt" class="pre"></pre>
          </details>
        </div>
      </div>
    </div>

    <!-- SEND -->
    <div class="panel" id="panel-send">
      <div class="grid">
        <div class="card">
          <div class="h2">Withdraw (USDT)</div>
          <div class="muted">Отправка через wallet-api /v1/withdraw (по OpenAPI: USDT + ETH).</div>

          <label style="margin-top:10px">Network</label>
          <select id="wdNetwork">
            <option value="ETH">ETH</option>
          </select>

          <label style="margin-top:10px">Amount (integer)</label>
          <input id="wdAmount" class="mono" placeholder="например 100" />

          <label style="margin-top:10px">To address</label>
          <input id="wdTo" class="mono" placeholder="0x... или другое" />

          <div class="row">
            <button id="btnWithdraw" class="btn primary">Send</button>
            <button id="btnWithdrawClear" class="btn">Clear</button>
          </div>

          <div id="wdStatus" class="status"></div>

          <details>
            <summary>Response</summary>
            <pre id="wdRaw" class="pre"></pre>
          </details>
        </div>

        <div class="card">
          <div class="h2">LOGOS transfer</div>
          <div class="muted">
            Для LGN-трансфера нужен endpoint в node-api (например /tx/send). Сейчас у тебя подтверждён только /balance.
            Как только дашь ручку отправки — подключу в эту вкладку.
          </div>
        </div>
      </div>
    </div>

    <!-- STAKING -->
    <div class="panel" id="panel-staking">
      <div class="card">
        <div class="h2">Staking</div>
        <div class="muted">
          Вкладка готова по UI. Чтобы она была “не пустая”, нужен backend endpoint стейкинга (stake/unstake/apy).
          Дай API — подключу. Пока не выдумываю, чтобы не было лжи и “пустых кнопок”.
        </div>
      </div>
    </div>

    <!-- BRIDGE -->
    <div class="panel" id="panel-bridge">
  <div id="bridgeRoot"></div>

      <div class="grid">
        <div class="card">
          <div class="h2">Topup address</div>
          <div class="muted">Получить адрес для пополнения (wallet-api /v1/topup/request).</div>

          <label style="margin-top:10px">Network</label>
          <select id="topNetwork">
            <option value="ETH">ETH</option>
          </select>

          <div class="row">
            <button id="btnTopup" class="btn primary">Get address</button>
          </div>

          <div id="topupStatus" class="status"></div>
          <div id="topupBox"></div>
        </div>

        <div class="card">
          <div class="h2">Quote</div>
          <div class="muted">Расчёт курса (wallet-api /v1/quote). amount — integer.</div>

          <label style="margin-top:10px">From</label>
          <input id="qFrom" class="mono" value="USDT" />

          <label style="margin-top:10px">To</label>
          <input id="qTo" class="mono" value="LGN" />

          <label style="margin-top:10px">Amount</label>
          <input id="qAmount" class="mono" placeholder="например 100" />

          <div class="row">
            <button id="btnQuote" class="btn primary">Get quote</button>
          </div>

          <div id="qStatus" class="status"></div>

          <details>
            <summary>Response</summary>
            <pre id="qRaw" class="pre"></pre>
          </details>
        </div>
      </div>
    </div>

    <!-- SETTINGS -->
    <div class="panel" id="panel-settings">
      <div class="grid">
        <div class="card">
          <div class="h2">Local storage</div>
          <div class="muted">RID и пароль хранятся локально в браузере.</div>

          <div class="row">
            <button id="btnShowLocal" class="btn">Show RID</button>
            <button id="btnClearLocal" class="btn danger">Clear local keys</button>
          </div>

          <div id="setStatus" class="status"></div>
        </div>

        <div class="card">
          <div class="h2">Endpoints</div>
          <div class="muted mono">API_BASE = /api, WALLET_API = /wallet-api</div>
        </div>
      </div>
    </div>

  </div>

  <script src="./app.js?v=20260112_084410" defer></script>
<script src="modules/settings.js?v=20260111_172540"></script>
  <script src="modules/tx_redirect.js?v=20260112_070814"></script>
<script src="modules/send.js?v=20260112_084410"></script>
</body>
</html>
```

### FILE: /opt/logos/www/wallet_dev/app.js
```js
(function(){
  const $ = (id) => document.getElementById(id);

  function setStatus(t){ const el=$("status"); if(el) el.textContent = t || ""; }
  function setNetBadge(ok){
    const el = $("netBadge");
    if (!el) return;
    el.className = "muted " + (ok ? "badge-ok" : "badge-bad");
    el.textContent = ok ? "live" : "offline";
  }

  function readRID(){
    try{
      return (localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "").trim();
    }catch(e){ return ""; }
  }

  function devMode(){
    try { return localStorage.getItem("logos_dev") === "1"; } catch(e){ return false; }
  }

  function fmtLgnFromMicro(micro){
    const s = String(micro);
    const neg = s.startsWith("-");
    const a = neg ? s.slice(1) : s;
    const pad = a.padStart(7, "0");
    const intPart = pad.slice(0, -6);
    const frac = pad.slice(-6);
    return (neg ? "-" : "") + intPart + "." + frac;
  }

  function shortRid(rid){
    if (!rid) return "—";
    if (rid.length <= 18) return rid;
    return rid.slice(0,10) + "…" + rid.slice(-6);
  }

  async function jfetch(url, opts){
    const t0 = performance.now();
    const r = await fetch(url, Object.assign({ cache: "no-store" }, opts||{}));
    const t1 = performance.now();
    return { r, ms: Math.round(t1 - t0) };
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  function copyText(t){
    try{ navigator.clipboard.writeText(String(t||"")); setStatus("OK: copied."); }
    catch(e){ setStatus("ERR: copy failed."); }
  }

  function mkLine(container, title, value, copyValue){
    const row = document.createElement("div");
    row.className = "kv";
    row.innerHTML = `
      <div>
        <div class="k">${escapeHtml(title)}</div>
        <div class="v">${escapeHtml(value || "—")}</div>
      </div>
      <button class="btn small">Copy</button>
    `;
    row.querySelector("button").addEventListener("click", () => copyText(copyValue ?? value ?? ""));
    container.appendChild(row);
  }

  function renderReceive(container, addresses){
    container.innerHTML = "";
    if (!addresses || typeof addresses !== "object"){
      container.innerHTML = '<div class="muted">Нет адресов.</div>';
      return;
    }
    // order: BTC, ETH, TRON, USDT_ERC20, USDT_TRC20
    const order = ["BTC","ETH","TRON","USDT_ERC20","USDT_TRC20"];
    for (const k of order){
      if (addresses[k]){
        const title =
          k === "USDT_ERC20" ? "USDT (ERC20)" :
          k === "USDT_TRC20" ? "USDT (TRC20)" :
          k;
        mkLine(container, title, addresses[k], addresses[k]);
      }
    }
  }

  function satToBtc(sat){ return (Number(sat||0) / 1e8).toFixed(8).replace(/\.?0+$/,''); }
  function formatNum(x){
    if (x == null) return "0";
    const n = Number(x);
    if (!isFinite(n)) return String(x);
    return String(n);
  }

  function renderExternal(container, j){
    container.innerHTML = "";
    if (!j || typeof j !== "object"){
      container.innerHTML = '<div class="muted">Нет данных.</div>';
      return;
    }

    const b = j.balances || {};
    // BTC
    if (b.BTC && typeof b.BTC === "object"){
      const sat = (b.BTC.total_sat ?? b.BTC.confirmed_sat ?? b.BTC.confirmed ?? 0);
      const btc = (b.BTC.total_btc != null) ? formatNum(b.BTC.total_btc) : satToBtc(sat);
      mkLine(container, "BTC balance", btc + " BTC", btc);
    } else {
      mkLine(container, "BTC balance", "0 BTC", "0");
    }

    // ETH + USDT ERC20
    if (b.ETH && typeof b.ETH === "object"){
      const eth = (b.ETH.eth != null) ? formatNum(b.ETH.eth) : (b.ETH.wei != null ? (Number(b.ETH.wei)/1e18) : 0);
      mkLine(container, "ETH balance", formatNum(eth) + " ETH", String(eth));
      if (b.ETH.usdt_erc20 && typeof b.ETH.usdt_erc20 === "object"){
        const u = b.ETH.usdt_erc20.usdt ?? 0;
        mkLine(container, "USDT (ERC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "ETH balance", "0 ETH", "0");
      mkLine(container, "USDT (ERC20) balance", "0 USDT", "0");
    }

    // TRON + USDT TRC20
    if (b.TRON && typeof b.TRON === "object"){
      const trx = (b.TRON.trx != null) ? formatNum(b.TRON.trx) : (b.TRON.sun != null ? (Number(b.TRON.sun)/1e6) : 0);
      mkLine(container, "TRX balance", formatNum(trx) + " TRX", String(trx));
      if (b.TRON.usdt_trc20 && typeof b.TRON.usdt_trc20 === "object"){
        const u = b.TRON.usdt_trc20.usdt ?? 0;
        mkLine(container, "USDT (TRC20) balance", formatNum(u) + " USDT", String(u));
      }
    } else {
      mkLine(container, "TRX balance", "0 TRX", "0");
      mkLine(container, "USDT (TRC20) balance", "0 USDT", "0");
    }

    // latency
    if (j.latency_ms != null){
      mkLine(container, "wallet-api latency", String(j.latency_ms) + " ms", String(j.latency_ms));
    }
  }

  async function refreshAll(){
    const rid = readRID();
    if (!rid){
      setStatus("ERR: RID не найден. Зайди через auth.html");
      try{ location.href = "./auth.html"; }catch(e){}
      return;
    }

    const API_BASE = window.API_BASE || "/api";
    const WALLET_API = window.WALLET_API || "/wallet-api";

    if ($("api")) $("api").textContent = API_BASE;
    if ($("rid")) $("rid").value = rid;
    if ($("topRid")) $("topRid").textContent = shortRid(rid);

    // 1) node balance
    try{
      const { r, ms } = await jfetch(API_BASE + "/balance/" + encodeURIComponent(rid));
      if ($("lat")) $("lat").textContent = ms + " ms";
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      const micro = (j && j.balance != null) ? j.balance : 0;
      if ($("balLgn")) $("balLgn").textContent = fmtLgnFromMicro(micro);
      if ($("balMicro")) $("balMicro").textContent = String(micro) + " micro-LGN";
      if ($("nonce")) $("nonce").textContent = (j && j.nonce != null) ? String(j.nonce) : "—";
      if ($("rawNode")) $("rawNode").textContent = JSON.stringify(j, null, 2);
      if ($("topBal")) $("topBal").textContent = fmtLgnFromMicro(micro);

      setNetBadge(true);
      setStatus("OK: обновлено.");
    }catch(e){
      setNetBadge(false);
      setStatus("ERR node-api: " + (e && e.message ? e.message : String(e)));
    }

    // 2) wallet receive
    try{
      const { r } = await jfetch(WALLET_API + "/v1/receive/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawRecv")) $("rawRecv").textContent = JSON.stringify(j, null, 2);
      renderReceive($("recvBox"), j.addresses || {});
    }catch(e){
      if ($("rawRecv")) $("rawRecv").textContent = "";
      if ($("recvBox")) $("recvBox").innerHTML = '<div class="muted">ERR wallet-api receive: ' + escapeHtml(e.message||String(e)) + '</div>';
    }

    // 3) wallet balances
    try{
      const { r } = await jfetch(WALLET_API + "/v1/balances/" + encodeURIComponent(rid));
      if (!r.ok) throw new Error("HTTP " + r.status);
      const j = await r.json();

      if ($("rawExt")) $("rawExt").textContent = JSON.stringify(j, null, 2);
      renderExternal($("extBalBox"), j);
    }catch(e){
      if ($("rawExt")) $("rawExt").textContent = "";
      if ($("extBalBox")) $("extBalBox").innerHTML = '<div class="muted">ERR wallet-api balances: ' + escapeHtml(e.message||String(e)) + '</div>';
    }
  }

  function setTab(name){
    document.querySelectorAll(".tab").forEach(t => {
      t.classList.toggle("active", t.dataset.tab === name);
    });
    document.querySelectorAll(".panel").forEach(p => p.classList.remove("active"));
    const panel = document.getElementById("panel-" + name);
    if (panel) panel.classList.add("active");
    try{ location.hash = name; }catch(e){}
  }

  function uuid(){
    const b = crypto.getRandomValues(new Uint8Array(16));
    b[6] = (b[6] & 0x0f) | 0x40;
    b[8] = (b[8] & 0x3f) | 0x80;
    const h = [...b].map(x => x.toString(16).padStart(2,"0")).join("");
    return `${h.slice(0,8)}-${h.slice(8,12)}-${h.slice(12,16)}-${h.slice(16,20)}-${h.slice(20)}`;
  }

  async function doTopup(){
    const rid = readRID();
    const net = $("topNetwork") ? ($("topNetwork").value || "ETH") : "ETH";
    const box = $("topupBox");
    const st = $("topupStatus");
    if (st) st.textContent = "request…";
    if (box) box.innerHTML = "";

    try{
      const body = { rid, token:"USDT", network: net };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/topup/request", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";

      if (box){
        box.innerHTML = "";
        if (j.address) mkLine(box, "Topup address", j.address, j.address);
        if (j.network) mkLine(box, "Network", j.network, j.network);
        if (j.token) mkLine(box, "Token", j.token, j.token);
      }
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doQuote(){
    const st = $("qStatus"), pre = $("qRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";
    try{
      const body = {
        from_token: ($("qFrom")?.value || "").trim(),
        to_token: ($("qTo")?.value || "").trim(),
        amount: parseInt(($("qAmount")?.value || "0").trim(), 10)
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/quote", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  async function doWithdraw(){
    const rid = readRID();
    const net = $("wdNetwork") ? ($("wdNetwork").value || "ETH") : "ETH";
    const amt = parseInt(($("wdAmount")?.value || "0").trim(), 10);
    const to = ($("wdTo")?.value || "").trim();

    const st = $("wdStatus"), pre = $("wdRaw");
    if (st) st.textContent = "request…";
    if (pre) pre.textContent = "";

    try{
      const body = {
        rid,
        token: "USDT",
        network: net,
        amount: amt,
        to_address: to,
        request_id: uuid()
      };
      const { r } = await jfetch((window.WALLET_API||"/wallet-api") + "/v1/withdraw", {
        method:"POST",
        headers:{ "content-type":"application/json" },
        body: JSON.stringify(body)
      });
      const j = await r.json().catch(()=>({}));
      if (!r.ok) throw new Error("HTTP " + r.status + ": " + JSON.stringify(j));
      if (st) st.textContent = "OK";
      if (pre) pre.textContent = JSON.stringify(j, null, 2);
    }catch(e){
      if (st) st.textContent = "ERR: " + (e.message||String(e));
    }
  }

  window.addEventListener("DOMContentLoaded", () => {
    // hide raw blocks for normal users
    if (!devMode()){
      document.querySelectorAll("details").forEach(d => d.style.display = "none");
    }

    document.querySelectorAll(".tab").forEach(t => {
      t.addEventListener("click", () => setTab(t.dataset.tab));
    });
    const start = (location.hash||"").replace("#","") || "assets";
    setTab(start);

    $("btnCopyRid")?.addEventListener("click", () => copyText($("rid")?.value || ""));
    $("btnRefresh")?.addEventListener("click", refreshAll);

    $("btnLogout")?.addEventListener("click", () => {
      try{ localStorage.removeItem("PASS"); localStorage.removeItem("logos_pass"); }catch(e){}
      location.href = "./auth.html";
    });

    $("btnTopup")?.addEventListener("click", doTopup);
    $("btnQuote")?.addEventListener("click", doQuote);

    $("btnWithdraw")?.addEventListener("click", doWithdraw);
    $("btnWithdrawClear")?.addEventListener("click", () => {
      if ($("wdAmount")) $("wdAmount").value = "";
      if ($("wdTo")) $("wdTo").value = "";
      if ($("wdStatus")) $("wdStatus").textContent = "";
      if ($("wdRaw")) $("wdRaw").textContent = "";
    });

    $("btnShowLocal")?.addEventListener("click", () => {
      const rid = readRID();
      if ($("setStatus")) $("setStatus").textContent = rid ? ("RID: " + rid) : "RID не найден.";
    });
    $("btnClearLocal")?.addEventListener("click", () => {
      try{
        localStorage.removeItem("RID");
        localStorage.removeItem("logos_rid");
        localStorage.removeItem("PASS");
        localStorage.removeItem("logos_pass");
      }catch(e){}
      if ($("setStatus")) $("setStatus").textContent = "OK: local keys cleared";
    });

    refreshAll();
  });

  window._logos_refreshAll = refreshAll;
})();

/* ========= BRIDGE MODULE (v1) ========= */
(() => {
  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function apiBase(){
    // wallet-api (FastAPI proxy)
    return (window.LOGOS_WALLET_API || window.WALLET_API || (window.location.origin.replace(/\/+$/, "") + "/wallet-api"));
  }

  function esc(s){
    return String(s ?? "").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function q(sel, root=document){ return root.querySelector(sel); }

  function setMsg(root, text, ok=true){
    const el = q(".bridgeMsg", root);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch(e) {}
    if (!r.ok){
      const msg = (j && (j.detail || j.error)) ? JSON.stringify(j) : (t || ("HTTP " + r.status));
      throw new Error(msg);
    }
    return j ?? {};
  }

  function shortRID(rid){
    if (!rid) return "";
    if (rid.length <= 18) return rid;
    return rid.slice(0, 10) + "…" + rid.slice(-6);
  }

  function genReqId(){
    return "w_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10);
  }

  function renderBridge(){
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // прячем старое/случайное содержимое панели, оставляем только bridgeRoot
    try{
      [...panel.children].forEach(ch => { if (ch !== root) ch.style.display = "none"; });
    }catch(e){}

    const rid = ridGet();
    root.innerHTML = `
      <div class="card">
        <div class="h">Bridge</div>
        <div class="muted">Обмен/ввод/вывод через wallet-api. Для обычных людей — без сырого текста.</div>
        <div style="height:10px"></div>
        <div class="bridgeMsg muted" style="opacity:0; transition:.2s;"></div>
      </div>

      <div class="card">
        <div class="h">Quote</div>
        <div class="muted">Расчёт курса (без отправки транзакции).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">From</div>
            <input class="mono" id="qFrom" value="USDT" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">To</div>
            <input class="mono" id="qTo" value="LGN" />
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="qAmt" value="100" />
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnQuote">Get quote</button>

        <div style="height:10px"></div>
        <div class="muted" id="quoteOut" style="white-space:pre-wrap;"></div>
      </div>

      <div class="card">
        <div class="h">Top up</div>
        <div class="muted">Получить адрес для пополнения (USDT).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="tuNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="tuTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
        </div>

        <div style="height:12px"></div>
        <button class="btn" id="btnTopup">Get deposit address</button>

        <div style="height:12px"></div>
        <div class="muted">Address</div>
        <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
          <input class="mono" id="tuAddr" readonly value="" style="flex:1; min-width:260px;" />
          <button class="btn" id="btnCopyTopup" type="button">Copy</button>
        </div>
      </div>

      <div class="card">
        <div class="h">Withdraw</div>
        <div class="muted">Вывод USDT (тестовая ручка, если включена на сервере).</div>
        <div style="height:12px"></div>

        <div class="row" style="display:flex; gap:10px; flex-wrap:wrap;">
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Network</div>
            <select class="mono" id="wdNet">
              <option value="ETH" selected>ETH</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Token</div>
            <select class="mono" id="wdTok">
              <option value="USDT" selected>USDT</option>
            </select>
          </div>
          <div style="flex:1; min-width:200px;">
            <div class="muted" style="margin-bottom:6px;">Amount</div>
            <input class="mono" id="wdAmt" value="1" />
          </div>
        </div>

        <div style="height:10px"></div>
        <div class="muted" style="margin-bottom:6px;">To address</div>
        <input class="mono" id="wdTo" value="" placeholder="0x... or T..." />

        <div style="height:12px"></div>
        <button class="btn" id="btnWithdraw">Withdraw</button>

        <div style="height:10px"></div>
        <div class="muted" id="wdOut" style="white-space:pre-wrap;"></div>
      </div>
    `;

    // handlers
    q("#btnQuote", root).addEventListener("click", async () => {
      try{
        setMsg(root, "Запрашиваю quote…");
        const from = q("#qFrom", root).value.trim();
        const to   = q("#qTo", root).value.trim();
        const amt  = parseInt(q("#qAmt", root).value.trim() || "0", 10);

        const data = await postJSON(apiBase() + "/v1/quote", {from_token: from, to_token: to, amount: amt});
        q("#quoteOut", root).textContent = `price: ${data.price}\nexpected_out: ${data.expected_out}`;
        setMsg(root, "OK: quote готов ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnTopup", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        setMsg(root, "Запрашиваю адрес пополнения…");
        const network = q("#tuNet", root).value;
        const token   = q("#tuTok", root).value;
        const data = await postJSON(apiBase() + "/v1/topup/request", {rid, network, token});
        q("#tuAddr", root).value = data.address || "";
        setMsg(root, "OK: адрес получен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    q("#btnCopyTopup", root).addEventListener("click", async () => {
      const v = q("#tuAddr", root).value;
      if (!v) return;
      try{ await navigator.clipboard.writeText(v); setMsg(root, "Скопировано ✅"); }
      catch(e){ setMsg(root, "Не смог скопировать (браузер).", false); }
    });

    q("#btnWithdraw", root).addEventListener("click", async () => {
      try{
        if (!rid) throw new Error("RID не найден в localStorage");
        const network = q("#wdNet", root).value;
        const token   = q("#wdTok", root).value;
        const amount  = parseInt(q("#wdAmt", root).value.trim() || "0", 10);
        const to_address = q("#wdTo", root).value.trim();
        if (!to_address) throw new Error("Укажи to_address");
        const request_id = genReqId();

        setMsg(root, "Отправляю withdraw…");
        const data = await postJSON(apiBase() + "/v1/withdraw", {rid, network, token, amount, to_address, request_id});
        q("#wdOut", root).textContent = data ? JSON.stringify(data, null, 2) : "OK";
        setMsg(root, "OK: withdraw запрос отправлен ✅");
      }catch(e){
        setMsg(root, "ERR: " + (e?.message || e), false);
      }
    });

    // верхняя шапка (чисто подсказка, не ломаем существующую)
    try{
      const top = document.querySelector(".topbar") || document.body;
      // ничего не трогаем, просто подсказка в сообщении
      setMsg(root, rid ? ("RID: " + shortRID(rid)) : "RID не найден", true);
    }catch(e){}
  }

  function initBridge(){
    const tab = document.querySelector('.tab[data-tab="bridge"]');
    const panel = document.getElementById("panel-bridge");
    const root = document.getElementById("bridgeRoot");
    if (!panel || !root) return;

    // рендерим при первом клике на вкладку
    if (tab && !tab.__bridgeBound){
      tab.__bridgeBound = true;
      tab.addEventListener("click", () => {
        try{ renderBridge(); }catch(e){}
      });
    }

    // если панель уже активна — рендерим сразу
    try{
      if (panel.style.display !== "none") renderBridge();
    }catch(e){}
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initBridge);
  } else {
    initBridge();
  }
})();



/* ========= SEND LGN MODULE (v2, sig_hex) ========= */
(() => {
  const NODE_API = (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");

  function q(sel, root=document){ return root.querySelector(sel); }
  function qa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function utf8(s){ return new TextEncoder().encode(String(s)); }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++){
      out += u8[i].toString(16).padStart(2,"0");
    }
    return out;
  }

  function hexToU8(h){
    h = (h||"").trim().replace(/^0x/,"");
    if (!h || (h.length % 2)) return null;
    const u = new Uint8Array(h.length/2);
    for (let i=0;i<u.length;i++) u[i] = parseInt(h.substr(i*2,2),16);
    return u;
  }

  function getRID(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || "";
  }

  // пытаемся найти private Ed25519 JWK в localStorage (если ключи хранятся так)
  function findEd25519PrivJwk(){
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      if (!k) continue;
      const v = localStorage.getItem(k);
      if (!v || v.length < 20) continue;
      try{
        const j = JSON.parse(v);
        if (j && j.crv === "Ed25519" && j.kty && j.d && j.x) return j;
      }catch(e){}
    }
    return null;
  }

  async function importPrivKeyFromJwk(jwk){
    return crypto.subtle.importKey("jwk", jwk, {name:"Ed25519"}, false, ["sign"]);
  }

  async function signEd25519(privKey, msgU8){
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msgU8);
    return new Uint8Array(sig);
  }

  async function getNonce(rid){
    const r = await fetch(`${NODE_API}/balance/${encodeURIComponent(rid)}`);
    if(!r.ok) throw new Error(`balance http ${r.status}`);
    const j = await r.json();
    return j.nonce;
  }

  async function getCanonBytes(draft){
    // пробуем debug_canon (если включен на сервере)
    try{
      const r = await fetch(`${NODE_API}/debug_canon`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(draft)
      });
      if (r.ok){
        const t = await r.text();
        // варианты: JSON или просто строка
        try{
          const j = JSON.parse(t);
          const ch = j.canon_hex || j.canon || j.msg_hex || j.message_hex || j.bytes_hex || "";
          const u = hexToU8(ch);
          if (u) return u;
          const s = (j.canon_str || j.message || j.msg || "");
          if (s) return utf8(s);
        }catch(e){
          // если просто строка
          const u = hexToU8(t);
          if (u) return u;
          if (t && t.length) return utf8(t);
        }
      }
    }catch(e){}

    // fallback: стабильная строка (если debug_canon нет)
    const memo = (draft.memo === null || draft.memo === undefined) ? "" : String(draft.memo);
    const s = `LOGOS_TX|from=${draft.from}|to=${draft.to}|amount=${draft.amount}|nonce=${draft.nonce}|memo=${memo}`;
    return utf8(s);
  }

  function setStatus(panel, text, ok=true){
    let el = q(".sendStatus", panel);
    if(!el){
      el = document.createElement("div");
      el.className = "sendStatus";
      el.style.marginTop = "10px";
      el.style.fontSize = "13px";
      el.style.opacity = "0.95";
      panel.appendChild(el);
    }
    el.textContent = text || "";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function findSendPanel(){
    return document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('.panel[data-panel="send"]')
      || null;
  }

  function findSendControls(panel){
    const btnSend = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("send lgn"));
    const inputs = qa("input", panel);
    const toRid   = inputs[0] || null;
    const amount  = inputs[1] || null;
    const memo    = inputs[2] || null;
    const btnFillMe = qa("button", panel).find(b => (b.textContent||"").toLowerCase().includes("мой rid"));
    return {btnSend, btnFillMe, toRid, amount, memo};
  }

  async function handleSend(panel, ui){
    const fromRid = getRID();
    const toRid = (ui.toRid?.value || "").trim();
    const memoStr = (ui.memo?.value || "").trim();
    const amtStr = (ui.amount?.value || "").trim();

    if(!fromRid){ setStatus(panel, "ERR: нет RID (ключи не найдены).", false); return; }
    if(!toRid || toRid.length < 10){ setStatus(panel, "ERR: введи RID получателя.", false); return; }

    const amt = Number(amtStr.replace(",", "."));
    if(!isFinite(amt) || amt <= 0){ setStatus(panel, "ERR: введи сумму > 0.", false); return; }

    const amount_mic = Math.round(amt * 1e6);

    setStatus(panel, "Отправляю…", true);

    let nonce;
    try{
      nonce = await getNonce(fromRid);
    }catch(e){
      setStatus(panel, "ERR: не смог получить nonce (balance).", false);
      return;
    }

    // draft по схеме TxIn (без подписи)
    const draft = {
      from: fromRid,
      to: toRid,
      amount: amount_mic,
      nonce: nonce,
      memo: memoStr ? memoStr : None
    };

    // JS не знает None, поэтому:
    if (!memoStr) draft.memo = null;

    // bytes for signing
    const canonBytes = await getCanonBytes(draft);

    // signer
    const jwk = findEd25519PrivJwk();
    if(!jwk){
      setStatus(panel, "ERR: приватный ключ не найден (localStorage). Если ключи в IndexedDB — скажи, сделаем доступ через существующий signer.", false);
      return;
    }

    let privKey;
    try{
      privKey = await importPrivKeyFromJwk(jwk);
    }catch(e){
      setStatus(panel, "ERR: не смог импортировать Ed25519 ключ.", false);
      return;
    }

    let sigU8;
    try{
      sigU8 = await signEd25519(privKey, canonBytes);
    }catch(e){
      setStatus(panel, "ERR: не смог подписать транзакцию.", false);
      return;
    }

    const txIn = {
      from: draft.from,
      to: draft.to,
      amount: draft.amount,
      nonce: draft.nonce,
      memo: draft.memo,
      sig_hex: hex(sigU8)
    };

    try{
      const r = await fetch(`${NODE_API}/submit_tx`, {
        method:"POST",
        headers: {"Content-Type":"application/json"},
        body: JSON.stringify(txIn)
      });
      const text = await r.text();
      if(!r.ok){
        setStatus(panel, `ERR submit_tx: ${r.status} ${text}`.slice(0,500), false);
        return;
      }
      try{
        const j = JSON.parse(text);
        if (j && j.ok){
          setStatus(panel, `✅ Отправлено. txid: ${(j.txid||"")}`.trim(), true);
        } else {
          setStatus(panel, `⚠️ Ответ: ${text}`.slice(0,500), false);
        }
      }catch(e){
        setStatus(panel, `✅ Отправлено. Ответ: ${text}`.slice(0,200), true);
      }
    }catch(e){
      setStatus(panel, "ERR: сеть/submit_tx не доступен.", false);
    }
  }

  function initSend(){
    const panel = findSendPanel();
    if(!panel) return;
    const ui = findSendControls(panel);

    if(ui.btnFillMe){
      ui.btnFillMe.addEventListener("click", () => {
        const rid = getRID();
        if(ui.toRid) ui.toRid.value = rid || "";
      });
    }
    if(ui.btnSend){
      ui.btnSend.addEventListener("click", () => handleSend(panel, ui));
    }
  }

  try{ initSend(); }catch(e){}
})();


```

### FILE: /opt/logos/www/wallet_dev/assets.js
```js
(() => {
  const $ = (q, el=document) => el.querySelector(q);

  function getRID(){
    return (localStorage.getItem("logos_rid") || "").trim();
  }

  async function jget(url){
    const r = await fetch(url, { cache: "no-store" });
    const t = await r.text();
    let data = {};
    try{ data = t ? JSON.parse(t) : {}; }catch(_){ data = { raw: t }; }
    if(!r.ok) throw new Error(`${r.status} ${url}: ${t.slice(0,200)}`);
    return data;
  }

  function fmtNum(x){
    if(x === null || x === undefined) return "0";
    const s = String(x);
    return s;
  }

  async function detectNodeBase(){
    // node-api у тебя работает и так, но делаем безопасно
    const cands = ["/node-api", "/node-api/api"];
    for(const b of cands){
      try{
        await jget(`${b}/healthz`);
        return b;
      }catch(_){}
    }
    return "/node-api";
  }

  function toast(msg){
    try{
      let t = $("#_toast");
      if(!t){
        t = document.createElement("div");
        t.id = "_toast";
        t.style.cssText = "position:fixed;left:50%;bottom:110px;transform:translateX(-50%);padding:10px 14px;border-radius:12px;z-index:9999;background:rgba(20,20,30,.75);border:1px solid rgba(255,255,255,.14);color:rgba(255,255,255,.92);backdrop-filter: blur(14px);box-shadow:0 20px 60px rgba(0,0,0,.5);font: 14px system-ui;opacity:0;transition:opacity .18s ease;";
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.opacity = "1";
      clearTimeout(t._tm);
      t._tm = setTimeout(()=>{ t.style.opacity="0"; }, 1400);
    }catch(_){}
  }

  async function copyText(txt){
    try{
      await navigator.clipboard.writeText(txt);
      toast("Скопировано");
    }catch(_){
      // fallback
      const ta = document.createElement("textarea");
      ta.value = txt;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      document.execCommand("copy");
      ta.remove();
      toast("Скопировано");
    }
  }

  function findAssetsHost(){
    // пробуем самые вероятные варианты (разная разметка)
    return (
      document.querySelector('[data-page="assets"]') ||
      document.getElementById("page-assets") ||
      document.getElementById("assetsPage") ||
      document.querySelector(".page.assets") ||
      document.querySelector(".assetsPage") ||
      document.querySelector('[data-tab="assets"]') ||
      null
    );
  }

  function ensureUI(host){
    let wrap = host.querySelector("#assetsWrap");
    if(!wrap){
      wrap = document.createElement("div");
      wrap.id = "assetsWrap";
      wrap.className = "assetsWrap";
      host.prepend(wrap);
    }

    wrap.innerHTML = `
      <div class="assetsHead">
        <div>
          <div class="assetsTitle">Активы</div>
          <div class="assetsSub">Баланс + адреса для депозита (BTC / ETH / TRON / USDT)</div>
        </div>
        <button class="btn btn--soft" id="assetsRefresh" type="button">Обновить</button>
      </div>

      <div class="assetsGrid" id="assetsGrid">
        <div class="assetCard"><div class="muted">Загрузка...</div></div>
      </div>
    `;
    return wrap;
  }

  function cardHTML({sym, name, bal, addr, note}){
    const addrShort = addr ? (addr.slice(0, 8) + "…" + addr.slice(-6)) : "—";
    return `
      <div class="assetCard">
        <div class="assetTop">
          <div class="assetSym">${sym}</div>
          <div class="assetMeta">
            <div class="assetName">${name}</div>
            <div class="assetBal">${bal}</div>
          </div>
        </div>

        <div class="assetAddrRow">
          <div class="assetAddr mono" title="${addr || ""}">${addrShort}</div>
          <button class="chip chip--small" type="button" data-copy="${addr || ""}">Copy</button>
        </div>

        ${note ? `<div class="assetNote muted">${note}</div>` : ``}
      </div>
    `;
  }

  async function loadAndRender(){
    const host = findAssetsHost();
    if(!host) return; // если активы-страницы нет, не мешаем UI

    const wrap = ensureUI(host);
    const grid = wrap.querySelector("#assetsGrid");
    const rid = getRID();

    if(!rid){
      grid.innerHTML = `<div class="assetCard"><div class="muted">RID не найден. Сначала создай/восстанови кошелёк.</div></div>`;
      return;
    }

    try{
      const nodeBase = await detectNodeBase();

      // 1) LGN balance (node-api)
      const lgn = await jget(`${nodeBase}/balance/${encodeURIComponent(rid)}`);

      // 2) мульти-активы + адреса (wallet-api)
      const b = await jget(`/wallet-api/v1/balances/${encodeURIComponent(rid)}`);

      const addr = (b && b.addresses) ? b.addresses : {};
      const bal  = (b && b.balances)  ? b.balances  : {};

      const cards = [];

      cards.push(cardHTML({
        sym: "LGN",
        name: "LOGOS",
        bal: fmtNum(lgn?.balance ?? 0),
        addr: rid,
        note: "Внутрисетевой RID (LGN)"
      }));

      cards.push(cardHTML({
        sym: "BTC",
        name: "Bitcoin",
        bal: fmtNum(bal?.BTC?.total_btc ?? "0"),
        addr: addr?.BTC || "",
        note: bal?.BTC?.source ? `Источник: ${bal.BTC.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "ETH",
        name: "Ethereum",
        bal: fmtNum(bal?.ETH?.eth ?? "0"),
        addr: addr?.ETH || "",
        note: bal?.ETH?.source ? `Источник: ${bal.ETH.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "TRX",
        name: "TRON",
        bal: fmtNum(bal?.TRON?.trx ?? "0"),
        addr: addr?.TRON || "",
        note: bal?.TRON?.source ? `Источник: ${bal.TRON.source}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (ERC20)",
        bal: fmtNum(bal?.ETH?.usdt_erc20?.usdt ?? "0"),
        addr: addr?.USDT_ERC20 || addr?.ETH || "",
        note: bal?.ETH?.usdt_erc20?.contract ? `Contract: ${bal.ETH.usdt_erc20.contract}` : ""
      }));

      cards.push(cardHTML({
        sym: "USDT",
        name: "Tether (TRC20)",
        bal: fmtNum(bal?.TRON?.usdt_trc20?.usdt ?? "0"),
        addr: addr?.USDT_TRC20 || addr?.TRON || "",
        note: bal?.TRON?.usdt_trc20?.contract ? `Contract: ${bal.TRON.usdt_trc20.contract}` : ""
      }));

      grid.innerHTML = cards.join("\n");

      // copy handlers
      grid.querySelectorAll("[data-copy]").forEach(btn => {
        btn.addEventListener("click", () => {
          const v = btn.getAttribute("data-copy") || "";
          if(!v) return toast("Адрес пустой");
          copyText(v);
        });
      });

    }catch(e){
      grid.innerHTML = `<div class="assetCard"><div class="muted">Ошибка загрузки: ${String(e).slice(0,200)}</div></div>`;
    }
  }

  function hook(){
    const host = findAssetsHost();
    if(!host) return;

    // кнопка обновить
    const r = document.getElementById("assetsRefresh");
    if(r && !r._wired){
      r._wired = true;
      r.addEventListener("click", loadAndRender);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // первая отрисовка + подстраховка
    loadAndRender();
    setTimeout(() => { hook(); loadAndRender(); }, 350);
  });

  // если вкладки переключаются через hidden/class — при переключении подхватим
  document.addEventListener("click", (ev) => {
    const t = ev.target;
    if(!(t instanceof HTMLElement)) return;
    const nav = t.closest('[data-nav="assets"],[data-tab="assets"]');
    if(nav){
      setTimeout(loadAndRender, 120);
    }
  });
})();

```

### FILE: /opt/logos/www/wallet_dev/auth.css
```css
/* Wallet Auth page tweaks (theme in /shared/wallet-theme.css) */

/* ВАЖНО: hidden управляет видимостью, CSS его не должен ломать */
[hidden]{ display:none !important; }

/* НЕ ставим display:none на эти блоки! */
#listWrap{ margin-top:12px; }
#mnemonicSection{ margin-top:14px; }

#mnemonicShow,#mnemonicConfirm,#restoreMnemonic{ min-height:120px; }

#ridList{
  list-style:none;
  padding:0;
  margin:10px 0 0;
  display:grid;
  gap:8px;
}

#ridList li{
  padding:10px 12px;
  border-radius:14px;
  border:1px solid rgba(255,255,255,.10);
  background:rgba(0,0,0,.22);
  cursor:pointer;
  font-family:var(--mono);
  font-size:12.5px;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
}

#ridList li:hover{
  border-color:rgba(77,163,255,.35);
  background:rgba(0,0,0,.28);
}

#out{ min-height:84px; }

```

### FILE: /opt/logos/www/wallet_dev/auth.html
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LOGOS Wallet — Login</title>
  <link rel="stylesheet" href="./app.css?v=1" />
  <script src="./api_base.js?v=1"></script>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="topbar" style="position:static;border:0;padding:0;background:transparent">
        <div class="brand">LOGOS Wallet</div>
        <div class="pill">HTTPS only</div>
      </div>

      <div class="h1">Доступ к кошельку</div>
      <div class="muted">Ключи живут локально в браузере. Сервер получает только подписанные операции.</div>

      <div style="margin-top:14px;display:grid;gap:10px">
        <label>RID</label>
        <input id="rid" class="mono" placeholder="RID..." autocomplete="off" />

        <label>Пароль</label>
        <input id="pass" type="password" placeholder="Пароль" autocomplete="off" />

        <div class="row">
          <button id="btnLogin" class="btn primary">Войти</button>
          <button id="btnSaved" class="btn">Показать сохранённый RID</button>
        </div>

        <div id="status" class="status"></div>
      </div>
    </div>
  </div>

<script>
(function(){
  const ridEl = document.getElementById("rid");
  const passEl = document.getElementById("pass");
  const statusEl = document.getElementById("status");

  function setStatus(t){ statusEl.textContent = t || ""; }

  function loadSaved(){
    try{
      const rid = localStorage.getItem("RID") || localStorage.getItem("logos_rid") || "";
      if (rid) ridEl.value = rid;
    }catch(e){}
  }
  loadSaved();

  document.getElementById("btnSaved").addEventListener("click", () => {
    loadSaved();
    setStatus(ridEl.value ? "RID подставлен из браузера." : "Сохранённого RID нет.");
  });

  document.getElementById("btnLogin").addEventListener("click", () => {
    const rid = (ridEl.value||"").trim();
    const pass = (passEl.value||"").trim();
    if (!rid || rid.length < 20) return setStatus("ERR: введи корректный RID.");
    if (!pass) return setStatus("ERR: введи пароль.");

    try{
      localStorage.setItem("RID", rid);
      localStorage.setItem("logos_rid", rid);
      localStorage.setItem("PASS", pass);
      localStorage.setItem("logos_pass", pass);
    }catch(e){}

    setStatus("OK: сохранено локально. Переход…");
    location.href = "./app.html?v=1";
  });
})();
</script>
</body>
</html>

```

### FILE: /opt/logos/www/wallet_dev/auth.js
```js
'use strict';

const DB_NAME = 'logos_wallet_v2';
const STORE   = 'keys';
const enc = new TextEncoder();

const ED25519_PKCS8_PREFIX = new Uint8Array([
  0x30,0x2e,0x02,0x01,0x00,
  0x30,0x05,0x06,0x03,0x2b,0x65,0x70,
  0x04,0x22,0x04,0x20
]);

const $ = (id) => document.getElementById(id);

function setStatus(t){
  const el = $('status');
  if (el) el.textContent = 'Статус: ' + t;
}

function ensureEnv(){
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.crypto?.subtle) throw new Error('WebCrypto недоступен');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!window.nacl?.sign?.keyPair?.fromSeed) throw new Error('tweetnacl не загружен (нет window.nacl)');
}

const B58_ALPH = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
function base58encode(bytes){
  const b = (bytes instanceof Uint8Array) ? bytes : new Uint8Array(bytes||[]);
  if (b.length === 0) return "";
  let digits = [0];
  for (let i=0;i<b.length;i++){
    let carry = b[i];
    for (let j=0;j<digits.length;j++){
      const x = digits[j]*256 + carry;
      digits[j] = x % 58;
      carry = (x/58) | 0;
    }
    while (carry){
      digits.push(carry % 58);
      carry = (carry/58) | 0;
    }
  }
  let out = "";
  for (let k=0;k<b.length && b[k]===0;k++) out += "1";
  for (let q=digits.length-1;q>=0;q--) out += B58_ALPH[digits[q]];
  return out;
}

async function sha256(u8){
  const d = await crypto.subtle.digest('SHA-256', u8);
  return new Uint8Array(d);
}

function pkcs8FromSeed(seed32){
  const seed = (seed32 instanceof Uint8Array) ? seed32 : new Uint8Array(seed32||[]);
  if (seed.length !== 32) throw new Error('seed must be 32 bytes');
  const out = new Uint8Array(ED25519_PKCS8_PREFIX.length + 32);
  out.set(ED25519_PKCS8_PREFIX, 0);
  out.set(seed, ED25519_PKCS8_PREFIX.length);
  return out;
}

async function deriveKey(pass, saltU8, usage=['encrypt','decrypt']){
  const keyMat = await crypto.subtle.importKey('raw', enc.encode(pass), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    { name:'PBKDF2', salt: saltU8, iterations:120000, hash:'SHA-256' },
    keyMat,
    { name:'AES-GCM', length:256 },
    false,
    usage
  );
}

async function aesEncrypt(aesKey, plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({ name:'AES-GCM', iv }, aesKey, plainU8);
  return { iv, ct: new Uint8Array(ct) };
}

async function aesDecrypt(aesKey, ivU8, ctU8){
  const plain = await crypto.subtle.decrypt({ name:'AES-GCM', iv: ivU8 }, aesKey, ctU8);
  return new Uint8Array(plain);
}

let DBP = null;
function openDb(){
  if (DBP) return DBP;
  DBP = new Promise((resolve,reject)=>{
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
  return DBP;
}

async function idbGet(key){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const r = st.get(key);
    r.onsuccess = ()=>resolve(r.result || null);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbPut(key, val){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readwrite');
    const st = tx.objectStore(STORE);
    const r = st.put(val, key);
    r.onsuccess = ()=>resolve(true);
    r.onerror = ()=>reject(r.error);
  });
}

async function idbListRids(){
  const db = await openDb();
  return new Promise((resolve,reject)=>{
    const tx = db.transaction(STORE,'readonly');
    const st = tx.objectStore(STORE);
    const out = [];
    const req = st.openCursor();
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve(out);
      const k = String(cur.key||'');
      if (k.startsWith('acct:')) out.push(k.slice(5));
      cur.continue();
    };
    req.onerror = ()=>reject(req.error);
  });
}

function setSession(rid, pass){
  // mirror to localStorage for app.js compatibility
  try {
    localStorage.setItem("logos_rid", String(rid||""));
    localStorage.setItem("RID", String(rid||""));
    if (pass != null) localStorage.setItem("logos_pass", String(pass||""));
  } catch(e) {}

  sessionStorage.setItem('logos_rid', rid);
  sessionStorage.setItem('logos_pass', pass);
  localStorage.setItem('logos_rid', rid);
  localStorage.setItem('logos_pass', pass);
}

function validatePass(p){
  const s = String(p||'').trim();
  if (s.length < 10) throw new Error('Пароль слишком короткий (мин 10)');
  return s;
}

function normalizePhrase(ph){
  return String(ph||'').trim().replace(/\s+/g,' ').toLowerCase();
}

const WORDS = [
  "alpha","bravo","canyon","delta","eagle","frost","galaxy","harbor","ivory","jungle","karma","legend",
  "matrix","nebula","orbit","pioneer","quantum","raven","signal","temple","union","vector","wander","xenon",
  "yellow","zenith","acoustic","breeze","crystal","drift","ember","forest","glimmer","horizon","island","jewel",
  "kernel","lunar","mirror","nova","oasis","prism","quiet","river","stone","thunder","ultra","vivid","whisper","zero"
];

function genPhrase16(){
  const rnd = crypto.getRandomValues(new Uint8Array(16));
  const w = [];
  for (let i=0;i<16;i++) w.push(WORDS[rnd[i] % WORDS.length]);
  return w.join(' ');
}

async function seedFromPhrase(phrase){
  const p = normalizePhrase(phrase);
  if (!p) throw new Error('Фраза пустая');
  const h = await sha256(enc.encode(p));
  return h.slice(0,32);
}

function ridFromSeed(seed32){
  const kp = nacl.sign.keyPair.fromSeed(seed32);
  const pub = new Uint8Array(kp.publicKey);
  return base58encode(pub);
}

async function storeAccount(rid, pass, seed32){
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const aes = await deriveKey(pass, salt, ['encrypt','decrypt']);
  const pkcs8 = pkcs8FromSeed(seed32);
  const {iv, ct} = await aesEncrypt(aes, pkcs8);

  const meta = { salt: Array.from(salt), iv: Array.from(iv), priv: Array.from(ct), ts: Date.now() };
  await idbPut('acct:' + rid, meta);
}

async function loadAndVerify(rid, pass){
  const meta = await idbGet('acct:' + rid);
  if (!meta) throw new Error('RID не найден на этом устройстве (нет локальной записи)');
  const salt = new Uint8Array(meta.salt || []);
  const iv   = new Uint8Array(meta.iv || []);
  const ct   = new Uint8Array(meta.priv || []);
  const aes  = await deriveKey(pass, salt, ['decrypt']);
  const pkcs8 = await aesDecrypt(aes, iv, ct);
  const seed = pkcs8.slice(ED25519_PKCS8_PREFIX.length);
  const checkRid = ridFromSeed(seed);
  if (checkRid !== rid) throw new Error('Неверный пароль');
  return true;
}

async function doShow(){
  try{
    ensureEnv();
    const list = await idbListRids();
    const box = $('savedList');
    if (box){
      box.style.display = '';
      box.textContent = list.length ? list.map(x=>'• '+x).join('\n') : '— пусто —';
    }
    setStatus('saved RID: ' + list.length);
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doLogin(){
  try{
    ensureEnv();
    const rid = String($('ridIn')?.value||'').trim();
    const pass = validatePass($('passIn')?.value||'');
    if (!rid) throw new Error('RID пустой');
    setStatus('checking…');
    await loadAndVerify(rid, pass);
    setSession(rid, pass);
    setStatus('ok → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doCreate(){
  try{
    ensureEnv();
    const pass = validatePass($('newPass')?.value||'');
    const phrase = genPhrase16();
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    const out = $('newPhraseOut');
    if (out) out.value = phrase;
    setSession(rid, pass);
    setStatus('created: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

async function doRestore(){
  try{
    ensureEnv();
    const phrase = normalizePhrase($('phraseIn')?.value||'');
    const pass = validatePass($('restorePass')?.value||'');
    if (!phrase) throw new Error('Фраза пустая');
    const seed = await seedFromPhrase(phrase);
    const rid = ridFromSeed(seed);
    await storeAccount(rid, pass, seed);
    setSession(rid, pass);
    setStatus('restored: ' + rid + ' → opening wallet…');
    location.href = './app.html';
  }catch(e){
    setStatus('ERR: ' + (e?.message || String(e)));
  }
}

window.addEventListener('DOMContentLoaded', ()=>{
  $('btnShow')?.addEventListener('click', doShow);
  $('btnLogin')?.addEventListener('click', doLogin);
  $('btnCreate')?.addEventListener('click', doCreate);
  $('btnRestore')?.addEventListener('click', doRestore);
  setStatus('ready');
});

```

### FILE: /opt/logos/www/wallet_dev/compat.js
```js
"use strict";

(function () {
  // Базовый URL API
  const API = location.origin + "/node-api";

  const $ = (s) => document.querySelector(s);

  async function jsonGet(path) {
    const r = await fetch(API + path, { method: "GET" });
    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`${path} ${r.status} ${txt}`);
    }
    try {
      return JSON.parse(txt);
    } catch {
      throw new Error(`${path} bad json: ${txt}`);
    }
  }

  // Правильный формат тела для /debug_canon
  async function debugCanon(from, to, amount, nonce) {
    const body = {
      from,
      to,
      amount: Number(amount),
      nonce: Number(nonce),
      // на бэкенде старые и новые типы — шлём оба поля на всякий случай
      sig: "",
      sig_hex: ""
    };

    const r = await fetch(API + "/debug_canon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/debug_canon ${r.status} ${txt}`);
    }
    let j;
    try {
      j = JSON.parse(txt);
    } catch {
      throw new Error(`/debug_canon bad json: ${txt}`);
    }
    if (!j.canon_hex) {
      throw new Error("debug_canon: no canon_hex in response");
    }
    return j.canon_hex;
  }

  // Подпись канонического hex; если есть старый signCanon — используем его
  async function signCanonCompat(canonHex) {
    // KEYS и signCanon объявлены в старом app.js (глобальные переменные)
    if (typeof signCanon === "function") {
      return await signCanon(KEYS.privateKey, canonHex);
    }

    if (!KEYS || !KEYS.privateKey) {
      throw new Error("кошелёк заблокирован (нет ключа)");
    }

    const bytes = new Uint8Array(
      canonHex.match(/.{1,2}/g).map((x) => parseInt(x, 16))
    );
    const sig = await crypto.subtle.sign("Ed25519", KEYS.privateKey, bytes);
    return Array.from(new Uint8Array(sig))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");
  }

  // Отправка batch'а (одна транза внутри массива)
  async function submitTx(tx) {
    const payload = { txs: [tx] };

    const r = await fetch(API + "/submit_tx_batch", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const txt = await r.text().catch(() => "");
    if (!r.ok) {
      throw new Error(`/submit_tx_batch ${r.status} ${txt}`);
    }

    try {
      return JSON.parse(txt);
    } catch {
      return txt;
    }
  }

  // Получаем текущий nonce по RID
  async function autoNonce(rid) {
    const data = await jsonGet("/balance/" + encodeURIComponent(rid));
    return Number(data.nonce || 0);
  }

  window.addEventListener("DOMContentLoaded", () => {
    const btn = $("#btn-send");
    if (!btn) return; // не на той странице

    // выпиливаем старые обработчики: клонируем кнопку
    const newBtn = btn.cloneNode(true);
    btn.parentNode.replaceChild(newBtn, btn);

    const nonceInput = $("#nonce");
    if (nonceInput) {
      nonceInput.readOnly = true;
      nonceInput.placeholder = "авто по сети";
    }
    const nonceBtn = $("#btn-nonce");
    if (nonceBtn) {
      nonceBtn.style.display = "none"; // прячем кнопку nonce
    }

    const out = $("#out-send");
    const show = (v) => {
      if (!out) return;
      out.textContent =
        typeof v === "string" ? v : JSON.stringify(v, null, 2);
    };

    newBtn.addEventListener("click", async () => {
      try {
        // RID и KEYS приходят из старого app.js
        if (typeof RID === "undefined" || !RID) {
          throw new Error("RID не найден (перезайди в кошелёк)");
        }
        if (typeof KEYS === "undefined" || !KEYS || !KEYS.privateKey) {
          throw new Error("кошелёк заблокирован (нет ключа)");
        }

        const toEl = $("#to");
        const amtEl = $("#amount");
        if (!toEl || !amtEl) throw new Error("не найдены поля формы");

        const to = toEl.value.trim();
        const amount = Number(amtEl.value);

        if (!to) throw new Error("укажи RID получателя");
        if (!Number.isFinite(amount) || amount <= 0) {
          throw new Error("сумма должна быть > 0");
        }

        // 1) узнаём nonce из /balance
        const currentNonce = await autoNonce(RID);
        const nonce = currentNonce + 1;
        if (nonceInput) nonceInput.value = String(nonce);

        // 2) получаем канонический hex от /debug_canon
        const canon = await debugCanon(RID, to, amount, nonce);

        // 3) подписываем
        const sigHex = await signCanonCompat(canon);

        // 4) собираем транзакцию под новый ApiSubmitTx
        const tx = {
          from: RID,
          to,
          amount: Number(amount),
          nonce,
          sig: sigHex,
          sig_hex: sigHex
        };

        const resp = await submitTx(tx);
        show(resp);
      } catch (e) {
        console.error(e);
        show(String(e));
      }
    });
  });
})();

```

### FILE: /opt/logos/www/wallet_dev/connect.js
```js
// LOGOS Wallet — Airdrop module REMOVED (2026-01-01)
// оставлено как безопасный stub, чтобы ничего не ломалось, если где-то осталась ссылка.
window.LOGOS_AIRDROP = { enabled: false };

```

### FILE: /opt/logos/www/wallet_dev/index.html
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <meta http-equiv="refresh" content="0; url=./auth.html?v=20260109_20"/>
  <title>LOGOS Wallet</title>
</head>
<body>
  Redirecting… <a href="./auth.html?v=20260109_20">Open LOGOS Wallet</a>
</body>
</html>

```

### FILE: /opt/logos/www/wallet_dev/login.html
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="refresh" content="0; url=./auth.html"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
</head>
<body>
  <p>Redirect to <a href="./auth.html">auth.html</a>…</p>
</body>
</html>

```

### FILE: /opt/logos/www/wallet_dev/modules/send.js
```js
/* modules/send.js — REAL SEND LGN (TxIn -> /api/submit_tx) */
(() => {
  function $(sel, root=document){ return root.querySelector(sel); }

  function ridGet(){
    return localStorage.getItem("RID")
      || localStorage.getItem("logos_rid")
      || localStorage.getItem("logos_last_rid")
      || sessionStorage.getItem("RID")
      || sessionStorage.getItem("logos_rid")
      || "";
  }

  function nodeApi(){
    return (window.LOGOS_NODE_API || "/api").replace(/\/+$/,"");
  }

  function setMsg(panel, text, ok=true){
    const el = $("#sendMsg", panel) || $(".sendMsg", panel);
    if (!el) return;
    el.textContent = text || "";
    el.style.opacity = text ? "1" : "0";
    el.style.color = ok ? "" : "#ff6b6b";
  }

  function b64ToU8(b64){
    b64 = (b64||"").replace(/-/g,'+').replace(/_/g,'/');
    while (b64.length % 4) b64 += "=";
    const s = atob(b64);
    const u = new Uint8Array(s.length);
    for (let i=0;i<s.length;i++) u[i] = s.charCodeAt(i);
    return u;
  }

  function hex(u8){
    let out = "";
    for (let i=0;i<u8.length;i++) out += u8[i].toString(16).padStart(2,"0");
    return out;
  }

  // точное преобразование LGN -> micro-LGN (6 decimals)
  function lgnToMicro(s){
    s = String(s||"").trim().replace(",",".");
    if (!s) return null;
    const m = s.match(/^(\d+)(?:\.(\d{0,6})\d*)?$/);
    if (!m) return null;
    const a = m[1];
    const frac = (m[2]||"").padEnd(6,"0");
    const microStr = a + frac;
    // без BigInt не рискуем переполнением? у нас u64 — используем BigInt
    return BigInt(microStr);
  }

  async function getJSON(url){
    const r = await fetch(url, {method:"GET"});
    const t = await r.text();
    let j=null; try{ j=JSON.parse(t);}catch(_){}
    if (!r.ok){
      const msg = j?.detail || j?.error || j?.message || t;
      throw new Error("HTTP " + r.status + ": " + msg);
    }
    return j ?? t;
  }

  async function postJSON(url, body){
    const r = await fetch(url, {
      method:"POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify(body || {})
    });
    const t = await r.text();
    let j=null; try{ j=JSON.parse(t);}catch(_){}
    if (!r.ok){
      const msg = j?.detail || j?.error || j?.message || t;
      throw new Error("HTTP " + r.status + ": " + msg);
    }
    return j ?? t;
  }

  // Пытаемся найти приватный ключ в localStorage (PKCS8 base64/base64url) — без знания имени.
  async function findEd25519PrivKeyForRid(rid){
    const keys = [];
    for (let i=0;i<localStorage.length;i++){
      const k = localStorage.key(i);
      const v = localStorage.getItem(k);
      if (!v) continue;
      if (v.length < 40) continue;
      keys.push([k,v]);
    }

    for (const [k,v] of keys){
      // пропускаем явно не ключи
      if (k.toLowerCase().includes("theme")) continue;
      if (k.toLowerCase().includes("lang")) continue;

      // пробуем как pkcs8 base64/base64url
      let u8 = null;
      try { u8 = b64ToU8(v); } catch(_){}
      if (!u8 || u8.length < 40) continue;

      try{
        const priv = await crypto.subtle.importKey(
          "pkcs8",
          u8,
          { name:"Ed25519" },
          false,
          ["sign"]
        );

        // проверяем: подпись должна валидироваться на pubkey, который соответствует RID
        // (RID у тебя base58(pubkey) — но мы не будем вычислять pubkey: просто вернём ключ и надеемся что он правильный;
        // если неправильный — сервер вернёт bad_signature)
        return priv;
      }catch(_){
        // not a pkcs8 ed25519
      }
    }
    return null;
  }

  function canonBytes(tx){
    // ВАЖНО: это канонизация “по-человечески”.
    // Если на ноде другой формат — сразу увидим "bad_signature", и тогда сделаем canon-endpoint.
    const memo = tx.memo ? String(tx.memo) : "";
    const s = `${tx.from}|${tx.to}|${tx.amount}|${tx.nonce}|${memo}`;
    return new TextEncoder().encode(s);
  }

  async function signTx(privKey, tx){
    const msg = canonBytes(tx);
    const sig = await crypto.subtle.sign({name:"Ed25519"}, privKey, msg);
    return hex(new Uint8Array(sig));
  }

  function render(){
    const panel =
      document.getElementById("panel-send")
      || document.getElementById("panel-transfer")
      || document.querySelector('[data-panel="send"]')
      || document.querySelector('#panel-send');

    if (!panel) return;

    const btnSend = $("#btnSendLGN", panel) || $("#sendBtn", panel) || panel.querySelector("button");
    if (!btnSend) return;

    btnSend.addEventListener("click", async () => {
      try{
        const from = ridGet();
        const to = ($("#sendToRid", panel)?.value || "").trim();
        const amountStr = ($("#sendAmount", panel)?.value || "").trim();
        const memo = ($("#sendMemo", panel)?.value || "").trim();

        if (!from) return setMsg(panel, "RID не найден. Перезайди в кошелёк.", false);
        if (!to || to.length < 12) return setMsg(panel, "Введи правильный RID получателя.", false);

        const micro = lgnToMicro(amountStr);
        if (micro === null) return setMsg(panel, "Введи сумму (например 1 или 0.5).", false);
        if (micro <= 0n) return setMsg(panel, "Сумма должна быть больше 0.", false);

        setMsg(panel, "Получаю nonce…", true);
        const bal = await getJSON(nodeApi() + "/balance/" + encodeURIComponent(from));
        const nonceNow = (bal && (bal.nonce ?? bal.nonce_u64 ?? bal.account_nonce)) ;
        if (nonceNow === undefined || nonceNow === null) {
          return setMsg(panel, "Не смог прочитать nonce из /balance. Нужно уточнить формат ответа.", false);
        }
        const nonce = BigInt(nonceNow) + 1n;

        setMsg(panel, "Ищу ключ…", true);
        const priv = await findEd25519PrivKeyForRid(from);
        if (!priv){
          return setMsg(panel, "Нет приватного ключа в браузере. Нужен импорт/создание ключа (добавим в Настройки).", false);
        }

        const tx = {
          from,
          to,
          amount: micro.toString(),
          nonce: nonce.toString(),
          memo: memo || null
        };

        setMsg(panel, "Подписываю…", true);
        const sig_hex = await signTx(priv, tx);

        setMsg(panel, "Отправляю в сеть…", true);
        const res = await postJSON(nodeApi() + "/submit_tx", {
          from: tx.from,
          to: tx.to,
          amount: Number(tx.amount), // u64 — у тебя тут маленькие суммы; если будут огромные — переведём на строку на сервере
          nonce: Number(tx.nonce),
          memo: tx.memo,
          sig_hex
        });

        setMsg(panel, "✅ Отправлено. " + (res?.txid ? ("txid: " + res.txid) : (res?.info ? res.info : "")), true);
      }catch(e){
        setMsg(panel, "ERR: " + (e?.message || e), false);
      }
    });
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", render);
  else render();
})();

```

### FILE: /opt/logos/www/wallet_dev/modules/settings.js
```js
/* ===== LOGOS Wallet: Settings module (v1) ===== */
(() => {
  const LS_DEV = "logos_dev_mode";

  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const $  = (sel, root=document) => root.querySelector(sel);

  function ridGet(){
    return (
      localStorage.getItem("RID") ||
      localStorage.getItem("logos_rid") ||
      sessionStorage.getItem("RID") ||
      sessionStorage.getItem("logos_rid") ||
      ""
    );
  }

  function devGet(){ return (localStorage.getItem(LS_DEV) === "1"); }
  function devSet(v){ localStorage.setItem(LS_DEV, v ? "1" : "0"); }

  function markDevOnly(){
    // 1) прячем все Details/raw блоки
    $$("details").forEach(d => {
      const t = (d.textContent || "").toLowerCase();
      const s = ($("summary", d)?.textContent || "").toLowerCase();
      if (t.includes("raw") || s.includes("details") || s.includes("raw") || t.includes("wallet-api raw")) {
        d.classList.add("devOnly");
      }
    });

    // 2) прячем pre/json дампы если есть
    $$("pre").forEach(p => {
      const t = (p.textContent || "").toLowerCase();
      if (t.includes("{") && (t.includes("rid") || t.includes("addresses") || t.includes("balances"))) {
        p.classList.add("devOnly");
      }
    });

    // 3) прячем любые элементы, где прямо написано "raw"
    $$("*").forEach(el => {
      const t = (el.textContent || "").toLowerCase();
      if (t.trim() === "details (raw)" || t.trim() === "details (wallet-api raw)" ) {
        el.classList.add("devOnly");
      }
    });
  }

  function applyDev(){
    const dev = devGet();
    document.documentElement.classList.toggle("dev", dev);

    // если у нас уже проставлены devOnly — CSS сделает остальное
    markDevOnly();

    // bridge: заменяем страшные сообщения для обычных людей
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const msg = bridgePanel.querySelector(".bridgeMsg");
      if (msg){
        const txt = (msg.textContent || "");
        if (!dev && (txt.includes("HOT wallet not configured") || txt.includes('"detail"'))){
          msg.textContent = "Top up / Withdraw временно недоступны (временно).";
        }
      }
    }
  }

  function downloadJSON(filename, obj){
    const blob = new Blob([JSON.stringify(obj, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
  }

  function clearWalletStorage(){
    // аккуратно удаляем только наши ключи
    const keys = [
      "RID","logos_rid","rid","logosRID",
      "logos_key","logos_priv","logos_pub",
      "wallet_key","wallet_priv","wallet_pub",
      "logos_token","logos_auth",
      "logos_wallet","logos_state",
      "LOGOS_WALLET","LOGOS_STATE",
    ];
    keys.forEach(k => { try{ localStorage.removeItem(k); }catch(e){} });
    keys.forEach(k => { try{ sessionStorage.removeItem(k); }catch(e){} });

    // удаляем всё, что начинается с logos_
    try{
      for (let i=localStorage.length-1;i>=0;i--){
        const k = localStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) localStorage.removeItem(k);
      }
    }catch(e){}
    try{
      for (let i=sessionStorage.length-1;i>=0;i--){
        const k = sessionStorage.key(i);
        if (k && (k.startsWith("logos_") || k.startsWith("LOGOS_"))) sessionStorage.removeItem(k);
      }
    }catch(e){}
  }

  function renderSettings(){
    const panel = document.getElementById("panel-settings");
    if (!panel) return;

    panel.innerHTML = `
      <div class="card">
        <div class="h">Настройки</div>
        <div class="muted">Ключи живут локально в браузере. Сервер видит только подписанные операции.</div>

        <div style="height:12px"></div>

        <div class="kvRow">
          <div>
            <div class="k">Dev mode</div>
            <div class="v muted">Скрывает/показывает технические детали (raw, debug, тексты ошибок).</div>
          </div>
          <label class="switch">
            <input type="checkbox" id="devToggle">
            <span class="slider"></span>
          </label>
        </div>

        <div style="height:14px"></div>

        <div class="card" style="padding:14px">
          <div class="h">Локальные данные</div>
          <div class="muted">RID/ключи/состояние хранятся в localStorage.</div>

          <div style="height:10px"></div>

          <div class="btnRow">
            <button class="btn" id="btnCopyRID">Скопировать RID</button>
            <button class="btn" id="btnExport">Экспорт бэкапа</button>
            <button class="btn danger" id="btnClear">Очистить локальные данные</button>
          </div>

          <div class="muted" style="margin-top:10px" id="settingsNote"></div>
        </div>

        <div style="height:12px"></div>

        <div class="card devOnly" style="padding:14px">
          <div class="h">Dev info</div>
          <div class="muted">Только для тебя.</div>
          <div style="height:10px"></div>
          <pre id="devDump" style="white-space:pre-wrap;margin:0"></pre>
        </div>
      </div>
    `;

    const devToggle = panel.querySelector("#devToggle");
    const note = panel.querySelector("#settingsNote");
    const dump = panel.querySelector("#devDump");

    devToggle.checked = devGet();
    devToggle.addEventListener("change", () => {
      devSet(devToggle.checked);
      applyDev();
      note.textContent = devToggle.checked ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
      // обновим devDump
      const rid = ridGet();
      dump.textContent = JSON.stringify({
        rid,
        origin: window.location.origin,
        api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
        wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
        dev_mode: devGet(),
        localStorage_keys: Object.keys(localStorage || {}).slice(0, 50)
      }, null, 2);
    });

    panel.querySelector("#btnCopyRID").addEventListener("click", async () => {
      const rid = ridGet();
      if (!rid) return (note.textContent = "RID не найден. Войди в кошелёк.");
      try{
        await navigator.clipboard.writeText(rid);
        note.textContent = "RID скопирован.";
      }catch(e){
        note.textContent = "Не удалось скопировать (браузер запретил).";
      }
    });

    panel.querySelector("#btnExport").addEventListener("click", () => {
      const rid = ridGet();
      const payload = {
        rid,
        exported_at: new Date().toISOString(),
        origin: window.location.origin,
        // сохраняем только безопасные вещи — без “сырых приватников”
        // (если приватники где-то лежат — лучше не выгружать в файл автоматически)
        hints: {
          note: "Это бэкап RID/настроек. Приватные ключи не экспортируются автоматически."
        }
      };
      const fn = `logos_wallet_backup_${Date.now()}.json`;
      downloadJSON(fn, payload);
      note.textContent = "Бэкап скачан.";
    });

    panel.querySelector("#btnClear").addEventListener("click", () => {
      const ok = confirm("Точно очистить локальные данные кошелька на этом устройстве? RID/ключи в браузере будут удалены.");
      if (!ok) return;
      clearWalletStorage();
      note.textContent = "Очищено. Перезагружаю…";
      setTimeout(() => location.reload(), 600);
    });

    // init view
    applyDev();
    note.textContent = devGet() ? "Dev mode включён." : "Dev mode выключен (обычный режим).";
    const rid = ridGet();
    dump.textContent = JSON.stringify({
      rid,
      origin: window.location.origin,
      api: (window.LOGOS_NODE_API || window.API_BASE || "/api"),
      wallet_api: (window.LOGOS_WALLET_API || window.WALLET_API || "/wallet-api"),
      dev_mode: devGet(),
    }, null, 2);

    // обновление bridge сообщений при изменениях (MutationObserver)
    const bridgePanel = document.getElementById("panel-bridge");
    if (bridgePanel){
      const obs = new MutationObserver(() => applyDev());
      obs.observe(bridgePanel, {subtree:true, childList:true, characterData:true});
    }
  }

  // старт
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", renderSettings);
  } else {
    renderSettings();
  }
})();

```

### FILE: /opt/logos/www/wallet_dev/modules/tx_redirect.js
```js
/* tx_redirect.js — redirect old /transfer -> /submit_tx and normalize body to TxIn */
(() => {
  const _fetch = window.fetch.bind(window);

  function isHex(s){
    s = String(s||"").replace(/^0x/,"").trim();
    return s.length > 0 && s.length % 2 === 0 && /^[0-9a-fA-F]+$/.test(s);
  }

  function b64urlToBytes(b64url){
    try{
      let s = String(b64url||"").replace(/-/g,'+').replace(/_/g,'/');
      while (s.length % 4) s += '=';
      const bin = atob(s);
      const u = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u[i] = bin.charCodeAt(i);
      return u;
    }catch(e){ return null; }
  }

  function bytesToHex(u){
    let out = "";
    for (let i=0;i<u.length;i++) out += u[i].toString(16).padStart(2,"0");
    return out;
  }

  function normalizeTx(body){
    const j = body && typeof body === "object" ? body : {};
    const from = j.from || j.rid_from || j.sender || j.rid || "";
    const to   = j.to   || j.rid_to   || j.receiver || "";
    let amount = j.amount_mic ?? j.amount_micro ?? j.amount ?? 0;
    const nonce = j.nonce ?? j.n ?? j.account_nonce;

    // если вдруг прислали amount_lgn — переводим в micro-LGN
    if (j.amount_lgn !== undefined && j.amount_lgn !== null){
      const a = Number(j.amount_lgn);
      if (isFinite(a)) amount = Math.round(a * 1e6);
    }

    // подпись: sig_hex обязательно
    let sig_hex = j.sig_hex || j.sigHex || "";
    if (!sig_hex){
      const s = j.sig || j.signature || j.sig_b64 || j.sigB64 || "";
      if (s){
        if (isHex(s)) sig_hex = String(s).replace(/^0x/,"");
        else {
          const u = b64urlToBytes(s);
          if (u) sig_hex = bytesToHex(u);
        }
      }
    }

    const memo = (j.memo === undefined ? null : j.memo);

    return { from, to, amount, nonce, memo, sig_hex };
  }

  window.fetch = async (input, init={}) => {
    try{
      const url = (typeof input === "string") ? input : (input && input.url ? input.url : "");
      if (url.includes("/transfer")){
        const newUrl = url.replace("/transfer", "/submit_tx");

        let bodyObj = {};
        try{ bodyObj = JSON.parse(init.body || "{}"); }catch(e){ bodyObj = {}; }

        const tx = normalizeTx(bodyObj);

        const newInit = {
          ...init,
          method: "POST",
          headers: { ...(init.headers||{}), "Content-Type":"application/json" },
          body: JSON.stringify({
            from: tx.from,
            to: tx.to,
            amount: tx.amount,
            nonce: tx.nonce,
            memo: tx.memo,
            sig_hex: tx.sig_hex
          })
        };

        return _fetch(newUrl, newInit);
      }
    }catch(e){}
    return _fetch(input, init);
  };

  console.log("[tx_redirect] installed: /transfer -> /submit_tx");
})();

```

### FILE: /opt/logos/www/wallet_dev/tabs.js
```js
'use strict';

(function () {
  function qs(sel, root=document){ return root.querySelector(sel); }
  function qsa(sel, root=document){ return Array.from(root.querySelectorAll(sel)); }

  function activate(name){
    const tabs  = qsa('.tab[data-tab]');
    const cards = qsa('.tabCard[data-tab]');

    tabs.forEach(b => b.classList.toggle('is-active', b.getAttribute('data-tab') === name));
    cards.forEach(c => c.classList.toggle('is-active', c.getAttribute('data-tab') === name));

    // optional: hash для прямой ссылки
    try { history.replaceState(null, '', '#'+name); } catch {}
    // вверх, чтобы не казалось что "всё в одной вкладке"
    window.scrollTo({ top: 0, behavior: 'smooth' });
  }

  window.LOGOS_TABS = { activate };

  window.addEventListener('DOMContentLoaded', () => {
    const tabs = qsa('.tab[data-tab]');
    if (!tabs.length) return;

    tabs.forEach(btn => {
      btn.addEventListener('click', () => activate(btn.getAttribute('data-tab')));
    });

    const fromHash = (location.hash || '').replace('#','').trim();
    const initial = fromHash && tabs.some(t => t.getAttribute('data-tab') === fromHash)
      ? fromHash
      : tabs[0].getAttribute('data-tab');

    activate(initial);
  });
})();

```

### FILE: /opt/logos/www/wallet_dev/ui.css
```css

/* assets ui */
.assetsWrap{display:block;margin-top:16px}
.assetsHead{display:flex;gap:12px;align-items:center;justify-content:space-between;margin:8px 0 14px}
.assetsTitle{font-weight:800;font-size:20px;letter-spacing:.2px}
.assetsSub{margin-top:4px;color:rgba(255,255,255,.62);font-size:12px}
.assetsGrid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:14px}
@media (max-width: 900px){.assetsGrid{grid-template-columns:1fr}}
.assetCard{background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:18px;padding:14px;box-shadow:0 16px 50px rgba(0,0,0,.35);backdrop-filter: blur(16px)}
.assetTop{display:flex;gap:12px;align-items:center}
.assetSym{width:48px;height:48px;border-radius:14px;display:flex;align-items:center;justify-content:center;font-weight:800;
  background:radial-gradient(120% 120% at 30% 10%, rgba(78,124,255,.35), rgba(139,92,246,.25), rgba(0,0,0,0));
  border:1px solid rgba(255,255,255,.12)
}
.assetName{font-weight:700}
.assetBal{margin-top:2px;font-size:13px;color:rgba(255,255,255,.75)}
.assetAddrRow{margin-top:12px;display:flex;gap:10px;align-items:center;justify-content:space-between}
.assetAddr{max-width:70%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:rgba(255,255,255,.85)}
.assetNote{margin-top:10px;font-size:12px}

/* ===== LOGOS PREMIUM TABS ===== */
.bottombar{
  position:fixed; left:0; right:0; bottom:0;
  display:flex; gap:10px; padding:12px 12px;
  backdrop-filter: blur(14px);
  background: rgba(10,14,26,.72);
  border-top: 1px solid rgba(255,255,255,.08);
  z-index: 9999;
}
.bottombar .tabBtn{
  flex:1;
  padding:10px 8px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,.10);
  background: rgba(255,255,255,.04);
  color: rgba(255,255,255,.86);
  font-weight: 600;
  cursor: pointer;
}
.bottombar .tabBtn.active{
  background: rgba(120,140,255,.18);
  border-color: rgba(120,140,255,.35);
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
}
body{ padding-bottom: 86px !important; }

/* чуть “премиумнее” общий вид */
.tabCard{
  border: 1px solid rgba(255,255,255,.08) !important;
  box-shadow: 0 14px 40px rgba(0,0,0,.35) !important;
  border-radius: 18px !important;
}

```

### FILE: /opt/logos/www/wallet_dev/ui.js
```js
(() => {
  // Берём API из app.js, если он есть, иначе собираем по origin
  const API_BASE = (window.API ||
                    window.API_ENDPOINT ||
                    (location.origin.replace(/\/$/, '') + '/node-api'));

  function fmtInt(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toLocaleString('en-US');
  }

  function fmtShare(x) {
    if (x === null || x === undefined) return '—';
    if (typeof x !== 'number') {
      const n = Number(x);
      if (!Number.isFinite(n)) return String(x);
      x = n;
    }
    return x.toFixed(6) + ' %';
  }

  function setBalanceWidgets(data) {
    const elLgn   = document.querySelector('#balance-lgn');
    const elRLgn  = document.querySelector('#balance-rlgn');
    const elMicro = document.querySelector('#balance-micro');
    const elShare = document.querySelector('#balance-share');

    const all = [elLgn, elRLgn, elMicro, elShare].filter(Boolean);
    if (!all.length) return;

    if (!data || typeof data !== 'object') {
      all.forEach((el) => { el.textContent = '—'; });
      return;
    }

    if (elLgn) {
      elLgn.textContent = (data.balance !== undefined)
        ? fmtInt(data.balance)
        : '—';
    }

    const rVal = (data.balance_rLGN !== undefined)
      ? data.balance_rLGN
      : data.balance_r_lgn;

    if (elRLgn) {
      elRLgn.textContent = (rVal !== undefined)
        ? fmtInt(rVal)
        : '—';
    }

    if (elMicro) {
      elMicro.textContent = (data.balance_micro !== undefined)
        ? fmtInt(data.balance_micro)
        : '—';
    }

    if (elShare) {
      elShare.textContent = (data.share_of_supply_percent !== undefined)
        ? fmtShare(data.share_of_supply_percent)
        : '—';
    }
  }

  async function fetchBalance(rid) {
    const resp = await fetch(
      `${API_BASE}/balance/${encodeURIComponent(rid)}`,
      { method: 'GET', credentials: 'same-origin', cache: 'no-store' },
    );
    if (!resp.ok) {
      throw new Error(`/balance ${resp.status}`);
    }
    return resp.json();
  }

  async function refreshWidgetsFromApi() {
    try {
      const inp = document.querySelector('#rid-balance');
      const rid = (inp && inp.value.trim()) || (window.RID || '').trim();
      if (!rid) return;
      const data = await fetchBalance(rid);
      setBalanceWidgets(data);
    } catch (e) {
      console.error('ui balance error:', e);
      setBalanceWidgets(null);
    }
  }

  function setup() {
    const btn = document.querySelector('#btn-balance');
    if (!btn) return;

    // При нажатии на "Показать баланс" делаем доп. запрос только для виджетов.
    btn.addEventListener('click', () => {
      // app.js уже делает свой запрос и пишет в <pre>,
      // а мы параллельно обновляем красивые плитки.
      refreshWidgetsFromApi();
    });

    // Можно один раз попробовать подтянуть баланс при загрузке,
    // если RID уже есть в сессии.
    refreshWidgetsFromApi().catch(() => {});
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setup);
  } else {
    setup();
  }
})();

```

### FILE: /opt/logos/www/wallet_dev/wallet.css
```css
:root {
  --bg: #050910;
  --bg-grad-1: rgba(56,189,248,0.18);
  --bg-grad-2: rgba(129,140,248,0.20);

  --card: #020617;
  --card-alt: #020617;

  --border-subtle: rgba(148,163,184,0.30);
  --border-strong: rgba(148,163,184,0.65);

  --accent: #3b82f6;
  --accent-soft: rgba(59,130,246,0.16);
  --accent-strong: #60a5fa;

  --danger: #f97373;

  --text-main: #e5e7eb;
  --text-muted: #9ca3af;

  --radius-card: 20px;
  --radius-sm: 10px;

  --shadow-soft: 0 24px 60px rgba(0,0,0,0.75);

  --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
           "Liberation Mono", "Courier New", monospace;
}

/* базовые */

*,
*::before,
*::after {
  box-sizing: border-box;
}

html, body {
  margin: 0;
  padding: 0;
}

body {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
               Roboto, sans-serif;
  background:
    radial-gradient(circle at top left, var(--bg-grad-1), transparent 58%),
    radial-gradient(circle at bottom right, var(--bg-grad-2), transparent 55%),
    var(--bg);
  color: var(--text-main);
  min-height: 100vh;
}

/* верхняя панель */

.topbar {
  position: sticky;
  top: 0;
  z-index: 40;
  background: linear-gradient(95deg, rgba(15,23,42,0.98), rgba(15,23,42,0.96));
  backdrop-filter: blur(16px);
  border-bottom: 1px solid rgba(148,163,184,0.18);
  box-shadow: 0 18px 40px rgba(0,0,0,0.65);
  padding: 10px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.topbar-left {
  display: flex;
  align-items: center;
  gap: 10px;
}

.logo-dot {
  width: 26px;
  height: 26px;
  border-radius: 999px;
  background: radial-gradient(circle at 30% 30%, #22d3ee, #6366f1);
  box-shadow: 0 0 20px rgba(56,189,248,0.55);
}

.topbar-title {
  display: flex;
  flex-direction: column;
  line-height: 1.1;
}

.topbar-title .brand {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  color: #e5e7eb;
}

.topbar-title .product {
  font-size: 13px;
  color: var(--text-muted);
}

.topbar-right {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 12px;
}

.endpoint-label {
  color: var(--text-muted);
}

.endpoint-value {
  font-family: var(--mono);
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.9);
}

/* общая раскладка */

.page-shell {
  max-width: 1040px;
  margin: 0 auto;
  padding: 18px 16px 40px;
}

.page-header {
  margin-bottom: 18px;
}

.page-header h1 {
  font-size: 22px;
  margin: 0 0 6px;
}

.subtitle {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

/* карточки */

.card {
  background: radial-gradient(circle at top left, rgba(56,189,248,0.10), transparent 55%),
              var(--card);
  border-radius: var(--radius-card);
  border: 1px solid var(--border-subtle);
  box-shadow: var(--shadow-soft);
  margin-bottom: 18px;
  overflow: hidden;
}

.card-header {
  padding: 14px 18px 10px;
  border-bottom: 1px solid rgba(15,23,42,0.9);
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: 12px;
}

.card-title {
  font-size: 16px;
  margin: 0 0 4px;
}

.card-caption {
  margin: 0;
  font-size: 13px;
  color: var(--text-muted);
}

.card-body {
  padding: 14px 18px 16px;
}

/* поля */

.field {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin-bottom: 12px;
}

.field-row {
  display: flex;
  gap: 10px;
  align-items: flex-end;
  margin-bottom: 12px;
}

.field-row .grow {
  flex: 1 1 auto;
}

.field-label {
  font-size: 12px;
  color: var(--text-muted);
}

.field-input {
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.95);
  color: var(--text-main);
  padding: 8px 10px;
  font-size: 14px;
  outline: none;
}

.field-input:focus {
  border-color: var(--accent-strong);
  box-shadow: 0 0 0 1px rgba(59,130,246,0.55);
}

/* текстовые выводы */

.mono-field,
.mono-output {
  width: 100%;
  font-family: var(--mono);
  font-size: 13px;
  border-radius: var(--radius-sm);
  border: 1px solid var(--border-subtle);
  background: rgba(2,6,23,0.96);
  color: var(--text-main);
  padding: 10px 12px;
  resize: vertical;
  min-height: 80px;
  white-space: pre-wrap;
}

.mono-output {
  margin-top: 8px;
}

/* кнопки */

.actions-row {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 6px;
  margin-bottom: 6px;
}

.btn {
  border-radius: 999px;
  border: 1px solid transparent;
  padding: 7px 14px;
  font-size: 13px;
  cursor: pointer;
  font-weight: 500;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.btn.primary {
  background: linear-gradient(135deg, #2563eb, #3b82f6);
  border-color: rgba(59,130,246,0.8);
  color: #fff;
}

.btn.primary:hover {
  background: linear-gradient(135deg, #1d4ed8, #2563eb);
}

.btn.secondary {
  background: rgba(15,23,42,0.95);
  border-color: var(--border-strong);
  color: var(--text-main);
}

.btn.secondary:hover {
  border-color: var(--accent-strong);
}

.btn.ghost {
  background: transparent;
  border-color: var(--border-subtle);
  color: var(--text-muted);
}

.btn.ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* чипы */

.chip {
  padding: 5px 10px;
  border-radius: 999px;
  border: 1px solid var(--border-subtle);
  background: rgba(15,23,42,0.92);
  font-size: 12px;
  color: var(--text-muted);
  cursor: pointer;
}

.chip-ghost:hover {
  border-color: var(--accent-soft);
  color: var(--text-main);
}

/* подсказки */

.hint {
  margin-top: 8px;
  font-size: 12px;
  color: var(--text-muted);
}

/* адаптив */

@media (max-width: 720px) {
  .topbar {
    flex-direction: column;
    align-items: flex-start;
    gap: 8px;
  }

  .field-row {
    flex-direction: column;
    align-items: stretch;
  }

  .page-shell {
    padding: 14px 10px 32px;
  }
}

```

### FILE: /root/logos_lrb/wallet-proxy/app.py
```py
y
import os, json, time, asyncio
from typing import Optional, Literal
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from web3 import Web3
from sqlalchemy import Column, Integer, String, BigInteger, create_engine, select, Index
from sqlalchemy.orm import declarative_base, Session
import aiohttp
from prometheus_client import Counter, Gauge, generate_latest, CONTENT_TYPE_LATEST

# ====== ENV ======
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
CORS         = [o.strip() for o in os.environ.get("LRB_WALLET_CORS", "*").split(",") if o.strip()]
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
HOT_PK       = os.environ.get("ETH_HOT_WALLET_PK", "")
DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"

# ====== DB ======
Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True)
    rid = Column(String, index=True, nullable=False)
    token = Column(String, nullable=False)
    network = Column(String, nullable=False)
    index = Column(Integer, nullable=False, default=0)
    address = Column(String, unique=True, nullable=False)
    created_at = Column(BigInteger, default=lambda:int(time.time()))
Index("ix_dep_unique", DepositMap.rid, DepositMap.token, DepositMap.network, unique=True)

class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True)
    txid = Column(String, unique=True, nullable=False)
    rid = Column(String, index=True)
    token = Column(String)
    network = Column(String)

engine = create_engine(DB_URL, future=True)
Base.metadata.create_all(engine)

from eth_utils import to_checksum_address

# ...

def _hot_pk_bytes() -> bytes:
    if not HOT_PK:
        raise HTTPException(500, "HOT wallet not configured")
    pk = HOT_PK.strip()
    # если это hex-строка приватника
    if pk.startswith("0x") and len(pk) in (66, 64 + 2):
        return bytes.fromhex(pk[2:])
    # fallback: просто UTF‑8, если вдруг формат другой (dev)
    return pk.encode("utf-8")


def derive_deposit_address(rid: str, token: str, network: str) -> str:
    """
    Детерминированно получаем ETH-адрес для депозита по (rid, token, network).

    ВАЖНО: seed зависит от HOT_PK и входных данных → без HOT_PK
    приватный ключ депозитного адреса не восстановить.
    """
    if not w3:
        raise HTTPException(503, "ETH RPC not connected")

    base = _hot_pk_bytes()
    seed = f"{rid}|{token}|{network}|LOGOS_DEPOSIT_V1".encode("utf-8")
    digest = Web3.keccak(base + seed)  # 32 байта

    try:
        acct = w3.eth.account.from_key(digest)
    except Exception as e:
        # совсем параноидальный fallback, на практике сюда не попадём
        raise HTTPException(500, f"failed to derive deposit address: {e}")

    return to_checksum_address(acct.address)

# ====== Web3 ======
w3: Optional[Web3] = None
USDT = None
ERC20_ABI = json.loads("""
[
 {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"","type":"uint256"}],"type":"function"},
 {"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"type":"function"},
 {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
]
""")
if ETH_RPC:
    try:
        w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
        if w3.is_connected():
            USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=ERC20_ABI)
            print("INFO Web3 connected:", USDT_ADDRESS)
        else:
            print("WARN ETH RPC not reachable"); w3=None
    except Exception as e:
        print("WARN web3 init error:", e); w3=None; USDT=None

# ====== HTTP helper ======
async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

# ====== FastAPI ======
app = FastAPI(title="LRB Wallet Proxy", version="1.2")
app.add_middleware(CORSMiddleware, allow_origins=CORS if CORS else ["*"],
                   allow_credentials=True, allow_methods=["*"], allow_headers=["*"])

# ====== Pydantic v2-safe models ======
class TopupRequest(BaseModel):
    rid: str
    token: Literal["USDT"] = "USDT"
    network: Literal["ETH"] = "ETH"
class TopupResponse(BaseModel):
    rid: str; token: str; network: str; address: str
class WithdrawRequest(BaseModel):
    rid: str; token: Literal["USDT"]="USDT"; network: Literal["ETH"]="ETH"
    amount: int; to_address: str; request_id: str
class QuoteRequest(BaseModel):
    from_token: str; to_token: str; amount: int
class QuoteResponse(BaseModel):
    price: float; expected_out: float

# ====== Metrics ======
PROXY_TOPUP_REQ   = Counter("proxy_topup_requests_total", "topup requests")
PROXY_WITHDRAW_OK = Counter("proxy_withdraw_ok_total",   "withdraw ok")
PROXY_WITHDRAW_ERR= Counter("proxy_withdraw_err_total",  "withdraw err")

@app.get("/metrics")
def metrics():
    return app.responses.Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)

# ====== Endpoints ======
@app.get("/")
def root():
    return {"ok": True, "service": "wallet-proxy", "eth_connected": bool(w3)}

@app.post("/v1/topup/request", response_model=TopupResponse)
def topup_request(req: TopupRequest):
    PROXY_TOPUP_REQ.inc()
    if not w3: raise HTTPException(503, "ETH RPC not connected")
    if not HOT_PK: raise HTTPException(500, "HOT wallet not configured")
    deposit_address = w3.eth.account.from_key(HOT_PK).address
    with Session(engine) as s:
        dm = s.execute(select(DepositMap).where(
            DepositMap.rid==req.rid, DepositMap.token==req.token, DepositMap.network==req.network
        )).scalar_one_or_none()
        if dm is None:
            s.add(DepositMap(rid=req.rid, token=req.token, network=req.network, address=deposit_address))
            s.commit()
    return TopupResponse(rid=req.rid, token=req.token, network=req.network, address=deposit_address)

@app.post("/v1/withdraw")
async def withdraw(req: WithdrawRequest):
    try:
        if req.amount<=0: raise HTTPException(400,"amount<=0")
        if not w3 or not USDT: raise HTTPException(503, "ETH RPC not connected")
        acct = w3.eth.account.from_key(HOT_PK)
        # redeem
        hdr = {"X-Bridge-Key": BRIDGE_KEY} if not BRIDGE_KEY.startswith("ey") else {"Authorization": f"Bearer {BRIDGE_KEY}"}
        st, data = await http_json("POST", f"{NODE_URL}/bridge/redeem", {
            "rid": req.rid, "amount": req.amount, "request_id": req.request_id
        }, hdr)
        if st//100 != 2: raise HTTPException(st, f"bridge redeem failed: {data}")
        # ERC-20
        nonce = w3.eth.get_transaction_count(acct.address)
        tx = USDT.functions.transfer(Web3.to_checksum_address(req.to_address), int(req.amount)).build_transaction({
            "chainId": w3.eth.chain_id, "from": acct.address, "nonce": nonce,
            "gas": 90000, "maxFeePerGas": w3.to_wei("30","gwei"), "maxPriorityFeePerGas": w3.to_wei("1","gwei"),
        })
        signed = w3.eth.account.sign_transaction(tx, private_key=HOT_PK)
        tx_hash = w3.eth.send_raw_transaction(signed.rawTransaction).hex()
        with Session(engine) as s: s.add(SeenTx(txid=tx_hash, rid=req.rid, token=req.token, network=req.network)); s.commit()
        PROXY_WITHDRAW_OK.inc()
        return {"ok": True, "txid": tx_hash}
    except HTTPException:
        PROXY_WITHDRAW_ERR.inc(); raise
    except Exception as e:
        PROXY_WITHDRAW_ERR.inc(); raise HTTPException(500, f"withdraw error: {e}")

@app.post("/v1/quote", response_model=QuoteResponse)
async def quote(req: QuoteRequest):
    return QuoteResponse(price=1.0, expected_out=float(req.amount))

```

### FILE: /root/logos_lrb/wallet-proxy/requirements.txt
```txt
aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
aiosqlite==0.21.0
annotated-types==0.7.0
anyio==4.10.0
attrs==25.3.0
bip-utils==2.9.3
bitarray==3.7.1
cbor2==5.7.0
certifi==2025.8.3
cffi==1.17.1
charset-normalizer==3.4.3
ckzg==2.1.1
click==8.2.1
coincurve==21.0.0
crcmod==1.7
cytoolz==1.0.1
ecdsa==0.19.1
ed25519-blake2b==1.4.1
eth-account==0.13.7
eth-hash==0.7.1
eth-keyfile==0.8.1
eth-keys==0.7.0
eth-rlp==2.2.0
eth-typing==5.2.1
eth-utils==5.3.1
eth_abi==5.2.0
fastapi==0.116.1
frozenlist==1.7.0
greenlet==3.2.4
h11==0.16.0
hexbytes==1.3.1
httptools==0.6.4
idna==3.10
multidict==6.6.4
parsimonious==0.10.0
prometheus_client==0.22.1
propcache==0.3.2
py-sr25519-bindings==0.2.2
pycparser==2.22
pycryptodome==3.23.0
pydantic==2.11.7
pydantic_core==2.33.2
PyNaCl==1.5.0
python-dotenv==1.1.1
pyunormalize==16.0.0
PyYAML==6.0.2
regex==2025.9.1
requests==2.32.5
rlp==4.1.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.43
starlette==0.47.3
toolz==1.0.0
types-requests==2.32.4.20250809
typing-inspection==0.4.1
typing_extensions==4.15.0
urllib3==2.5.0
uvicorn==0.35.0
uvloop==0.21.0
watchfiles==1.1.0
web3==7.13.0
websockets==15.0.1
yarl==1.20.1

```

### FILE: /root/logos_lrb/wallet-proxy/scanner.py
```py
import os, json, time, asyncio
from typing import Optional
from web3 import Web3
from sqlalchemy import create_engine, select
from sqlalchemy.orm import Session
from prometheus_client import Counter, Gauge, start_http_server
import aiohttp

DB_URL       = "sqlite:////opt/logos/wallet-proxy/wproxy.db"
NODE_URL     = os.environ.get("LRB_NODE_URL", "http://127.0.0.1:8080")
BRIDGE_KEY   = os.environ.get("LRB_BRIDGE_KEY", "")
ETH_RPC      = os.environ.get("ETH_PROVIDER_URL", "")
USDT_ADDRESS = os.environ.get("USDT_ERC20_ADDRESS", "0xdAC17F958D2ee523a2206206994597C13D831ec7")
CONFIRMATIONS= int(os.environ.get("ETH_CONFIRMATIONS", "6"))

from sqlalchemy.orm import declarative_base
from sqlalchemy import Column, Integer, String, BigInteger

Base = declarative_base()
class DepositMap(Base):
    __tablename__ = "deposit_map"
    id = Column(Integer, primary_key=True); rid = Column(String); token = Column(String); network = Column(String); address = Column(String)
class SeenTx(Base):
    __tablename__ = "seen_tx"
    id = Column(Integer, primary_key=True); txid = Column(String, unique=True); rid = Column(String); token = Column(String); network = Column(String)
class Kv(Base):
    __tablename__ = "kv"
    k = Column(String, primary_key=True); v = Column(String, nullable=False)

engine = create_engine(DB_URL, future=True)

# metrics
SCAN_LAST_BLOCK = Gauge("scanner_last_scanned_block", "last scanned block")
SCAN_LAG        = Gauge("scanner_block_lag", "chain head minus safe block")
DEP_OK          = Counter("scanner_deposit_ok_total", "successful deposits")
DEP_ERR         = Counter("scanner_deposit_err_total","failed deposits")

async def http_json(method:str, url:str, body:dict=None, headers:dict=None):
    async with aiohttp.ClientSession() as sess:
        async with sess.request(method, url, json=body, headers=headers) as r:
            t = await r.text()
            try: data = json.loads(t) if t else {}
            except: data = {"raw": t}
            return r.status, data

def kv_get(key:str, default:str="0")->str:
    with Session(engine) as s:
        row = s.get(Kv, key); return row.v if row else default
def kv_set(key:str, val:str):
    with Session(engine) as s:
        row = s.get(Kv, key)
        if row: row.v = val
        else:   s.add(Kv(k=key, v=val))
        s.commit()

async def scanner():
    if not ETH_RPC:
        print("No ETH RPC configured; scanner idle"); 
        while True: await asyncio.sleep(30)

    w3 = Web3(Web3.HTTPProvider(ETH_RPC, request_kwargs={"timeout":10}))
    if not w3.is_connected():
        print("ETH RPC unreachable; scanner idle")
        while True: await asyncio.sleep(30)

    USDT = w3.eth.contract(address=Web3.to_checksum_address(USDT_ADDRESS), abi=json.loads("""
    [
     {"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}
    ]
    """))
    key = "last_scanned_block"
    backoff = 1
    while True:
        try:
            head = w3.eth.block_number
            safe_to = head - CONFIRMATIONS
            last = int(kv_get(key, "0"))
            SCAN_LAG.set(max(0, head - safe_to))
            if safe_to <= last:
                await asyncio.sleep(5); continue

            step = 2000
            from_block = last + 1
            with Session(engine) as s:
                addr_map = {dm.address.lower(): dm for dm in s.query(DepositMap).all()}

            while from_block <= safe_to:
                to_block = min(from_block + step - 1, safe_to)
                logs = w3.eth.get_logs({
                    "fromBlock": from_block, "toBlock": to_block,
                    "address": Web3.to_checksum_address(USDT_ADDRESS),
                    "topics": [Web3.keccak(text="Transfer(address,address,uint256)")]
                })
                for lg in logs:
                    to_hex = "0x"+lg["topics"][2].hex()[-40:]
                    to_norm = Web3.to_checksum_address(to_hex).lower()
                    dm = addr_map.get(to_norm)
                    if not dm: continue
                    txid = lg["transactionHash"].hex()
                    value = int(lg["data"], 16)
                    # идемпотентность
                    with Session(engine) as s:
                        if s.execute(select(SeenTx).where(SeenTx.txid==txid)).scalar_one_or_none():
                            continue
                        s.add(SeenTx(txid=txid, rid=dm.rid, token=dm.token, network=dm.network)); s.commit()
                    # bridge deposit
                    hdr = {"X-Bridge-Key": os.environ.get("LRB_BRIDGE_KEY","")}
                    st, data = await http_json("POST", f"{NODE_URL}/bridge/deposit",
                                               {"rid": dm.rid, "amount": value, "ext_txid": txid}, hdr)
                    if st//100 == 2: DEP_OK.inc()
                    else:
                        DEP_ERR.inc()
                        print("WARN deposit fail", txid, st, data)
                kv_set(key, str(to_block))
                SCAN_LAST_BLOCK.set(to_block)
                from_block = to_block + 1
                backoff = 1
            await asyncio.sleep(5)
        except Exception as e:
            print("scanner error:", e)
            await asyncio.sleep(min(60, backoff)); backoff = min(60, backoff*2)

if __name__ == "__main__":
    # метрики на 9101
    start_http_server(9101)
    asyncio.run(scanner())

```

### FILE: /var/www/logos/wallet/app.html
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Кошелёк</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c;position:sticky;top:0}
    h1{font-size:18px;margin:0}
    main{max-width:1024px;margin:24px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    input,button,textarea{width:100%;padding:10px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    small{opacity:.8}
  </style>
</head>
<body>
<header>
  <h1>LOGOS Wallet — Кошелёк</h1>
</header>
<main>
  <section>
    <div class="grid">
      <div>
        <h3>Твой RID / Публичный ключ</h3>
        <textarea id="pub" class="mono" rows="4" readonly></textarea>
        <div style="display:flex;gap:10px;margin-top:10px">
          <button id="btn-lock" class="secondary">Выйти (заблокировать)</button>
          <button id="btn-nonce" class="secondary">Получить nonce</button>
        </div>
        <p><small>Ключ в памяти. Закроешь вкладку — понадобится пароль на странице входа.</small></p>
      </div>
      <div>
        <h3>Баланс</h3>
        <div class="grid">
          <div><label>RID</label><input id="rid-balance" class="mono" placeholder="RID (base58)"/></div>
          <div><label>&nbsp;</label><button id="btn-balance">Показать баланс</button></div>
        </div>
        <pre id="out-balance" class="mono" style="margin-top:12px"></pre>
      </div>
    </div>
  </section>

  <section>
    <h3>Подпись и отправка (batch)</h3>
    <div class="grid">
      <div><label>Получатель (RID)</label><input id="to" class="mono" placeholder="RID получателя"/></div>
      <div><label>Сумма (LGN)</label><input id="amount" type="number" min="1" step="1" value="1"/></div>
    </div>
    <div class="grid">
      <div><label>Nonce</label><input id="nonce" type="number" min="1" step="1" placeholder="нажми 'Получить nonce'"/></div>
      <div><label>&nbsp;</label><button id="btn-send">Подписать и отправить</button></div>
    </div>
    <pre id="out-send" class="mono" style="margin-top:12px"></pre>
  </section>

  <section>
    <h3>Мост rToken (депозит, демо)</h3>
    <div class="grid">
      <div><label>ext_txid</label><input id="ext" class="mono" placeholder="например eth_txid_0xabc"/></div>
      <div><label>&nbsp;</label><button id="btn-deposit">Deposit rLGN</button></div>
    </div>
    <pre id="out-bridge" class="mono" style="margin-top:12px"></pre>
  </section>
</main>
<script src="./app.js?v=20250906_01" defer></script>
</body>
</html>

```

### FILE: /var/www/logos/wallet/app.js
```js
// === БАЗА ===
const API = location.origin + '/api/';     // ГАРАНТИРОВАННЫЙ префикс
const enc = new TextEncoder();

const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));

function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }

// === НАДЁЖНЫЙ fetchJSON: ВСЕГДА JSON (даже при ошибке) ===
async function fetchJSON(url, opts) {
  const r = await fetch(url, opts);
  const text = await r.text();
  try {
    const json = text ? JSON.parse(text) : {};
    if (!r.ok) throw json;
    return json;
  } catch(e) {
    // если прилетел текст/HTML — упакуем в JSON с сообщением
    throw { ok:false, error: (typeof e==='object' && e.error) ? e.error : (text || 'not json') };
  }
}

// === КЛЮЧИ/SESSION ===
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('./login.html'); throw new Error('locked'); }

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey = await deriveKey(pass, new Uint8Array(meta.salt));
  const pkcs8  = await aesDecrypt(aesKey, new Uint8Array(meta.iv_priv), new Uint8Array(meta.priv));
  const pubraw = await aesDecrypt(aesKey, new Uint8Array(meta.iv_pub),  new Uint8Array(meta.pub));
  const privateKey = await crypto.subtle.importKey('pkcs8', pkcs8, {name:'Ed25519'}, false, ['sign']);
  const publicKey  = await crypto.subtle.importKey('raw',   pubraw, {name:'Ed25519'}, true,  ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}

let KEYS=null, META=null;
(async ()=>{
  META = await idbGet('acct:'+RID);
  if (!META) { sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS = await importKey(PASS, META);
  $('#pub') && ($('#pub').value = `RID: ${RID}\npub: ${KEYS.pub_hex}`);
  $('#rid-balance') && ($('#rid-balance').value = RID);
})();

// === КАНОНИКА/ПОДПИСЬ ===
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(privateKey, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', privateKey, msg);
  return toHex(sig);
}

// === API HELPERS ===
async function getBalance(rid){ return fetchJSON(`${API}balance/${encodeURIComponent(rid)}`); }
async function submitTxBatch(txs){
  return fetchJSON(`${API}submit_tx_batch`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ txs })
  });
}
async function stakeDelegate(delegator, validator, amount){
  return fetchJSON(`${API}stake/delegate`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ delegator, validator, amount:Number(amount) })
  });
}
async function stakeUndelegate(delegator, validator, amount){
  return fetchJSON(`${API}stake/undelegate`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ delegator, validator, amount:Number(amount) })
  });
}
async function stakeClaim(delegator, validator){
  return fetchJSON(`${API}stake/claim`, {
    method:'POST', headers:{'content-type':'application/json'},
    body: JSON.stringify({ delegator, validator, amount:0 })
  });
}
async function stakeMy(rid){ return fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`); }

// === UI ===
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid = ($('#rid-balance')?.value || RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ alert(`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to     = $('#to')?.value.trim();
    const amount = $('#amount')?.value.trim();
    const nonce  = $('#nonce')?.value.trim();
    if (!to || !amount || !nonce) throw {error:'fill to/amount/nonce'};
    const ch = await canonHex(RID, to, amount, nonce, KEYS.pub_hex);
    const sigHex = await signCanon(KEYS.privateKey, ch);
    const tx = { from_rid:RID, to_rid:to, amount:Number(amount), nonce:Number(nonce), pubkey_hex:KEYS.pub_hex, sig_hex:sigHex };
    const res = await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent = JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent = `ERR: ${JSON.stringify(e)}`); }
});

$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')?.value || RID).trim();
    const amount = ($('#stake-amount')?.value || '').trim() || ($('#amount')?.value || '').trim();
    const res = await stakeDelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')?.value || RID).trim();
    const amount = ($('#stake-amount')?.value || '').trim() || ($('#amount')?.value || '').trim();
    const res = await stakeUndelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')?.value || RID).trim();
    const res = await stakeClaim(RID, val);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{
    const res = await stakeMy(RID);
    $('#out-my') && ($('#out-my').textContent = JSON.stringify(res));
  }catch(e){ $('#out-my') && ($('#out-my').textContent = `ERR: ${JSON.stringify(e)}`); }
});

// кнопка NONCE (если есть)
$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); $('#nonce') && ($('#nonce').value = String(j.nonce||0)); }
  catch(e){ alert(`ERR: ${JSON.stringify(e)}`); }
});

```

### FILE: /var/www/logos/wallet/app.v2.js
```js
// == CONFIG ==
const API = location.origin + '/api/';
const enc = new TextEncoder();

// == utils ==
const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));
function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }

// == robust fetch: always JSON ==
async function fetchJSON(url, opts){
  try{
    const r = await fetch(url, opts);
    const text = await r.text();
    try {
      const js = text ? JSON.parse(text) : {};
      if(!r.ok) throw js;
      return js;
    } catch(parseErr){
      throw { ok:false, error:(text||'not json'), status:r.status||0 };
    }
  }catch(netErr){
    throw { ok:false, error:(netErr?.message||'network error') };
  }
}

// == session/keys ==
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('./login.html'); throw new Error('locked'); }

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8 =await aesDecrypt(aesKey,new Uint8Array(meta.iv_priv),new Uint8Array(meta.priv));
  const pubraw=await aesDecrypt(aesKey,new Uint8Array(meta.iv_pub), new Uint8Array(meta.pub));
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},false,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',  pubraw,{name:'Ed25519'},true, ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}
let KEYS=null, META=null;
(async()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS, META);
  $('#pub') && ($('#pub').value=`RID: ${RID}\npub: ${KEYS.pub_hex}`);
  ($('#rid-balance')||{}).value = RID;
})();

// == canonical/sign ==
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(priv, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', priv, msg);
  return toHex(sig);
}

// == API wrappers ==
async function getBalance(rid){ return fetchJSON(`${API}balance/${encodeURIComponent(rid)}`); }
async function submitTxBatch(txs){
  return fetchJSON(`${API}submit_tx_batch`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({ txs }) });
}
async function stakeDelegate(delegator,validator,amount){
  return fetchJSON(`${API}stake/delegate`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({delegator,validator,amount:Number(amount)}) });
}
async function stakeUndelegate(delegator,validator,amount){
  return fetchJSON(`${API}stake/undelegate`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({delegator,validator,amount:Number(amount)}) });
}
async function stakeClaim(delegator,validator){
  return fetchJSON(`${API}stake/claim`, { method:'POST', headers:{'content-type':'application/json'}, body: JSON.stringify({delegator,validator,amount:0}) });
}
async function stakeMy(rid){ return fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`); }

// == UI handlers ==
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid=($('#rid-balance')?.value||RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ $('#out-balance') && ($('#out-balance').textContent=`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to = ($('#to')||$('#rid-to'))?.value.trim();
    const amount = ($('#amount')||$('#sum')||$('#stake-amount'))?.value.trim();
    const nonce  = ($('#nonce')||$('#tx-nonce'))?.value.trim();
    if(!to||!amount||!nonce) throw {error:'fill to/amount/nonce'};
    const ch = await canonHex(RID, to, amount, nonce, KEYS.pub_hex);
    const sigHex = await signCanon(KEYS.privateKey, ch);
    const tx = { from_rid:RID, to_rid:to, amount:Number(amount), nonce:Number(nonce), pubkey_hex:KEYS.pub_hex, sig_hex:sigHex };
    const res = await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent = JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent = `ERR: ${JSON.stringify(e)}`); }
});

$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')||$('#val')||$('#rid-validator'))?.value.trim() || RID;
    const amount = ($('#stake-amount')||$('#amount')||$('#sum'))?.value.trim();
    const res = await stakeDelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')||$('#val')||$('#rid-validator'))?.value.trim() || RID;
    const amount = ($('#stake-amount')||$('#amount')||$('#sum'))?.value.trim();
    const res = await stakeUndelegate(RID, val, amount);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val = ($('#validator')||$('#val')||$('#rid-validator'))?.value.trim() || RID;
    const res = await stakeClaim(RID, val);
    $('#out-stake') && ($('#out-stake').textContent = JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent = `ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{ const res = await stakeMy(RID); $('#out-my') && ($('#out-my').textContent = JSON.stringify(res)); }
  catch(e){ $('#out-my') && ($('#out-my').textContent = `ERR: ${JSON.stringify(e)}`); }
});

// nonce helper
$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); ($('#nonce')||$('#tx-nonce')) && ((($('#nonce')||$('#tx-nonce')).value)=String(j.nonce||0)); }
  catch(e){ /* ignore */ }
});

```

### FILE: /var/www/logos/wallet/app.v3.js
```js
const API = location.origin + '/api/';
const enc = new TextEncoder();

// utils
const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));
function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }

// robust fetch → всегда JSON
async function fetchJSON(url, opts){
  const r = await fetch(url, opts);
  const text = await r.text();
  try {
    const js = text ? JSON.parse(text) : {};
    if (!r.ok) throw js;
    return js;
  } catch(e) {
    throw { ok:false, error:(typeof e==='object'&&e.error)?e.error:(text||'not json'), status:r.status||0 };
  }
}

// session/keys
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('./login.html'); throw new Error('locked'); }

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8 =await aesDecrypt(aesKey,new Uint8Array(meta.iv_priv),new Uint8Array(meta.priv));
  const pubraw=await aesDecrypt(aesKey,new Uint8Array(meta.iv_pub), new Uint8Array(meta.pub));
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},false,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',  pubraw,{name:'Ed25519'},true, ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}
let KEYS=null, META=null;
(async()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('./login.html'); return; }
  KEYS=await importKey(PASS, META);
  const pubEl=$('#pub'); if(pubEl) pubEl.value=`RID: ${RID}\npub: ${KEYS.pub_hex}`;
  const rb=$('#rid-balance'); if(rb) rb.value=RID;
})();

// canonical+sign
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(priv, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', priv, msg);
  return toHex(sig);
}

// API wrappers
const getBalance = (rid)=>fetchJSON(`${API}balance/${encodeURIComponent(rid)}`);
const submitTxBatch = (txs)=>fetchJSON(`${API}submit_tx_batch`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({txs})});
const stakeDelegate   = (delegator,validator,amount)=>fetchJSON(`${API}stake/delegate`,  {method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeUndelegate = (delegator,validator,amount)=>fetchJSON(`${API}stake/undelegate`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeClaim      = (delegator,validator)=>fetchJSON(`${API}stake/claim`,            {method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:0})});
const stakeMy         = (rid)=>fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`);

// UI handlers
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid=($('#rid-balance')?.value||RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ $('#out-balance') && ($('#out-balance').textContent=`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); const n=($('#nonce')); if(n) n.value=String(j.nonce||0); } catch(e){}
});

$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to=$('#to')?.value.trim(); const amount=$('#amount')?.value.trim(); const nonce=$('#nonce')?.value.trim();
    if(!to||!amount||!nonce) throw {error:'fill to/amount/nonce'};
    const ch=await canonHex(RID,to,amount,nonce,KEYS.pub_hex);
    const sig=await signCanon(KEYS.privateKey,ch);
    const tx={from_rid:RID,to_rid:to,amount:Number(amount),nonce:Number(nonce),pubkey_hex:KEYS.pub_hex,sig_hex:sig};
    const res=await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent=JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent=`ERR: ${JSON.stringify(e)}`); }
});

$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim(); const amount=$('#stake-amount')?.value.trim();
    const res=await stakeDelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim(); const amount=$('#stake-amount')?.value.trim();
    const res=await stakeUndelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const res=await stakeClaim(RID,val);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{ const res=await stakeMy(RID); $('#out-my') && ($('#out-my').textContent=JSON.stringify(res)); }
  catch(e){ $('#out-my') && ($('#out-my').textContent=`ERR: ${JSON.stringify(e)}`); }
});

```

### FILE: /var/www/logos/wallet/auth.js
```js
// AUTH v3: RID + пароль. Сохраняем под "acct:<RID>".
// Фичи: авто-подстановка last_rid, кликабельный список, чистка всех пробелов/переносов в RID.

const DB_NAME='logos_wallet_v2', STORE='keys', enc=new TextEncoder();
const $ = s => document.querySelector(s);
const out = msg => { const el=$('#out'); if(el) el.textContent=String(msg); };

function normRid(s){ return (s||'').replace(/\s+/g,'').trim(); } // убираем все пробелы/переносы

function ensureEnv() {
  if (!window.isSecureContext) throw new Error('Нужен HTTPS (secure context)');
  if (!window.indexedDB) throw new Error('IndexedDB недоступен');
  if (!crypto || !crypto.subtle) throw new Error('WebCrypto недоступен');
}

const idb=()=>new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=()=>r.result.createObjectStore(STORE);r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});
const idbGet=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readonly').objectStore(STORE).get(k);t.onsuccess=()=>res(t.result||null);t.onerror=()=>rej(t.error);});};
const idbSet=async (k,v)=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).put(v,k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};
const idbDel=async k=>{const db=await idb();return new Promise((res,rej)=>{const t=db.transaction(STORE,'readwrite').objectStore(STORE).delete(k);t.onsuccess=()=>res(true);t.onerror=()=>rej(t.error);});};

async function deriveKey(pass,salt){
  const keyMat=await crypto.subtle.importKey('raw',enc.encode(pass),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:120000,hash:'SHA-256'},keyMat,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);
}
async function aesEncrypt(aesKey,data){const iv=crypto.getRandomValues(new Uint8Array(12));const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,data);return{iv:Array.from(iv),ct:Array.from(new Uint8Array(ct))}}
async function aesDecrypt(aesKey,iv,ct){return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv:new Uint8Array(iv)},aesKey,new Uint8Array(ct)))}

function b58(bytes){
  const ALPH="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  const hex=[...new Uint8Array(bytes)].map(b=>b.toString(16).padStart(2,'0')).join('');
  let x=BigInt('0x'+hex), out=''; while(x>0n){ out=ALPH[Number(x%58n)]+out; x/=58n; } return out||'1';
}

async function addAccount(rid){ const list=(await idbGet('accounts'))||[]; if(!list.includes(rid)){ list.push(rid); await idbSet('accounts',list); } }
async function listAccounts(){ return (await idbGet('accounts'))||[]; }

async function createAccount(pass){
  ensureEnv();
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  out('Создаём ключ…');
  const kp=await crypto.subtle.generateKey({name:'Ed25519'},true,['sign','verify']);
  const rawPub=new Uint8Array(await crypto.subtle.exportKey('raw',kp.publicKey));
  const rid=b58(rawPub);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey('pkcs8',kp.privateKey));
  const salt=crypto.getRandomValues(new Uint8Array(16));
  const aes=await deriveKey(pass,salt);
  const {iv,ct}=await aesEncrypt(aes,pkcs8);
  const meta={rid,pub:Array.from(rawPub),salt:Array.from(salt),iv,priv:ct};

  await idbSet('acct:'+rid,meta);
  await addAccount(rid);
  await idbSet('last_rid', rid);

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  out('RID создан: '+rid+' → вход…');
  location.href='./app.html';
}

async function loginAccount(rid, pass){
  ensureEnv();
  rid = normRid(rid);
  if(!rid) throw new Error('Укажи RID');
  if(!pass || pass.length<6) throw new Error('Пароль ≥6 символов');

  const meta=await idbGet('acct:'+rid);
  if(!meta){
    const list=await listAccounts();
    throw new Error('RID не найден на этом устройстве. Сохранённые RID:\n'+(list.length?list.join('\n'):'—'));
  }
  const aes=await deriveKey(pass,new Uint8Array(meta.salt));
  try{ await aesDecrypt(aes,meta.iv,meta.priv); } catch(e){ throw new Error('Неверный пароль'); }

  sessionStorage.setItem('logos_pass',pass);
  sessionStorage.setItem('logos_rid',rid);
  await idbSet('last_rid', rid);
  out('Вход…'); location.href='./app.html';
}

async function resetAll(){
  const list=await listAccounts();
  for(const rid of list){ await idbDel('acct:'+rid); }
  await idbDel('accounts'); await idbDel('last_rid');
  sessionStorage.clear();
  out('Все аккаунты удалены (DEV).');
}

function renderRidList(list){
  const wrap=$('#listWrap'), ul=$('#ridList'); ul.innerHTML='';
  if(!list.length){ wrap.style.display='block'; ul.innerHTML='<li>— пусто —</li>'; return; }
  wrap.style.display='block';
  list.forEach(rid=>{
    const li=document.createElement('li'); li.textContent=rid;
    li.addEventListener('click', ()=>{ $('#loginRid').value=rid; out('RID подставлен'); });
    ul.appendChild(li);
  });
}

// авто-подстановка last_rid при загрузке
(async ()=>{
  const last=await idbGet('last_rid'); if(last){ $('#loginRid').value=last; }
})();

// wire UI
$('#btn-login').addEventListener('click', async ()=>{
  const rid=$('#loginRid').value; const pass=$('#pass').value;
  try{ await loginAccount(rid,pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-create').addEventListener('click', async ()=>{
  const pass=$('#pass').value;
  try{ await createAccount(pass); }catch(e){ out('ERR: '+(e&&e.message?e.message:e)); }
});
$('#btn-list').addEventListener('click', async ()=>{
  try{ renderRidList(await listAccounts()); }catch(e){ out('ERR: '+e); }
});
$('#btn-reset').addEventListener('click', resetAll);

```

### FILE: /var/www/logos/wallet/css/styles.css
```css
:root{color-scheme:dark}
*{box-sizing:border-box}
body{margin:0;background:#0b1016;color:#e7eef7;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
.wrap{max-width:1100px;margin:24px auto;padding:0 16px}
.card{background:#0f1723;border:1px solid #243048;border-radius:16px;padding:18px;margin:12px 0}
h1,h2,h3{margin:0 0 10px}
.muted{color:#9fb2c9}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.grid{display:grid;gap:12px}
.cols-2{grid-template-columns:1fr 1fr}
.cols-3{grid-template-columns:1fr 1fr 1fr}
.mt10{margin-top:10px}
@media(max-width:980px){.cols-2,.cols-3{grid-template-columns:1fr}}
input,button,textarea{border-radius:12px;border:1px solid #28344c;background:#0d1420;color:#e7eef7;padding:12px;width:100%}
textarea{min-height:100px;resize:vertical}
input:focus,textarea:focus{outline:none;border-color:#3a70ff;box-shadow:0 0 0 2px #3a70ff26}
button{background:#3366ff;border:none;cursor:pointer;transition:.15s}
button.secondary{background:#1a2333}
button.ghost{background:#0d1420;border:1px dashed #2a3a56}
.badge{background:#141e2d;border:1px solid #2a3a56;border-radius:999px;padding:6px 10px;font-size:12px}
.kpi{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace;word-break:break-all}
.table{width:100%;border-collapse:collapse}
.table th,.table td{border-bottom:1px solid #1a2436;padding:10px 8px;text-align:left;font-size:13px}
.table th{color:#9fb2c9;font-weight:600}
.scroll{overflow:auto}
.toast{position:fixed;right:16px;bottom:16px;display:none;background:#0e1520;border:1px solid #20406f;color:#bfe0ff;padding:12px 14px;border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35);max-width:80%}
.toast.show{display:block}

/* Secure overlay */
#lockOverlay{position:fixed;inset:0;background:rgba(11,16,22,.96);backdrop-filter:saturate(120%) blur(2px);display:flex;align-items:center;justify-content:center;z-index:9999}
#lockCard{width:min(620px,92%);background:#0f1723;border:1px solid #243048;border-radius:18px;padding:18px}
#brand{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
#phish{background:#0c1420;border:1px solid #2a3a56;border-radius:12px;padding:10px;font-size:12px;color:#9fb2c9}
.hidden{display:none}

```

### FILE: /var/www/logos/wallet/index.html
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet</title>
  <link rel="stylesheet" href="./css/styles.css?v=1757930528">
</head>
<body>
<div class="wrap">
  <h1>LOGOS Wallet</h1>

  <!-- App (показывается после unlock) -->
  <section id="viewApp" class="card hidden">
    <h3>Кошелёк разблокирован</h3>
    <div class="kpi">
      <span class="badge">RID: <b class="mono" id="kpiRid">—</b></span>
      <span class="badge">balance: <b id="kpiBal">—</b></span>
      <span class="badge">nonce: <b id="kpiNonce">—</b></span>
      <span class="badge">head: <b id="kpiHead">—</b></span>
      <span class="badge">delegated: <b id="kpiDelegated">—</b></span>
      <span class="badge">entries: <b id="kpiEntries">—</b></span>
      <span class="badge">claimable: <b id="kpiClaimable">—</b></span>
    </div>
  </section>

  <section id="viewSend" class="card hidden">
    <h3>Отправка</h3>
    <div class="grid cols-2">
      <div><label>RID получателя</label><input id="sendTo" class="mono" placeholder="RID"/></div>
      <div><label>Сумма</label><input id="sendAmount" type="number" min="1" step="1" placeholder="amount (u64)"/></div>
    </div>
    <div class="row mt10"><button id="btnSendTx">Отправить</button></div>
  </section>

  <section id="viewStake" class="card hidden">
    <h3>Стейкинг</h3>
    <div class="grid cols-3">
      <div><label>RID валидатора (SELF = свой RID)</label><input id="stakeValidator" class="mono" readonly/></div>
      <div><label>Сумма</label><input id="stakeAmount" type="number" min="1" step="1" placeholder="amount (u64)"/></div>
      <div class="row" style="align-items:end">
        <button id="btnStakeDel">Delegate</button>
        <button id="btnStakeUn" class="secondary">Undelegate</button>
        <button id="btnStakeClaim" class="secondary">Claim</button>
      </div>
    </div>
  </section>

  <section id="viewHistory" class="card hidden">
    <h3>История</h3>
    <div class="scroll">
      <table class="table">
        <thead><tr><th>type</th><th>counterparty</th><th>amount</th><th>nonce</th><th>height</th><th>tx</th></tr></thead>
        <tbody id="histBody"></tbody>
      </table>
    </div>
  </section>
</div>

<!-- Secure Unlock overlay -->
<div id="lockOverlay">
  <div id="lockCard">
    <div id="brand">
      <div><b>LOGOS Wallet — Secure Unlock</b></div>
      <div class="badge mono" id="rpHost">—</div>
    </div>
    <div id="phish">Проверь домен и значок 🔒 TLS. Никому не сообщай пароль.</div>

    <!-- Лэндинг -->
    <div id="viewLanding">
      <p class="muted">Выберите действие:</p>
      <div class="row">
        <button id="goCreate">Создать новый</button>
        <button id="goImport" class="secondary">Импортировать</button>
        <button id="goUnlock" class="ghost">Разблокировать</button>
      </div>
    </div>

    <!-- Создать: пароль -->
    <div id="viewCreatePwd" class="hidden mt10">
      <h3>Создать пароль</h3>
      <div class="grid cols-2">
        <div><label>Пароль</label><input id="newPwd1" type="password" autocomplete="new-password" placeholder="(≥8)"/></div>
        <div><label>Повтор</label><input id="newPwd2" type="password" autocomplete="new-password" placeholder="повтор"/></div>
      </div>
      <div class="row mt10"><button id="createNext">Далее</button><button id="back1" class="ghost">Назад</button></div>
    </div>

    <!-- Создать: бэкап -->
    <div id="viewBackup" class="hidden mt10">
      <h3>Резервный ключ</h3>
      <p class="muted">Сохраните PKCS8 Base64 (как seed). Без него восстановление невозможно.</p>
      <textarea id="backupArea" class="mono" readonly></textarea>
      <label class="row mt10" style="gap:8px;align-items:center"><input type="checkbox" id="chkSaved"/> Я записал ключ</label>
      <div class="row mt10"><button id="finishCreate" disabled>Завершить и разблокировать</button><button id="back2" class="ghost">Назад</button></div>
    </div>

    <!-- Импорт -->
    <div id="viewImport" class="hidden mt10">
      <h3>Импорт</h3>
      <label>PKCS8 Base64</label><textarea id="impKey" class="mono" placeholder="----- base64 -----"></textarea>
      <div class="grid cols-2 mt10">
        <div><label>Пароль</label><input id="impPwd1" type="password" autocomplete="new-password" placeholder="(≥8)"/></div>
        <div><label>Повтор</label><input id="impPwd2" type="password" autocomplete="new-password" placeholder="повтор"/></div>
      </div>
      <div class="row mt10"><button id="doImport">Импортировать и разблокировать</button><button id="back3" class="ghost">Назад</button></div>
    </div>

    <!-- Разблокировать -->
    <div id="viewUnlock" class="hidden mt10">
      <h3>Разблокировать</h3>
      <label>Пароль</label><input id="unPwd" type="password" autocomplete="current-password" placeholder="Пароль"/>
      <div class="row mt10"><button id="btnUnlock">Разблокировать</button><button id="btnReset" class="secondary">Сбросить</button></div>
    </div>
  </div>
</div>

<div id="toast" class="toast"></div>

<!-- Модули -->
<script type="module" src="./js/core.js?v=1757930528"></script>
<script type="module" src="./js/vault.js?v=1757930528"></script>
<script type="module" src="./js/unlock.js?v=1757930528"></script>
<script type="module" src="./js/app.js?v=1757930528"></script>
</body>
</html>

```

### FILE: /var/www/logos/wallet/js/api.js
```js
export const API = "/api";

export async function apiGet(p){
  const r = await fetch(API+p);
  if(!r.ok) throw new Error(`GET ${p} -> ${r.status}`);
  return r.json();
}
export async function apiPost(p,b){
  const r = await fetch(API+p,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(b)});
  if(!r.ok){ const t=await r.text().catch(()=> ""); throw new Error(`POST ${p} -> ${r.status} ${t}`); }
  return r.json();
}

```

### FILE: /var/www/logos/wallet/js/app.js
```js
import { $, toast, canon, short, fmt } from "./core.js";
import { apiGet, apiPost } from "./core.js";   // API в core.js
import { currentRID, ensureSessionKey, signEd25519 } from "./vault.js";

async function loadPassport(){
  const rid = currentRID(); if(!rid){ toast("RID отсутствует"); return; }
  const [p,s,h] = await Promise.allSettled([
    apiGet(`/profile/${rid}`),
    apiGet(`/stake/summary/${rid}`),
    apiGet(`/history/${rid}?limit=50`)
  ]);
  const prof=p.status==="fulfilled"?p.value:{}, sum=s.status==="fulfilled"?s.value:{}, items=h.status==="fulfilled"?(h.value.items||[]):[];
  $('#kpiRid').textContent = rid;
  $('#kpiBal').textContent = fmt(prof.balance??0);
  $('#kpiNonce').textContent = (prof.nonce&&prof.nonce.next)??"-";
  $('#kpiHead').textContent = prof.head??"-";
  $('#kpiDelegated').textContent = fmt(sum.delegated??0);
  $('#kpiEntries').textContent  = fmt(sum.entries??0);
  $('#kpiClaimable').textContent= fmt(sum.claimable??0);

  $('#stakeValidator').value = rid;
  const tb=$('#histBody'); tb.innerHTML="";
  for(const it of items){
    const e=it.evt||{}; const cp=e.dir==="out"?e.to:(e.dir==="in"?e.from:(e.rid||"-"));
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${e.type||"transfer"}</td><td class="mono">${short(cp,24)}</td><td>${fmt(e.amount??0)}</td><td>${e.nonce??"-"}</td><td>${e.height??"-"}</td><td class="mono">${short(e.tx,28)}</td>`;
    tb.appendChild(tr);
  }
}

async function sendTx(){
  const rid=currentRID(); const to=($('#sendTo').value||"").trim(); const amount=Number($('#sendAmount').value||"0");
  if(!rid){ toast("Разблокируйте кошелёк"); return; }
  if(!to||!amount){ toast("RID/сумма?"); return;}
  const nn=await apiGet(`/nonce/${rid}`); const nonce=nn.next;
  await ensureSessionKey();
  const sig=await signEd25519(canon(rid,to,amount,nonce));
  const b=$('#btnSendTx'); const orig=b.textContent; b.disabled=true; b.textContent="Отправляем…";
  try{ const r=await apiPost(`/submit_tx`,{from:rid,to,amount,nonce,sig}); toast(r?.status==="queued"?"Tx отправлена":"Отправлено"); await loadPassport(); }
  catch(e){ toast("Ошибка: "+e.message); }
  finally{ b.disabled=false; b.textContent=orig; }
}
async function stakeDel(){ const rid=currentRID(); const a=Number($('#stakeAmount').value||"0"); if(!rid||!a){toast("RID/сумма?");return;} const r=await apiPost(`/stake/delegate`,{validator:rid,amount:a}); toast(r.ok?"Delegated":"Delegate failed"); await loadPassport(); }
async function stakeUn(){  const rid=currentRID(); const a=Number($('#stakeAmount').value||"0"); if(!rid||!a){toast("RID/сумма?");return;} const r=await apiPost(`/stake/undelegate`,{validator:rid,amount:a}); toast(r.ok?"Undelegated":"Undelegate failed"); await loadPassport(); }
async function stakeClaim(){const rid=currentRID(); if(!rid){toast("RID?");return;} const r=await apiPost(`/stake/claim`,{rid}); toast(r.ok?`Claimed ${r.claimed}`:"Claim failed"); await loadPassport(); }

document.addEventListener('DOMContentLoaded', ()=>{
  // если App уже показан (после unlock) — инициализируем
  if(!document.getElementById('viewApp').classList.contains('hidden')){
    loadPassport().catch(e=>toast(String(e)));
  }
  // действия
  $('#btnSendTx').onclick = ()=>sendTx().catch(e=>toast(String(e)));
  $('#btnStakeDel').onclick= ()=>stakeDel().catch(e=>toast(String(e)));
  $('#btnStakeUn').onclick = ()=>stakeUn().catch(e=>toast(String(e)));
  $('#btnStakeClaim').onclick=()=>stakeClaim().catch(e=>toast(String(e)));
});

```

### FILE: /var/www/logos/wallet/js/app_wallet.js
```js
import { $, toast, canon, short, fmtInt, be8, enc } from "./core.js";
import { apiGet, apiPost } from "./api.js";
import { currentRID, signEd25519, ensureSessionKey } from "./vault_bridge.js";

function ui(){
  return {
    passport: $("#viewApp"),
    ridOut:   $("#ridOut"),
    // поля отправки
    to: $("#sendTo"),
    amount: $("#sendAmount"),
    btnSend: $("#btnSendTx"),
    // профиль/паспорт KPI
    kpiBal: $("#kpiBal"), kpiNonce: $("#kpiNonce"), kpiHead: $("#kpiHead"),
    kpiDel: $("#kpiDelegated"), kpiEnt: $("#kpiEntries"), kpiClaim: $("#kpiClaimable"),
    // история
    histBody: $("#histBody"),
    // стейкинг
    val: $("#stakeValidator"), stakeAmt: $("#stakeAmount"),
    btnDel: $("#btnStakeDel"), btnUn: $("#btnStakeUn"), btnClaim: $("#btnStakeClaim"),
  };
}

async function loadPassport(){
  const rid = currentRID();
  const u = ui();
  u.ridOut.textContent = rid || "—";
  if(!rid){ toast("RID не найден. Разблокируйте кошелёк."); return; }

  const [p,s,h] = await Promise.allSettled([
    apiGet(`/profile/${rid}`),
    apiGet(`/stake/summary/${rid}`),
    apiGet(`/history/${rid}?limit=25`)
  ]);

  const prof = p.status==="fulfilled" ? p.value : {};
  const sum  = s.status==="fulfilled" ? s.value : {};
  const hist = h.status==="fulfilled" ? (h.value.items||[]) : [];

  u.kpiBal.textContent   = fmtInt(prof.balance ?? 0);
  u.kpiNonce.textContent = (prof.nonce && prof.nonce.next) ?? "-";
  u.kpiHead.textContent  = prof.head ?? "-";
  u.kpiDel.textContent   = fmtInt(sum.delegated ?? 0);
  u.kpiEnt.textContent   = fmtInt(sum.entries ?? 0);
  u.kpiClaim.textContent = fmtInt(sum.claimable ?? 0);

  // история
  u.histBody.innerHTML = "";
  for(const it of hist){
    const e = it.evt || {};
    const cp = e.dir==="out" ? e.to : (e.dir==="in" ? e.from : (e.rid||"-"));
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${e.type||"transfer"}</td>
      <td class="mono">${short(cp,24)}</td>
      <td>${fmtInt(e.amount ?? 0)}</td>
      <td>${e.nonce ?? "-"}</td>
      <td>${e.height ?? "-"}</td>
      <td class="mono">${short(e.tx,28)}</td>`;
    u.histBody.appendChild(tr);
  }
}

async function sendTx(){
  const rid = currentRID();
  const u = ui();
  const to = (u.to.value||"").trim();
  const amount = Number(u.amount.value||"0");
  if(!rid){ toast("Разблокируйте кошелёк"); return; }
  if(!to || !amount){ toast("Укажите получателя и сумму"); return; }

  // ensure key in memory (может запросить пароль один раз)
  await ensureSessionKey();

  const nn = await apiGet(`/nonce/${rid}`);
  const nonce = nn.next;
  const msg = canon(rid, to, amount, nonce);
  const sigB64 = await signEd25519(msg);

  u.btnSend.disabled = true;
  u.btnSend.textContent = "Отправляем…";
  try{
    const res = await apiPost(`/submit_tx`, {from: rid, to, amount, nonce, sig: sigB64});
    toast(res?.status==="queued" ? "Tx отправлена" : "Отправлено");
    await loadPassport();
  }catch(e){ toast("Ошибка: "+e.message); }
  finally{ u.btnSend.disabled=false; u.btnSend.textContent = "Отправить"; }
}

async function stakeDelegate(){
  const u = ui(); const rid = currentRID(); const a = Number(u.stakeAmt.value||"0");
  if(!rid || !a){ toast("RID/сумма?"); return; }
  try{
    const r = await apiPost(`/stake/delegate`, {validator: rid, amount: a});
    toast(r.ok ? "Delegated" : "Delegate failed");
    await loadPassport();
  }catch(e){ toast("Ошибка: "+e.message); }
}
async function stakeUndelegate(){
  const u = ui(); const rid = currentRID(); const a = Number(u.stakeAmt.value||"0");
  if(!rid || !a){ toast("RID/сумма?"); return; }
  try{
    const r = await apiPost(`/stake/undelegate`, {validator: rid, amount: a});
    toast(r.ok ? "Undelegated" : "Undelegate failed");
    await loadPassport();
  }catch(e){ toast("Ошибка: "+e.message); }
}
async function stakeClaim(){
  const rid = currentRID();
  if(!rid){ toast("RID?"); return; }
  try{
    const r = await apiPost(`/stake/claim`, {rid});
    toast(r.ok ? `Claimed ${r.claimed}` : "Claim failed");
    await loadPassport();
  }catch(e){ toast("Ошибка: "+e.message); }
}

export function initAppWallet(){
  $("#kpiRid").textContent = currentRID() || "—";
  $("#btnSendTx").addEventListener("click", ()=>sendTx().catch(e=>toast(String(e))));
  $("#btnStakeDel").addEventListener("click", ()=>stakeDelegate().catch(e=>toast(String(e))));
  $("#btnStakeUn").addEventListener("click", ()=>stakeUndelegate().catch(e=>toast(String(e))));
  $("#btnStakeClaim").addEventListener("click", ()=>stakeClaim().catch(e=>toast(String(e))));
  loadPassport().catch(e=>toast(String(e)));
}

```

### FILE: /var/www/logos/wallet/js/core.js
```js
export const enc = new TextEncoder();
export const API = "/api";
export const $ = (sel)=>document.querySelector(sel);

export function toast(m){ const t=document.getElementById('toast'); if(!t) return; t.textContent=m; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),2000); }

export function be8(n){ const a=new Uint8Array(8); new DataView(a.buffer).setBigUint64(0, BigInt(n)); return a; }
export function cat(...xs){ let L=0; for(const a of xs)L+=a.length; const out=new Uint8Array(L); let o=0; for(const a of xs){ out.set(a,o); o+=a.length; } return out; }
export function canon(from,to,amount,nonce){ return cat(new TextEncoder().encode(from),Uint8Array.of(0x7c),new TextEncoder().encode(to),Uint8Array.of(0x7c),be8(amount),Uint8Array.of(0x7c),be8(nonce)); }
export function fmt(x){ return (x??0).toLocaleString('ru-RU'); }
export function short(s,n=28){ if(!s) return "-"; return s.length>n ? s.slice(0,n-3)+"…" : s; }
const B58="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
export function b58(bytes){ let x=0n; for(const v of bytes) x=(x<<8n)+BigInt(v); let s=""; while(x>0n){const r=Number(x%58n);x/=58n;s=B58[r]+s;} for(const v of bytes){ if(v===0)s="1"+s; else break;} return s||"1"; }

export async function apiGet(p){ const r=await fetch(API+p); if(!r.ok) throw new Error(`GET ${p} -> ${r.status}`); return r.json(); }
export async function apiPost(p,b){ const r=await fetch(API+p,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(b)}); if(!r.ok){const t=await r.text().catch(()=> ""); throw new Error(`POST ${p} -> ${r.status} ${t}`);} return r.json(); }

```

### FILE: /var/www/logos/wallet/js/unlock.js
```js
import { $, toast } from "./core.js";
import { hasVault, createPairAndBackup, finalizeCreate, importVault, unlockWith, currentRID } from "./vault.js";

function show(id){ ['#viewLanding','#viewCreatePwd','#viewBackup','#viewImport','#viewUnlock'].forEach(v=>$(v).classList.add('hidden')); $(id).classList.remove('hidden'); }
function showApp(){ document.getElementById('lockOverlay').style.display='none'; ['#viewApp','#viewSend','#viewStake','#viewHistory'].forEach(id=>$(id).classList.remove('hidden')); }

document.addEventListener('DOMContentLoaded', ()=>{
  $('#rpHost').textContent = location.host + ' JS✓';
  if(hasVault()) show('#viewUnlock'); else show('#viewLanding');

  // роутинг
  $('#goCreate').onclick = ()=> show('#viewCreatePwd');
  $('#goImport').onclick = ()=> show('#viewImport');
  $('#goUnlock').onclick = ()=> show('#viewUnlock');
  $('#back1').onclick = ()=> show('#viewLanding');
  $('#back2').onclick = ()=> show('#viewCreatePwd');
  $('#back3').onclick = ()=> show('#viewLanding');

  // создание шаг1
  $('#createNext').onclick = async ()=>{
    const p1=$('#newPwd1').value.trim(), p2=$('#newPwd2').value.trim();
    if(p1.length<8){ toast('Пароль минимум 8 символов'); return;}
    if(p1!==p2){ toast('Пароли не совпадают'); return;}
    try{
      const b64 = await createPairAndBackup(p1);
      $('#backupArea').value = b64; $('#chkSaved').checked=false; $('#finishCreate').disabled=true;
      show('#viewBackup');
    }catch(e){ toast('Крипто-ошибка. Обнови браузер.'); }
  };
  $('#chkSaved').onchange = ()=> $('#finishCreate').disabled = !$('#chkSaved').checked;
  $('#finishCreate').onclick = async ()=>{
    try{ await finalizeCreate(); toast('Кошелёк создан'); show('#viewUnlock'); }
    catch(e){ toast('Не удалось сохранить'); }
  };

  // импорт
  $('#doImport').onclick = async ()=>{
    const b64=$('#impKey').value.trim(), p1=$('#impPwd1').value.trim(), p2=$('#impPwd2').value.trim();
    if(!b64){ toast('Вставьте ключ'); return;}
    if(p1.length<8){ toast('Пароль минимум 8 символов'); return;}
    if(p1!==p2){ toast('Пароли не совпадают'); return;}
    try{ await importVault(b64,p1); toast('Импорт выполнен'); show('#viewUnlock'); }
    catch(e){ toast('Импорт не удался'); }
  };

  // разблокировать
  $('#btnUnlock').onclick = async ()=>{
    const pass=$('#unPwd').value.trim();
    if(pass.length<8){ toast('Пароль минимум 8 символов'); return; }
    const b=$('#btnUnlock'); const orig=b.textContent; b.disabled=true; b.textContent='Разблокируем…';
    try{
      await Promise.race([ unlockWith(pass), new Promise((_,rej)=>setTimeout(()=>rej(new Error('TIMEOUT')),12000)) ]);
      $('#kpiRid').textContent = currentRID() || "—";
      showApp(); toast('Готово');
    }catch(e){
      const code=String(e&&e.message||e);
      if(code==='NO_KEY') toast('Кошелёк не найден');
      else if(code==='BAD_PASS') toast('Неверный пароль');
      else if(code==='TIMEOUT') toast('Долго думает… повторите');
      else toast('Ошибка разблокировки');
    }finally{ b.disabled=false; b.textContent=orig; }
  };

  $('#btnReset').onclick = ()=>{ if(confirm('Очистить локальный ключ?')){ try{localStorage.removeItem('logos_secure_v3_vault');}catch{} toast('Сброшено'); show('#viewLanding'); } };
});

```

### FILE: /var/www/logos/wallet/js/vault.js
```js
import { enc, b58, toast } from "./core.js";

const LS="logos_secure_v3_vault";
const ITER=250000;

function getVault(){ const raw=localStorage.getItem(LS); if(!raw) return null; try{ return JSON.parse(raw);}catch{ return null; } }
function saveVault(salt,iv,ct,pub){ localStorage.setItem(LS, JSON.stringify({
  salt:btoa(String.fromCharCode(...salt)), iv:btoa(String.fromCharCode(...iv)), ct:btoa(String.fromCharCode(...ct)), pub:btoa(String.fromCharCode(...pub)), iter:ITER
})); }
async function kdf(pass,salt){ const base=await crypto.subtle.importKey("raw",enc.encode(pass),{name:"PBKDF2"},false,["deriveKey"]); return crypto.subtle.deriveKey({name:"PBKDF2",salt,iterations:ITER,hash:"SHA-256"},base,{name:"AES-GCM",length:256},false,["encrypt","decrypt"]); }

export const hasVault = ()=> !!getVault();
export const currentRID = ()=>{ const v=getVault(); if(!v) return ""; const pub=Uint8Array.from(atob(v.pub),c=>c.charCodeAt(0)); return b58(pub); };

let __priv=null, __pub=null, __timer=null;
function sessionSet(priv,pub){ __priv=priv; __pub=pub; clearTimeout(__timer); __timer=setTimeout(()=>{__priv=null;__pub=null;}, 5*60*1000); }
export const hasSession = ()=> !!__priv;

export async function createPairAndBackup(pw){
  const kp=await crypto.subtle.generateKey({name:"Ed25519"},true,["sign","verify"]);
  const pkcs8=new Uint8Array(await crypto.subtle.exportKey("pkcs8",kp.privateKey));
  const pub=new Uint8Array(await crypto.subtle.exportKey("raw",kp.publicKey));
  sessionStorage.setItem('TMP_PK', btoa(String.fromCharCode(...pkcs8)));
  sessionStorage.setItem('TMP_PW', pw);
  sessionStorage.setItem('TMP_PUB', btoa(String.fromCharCode(...pub)));
  return btoa(String.fromCharCode(...pkcs8));
}
export async function finalizeCreate(){
  const b64=sessionStorage.getItem('TMP_PK'), p1=sessionStorage.getItem('TMP_PW'), pubB=sessionStorage.getItem('TMP_PUB');
  if(!b64||!p1||!pubB) throw new Error("CREATE_SESSION_LOST");
  const pk = Uint8Array.from(atob(b64),c=>c.charCodeAt(0));
  const pub= Uint8Array.from(atob(pubB),c=>c.charCodeAt(0));
  const s=new Uint8Array(16); crypto.getRandomValues(s);
  const iv=new Uint8Array(12); crypto.getRandomValues(iv);
  const key=await kdf(p1,s); const ct=new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM",iv},key,pk));
  saveVault(s,iv,ct,pub); sessionStorage.clear();
}
export async function importVault(b64,p1){
  const pk = Uint8Array.from(atob(b64),c=>c.charCodeAt(0));
  const tmp=await crypto.subtle.generateKey({name:"Ed25519"},true,["sign","verify"]);
  const pub=new Uint8Array(await crypto.subtle.exportKey("raw",tmp.publicKey));
  const s=new Uint8Array(16); crypto.getRandomValues(s);
  const iv=new Uint8Array(12); crypto.getRandomValues(iv);
  const key=await kdf(p1,s); const ct=new Uint8Array(await crypto.subtle.encrypt({name:"AES-GCM",iv},key,pk));
  saveVault(s,iv,ct,pub);
}
export async function unlockWith(pass){
  const v=getVault(); if(!v) throw new Error("NO_KEY");
  const s=Uint8Array.from(atob(v.salt),c=>c.charCodeAt(0));
  const iv=Uint8Array.from(atob(v.iv),c=>c.charCodeAt(0));
  const ct=Uint8Array.from(atob(v.ct),c=>c.charCodeAt(0));
  const key=await kdf(pass,s);
  const pk8=await crypto.subtle.decrypt({name:"AES-GCM",iv},key,ct).catch(()=>{throw new Error("BAD_PASS")});
  const priv=await crypto.subtle.importKey("pkcs8",pk8,{name:"Ed25519"},false,["sign"]);
  const pub =Uint8Array.from(atob(v.pub),c=>c.charCodeAt(0));
  sessionSet(priv,pub);
}
export async function ensureSessionKey(){
  if(__priv) return {priv:__priv, pub:__pub};
  const v=getVault(); if(!v){ toast("Кошелёк не найден"); throw new Error("NO_KEY"); }
  const pass = prompt("Пароль для подписи"); if(!pass||pass.length<8){ throw new Error("PASS_SHORT"); }
  await unlockWith(pass); return {priv:__priv, pub:__pub};
}
export async function signEd25519(bytes){
  const {priv}=await ensureSessionKey();
  const sig=new Uint8Array(await crypto.subtle.sign({name:"Ed25519"},priv,bytes));
  let bin=""; for(let i=0;i<sig.length;i++) bin+=String.fromCharCode(sig[i]); return btoa(bin);
}

```

### FILE: /var/www/logos/wallet/js/vault_bridge.js
```js
import { enc, b58, toast } from "./core.js";

// Шифрованный сейф (как на экране unlock)
const LS = "logos_secure_v3_vault";
const ITER = 250000;

function getVault(){
  const raw = localStorage.getItem(LS);
  if(!raw) return null;
  try{ return JSON.parse(raw); }catch{ return null; }
}

async function kdf(pass, salt){
  const base = await crypto.subtle.importKey("raw", enc.encode(pass), {name:"PBKDF2"}, false, ["deriveKey"]);
  return crypto.subtle.deriveKey({name:"PBKDF2", salt, iterations:ITER, hash:"SHA-256"}, base, {name:"AES-GCM", length:256}, false, ["encrypt","decrypt"]);
}

// Сессионный приватник (в памяти страницы), авто-очистка через 5 минут
let __priv = null, __pubRaw = null, __timer = null;
function sessionSet(priv, pub){
  __priv = priv; __pubRaw = pub;
  clearTimeout(__timer); __timer = setTimeout(()=>{ __priv=null; __pubRaw=null; }, 5*60*1000);
}

export function hasSession(){ return !!__priv; }
export function currentRID(){ const v=getVault(); if(!v) return ""; const pub = Uint8Array.from(atob(v.pub),c=>c.charCodeAt(0)); return b58(pub); }

// Гарантирует, что в памяти есть приватник. Если нет — запросит пароль и расшифрует.
export async function ensureSessionKey(){
  if(__priv) return {priv:__priv, pubRaw: __pubRaw};
  const v = getVault();
  if(!v){ toast("Кошелёк не найден. Создайте/импортируйте."); throw new Error("NO_KEY"); }
  const pass = prompt("Введите пароль кошелька для подписи");
  if(!pass || pass.length<8){ toast("Пароль минимум 8 символов"); throw new Error("PASS_SHORT"); }

  const salt = Uint8Array.from(atob(v.salt), c=>c.charCodeAt(0));
  const iv   = Uint8Array.from(atob(v.iv),   c=>c.charCodeAt(0));
  const ct   = Uint8Array.from(atob(v.ct),   c=>c.charCodeAt(0));
  const pub  = Uint8Array.from(atob(v.pub),  c=>c.charCodeAt(0));

  const key  = await kdf(pass, salt);
  let pkcs8;
  try{ pkcs8 = await crypto.subtle.decrypt({name:"AES-GCM", iv}, key, ct); }
  catch{ toast("Неверный пароль"); throw new Error("BAD_PASS"); }

  const priv = await crypto.subtle.importKey("pkcs8", pkcs8, {name:"Ed25519"}, false, ["sign"]);
  sessionSet(priv, pub);
  return {priv, pubRaw: pub};
}

export async function signEd25519(bytes){
  const { priv } = await ensureSessionKey();
  const sig = new Uint8Array(await crypto.subtle.sign({name:"Ed25519"}, priv, bytes));
  let bin=""; for(let i=0;i<sig.length;i++) bin += String.fromCharCode(sig[i]);
  return btoa(bin);
}

```

### FILE: /var/www/logos/wallet/login.html
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>LOGOS Wallet — Вход</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#0b0c10;color:#e6edf3}
    header{padding:16px 20px;background:#11151a;border-bottom:1px solid #1e242c}
    h1{font-size:18px;margin:0}
    main{max-width:720px;margin:48px auto;padding:0 16px}
    section{background:#11151a;margin:16px 0;border-radius:12px;padding:16px;border:1px solid #1e242c}
    label{display:block;margin:8px 0 6px}
    input,button{width:100%;padding:12px;border-radius:10px;border:1px solid #2a313a;background:#0b0f14;color:#e6edf3}
    button{cursor:pointer;border:1px solid #3b7ddd;background:#1665c1}
    button.secondary{background:#1b2129}
    small{opacity:.8}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:720px){.grid{grid-template-columns:1fr}}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
    ul{list-style:none;padding:0;margin:8px 0}
    li{padding:8px;border:1px solid #2a313a;border-radius:8px;margin-bottom:6px;cursor:pointer;background:#0b0f14}
  </style>
</head>
<body>
<header><h1>LOGOS Wallet — Secure (WebCrypto + IndexedDB)</h1></header>
<main>
  <section>
    <h3>Вход в аккаунт</h3>
    <label>Логин (RID)</label>
    <input id="loginRid" class="mono" placeholder="Вставь RID (base58) или выбери из списка ниже"/>
    <label>Пароль</label>
    <input id="pass" type="password" placeholder="Пароль для шифрования ключа"/>

    <div class="grid" style="margin-top:12px">
      <button id="btn-login">Войти по RID + пароль</button>
      <button id="btn-create">Создать новый RID</button>
    </div>

    <div style="margin-top:12px">
      <button id="btn-list" class="secondary">Показать сохранённые RID</button>
      <button id="btn-reset" class="secondary">Сбросить все аккаунты (DEV)</button>
    </div>

    <div id="listWrap" style="display:none;margin-top:10px">
      <small>Сохранённые на этом устройстве RID (тапни, чтобы подставить):</small>
      <ul id="ridList"></ul>
    </div>

    <p><small>Ключ Ed25519 хранится зашифрованным AES-GCM (PBKDF2) в IndexedDB. Ничего не уходит в сеть.</small></p>
    <pre id="out" class="mono"></pre>
  </section>
</main>
<script src="./auth.js?v=20250906_03" defer></script>
</body>
</html>

```

### FILE: /var/www/logos/wallet/ping.html
```html
<!doctype html><meta charset="utf-8">
<title>Wallet JS Ping</title>
<button onclick="alert('JS OK')">JS TEST</button>

```

### FILE: /var/www/logos/wallet/staking.js
```js
// LOGOS Wallet — staking (prod)
async function stakeSign(op, validator, amount, nonce){
  const msg = `${session.rid}|${op}|${validator}|${amount||0}|${nonce}`;
  return await crypto.subtle.sign('Ed25519', session.privKey, new TextEncoder().encode(msg)).then(buf=>{
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
  });
}
document.getElementById('btnDelegate').onclick = async ()=>{
  try{
    const b=await (await fetch(`${location.origin + '/api'}/balance/${encodeURIComponent(session.rid)}`)).json();
    const validator=document.getElementById('valRid').value.trim();
    const amount=Number(document.getElementById('stakeAmt').value);
    const nonce=(b.nonce??0)+1;
    const sig_hex=await stakeSign('delegate',validator,amount,nonce);
    const r=await fetch(`${location.origin + '/api'}/stake/submit`,{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,op:'delegate',validator,amount,nonce,sig_hex})});
    const j=await r.json(); document.getElementById('stakeStatus').textContent = j.ok?'Delegate OK':'ERR '+j.info;
  }catch(e){ document.getElementById('stakeStatus').textContent='Ошибка delegate'; }
};
document.getElementById('btnUndelegate').onclick = async ()=>{
  try{
    const b=await (await fetch(`${location.origin + '/api'}/balance/${encodeURIComponent(session.rid)}`)).json();
    const validator=document.getElementById('valRid').value.trim();
    const amount=Number(document.getElementById('stakeAmt').value);
    const nonce=(b.nonce??0)+1;
    const sig_hex=await stakeSign('undelegate',validator,amount,nonce);
    const r=await fetch(`${location.origin + '/api'}/stake/submit`,{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,op:'undelegate',validator,amount,nonce,sig_hex})});
    const j=await r.json(); document.getElementById('stakeStatus').textContent = j.ok?'Undelegate OK':'ERR '+j.info;
  }catch(e){ document.getElementById('stakeStatus').textContent='Ошибка undelegate'; }
};
document.getElementById('btnClaim').onclick = async ()=>{
  try{
    const b=await (await fetch(`${location.origin + '/api'}/balance/${encodeURIComponent(session.rid)}`)).json();
    const validator=document.getElementById('valRid').value.trim();
    const nonce=(b.nonce??0)+1;
    const sig_hex=await stakeSign('claim',validator,0,nonce);
    const r=await fetch(`${location.origin + '/api'}/stake/submit`,{method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,op:'claim',validator,amount:0,nonce,sig_hex})});
    const j=await r.json(); document.getElementById('stakeStatus').textContent = j.ok?'Claim OK':'ERR '+j.info;
  }catch(e){ document.getElementById('stakeStatus').textContent='Ошибка claim'; }
};

```

### FILE: /var/www/logos/wallet/wallet.css
```css
:root {
  --bg: #0e1116;
  --fg: #e6edf3;
  --muted: #9aa4ae;
  --card: #161b22;
  --border: #2d333b;
  --accent: #2f81f7;
  --accent-2: #7ee787;
  --warn: #f0883e;
  --error: #ff6b6b;
  --mono: ui-monospace, SFMono-Regular, Menlo, monospace;
  --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, sans-serif;
}
html[data-theme="light"] {
  --bg: #f6f8fa;
  --fg: #0b1117;
  --muted: #57606a;
  --card: #ffffff;
  --border: #d0d7de;
  --accent: #0969da;
  --accent-2: #1a7f37;
  --warn: #9a6700;
}
* { box-sizing: border-box; }
body { margin: 0; background: var(--bg); color: var(--fg); font-family: var(--sans); }
a { color: var(--accent); text-decoration: none; }
.topbar {
  position: sticky; top: 0; z-index: 10;
  display: flex; align-items: center; gap: 8px;
  padding: 10px 14px; border-bottom: 1px solid var(--border); background: var(--card);
}
.brand { font-weight: 700; }
.spacer { flex: 1; }
.endpoint { font-size: 12px; color: var(--muted); }
.container { max-width: 980px; margin: 16px auto; padding: 0 12px; display: grid; gap: 16px; }
.card {
  border: 1px solid var(--border); border-radius: 10px;
  background: var(--card); padding: 14px;
}
h2 { margin: 0 0 10px 0; font-size: 18px; }
.row { display: flex; gap: 8px; align-items: center; }
.wrap { flex-wrap: wrap; }
.grid2 { display: grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap: 8px; }
.mt8 { margin-top: 8px; }
.input {
  border: 1px solid var(--border); background: transparent; color: var(--fg);
  padding: 8px 10px; border-radius: 8px; outline: none;
}
.input:focus { border-color: var(--accent); }
.grow { flex: 1; min-width: 260px; }
.w100 { width: 100px; }
.w120 { width: 120px; }
.btn {
  border: 1px solid var(--border); background: var(--accent); color: #fff;
  padding: 8px 12px; border-radius: 8px; cursor: pointer;
}
.btn.secondary { background: transparent; color: var(--fg); }
.btn.warn { background: var(--warn); color: #111; }
.btn:disabled { opacity: .6; cursor: not-allowed; }
.mono { font-family: var(--mono); }
.log {
  font-family: var(--mono); background: transparent; border: 1px dashed var(--border);
  border-radius: 8px; padding: 8px; min-height: 40px; white-space: pre-wrap;
}
.statusbar {
  position: sticky; bottom: 0; margin-top: 12px; padding: 8px 14px;
  border-top: 1px solid var(--border); background: var(--card); color: var(--muted);
}

/* auto-theming для системной темы, если юзер не переключал вручную */
@media (prefers-color-scheme: light) {
  html[data-theme="auto"] { --bg: #f6f8fa; --fg: #0b1117; --muted:#57606a; --card:#fff; --border:#d0d7de; --accent:#0969da; --accent-2:#1a7f37; --warn:#9a6700; }
}

```

### FILE: /var/www/logos/wallet/wallet.js
```js
// LOGOS Wallet core — PROD
// Подключение к API через /api (nginx proxy)
const BASE = location.origin + '/api';

// ===== IndexedDB =====
const DB_NAME='logos_wallet', DB_STORE='keys';
function idbOpen(){return new Promise((res,rej)=>{const r=indexedDB.open(DB_NAME,1);r.onupgradeneeded=e=>{const db=e.target.result;if(!db.objectStoreNames.contains(DB_STORE))db.createObjectStore(DB_STORE,{keyPath:'rid'})};r.onsuccess=()=>res(r.result);r.onerror=()=>rej(r.error);});}
async function idbPut(rec){const db=await idbOpen();await new Promise((res,rej)=>{const tx=db.transaction(DB_STORE,'readwrite');tx.objectStore(DB_STORE).put(rec);tx.oncomplete=res;tx.onerror=()=>rej(tx.error)});db.close();}
async function idbGet(rid){const db=await idbOpen();return await new Promise((res,rej)=>{const tx=db.transaction(DB_STORE,'readonly');const rq=tx.objectStore(DB_STORE).get(rid);rq.onsuccess=()=>res(rq.result||null);rq.onerror=()=>rej(rq.error);tx.oncomplete=()=>db.close()});}

// ===== UI refs =====
const ui={
  loginRid:document.getElementById('loginRid'), loginPass:document.getElementById('loginPass'),
  btnLogin:document.getElementById('btnLogin'), loginStatus:document.getElementById('loginStatus'),
  newPass:document.getElementById('newPass'), btnCreate:document.getElementById('btnCreate'), createStatus:document.getElementById('createStatus'),
  panel:document.getElementById('walletPanel'),
  ridView:document.getElementById('ridView'), balView:document.getElementById('balView'), nonceView:document.getElementById('nonceView'),
  toRid:document.getElementById('toRid'), amount:document.getElementById('amount'), btnSend:document.getElementById('btnSend'), sendStatus:document.getElementById('sendStatus'),
  ridStake:document.getElementById('ridStake'),
  histBody:document.getElementById('histBody'), btnMoreHist:document.getElementById('btnMoreHist'),
  tabs:[...document.querySelectorAll('.tab')],
  btnExport:document.getElementById('btnExport'), btnImport:document.getElementById('btnImport'), impFile:document.getElementById('impFile'),
  settingsInfo:document.getElementById('settingsInfo'), exportStatus:document.getElementById('exportStatus')
};

// ===== WebCrypto helpers =====
function hex(buf){return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');}
async function sha256(s){const h=await crypto.subtle.digest('SHA-256', new TextEncoder().encode(s)); return hex(h);}
async function pbkdf2(pass,salt,iters=300000){const key=await crypto.subtle.importKey('raw', new TextEncoder().encode(pass), 'PBKDF2', false, ['deriveKey']);return crypto.subtle.deriveKey({name:'PBKDF2', hash:'SHA-256', salt, iterations:iters}, key, {name:'AES-GCM', length:256}, false, ['encrypt','decrypt']);}
async function signHex(bytes){const sig=await crypto.subtle.sign('Ed25519', session.privKey, bytes); return hex(sig);}

// ===== Anti-bot PoW (на создание) =====
async function powCreate(){const ts=Date.now().toString();let n=0;for(;;){const h=await sha256(ts+'|'+n);if(h.startsWith('00000'))return{ts,nonce:n,h};n++; if(n%5000===0) await new Promise(r=>setTimeout(r));}}

// ===== Session =====
let session={rid:null, privKey:null, pubKeyRaw:null};

// ===== Balance/nonce =====
async function refreshBalance(){
  const enc=encodeURIComponent(session.rid);
  const r=await fetch(`${BASE}/balance/${enc}`); const j=await r.json();
  ui.balView.textContent=j.balance??0; ui.nonceView.textContent=j.nonce??0;
  return j;
}

// ===== Create wallet =====
ui.btnCreate.onclick = async ()=>{
  try{
    ui.createStatus.textContent='Генерация…';
    const pass = ui.newPass.value.trim();
    if(pass.length<8){ ui.createStatus.textContent='Сложнее пароль'; return; }
    await powCreate();

    const kp = await crypto.subtle.generateKey({name:'Ed25519'}, true, ['sign','verify']);
    const pubRaw = await crypto.subtle.exportKey('raw', kp.publicKey);
    const privRaw = await crypto.subtle.exportKey('pkcs8', kp.privateKey);

    const rid = 'Λ0@7.83Hzφ' + (await sha256(hex(pubRaw))).slice(0,6);

    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv   = crypto.getRandomValues(new Uint8Array(12));
    const aek  = await pbkdf2(pass, salt);
    const enc  = await crypto.subtle.encrypt({name:'AES-GCM', iv}, aek, privRaw);

    await idbPut({ rid, pub_hex: hex(pubRaw), enc_priv_b64: btoa(String.fromCharCode(...new Uint8Array(enc))), salt_hex: hex(salt), iv_hex: hex(iv) });

    ui.loginRid.value = rid; ui.loginPass.value = pass;
    ui.createStatus.textContent='OK — кошелёк создан';
  }catch(e){ console.error(e); ui.createStatus.textContent='Ошибка создания'; }
};

// ===== Login =====
ui.btnLogin.onclick = async ()=>{
  try{
    ui.loginStatus.textContent = 'Поиск…';
    const rid = ui.loginRid.value.trim(), pass = ui.loginPass.value.trim();
    const rec = await idbGet(rid);
    if(!rec){ ui.loginStatus.textContent = 'RID не найден в этом браузере'; return; }

    const salt = Uint8Array.from(rec.salt_hex.match(/.{2}/g).map(h=>parseInt(h,16)));
    const iv   = Uint8Array.from(rec.iv_hex.match(/.{2}/g).map(h=>parseInt(h,16)));
    const enc  = Uint8Array.from(atob(rec.enc_priv_b64), c=>c.charCodeAt(0));
    const aek  = await pbkdf2(pass, salt);
    const privRaw = await crypto.subtle.decrypt({name:'AES-GCM', iv}, aek, enc);
    const privKey = await crypto.subtle.importKey('pkcs8', privRaw, {name:'Ed25519'}, false, ['sign']);

    session = { rid, privKey, pubKeyRaw: Uint8Array.from(rec.pub_hex.match(/.{2}/g).map(h=>parseInt(h,16))).buffer };

    // UI
    document.getElementById('walletPanel').style.display='';
    document.getElementById('ridView').textContent = rid;
    document.getElementById('ridStake').textContent = rid;
    ui.loginStatus.textContent='OK';

    await refreshBalance();
    histCursor=null; ui.histBody.innerHTML=''; await loadHistoryPage();
  }catch(e){ console.error(e); ui.loginStatus.textContent='Ошибка входа'; }
};

// ===== Send TX =====
ui.btnSend.onclick = async ()=>{
  try{
    ui.sendStatus.textContent='Отправка…';
    const b=await refreshBalance();
    const to=ui.toRid.value.trim();
    const amt=Number(ui.amount.value);
    const nonce=(b.nonce??0)+1;

    const msg=`${session.rid}|${to}|${amt}|${nonce}`;
    const sig_hex = await signHex(new TextEncoder().encode(msg));

    // Лёгкий локальный троттлинг (anti-bot throttle)
    await new Promise(r=>setTimeout(r, 300 + Math.random()*500));

    const res = await fetch(`${BASE}/submit_tx`,{
      method:'POST',headers:{'Content-Type':'application/json'},
      body:JSON.stringify({from:session.rid,to,amount:amt,nonce,sig_hex})
    });
    const j=await res.json();
    ui.sendStatus.textContent = j.ok ? ('OK: '+(j.txid||'')) : ('ERR: '+j.info);
    await refreshBalance();
  }catch(e){ console.error(e); ui.sendStatus.textContent='Ошибка'; }
};

// ===== History (пагинация by height) =====
let histCursor=null;
async function loadHistoryPage(){
  const enc=encodeURIComponent(session.rid);
  let url=`${BASE}/archive/history/${enc}`; if(histCursor!=null) url+=`?before_height=${histCursor}`;
  const r=await fetch(url); const list=await r.json(); if(!Array.isArray(list) || list.length===0) return;
  histCursor = Number(list[list.length-1].height) - 1;
  const frag=document.createDocumentFragment();
  for(const t of list){
    const tr=document.createElement('tr');
    tr.innerHTML=`<td class="mono">${String(t.txid).slice(0,16)}…</td><td class="mono">${t.from}</td><td class="mono">${t.to}</td><td>${t.amount}</td><td>${t.height}</td><td>${t.ts??''}</td>`;
    ui.histBody.appendChild(tr);
  }
}
ui.btnMoreHist.onclick = ()=> loadHistoryPage();

// ===== Tabs =====
ui.tabs.forEach(tab=>{
  tab.onclick=()=>{
    ui.tabs.forEach(t=>t.classList.remove('active')); tab.classList.add('active');
    const name=tab.dataset.tab;
    document.getElementById('tab-send').classList.toggle('hide', name!=='send');
    document.getElementById('tab-stake').classList.toggle('hide', name!=='stake');
    document.getElementById('tab-history').classList.toggle('hide', name!=='history');
    document.getElementById('tab-settings').classList.toggle('hide', name!=='settings');
  };
});

// ===== Export / Import =====
ui.btnExport.onclick = async ()=>{
  const rec = await idbGet(session.rid);
  const blob = new Blob([JSON.stringify(rec)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = `logos_wallet_${session.rid}.json`; a.click();
  ui.exportStatus.textContent='Экспортирован зашифрованный бэкап';
};
ui.btnImport.onclick = ()=> ui.impFile.click();
ui.impFile.onchange = async (e)=>{
  try{
    const f=e.target.files[0]; const text=await f.text(); const rec=JSON.parse(text);
    if(!rec.rid || !rec.enc_priv_b64) throw new Error('bad backup');
    await idbPut(rec); ui.exportStatus.textContent='Импорт OK';
  }catch(err){ ui.exportStatus.textContent='Ошибка импорта'; }
};

```

### FILE: /var/www/logos/wallet3/app.v3.js
```js
const API = location.origin + '/api/';
const enc = new TextEncoder();

// utils
const $ = s => document.querySelector(s);
const toHex   = b => [...new Uint8Array(b)].map(x=>x.toString(16).padStart(2,'0')).join('');
const fromHex = h => new Uint8Array((h.match(/.{1,2}/g)||[]).map(x=>parseInt(x,16)));
function u64le(n){ const b=new Uint8Array(8); new DataView(b.buffer).setBigUint64(0, BigInt(n), true); return b; }
async function sha256(bytes){ const d=await crypto.subtle.digest('SHA-256', bytes); return new Uint8Array(d); }
async function fetchJSON(url, opts){
  const r = await fetch(url, opts);
  const t = await r.text();
  try { const j = t?JSON.parse(t):{}; if(!r.ok) throw j; return j; }
  catch(e){ throw { ok:false, error:(typeof e==='object'&&e.error)?e.error:(t||'not json'), status:r.status||0 }; }
}

// session/keys
const PASS = sessionStorage.getItem('logos_pass');
const RID  = sessionStorage.getItem('logos_rid');
if (!PASS || !RID) { location.replace('../wallet/login.html'); throw new Error('locked'); } // переиспользуем старую страницу логина

const DB_NAME='logos_wallet_v2', STORE='keys';
function idb(){ return new Promise((res,rej)=>{ const r=indexedDB.open(DB_NAME,1); r.onupgradeneeded=()=>r.result.createObjectStore(STORE); r.onsuccess=()=>res(r.result); r.onerror=()=>rej(r.error); }); }
async function idbGet(k){ const db=await idb(); return new Promise((res,rej)=>{ const tx=db.transaction(STORE,'readonly'); const st=tx.objectStore(STORE); const rq=st.get(k); rq.onsuccess=()=>res(rq.result||null); rq.onerror=()=>rej(rq.error); }); }
async function deriveKey(pass,salt){ const km=await crypto.subtle.importKey('raw', enc.encode(pass), {name:'PBKDF2'}, false, ['deriveKey']); return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:120000}, km, {name:'AES-GCM',length:256}, false, ['encrypt','decrypt']); }
async function aesDecrypt(aesKey,iv,ct){ return new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM',iv}, aesKey, ct)); }
async function importKey(pass, meta){
  const aesKey=await deriveKey(pass,new Uint8Array(meta.salt));
  const pkcs8 =await aesDecrypt(aesKey,new Uint8Array(meta.iv_priv),new Uint8Array(meta.priv));
  const pubraw=await aesDecrypt(aesKey,new Uint8Array(meta.iv_pub), new Uint8Array(meta.pub));
  const privateKey=await crypto.subtle.importKey('pkcs8',pkcs8,{name:'Ed25519'},false,['sign']);
  const publicKey =await crypto.subtle.importKey('raw',  pubraw,{name:'Ed25519'},true, ['verify']);
  return { privateKey, publicKey, pub_hex: toHex(pubraw) };
}
let KEYS=null, META=null;
(async()=>{
  META=await idbGet('acct:'+RID);
  if(!META){ sessionStorage.clear(); location.replace('../wallet/login.html'); return; }
  KEYS=await importKey(PASS, META);
})();

// canonical + sign
async function canonHex(from_rid,to_rid,amount,nonce,pubkey_hex){
  const parts=[enc.encode(from_rid),enc.encode(to_rid),u64le(Number(amount)),u64le(Number(nonce)),enc.encode(pubkey_hex)];
  const buf=new Uint8Array(parts.reduce((s,p)=>s+p.length,0)); let o=0; for(const p of parts){ buf.set(p,o); o+=p.length; }
  return toHex(await sha256(buf));
}
async function signCanon(priv, canonHexStr){
  const msg = fromHex(canonHexStr);
  const sig = await crypto.subtle.sign('Ed25519', priv, msg);
  return toHex(sig);
}

// API
const getBalance=(rid)=>fetchJSON(`${API}balance/${encodeURIComponent(rid)}`);
const submitTxBatch=(txs)=>fetchJSON(`${API}submit_tx_batch`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({txs})});
const stakeDelegate=(delegator,validator,amount)=>fetchJSON(`${API}stake/delegate`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeUndelegate=(delegator,validator,amount)=>fetchJSON(`${API}stake/undelegate`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:Number(amount)})});
const stakeClaim=(delegator,validator)=>fetchJSON(`${API}stake/claim`,{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({delegator,validator,amount:0})});
const stakeMy=(rid)=>fetchJSON(`${API}stake/my/${encodeURIComponent(rid)}`);

// UI
$('#btn-balance')?.addEventListener('click', async ()=>{
  try{ const rid=($('#rid-balance')?.value||RID).trim(); const j=await getBalance(rid); $('#out-balance') && ($('#out-balance').textContent=JSON.stringify(j)); }
  catch(e){ $('#out-balance') && ($('#out-balance').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-nonce')?.addEventListener('click', async ()=>{
  try{ const j=await getBalance(RID); const n=$('#nonce'); if(n) n.value=String(j.nonce||0); }catch(e){}
});
$('#btn-send')?.addEventListener('click', async ()=>{
  try{
    const to=$('#to')?.value.trim(), amount=$('#amount')?.value.trim(), nonce=$('#nonce')?.value.trim();
    if(!to||!amount||!nonce) throw {error:'fill to/amount/nonce'};
    const ch=await canonHex(RID,to,amount,nonce,KEYS.pub_hex);
    const sig=await signCanon(KEYS.privateKey,ch);
    const tx={from_rid:RID,to_rid:to,amount:Number(amount),nonce:Number(nonce),pubkey_hex:KEYS.pub_hex,sig_hex:sig};
    const res=await submitTxBatch([tx]);
    $('#out-send') && ($('#out-send').textContent=JSON.stringify(res,null,2));
  }catch(e){ $('#out-send') && ($('#out-send').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-delegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const amount=$('#stake-amount')?.value.trim();
    const res=await stakeDelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-undelegate')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const amount=$('#stake-amount')?.value.trim();
    const res=await stakeUndelegate(RID,val,amount);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-claim')?.addEventListener('click', async ()=>{
  try{
    const val=($('#validator')?.value||RID).trim();
    const res=await stakeClaim(RID,val);
    $('#out-stake') && ($('#out-stake').textContent=JSON.stringify(res));
  }catch(e){ $('#out-stake') && ($('#out-stake').textContent=`ERR: ${JSON.stringify(e)}`); }
});
$('#btn-my')?.addEventListener('click', async ()=>{
  try{ const res=await stakeMy(RID); $('#out-my') && ($('#out-my').textContent=JSON.stringify(res)); }
  catch(e){ $('#out-my') && ($('#out-my').textContent=`ERR: ${JSON.stringify(e)}`); }
});

```

### FILE: /var/www/logos/wallet3/index.html
```html
<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate"/>
  <meta http-equiv="Pragma" content="no-cache"/>
  <meta http-equiv="Expires" content="0"/>
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; connect-src 'self'; img-src 'self'; script-src 'self'; style-src 'self'">
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>LOGOS Wallet (v3)</title>
  <style>
    body{font-family:system-ui,Roboto,Arial,sans-serif;background:#0b0e11;color:#e6e6e6;margin:0}
    header{padding:12px 20px;background:#12161a;border-bottom:1px solid #1b2026}
    main{padding:20px} h3{margin:0}
    section{margin-bottom:20px}
    input,button{padding:8px 10px;border-radius:6px;border:none;font-size:14px}
    button{background:#2d6cdf;color:#fff;cursor:pointer;margin:4px 2px}
    .out{margin-top:10px;font-family:monospace;font-size:13px;white-space:pre-wrap}
  </style>
  <script>
    (async()=>{ // убьём SW/Cache на всякий случай
      try{
        if('serviceWorker' in navigator){
          for(const r of await navigator.serviceWorker.getRegistrations()) try{await r.unregister()}catch{}
        }
        if(window.caches){ for(const k of await caches.keys()) try{await caches.delete(k)}catch{} }
      }catch(e){}
    })();
  </script>
</head>
<body>
<header>
  <h3>LOGOS Wallet (v3)</h3>
  <div>node: <span id="node-url"></span> | head: <span id="head"></span></div>
</header>
<main>
  <section>
    <h4>Настройки</h4>
    <div>RID: <span id="rid"></span></div>
    <div>Баланс: <span id="balance"></span> | Nonce: <span id="nonce-show"></span></div>
    <input id="rid-balance" placeholder="RID для проверки"/>
    <button id="btn-balance">Баланс</button>
    <div id="out-balance" class="out"></div>
  </section>

  <section>
    <h4>Отправка</h4>
    <input id="to" placeholder="RID получателя"/>
    <input id="amount" type="number" placeholder="Сумма (микро-LGN)"/>
    <input id="nonce" type="number" placeholder="Nonce"/>
    <button id="btn-nonce">NONCE</button>
    <button id="btn-send">Отправить</button>
    <div id="out-send" class="out"></div>
  </section>

  <section>
    <h4>Стейкинг</h4>
    <input id="validator" placeholder="RID валидатора"/>
    <input id="stake-amount" type="number" placeholder="Сумма (микро-LGN)"/>
    <button id="btn-delegate">Delegate</button>
    <button id="btn-undelegate">Undelegate</button>
    <button id="btn-claim">Claim</button>
    <button id="btn-my">Мои делегации</button>
    <div id="out-stake" class="out"></div>
    <div id="out-my" class="out"></div>
  </section>
</main>

<script src="app.v3.js?v=3"></script>
<script>
  document.getElementById('node-url').textContent = location.origin;
  (async function tick(){
    try{
      const h=await (await fetch(location.origin+'/api/head')).json();
      document.getElementById('head').textContent=h.height;
      const rid=sessionStorage.getItem('logos_rid');
      if(rid){
        const bj=await (await fetch(location.origin+'/api/balance/'+encodeURIComponent(rid))).json();
        document.getElementById('rid').textContent=rid;
        document.getElementById('balance').textContent=bj.balance;
        document.getElementById('nonce-show').textContent=bj.nonce;
      }
    }catch(e){}
    setTimeout(tick,1500);
  })();
</script>
</body>
</html>

```

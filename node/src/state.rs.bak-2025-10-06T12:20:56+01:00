use std::{net::SocketAddr, sync::Arc};
use anyhow::{Context, Result};
use parking_lot::Mutex;
use sled::Db;

pub struct AppState {
    pub ledger: Arc<Mutex<lrb_core::ledger::Ledger>>,
    pub sled: Db,
    pub archive: Option<crate::archive::Archive>,
}

impl AppState {
    /// Синхронный конструктор: открываем sled и ledger на одном пути
    pub fn new() -> Result<Self> {
        let path = std::env::var("LRB_DATA_PATH")
            .unwrap_or_else(|_| "/var/lib/logos/data.sled".to_string());

        // sled для служебных структур (anti-replay, журналы и т.д.)
        let sled_db = sled::open(&path).context("open sled")?;

        // Ledger использует тот же путь (внутри свой namespace)
        let ledger = lrb_core::ledger::Ledger::open(&path).context("open ledger")?;

        Ok(Self {
            ledger: Arc::new(Mutex::new(ledger)),
            sled: sled_db,
            archive: None,
        })
    }

    /// Адрес бинда HTTP/metrics
    pub fn bind_addr(&self) -> SocketAddr {
        let s = std::env::var("LRB_BIND").unwrap_or_else(|_| "0.0.0.0:8080".to_string());
        s.parse().expect("LRB_BIND must be host:port")
    }

    /// Геттер для sled (нужен bridge/anti-replay)
    #[inline]
    pub fn sled(&self) -> &Db {
        &self.sled
    }

    /// Инициализация PG-архива (опционально)
    pub async fn init_archive(&mut self) -> Result<()> {
        if let Some(a) = crate::archive::Archive::new_from_env().await {
            self.archive = Some(a);
        }
        Ok(())
    }
}
